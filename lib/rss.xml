<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Category]]></title><description><![CDATA[Obsidian digital garden]]></description><link>https://lts.kr/</link><image><url>https://lts.kr/lib/media/favicon.png</url><title>Category</title><link>https://lts.kr/</link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Fri, 30 May 2025 09:02:12 GMT</lastBuildDate><atom:link href="https://lts.kr/lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Fri, 30 May 2025 09:02:11 GMT</pubDate><copyright><![CDATA[taesung's Blog]]></copyright><ttl>60</ttl><dc:creator>taesung's Blog</dc:creator><item><title><![CDATA[젠킨스 파이프라인 설정]]></title><description><![CDATA[<br><br><br><br><br>credential은 도커 허브, 깃 허브 등 젠킨스가 빌드하고 배포하는 과정에서 필요한 로그인 정보들이라고 생각하면 된다.<br>설정은 Jenkins 관리 &gt; Security &gt; Credential로 진입
<img alt="Pasted image 20250529235812.png" src="https://lts.kr/사진-및-문서/pasted-image-20250529235812.png" target="_self"><br>이후 system &gt; global credential &gt; 우측 상단에 add credential<br>여기서 도커 허브와 git hub 등 인증 정보를 기입
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@uiop5487/Jenkins-CICD-Pipeline-%EA%B5%AC%EC%B6%95" target="_self">https://velog.io/@uiop5487/Jenkins-CICD-Pipeline-%EA%B5%AC%EC%B6%95</a>
해당 블로그 참고<br><br>아이템 접속(Annoni-App-Prod) &gt; 구성으로 접속<br>자동 빌드보다는 수동빌드가 더 안전하다고 생각해서 폴링이나 웹훅 방식을 사용하지 않는다.<br><img alt="Pasted image 20250529235718.png" src="https://lts.kr/사진-및-문서/pasted-image-20250529235718.png" target="_self">
그래서 트리거는 아무것도 설정하지 않음<br>회사에서 처럼 직접 젠킨스에서 빌드를 눌러야 빌드가 시작됨<br>스크립트 작성<br>pipeline { agent any environment { // Docker Hub 정보 DOCKER_HUB_REPO = 'xotjd794613/my-spring-app' //도커 허브 레포 넣기 DOCKER_IMAGE_TAG = String.format("v0.%02d", BUILD_NUMBER as Integer) DOCKER_LATEST_TAG = 'latest' // 컨테이너 정보 CONTAINER_NAME = 'annonichat-app' //주석 1번 : 컨테이너 실행 명령어 수정 필요 CONTAINER_PORT = '8000:8080' // Docker Hub Credentials ID (Jenkins에서 설정할 이름) DOCKER_HUB_CREDENTIALS = 'docker-hub-credentials' //도커허브 credential에서 지정한 이름 } //2025.05.29 여기까지 했음.. stages { stage('1. Git Clone') { steps { echo '📂 GitHub에서 최신 코드 가져오기...' checkout scm sh 'git log --oneline -5' } } stage('2. Build') { steps { echo '🔨 Spring Boot 애플리케이션 빌드 중...' script { // Gradle 프로젝트인 경우 if (fileExists('gradlew')) { sh './gradlew clean build -x test' } // Maven 프로젝트인 경우 else if (fileExists('pom.xml')) { sh 'mvn clean compile -DskipTests' } else { error('Gradle 또는 Maven 프로젝트가 아닙니다!') } } } } stage('3. Test') { steps { echo '🧪 단위 테스트 실행 중...' script { try { if (fileExists('gradlew')) { sh './gradlew test' } else if (fileExists('pom.xml')) { sh 'mvn test' } } catch (Exception e) { echo "⚠️ 테스트 실패: ${e.getMessage()}" // 테스트 실패 시 빌드 중단하려면 아래 주석 해제 // throw e } } } post { always { // 테스트 결과 게시 (선택사항) script { if (fileExists('build/test-results/test/*.xml')) { publishTestResults testResultsPattern: 'build/test-results/test/*.xml' } else if (fileExists('target/surefire-reports/*.xml')) { publishTestResults testResultsPattern: 'target/surefire-reports/*.xml' } } } } } stage('4. Docker Image Build') { steps { echo '🐳 Docker 이미지 빌드 중...' script { // JAR 파일 위치 확인 def jarFile = '' if (fileExists('build/libs/')) { jarFile = sh(script: 'find build/libs -name "*.jar" | grep -v plain', returnStdout: true).trim() } else if (fileExists('target/')) { jarFile = sh(script: 'find target -name "*.jar"', returnStdout: true).trim() } if (jarFile) { echo "JAR 파일 발견: ${jarFile}" // Docker 이미지 빌드 sh """ docker build -t ${DOCKER_HUB_REPO}:${DOCKER_IMAGE_TAG} . docker tag ${DOCKER_HUB_REPO}:${DOCKER_IMAGE_TAG} ${DOCKER_HUB_REPO}:${DOCKER_LATEST_TAG} """ echo "✅ Docker 이미지 빌드 완료: ${DOCKER_HUB_REPO}:${DOCKER_IMAGE_TAG}" } else { error('JAR 파일을 찾을 수 없습니다!') } } } } stage('5. Docker Image Push') { steps { echo '📤 Docker Hub에 이미지 푸시 중...' script { // Docker Hub 로그인 및 푸시 withCredentials([usernamePassword(credentialsId: "${DOCKER_HUB_CREDENTIALS}", passwordVariable: 'DOCKER_PASSWORD', usernameVariable: 'DOCKER_USERNAME')]) { sh """ echo ${DOCKER_PASSWORD} | docker login -u ${DOCKER_USERNAME} --password-stdin docker push ${DOCKER_HUB_REPO}:${DOCKER_IMAGE_TAG} docker push ${DOCKER_HUB_REPO}:${DOCKER_LATEST_TAG} docker logout """ } } echo "✅ Docker 이미지 푸시 완료!" } } stage('6. Deploy') { steps { echo '🚀 최신 이미지로 배포 중...' script { try { // 기존 컨테이너 중지 및 삭제 sh "docker stop ${CONTAINER_NAME} || true" sh "docker rm ${CONTAINER_NAME} || true" // 기존 이미지 삭제 (용량 절약) sh "docker rmi ${DOCKER_HUB_REPO}:${DOCKER_LATEST_TAG} || true" // 최신 이미지 Pull sh "docker pull ${DOCKER_HUB_REPO}:${DOCKER_LATEST_TAG}" // 새 컨테이너 실행 sh """ docker run -d \\ --name ${CONTAINER_NAME} \\ --restart always \\ -p ${CONTAINER_PORT} \\ ${DOCKER_HUB_REPO}:${DOCKER_LATEST_TAG} """ // 컨테이너 상태 확인 sh "sleep 10" // 컨테이너 시작 대기 sh "docker ps | grep ${CONTAINER_NAME}" echo "✅ 배포 완료! 컨테이너 ${CONTAINER_NAME}가 실행 중입니다." } catch (Exception e) { echo "❌ 배포 실패: ${e.getMessage()}" throw e } } } } } post { always { echo '🧹 빌드 후 정리 작업...' // 빌드 과정에서 생성된 임시 이미지들 정리 sh 'docker image prune -f || true' } success { echo '🎉 CI/CD 파이프라인이 성공적으로 완료되었습니다!' // 성공 시 알림 (Slack, Email 등 설정 가능) } failure { echo '❌ CI/CD 파이프라인이 실패했습니다.' // 실패 시 알림 설정 가능 } }
}
<br>
<br>컨테이너 실행 명령어 변경이 필요한 이유 : 기존 명령어는 container name이 지정되어 있지 않아서 도커가 무작위로 생성했었다.
그래서 스크립트에 필요한 컨테이너 이름을 고정적으로 사용하기 위해 명령어를 바꿔야한다.
변경 명령어 : docker run -d \ --name anonichat-app \ -p 8081:8080 \ xotjd794613/anonichat:v0.04
]]></description><link>https://lts.kr/project/new-project/젠킨스-파이프라인-설정.html</link><guid isPermaLink="false">project/New Project/젠킨스 파이프라인 설정.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Fri, 30 May 2025 09:01:56 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20250529235812.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20250529235812.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[젠킨스 설정 초기화 문제]]></title><description><![CDATA[<br><br><br><br> 젠킨스 웹페이지에 접속 &gt; 초기 비밀번호 입력 &gt; admin id/pw 생성 &gt; 플러그인 설치 &gt; 젠킨스 메인 화면 까지 이미 마친 상황이었다.
그런데 퇴근하고 집에서 젠킨스에 다시 접속하니까 초기 비밀번호 입력부터 다시 시작되었다.<br>분명히 모든 설정을 끝냈는데 다시 하는게 뭔가 이상했다.<br>초기 비밀번호는 항상 입력하고 들어가야했다.
분명 문제가 있다 생각하고 연구를 해보았다.<br><br>문제는 볼륨 마운트였다.<br>볼륨 마운트는 컨테이너의 문제점인 컨테이너 삭제시 모든 데이터가 사라지는것을 방지하는 기술이다.<br>컨테이너의 문제점:<br>컨테이너 생성 → 데이터 저장 → 컨테이너 삭제 → 모든 데이터 사라짐
<br>볼륨 마운트 해결책:<br>컨테이너 생성 → 데이터 저장 → 컨테이너 삭제 → 데이터는 호스트에 보존
새 컨테이너 생성 → 기존 데이터 그대로 사용
<br>즉 기존에는 볼륨 마운트를 적용하지 않아서 젠킨스 초기 설정 정보가 모두 날아갔고
집에와서 다시 접속해보니 처음부터 다시 시작한 것이다.<br>기존 컨테이너 실행 명령어<br>docker run -d \ --name jenkins-dood \ -p 8080:8080 \ -v /var/run/docker.sock:/var/run/docker.sock \ jenkins-dood:v0.06
<br>볼륨 마운트 적용한 컨테이너 실행 명령어<br>docker run -d \ —name jenkins-dood \ -p 8080:8080 \ -v /var/run/docker.sock:/var/run/docker.sock \ -v jenkins_home:/home/hello \ ##볼륨 마운트 적용 명령어 xotjd794613/jenkins-dood:v0.06
<br>단순한 한줄이지만 컨테이너에서 생성된 데이터를 해당 디렉토리에 저장해놓고
컨테이너가 다시 실행되더라도 필요한 데이터를 지정한 디렉토리에서 꺼내서 사용한다.<br><br>위의 명령어로 컨테이너를 다시 실행하고 젠킨스에 접속했다.
그리고 모든 초기설정을 마쳤다.<br><img alt="Pasted image 20250529221139.png" src="https://lts.kr/사진-및-문서/pasted-image-20250529221139.png" target="_self">
브라우저 캐시 삭제 후 다시 접속하니 이제 초기 비밀번호 입력하는 것도 안나오고
정상적으로 젠킨스 로그인 화면이 나온다.]]></description><link>https://lts.kr/project/new-project/젠킨스-설정-초기화-문제.html</link><guid isPermaLink="false">project/New Project/젠킨스 설정 초기화 문제.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Fri, 30 May 2025 09:01:47 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20250529221139.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20250529221139.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🔑 Docker Image를 Git repo로 관리하기]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:프로젝트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로젝트</a> <a class="tag" href="https://lts.kr/?query=tag:개발" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#개발</a> <a class="tag" href="https://lts.kr/?query=tag:인프라" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#인프라</a> <a class="tag" href="https://lts.kr/?query=tag:docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#docker</a> <a class="tag" href="https://lts.kr/?query=tag:git" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#git</a> <br> <a href="https://lts.kr?query=tag:프로젝트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로젝트">#프로젝트</a> <a href="https://lts.kr?query=tag:개발" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#개발">#개발</a> <a href="https://lts.kr?query=tag:인프라" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#인프라">#인프라</a> <a href="https://lts.kr?query=tag:docker" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#docker">#docker</a> <a href="https://lts.kr?query=tag:git" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#git">#git</a><br>
<br>Docker 이미지를 Docker Hub가 아닌 GitHub 팀 저장소에서 관리하려면,<br>GitHub Container Registry(GHCR) 를 활용하여 이미지를 저장하고 배포할 수 있다. <br>
<br>GitHub와의 통합 <br>GHCR는 GitHub와 통합되어 있어, 저장소와 연동하여 컨테이너 이미지를 관리할 수 있다. <br>퍼블릭 및 프라이빗 이미지 지원 <br>이미지를 퍼블릭 또는 프라이빗으로 설정할 수 있어, 접근 제어가 가능하다. <br>세분화된 권한 관리 <br>Personal Access Token(PAT)을 사용하여 세분화된 권한 설정이 가능하다. <br>GitHub Actions와의 연동 <br>GitHub Actions를 통해 CI/CD 파이프라인을 구축하고, 자동으로 이미지를 빌드하고 GHCR에 푸시할 수 있다. <br>GHCR에 이미지를 푸시하려면 인증이 필요하다. 이를 위해 Personal Access Token(PAT)을 생성하고 설정해야 한다.<br>
GitHub 계정의 Settings &gt; Developer settings &gt; Personal access tokens로 이동한다. <br>
Generate new token을 클릭하고, 권한을 선택 <br>write:packages <br>read:packages <br>delete:packages (선택 사항)
<img alt="Pasted image 20250530173935.png" src="https://lts.kr/사진-및-문서/pasted-image-20250530173935.png" target="_self"> <br>
토큰을 생성하고 안전한 곳에 저장 후 <br>
로컬 환경에서 다음 명령어로 Docker에 로그인한다. <br>echo $CR_PAT | docker login ghcr.io -u YOUR_GITHUB_USERNAME --password-stdin
<br>여기서 CR_PAT는 생성한 토큰을 환경 변수로 설정하는 명령어 이다.<br>Dockerfile이 있는 디렉토리에서 다음 명령어로 이미지를 빌드하고 태깅한다.<br>docker build -t ghcr.io/"OWNER"/"REPOSITORY"/"IMAGE_NAME":"TAG" .
<br>OWNER는 GitHub 사용자명 또는 조직명입니다. <br>REPOSITORY는 이미지와 연결할 GitHub 저장소명입니다. <br>IMAGE_NAME은 이미지의 이름입니다.
<br>docker build -t ghcr.io/my-org/my-repo/my-app:latest .
<br>빌드한 이미지를 GHCR에 푸시한다.<br>docker push ghcr.io/OWNER/REPOSITORY/IMAGE_NAME:TAG
<br>예시:<br>docker push ghcr.io/my-org/my-repo/my-app:latest
<br>푸시가 완료되면, 해당 이미지는 GitHub의 Packages 섹션에서 확인할 수 있다.<br>GHCR에 푸시된 이미지는 다음 명령어로 사용할 수 있다.<br>docker pull ghcr.io/OWNER/REPOSITORY/IMAGE_NAME:TAG
<br>또한, Kubernetes 등의 오케스트레이션 도구에서 해당 이미지를 참조하여 배포할 수 있다.<br>이러한 과정을 통해 Docker 이미지를 GitHub 팀 저장소에서 효과적으로 관리하고 배포할 수 있다.<br>또한, 추가적인 자동화나 보안 설정이 필요하다면, GitHub Actions의 다양한 기능과 GHCR의 접근 제어 설정을 활용할 수 있다.]]></description><link>https://lts.kr/project/new-project/🔑-docker-image를-git-repo로-관리하기.html</link><guid isPermaLink="false">project/New Project/🔑 Docker Image를 Git repo로 관리하기.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Fri, 30 May 2025 08:39:36 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20250530173935.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20250530173935.png"&gt;&lt;/figure&gt;</content:encoded></item></channel></rss>