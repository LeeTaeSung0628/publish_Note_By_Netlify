<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Category]]></title><description><![CDATA[Obsidian digital garden]]></description><link>https://lts.kr/</link><image><url>https://lts.kr/lib/media/favicon.png</url><title>Category</title><link>https://lts.kr/</link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Wed, 02 Jul 2025 08:09:37 GMT</lastBuildDate><atom:link href="https://lts.kr/lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Wed, 02 Jul 2025 08:09:34 GMT</pubDate><copyright><![CDATA[taesung's Blog]]></copyright><ttl>60</ttl><dc:creator>taesung's Blog</dc:creator><item><title><![CDATA[🧑‍🤝‍🧑 AWSKRUG 플랫폼엔지니어링 모임 Agentic MCP for EKS 회고]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="https://lts.kr/?query=tag:AWS" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#AWS</a> <a class="tag" href="https://lts.kr/?query=tag:AWSKRUG" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#AWSKRUG</a> <a class="tag" href="https://lts.kr/?query=tag:플랫폼" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#플랫폼</a> <a class="tag" href="https://lts.kr/?query=tag:모임" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#모임</a> <a class="tag" href="https://lts.kr/?query=tag:회고" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#회고</a> <a class="tag" href="https://lts.kr/?query=tag:EKS" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#EKS</a> <a class="tag" href="https://lts.kr/?query=tag:MCP" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#MCP</a> <a class="tag" href="https://lts.kr/?query=tag:AI" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#AI</a> <br> <a href="https://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="https://lts.kr?query=tag:AWS" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#AWS">#AWS</a> <a href="https://lts.kr?query=tag:AWSKRUG" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#AWSKRUG">#AWSKRUG</a> <a href="https://lts.kr?query=tag:플랫폼" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#플랫폼">#플랫폼</a> <a href="https://lts.kr?query=tag:모임" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#모임">#모임</a> <a href="https://lts.kr?query=tag:회고" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#회고">#회고</a> <a href="https://lts.kr?query=tag:EKS" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#EKS">#EKS</a> <a href="https://lts.kr?query=tag:MCP" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#MCP">#MCP</a> <a href="https://lts.kr?query=tag:AI" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#AI">#AI</a> <br><img alt="do-messenger_screenshot_2025-07-02_11_35_48.png" src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-07-02_11_35_48.png" style="width: 500px; max-width: 100%;" target="_self"><br>
최근 나는 vultr플랫폼에서 ci/cd를 구현하여 운영중에 있다.<br>AWS가 아닌 vultr를 사용하게 된 계기는 역시 운영비 부분이 가장 컸다. 하지만, 이번 세미나를 통해서 다시 AWS로 운영플랫폼을 옮길까 고민을 하게 되었다. 그만큼 ai에이전트 기반 운영 자동화의 성능이 생각보다 더 뛰어났다는 소리다.<br>AWSKRUG 플랫폼엔지니어링 모임에 참여후 학습한 내용과 소감을 간단하게 정리하려고 한다.<br>
<br>AWSKRUG(AWS한국사용자모임)에서 주최한 Agentic/MCP for EKS 핸즈온랩 강의 이다.
<br>Amazon Q Developer와 연계된 AI에이전트가 어떻게 k8s기반 운영을 지원할 수 있는지.
<br>코드 생성 + 실행 + 트러블슈팅이 하나의 흐름으로 연결되는 Agentic Workflow가 어떤 모습인지.
<br>실제 Git 기반 설정 파일과 EKS 리소스를 자동으로 생성·관리하는 방식이 어떻게 되는지.
<br>각각의 단어에 대해 알아보자.<br>
<br>Agentic는 자율성에 관한 유형 중 하나이다.
<br>Agent는 주로 자율적으로 목표를 달성하고, 상황을 인식하며, 의사결정을 수행하는 독립 실행 단위를 말한다.
<br>예를 들어, AI Agentic 시스템은 단순히 명령만 수행하는 게 아니라, 스스로 다음 행동을 계획하고 실행 흐름을 제어한다.
<br>DevOps 맥락에서는 운영 자동화 에이전트, 자율 오케스트레이션, 자기 복구(Self-Healing) 시스템 같은 데에서 Agentic 개념이 쓰인다.
<br>
<br>MCP는 보통 Model Context Protocol의 줄임말로 사용된다.
<br>2024년 11월 AI기업 Anthrophic이 오픈소스로 공개한 새로운 기술 표준이다.
<br>AI가 여러 데이터와 도구를 통합해 활용할 수 있도록 하는 표준 프로토콜(규약), 연결 규칙이다.
<br>ex) Google, MongoDB, Obsidian 등 MCP를 활용하면 CLI프롬프트 한번으로 여러작업을 모두 ai처리에 맡길 수 있음(읽기,쓰기 모두 가능)
<br>
<br>EKS는 Elastic Kubernetes Service의 약자.
<br>AWS가 제공하는 Managed Kubernetes 클러스터 서비스이다.
<br>사용자는 직접 Kubernetes Control Plane을 설치하거나 유지보수하지 않고, <br>AWS가 API Server, etcd, Control Plane 확장 등을 자동으로 관리. <br>사용자는 워커 노드(Node Group)만 구성해서 Pod을 배포하면 된다.
<br>EKS는 AWS IAM, VPC, ELB, CloudWatch 같은 AWS 서비스와 통합된다.
<br>온프레미스에서 직접 Kubernetes 운영하는 것보다 운영 복잡성이 낮아진다.
<br>위 과정은 Q CLI를 셋팅하는 것 부터 시작한다.<br>curl --proto '=https' --tlsv1.2 -sSf \ "https://desktop-release.q.us-east-1.amazonaws.com/latest/q-x86_64-linux.zip" \ -o "q.zip" ✔ Do you want q to modify your shell config? → Yes
✔ Select login method → Use for Free with Builder ID Confirm the following code in the browser:
Code: xxxx-xxxx Open this URL: https://view.awsapps.com/start/#/device?user_code=xxxx-xxxx To learn more about MCP safety, see https://docs.aws.amazon.com/amazonq/latest/qdeveloper-ug/command-line-mcp-security.html Welcome to █████╗ ███╗ ███╗ █████╗ ███████╗ ██████╗ ███╗ ██╗ ██████╗ ██╔══██╗████╗ ████║██╔══██╗╚══███╔╝██╔═══██╗████╗ ██║ ██╔═══██╗
███████║██╔████╔██║███████║ ███╔╝ ██║ ██║██╔██╗ ██║ ██║ ██║
██╔══██║██║╚██╔╝██║██╔══██║ ███╔╝ ██║ ██║██║╚██╗██║ ██║▄▄ ██║
██║ ██║██║ ╚═╝ ██║██║ ██║███████╗╚██████╔╝██║ ╚████║ ╚██████╔╝
╚═╝ ╚═╝╚═╝ ╚═╝╚═╝ ╚═╝╚══════╝ ╚═════╝ ╚═╝ ╚═══╝ ╚══▀▀═╝ <br>Q CLI는 터미널에서 실행되는 ai기반 도우미이다.
<br>AWS환경과 상호작용할 수 있는 CLI를 제공한다.
<br>예를 들어 다음과 같은 질문도 가능하다.<br>“EKS 클러스터를 보호하기 위한 몇 가지 모범 사례는 무엇인가요?” --- EKS 클러스터를 보호하기 위한 모범 사례는 다음과 같습니다: 1. 네트워크 보안 • 프라이빗 서브넷에 워커 노드 배치 • 보안 그룹을 사용하여 트래픽 제한 • AWS PrivateLink 또는 VPC 엔드포인트 사용 2. IAM 및 RBAC 구성 • 최소 권한 원칙 적용 • IAM 역할과 Kubernetes RBAC 통합 • 서비스 계정에 IAM 역할 사용 (IRSA) 3. 암호화 및 보안 설정 • EKS 클러스터 및 EBS 볼륨에 대한 암호화 활성화 • Secrets 암호화 구현 • AWS KMS 키 사용 4. 컨테이너 보안 • 신뢰할 수 있는 이미지만 사용 • 이미지 스캐닝 구현 (ECR 스캐닝 또는 서드파티 도구) • 컨테이너 실행 시 루트 권한 제한 ... 등등 이러한 모범 사례를 구현하면 EKS 클러스터의 보안 태세를 크게 향상시킬 수 있습니다.
<br>~/environment/myeks 디렉토리에 nginx-deployment.yaml이라는 이름으로 기본 Kubernetes nginx 배포를 위한 YAML 파일을 생성해주세요. --- Kubernetes nginx 배포를 위한 기본 YAML 파일을 생성하겠습니다. 🛠️ Using tool: fs_write ⋮ ● Path: /home/ec2-user/nginx-deployment.yaml + 1: apiVersion: apps/v1
+ 2: kind: Deployment
+ 3: metadata:
+ 4: name: nginx-deployment
+ 5: labels:
+ 6: app: nginx
+ 7: spec:
+ 8: replicas: 3
+ 9: selector:
+ 10: matchLabels:
+ 11: app: nginx ... 중략
+ 35: selector:
+ 36: app: nginx
+ 37: ports:
+ 38: - port: 80
+ 39: targetPort: 80
+ 40: type: ClusterIP Allow this action? Use 't' to trust (always allow) this tool for the session. [y/n/t]: &gt; t
Creating: /home/ec2-user/nginx-deployment.yaml ⋮ ● Completed in 0.0s nginx-deployment.yaml 파일을 성공적으로 생성했습니다. 이 파일에는 다음 내용이 포함되어 있습니다: 1. Deployment 리소스: • 3개의 복제본(replicas) • nginx:1.14.2 이미지 사용 • 포트 80 노출 • 리소스 제한 설정: • CPU 제한: 0.5 코어, 요청: 0.2 코어 • 메모리 제한: 512Mi, 요청: 256Mi 2. Service 리소스: • ClusterIP 타입 서비스 • 포트 80을 통해 Deployment에 연결 <br>docker image 다운로드
<br>셋팅 yml파일 작성
<br>권한부여
<br>리소스 차트 작성
<br>컨테이너 실행
<br>테스트
<br>또한, 위 과정은 아주 단편적인 기능일 뿐 활용도는 무궁무진 하며 캐시데이터로 학습이 지속적으로 이루어졌을 때는 성능이 더욱 높아질 여지가 충분하다.<br>┌────────────┐ ┌────────────┐ ┌────────────┐
│ 터미널 입력│ ─▶ │ Q CLI │─▶ │ MCP Client │
└────────────┘ └────────────┘ └────────────┘ │ JSON-RPC over stdio/stdout │ ┌────────────┐ │ MCP Server │ └────────────┘ │ ┌────────────┐ │ 로컬 Tools │ └────────────┘ <br>
<br>사용자 입력
<br>Q CLI 입력 처리
<br>컨텍스트 수집 시작
<br>컨텍스트 수집 완료
<br>MCP Client 초기화
<br>도구 발견
<br>LLM 페이로드 구성
<br>LLM 분석 요청
<br>LLM 분석 완료
<br>도구 실행 시작
<br>kubectl 명령 실행
<br>결과 분석 및 응답 생성
<br>사용자에게 응답 전달
<br>
<br>보안 <br>민감한 AWS 자격증명을 로컬에서만 처리 → 민감정보가 로컬을 벗어날 때에는 자체 마스킹 처리
<br>Kubeconfig 같은 클러스터 접근정보 보호 <br>성능 <br>로컬 파일 시스템 접근 빠름
<br>네트워크 호출 최소화 <br>일관성 <br>사용자 환경 맞춤 컨텍스트 자동 수집 → 위에서 기술한 대로, 학습하여 성능이 더욱 개선(최적화) 될 수 있다. <br>실제 실무 파일 <br>AWS 프로파일, 자격증명, K8s 설정, 현재 디렉터리 사용 <br>질문자의 역량에 따라서, 불필요한 반복 역질문과 같이 토큰을 소모하거나, 보안/운영상의 큰 위험요소를 남길 수 있다.<br>이를 미연에 방지하고, 최적화 하는 방법이 바로 프로파일과 컨텍스트이다.<br>컨텍스트를 활용하여 Amazon Q가 다양한 작업을 더 효과적으로 도와줄 수 있다.<br>
<br>개발 규칙, 프로젝트 세부사항, 코딩 표준 등을 포함한 정보
<br>Amazon Q의 응답을 더 정확하고 맞춤화되게 만든다.
<br>
<br>Amazon Q가 사용자와 시스템에 맞춰 반응하도록 설정된 컨텍스트 모음입니다.
<br>
<br>모든 프로파일에 공통적으로 적용되는 규칙
<br>
<br>특정 프로파일에만 적용되는 규칙
<br>
컨텍스트 파일은 일반적으로 Markdown 형식이며, 다음과 같은 내용을 포함할 수 있다.<br>프로젝트 요구사항
<br>개발 가이드라인
<br>보안 정책
<br>배포 표준 등
<br>ex)<br># shell 에서 실행합니다.
cat &gt; ~/environment/myeks/kubernetes_standards.md &lt;&lt; 'EOF'
# Kubernetes 배포 표준 ## 일반 가이드라인
- 모든 Kubernetes 리소스는 다음과 같은 라벨을 반드시 포함해야 합니다: - app: {애플리케이션 이름} - environment: {dev|staging|prod} - team: platform-engineering - cost-center: cc-12345 ## 배포 구성
- 리소스 요청(requests) 및 제한(limits)을 반드시 명시해야 합니다
- CPU 요청: 최소 100m, 최대 1000m
- 메모리 요청: 최소 128Mi, 최대 1Gi
- 배포 전략은 롤링 업데이트를 사용하며, maxSurge는 25%, maxUnavailable도 25%로 설정
- 모든 컨테이너에 readiness 및 liveness probe를 설정해야 합니다
- 이미지 풀 정책은 "IfNotPresent"로 설정할 것 ## 컨테이너 보안
- 컨테이너는 root가 아닌 사용자로 실행해야 함 (runAsNonRoot: true)
- 가능하면 읽기 전용 루트 파일 시스템을 사용할 것 (readOnlyRootFilesystem: true)
- 권한 상승 허용은 false로 설정 (allowPrivilegeEscalation: false)
- 모든 capabilities는 제거하고 필요한 항목만 명시적으로 추가 ## 네트워킹
- 서비스 포트는 프로토콜에 따라 명확히 이름 지정 (예: http, https, grpc)
- Ingress 리소스는 TLS를 사용하고, HTTP 요청은 HTTPS로 리디렉션해야 함
- 네임스페이스 간 트래픽 제한을 위해 NetworkPolicy 사용 ## 예시: 컨테이너 포트 설정
yaml
ports:
• name: http containerPort: 8080 protocol: TCP
EOF
<br>일련의 과정을 통해서 각 서비스 마다의 프로파일을 최적으로 구성한다면,<br>업무 효율은 어마어마 할것 같다.<br>이전, claude 를 사용해 fileSystem, git, obsidian MCP를 연결하여 포스팅 자동화 시스템을 구축한 경험이 있다.<br>이때에는 단순히 작업 플로우를 줄이는데에 목적이 있다고 생각했다. 하지만, 이번 세미나를 통해서 배운 지식은 그것을 훨씬 뛰어넘었다.<br>보통의 경우엔 컨트롤하지 못하는 영역까지 ai의 범위가 넓어졌고, 양질의 정보만을 선택적으로 학습한 전문적인 ai솔루션이 나옴에 따라<br>사용 경험이 이전과는 확연하게 달라짐을 느꼈다. 앞으로는 AI로 인하여, 업무 학습방법이 이전과는 크게 달라질 것으로 생각된다.<br>코딩(행위)이 아닌 개념과 아키텍처로?<br>이는 비단, AWS의 Q CLI뿐 아니라 모든 AI 에이전트에 해당되는 사항일 것이다.
<br>그러나 AI는 여전히 생산성을 높여주는 보조도구일 뿐, 전체적인 시스템과 세부 내용들을 이해하지 못하고 사용한다면 위험한 무기가 될 수 도있다고 생각한다. 때문에 다방면으로 넓은 지식을 쌓을 필요가 생겼다.]]></description><link>https://lts.kr/study/cs/🧑‍🤝‍🧑-awskrug-플랫폼엔지니어링-모임-agentic-mcp-for-eks-회고.html</link><guid isPermaLink="false">study/CS/🧑‍🤝‍🧑 AWSKRUG 플랫폼엔지니어링 모임 Agentic MCP for EKS 회고.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 02 Jul 2025 08:08:59 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-07-02_11_35_48.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-07-02_11_35_48.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🏠 taesung's Blog]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:home" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#home</a> <a class="tag" href="https://lts.kr/?query=tag:index" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#index</a> <a class="tag" href="https://lts.kr/?query=tag:blog" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#blog</a> <a class="tag" href="https://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <br> <a href="https://lts.kr?query=tag:home" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#home">#home</a> <a href="https://lts.kr?query=tag:index" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#index">#index</a> <a href="https://lts.kr?query=tag:blog" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#blog">#blog</a> <a href="https://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a><br><a data-tooltip-position="top" aria-label="https://github.com/LeeTaeSung0628" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/LeeTaeSung0628" target="_self"><span alt="prof2.jpg" src="prof2.jpg" class="internal-embed media-embed image-embed is-loaded" style="width: 250px; max-width: 100%;"></span></a><img alt="prof2.jpg" src="https://lts.kr/사진-및-문서/prof2.jpg" style="width: 250px; max-width: 100%;" target="_self"><br><a data-tooltip-position="top" aria-label="https://git.io/typing-svg" rel="noopener nofollow" class="external-link is-unresolved" href="https://git.io/typing-svg" target="_self"></a><img alt="Typing SVG" src="https://readme-typing-svg.demolab.com?font=Fira+Code&amp;pause=1000&amp;color=36A9F7&amp;random=false&amp;width=435&amp;lines=%EC%97%AC%EA%B8%B0%EB%8A%94+%EA%B3%B5%EB%B6%80%ED%95%98%EA%B3%A0%2C+%EA%B8%B0%EB%A1%9D%ED%95%98%EB%8A%94+%EA%B3%B3%EC%9E%85%EB%8B%88%EB%8B%A4" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br>]]></description><link>https://lts.kr/🏠-taesung's-blog.html</link><guid isPermaLink="false">🏠 taesung's Blog.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 02 Jul 2025 02:56:00 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/prof2.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/prof2.jpg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[📕 공부]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="https://lts.kr/?query=tag:모음" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#모음</a> <br> <a href="https://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="https://lts.kr?query=tag:모음" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#모음">#모음</a><br>공부
보고 배운 지식 중 공유하고 싶은 정보를 모아둔 카테고리 입니다.
<br>
<br><a data-href="🧑‍🤝‍🧑 AWSKRUG 플랫폼엔지니어링 모임 Agentic MCP for EKS 회고" href="https://lts.kr/study/cs/🧑‍🤝‍🧑-awskrug-플랫폼엔지니어링-모임-agentic-mcp-for-eks-회고.html" class="internal-link" target="_self" rel="noopener nofollow">🧑‍🤝‍🧑 AWSKRUG 플랫폼엔지니어링 모임 Agentic MCP for EKS 회고</a> <br><a data-href="🍌 React와 Next.js" href="https://lts.kr/study/cs/🍌-react와-next.js.html" class="internal-link" target="_self" rel="noopener nofollow">🍌 React와 Next.js</a>
<br><a data-href="🎗 @Transactional(readOnly = true) 붙이는 이유" href="https://lts.kr/study/cs/🎗-@transactional(readonly-=-true)-붙이는-이유.html" class="internal-link" target="_self" rel="noopener nofollow">🎗 @Transactional(readOnly = true) 붙이는 이유</a>
<br><a data-href="🌩 Cloud-Native Architecture 분석" href="https://lts.kr/study/cs/🌩-cloud-native-architecture-분석.html" class="internal-link" target="_self" rel="noopener nofollow">🌩 Cloud-Native Architecture 분석</a> <br><a data-href="🐹 MSA(Microservices Architecture)" href="https://lts.kr/study/cs/🐹-msa(microservices-architecture).html" class="internal-link" target="_self" rel="noopener nofollow">🐹 MSA(Microservices Architecture)</a>
<br><a data-href="🐋 docker 란" href="https://lts.kr/tools/docker/🐋-docker-란.html" class="internal-link" target="_self" rel="noopener nofollow">🐋 docker 란</a>
<br><a data-href="🚢Kubernetes(k8s)란" href="https://lts.kr/tools/kubernetes/🚢kubernetes(k8s)란.html" class="internal-link" target="_self" rel="noopener nofollow">🚢Kubernetes(k8s)란</a>
<br><a data-href="👔 Jenkins란" href="https://lts.kr/tools/jenkins/👔-jenkins란.html" class="internal-link" target="_self" rel="noopener nofollow">👔 Jenkins란</a> <br><a data-href="🐡 Spring Security와 Filter" href="https://lts.kr/study/cs/🐡-spring-security와-filter.html" class="internal-link" target="_self" rel="noopener nofollow">🐡 Spring Security와 Filter</a>
<br><a data-href="🚨 RSA 암호화 방식의 이해와 적용 (feat.취약성점검)" href="https://lts.kr/issue_troubleshooting/🚨-rsa-암호화-방식의-이해와-적용-(feat.취약성점검).html" class="internal-link" target="_self" rel="noopener nofollow">🚨 RSA 암호화 방식의 이해와 적용 (feat.취약성점검)</a> <br><a data-href="🍎 Redis로 Key관리하기" href="https://lts.kr/study/cs/🍎-redis로-key관리하기.html" class="internal-link" target="_self" rel="noopener nofollow">🍎 Redis로 Key관리하기</a> <br><a data-href="🌋 OSIV란 무엇인가" href="https://lts.kr/study/cs/🌋-osiv란-무엇인가.html" class="internal-link" target="_self" rel="noopener nofollow">🌋 OSIV란 무엇인가</a>
<br><a data-href="🐰 Java의 String과 SpringBuffer" href="https://lts.kr/study/cs/🐰-java의-string과-springbuffer.html" class="internal-link" target="_self" rel="noopener nofollow">🐰 Java의 String과 SpringBuffer</a>
<br><a data-href="🛬 JDK와 JRE, JVM" href="https://lts.kr/study/cs/🛬-jdk와-jre,-jvm.html" class="internal-link" target="_self" rel="noopener nofollow">🛬 JDK와 JRE, JVM</a>
<br><a data-href="🍊 Spring의 의존성 주입(DI)" href="https://lts.kr/study/cs/🍊-spring의-의존성-주입(di).html" class="internal-link" target="_self" rel="noopener nofollow">🍊 Spring의 의존성 주입(DI)</a>
<br><a data-href="🪕 JPA 관련 용어 정리" href="https://lts.kr/study/cs/🪕-jpa-관련-용어-정리.html" class="internal-link" target="_self" rel="noopener nofollow">🪕 JPA 관련 용어 정리</a>
<br>
<br><a data-href="☕ JAVA , OOP" href="https://lts.kr/study/cs/☕-java-,-oop.html" class="internal-link" target="_self" rel="noopener nofollow">☕ JAVA , OOP</a>
<br><a data-href="🍃 Spring" href="https://lts.kr/study/cs/🍃-spring.html" class="internal-link" target="_self" rel="noopener nofollow">🍃 Spring</a>
<br><a data-href="🎩 DevOps" href="https://lts.kr/study/cs/🎩-devops.html" class="internal-link" target="_self" rel="noopener nofollow">🎩 DevOps</a>
<br><a data-href="📔 DataBase" href="https://lts.kr/study/cs/📔-database.html" class="internal-link" target="_self" rel="noopener nofollow">📔 DataBase</a>
<br><a data-href="📭 Server" href="https://lts.kr/study/cs/📭-server.html" class="internal-link" target="_self" rel="noopener nofollow">📭 Server</a>
<br><a data-href="🐞 etc" href="https://lts.kr/study/cs/🐞-etc.html" class="internal-link" target="_self" rel="noopener nofollow">🐞 etc</a>
<br>
<br><a data-href="🤠 Coding Test 풀이 모음" href="https://lts.kr/study/coding-test/🤠-coding-test-풀이-모음.html" class="internal-link" target="_self" rel="noopener nofollow">🤠 Coding Test 풀이 모음</a>
<br><a data-href="👽 Algorithm" href="https://lts.kr/study/coding-test/👽-algorithm.html" class="internal-link" target="_self" rel="noopener nofollow">👽 Algorithm</a>
<br>
<br><a data-href="🔻 Redis 캐쉬 전략 - hello 서비스에 적용하여 성능개선 가능성" href="https://lts.kr/study/dev-seminar/🔻-redis-캐쉬-전략-hello-서비스에-적용하여-성능개선-가능성.html" class="internal-link" target="_self" rel="noopener nofollow">🔻 Redis 캐쉬 전략 - hello 서비스에 적용하여 성능개선 가능성</a>
<br><a data-href="🔐 상품 투자하기 서비스 Lock기법 개선안" href="https://lts.kr/issue_troubleshooting/🔐-상품-투자하기-서비스-lock기법-개선안.html" class="internal-link" target="_self" rel="noopener nofollow">🔐 상품 투자하기 서비스 Lock기법 개선안</a>
<br><a data-href="🔹 TDD에 대하여" href="https://lts.kr/study/dev-seminar/🔹-tdd에-대하여.html" class="internal-link" target="_self" rel="noopener nofollow">🔹 TDD에 대하여</a>
<br><a data-href="🍂 JPA, Mybatis , Dead Lock이슈" href="https://lts.kr/study/dev-seminar/🍂-jpa,-mybatis-,-dead-lock이슈.html" class="internal-link" target="_self" rel="noopener nofollow">🍂 JPA, Mybatis , Dead Lock이슈</a>
<br><a data-href="🥗 Spring Security_토큰-세션-쿠키-JWT 에 대하여" href="https://lts.kr/study/dev-seminar/🥗-spring-security_토큰-세션-쿠키-jwt-에-대하여.html" class="internal-link" target="_self" rel="noopener nofollow">🥗 Spring Security_토큰-세션-쿠키-JWT 에 대하여</a>
<br><a data-href="📔 DB 테이블 설계, 어떻게 하는게 옳은 방법인가" href="https://lts.kr/study/dev-seminar/📔-db-테이블-설계,-어떻게-하는게-옳은-방법인가.html" class="internal-link" target="_self" rel="noopener nofollow">📔 DB 테이블 설계, 어떻게 하는게 옳은 방법인가</a>]]></description><link>https://lts.kr/study/📕-공부.html</link><guid isPermaLink="false">study/📕 공부.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 02 Jul 2025 02:33:00 GMT</pubDate></item><item><title><![CDATA[📍 Next.js Page Router]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:프로젝트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로젝트</a> <a class="tag" href="https://lts.kr/?query=tag:개발" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#개발</a> <a class="tag" href="https://lts.kr/?query=tag:프론트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프론트</a> <a class="tag" href="https://lts.kr/?query=tag:React" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#React</a> <a class="tag" href="https://lts.kr/?query=tag:Nextjs" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Nextjs</a> <a class="tag" href="https://lts.kr/?query=tag:Front" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Front</a> <a class="tag" href="https://lts.kr/?query=tag:언어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#언어</a> <a class="tag" href="https://lts.kr/?query=tag:프레임워크" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프레임워크</a> <a class="tag" href="https://lts.kr/?query=tag:FRAMWORK" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#FRAMWORK</a> <a class="tag" href="https://lts.kr/?query=tag:Nodejs" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Nodejs</a> <br> <a href="https://lts.kr?query=tag:프로젝트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로젝트">#프로젝트</a> <a href="https://lts.kr?query=tag:개발" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#개발">#개발</a> <a href="https://lts.kr?query=tag:프론트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프론트">#프론트</a> <a href="https://lts.kr?query=tag:React" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#React">#React</a> <a href="https://lts.kr?query=tag:Nextjs" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Nextjs">#Nextjs</a> <a href="https://lts.kr?query=tag:Front" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Front">#Front</a> <a href="https://lts.kr?query=tag:언어" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#언어">#언어</a> <a href="https://lts.kr?query=tag:프레임워크" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프레임워크">#프레임워크</a> <a href="https://lts.kr?query=tag:FRAMWORK" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#FRAMWORK">#FRAMWORK</a> <a href="https://lts.kr?query=tag:Nodejs" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Nodejs">#Nodejs</a><br>
<br>사용자가 웹에서 URL을 입력했을 때, 어떤 페이지를 보여줄지 결정하는 동작.
<br>즉, URL → 페이지 매핑 규칙이다.
<br>ex) /about 을 입력하면, About페이지 컴포넌트를 랜더링한다.
<br>
<br>라우팅을 수행하고 관리하는 시스템.
<br>페이지 전환, 파라미터 처리, URL변경 감지 등을 담당.
<br>이번에는 Next.js의 라우팅 방식의 종류를 자세하게 알아보겠다.<br>Next.js는 파일 시스템 기반 라우팅(file-system based routing) 을 사용한다.<br>즉, 폴더와 파일 구조 자체가 URL 라우트로 매핑된다.<br>
<br>pages 디렉터리나 app 디렉터리에 파일을 추가하면 곧바로 동일한 경로의 페이지가 생성.
<br>예를 들어 pages/about.js 파일을 만들면 /about 경로에 해당 페이지가 생성되는 식이다.
<br>페이지 디렉터리에 파일을 추가하는 것만으로 새로운 웹 페이지(라우트)가 만들어지므로, 초보자도 쉽게 URL 경로를 정의할 수 있습니다. <br>동적 라우팅(Dynamic Routing): 경로 일부가 가변적인 경우 동적 경로를 사용할 수 있습니다. 파일이나 폴더 이름을 [param] 형태의 대괄호로 감싸면 동적 세그먼트로 인식되어, 요청 시 해당 부분을 변수로 처리합니다<a data-tooltip-position="top" aria-label="https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes#:~:text=A%20Dynamic%20Segment%20can%20be,slug" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes#:~:text=A%20Dynamic%20Segment%20can%20be,slug" target="_self">nextjs.org</a><a data-tooltip-position="top" aria-label="https://nextjs.org/docs/app/api-reference/file-conventions/dynamic-routes#:~:text=A%20Dynamic%20Segment%20can%20be,Dynamic%20Segment%20for%20blog%20posts" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/app/api-reference/file-conventions/dynamic-routes#:~:text=A%20Dynamic%20Segment%20can%20be,Dynamic%20Segment%20for%20blog%20posts" target="_self">nextjs.org</a>. 예를 들어 pages/blog/[slug].js는 /blog/hello나 /blog/world 등으로 요청할 때 [slug] 자리에 들어온 값을 읽어 각각의 페이지를 렌더링합니다. 동적 경로 내부에서 Next.js Router를 통해 해당 파라미터에 접근할 수 있습니다. (Pages Router의 경우 useRouter 훅의 router.query.slug로 접근하고, App Router의 경우 컴포넌트의 params 프로퍼티로 접근합니다.) <br>캐치올 라우팅(Catch-all Routing): 여러 경로 세그먼트를 한 번에 캡처하고자 할 때는 [...] 형태로 세 개의 점을 사용합니다. 예를 들어 pages/shop/[...slug].js 파일을 만들면 /shop 하위의 임의의 경로에 모두 매칭됩니다. /shop/clothes, /shop/clothes/tops 등 여러 수준의 경로를 하나의 페이지로 처리할 수 있습니다<a data-tooltip-position="top" aria-label="https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes#:~:text=Dynamic%20Segments%20can%20be%20extended,segmentName" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes#:~:text=Dynamic%20Segments%20can%20be%20extended,segmentName" target="_self">nextjs.org</a><a data-tooltip-position="top" aria-label="https://nextjs.org/docs/app/api-reference/file-conventions/dynamic-routes#:~:text=Catch" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/app/api-reference/file-conventions/dynamic-routes#:~:text=Catch" target="_self">nextjs.org</a>. 이 때 router.query.slug (또는 App Router의 params.slug)는 배열 형태로 여러 세그먼트 값을 담게 됩니다. <br>옵셔널 캐치올(Optional Catch-all): 캐치올 경로를 정의하면서 해당 경로가 없을 때도 페이지를 매칭시키려면 대괄호를 두 번 겹친 [[...param]] 형태를 사용합니다. 예를 들어 pages/shop/[[...slug]].js 파일은 /shop 경로 자체와 /shop/ 이하의 모든 하위 경로를 모두 처리합니다<a data-tooltip-position="top" aria-label="https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes#:~:text=Catch,segmentName" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes#:~:text=Catch,segmentName" target="_self">nextjs.org</a><a data-tooltip-position="top" aria-label="https://nextjs.org/docs/app/api-reference/file-conventions/dynamic-routes#:~:text=Optional%20Catch" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/app/api-reference/file-conventions/dynamic-routes#:~:text=Optional%20Catch" target="_self">nextjs.org</a>. 옵셔널 캐치올을 사용하면 /shop처럼 파라미터가 없을 경우에도 페이지가 렌더링되며, 이때 파라미터 값은 undefined(혹은 빈 배열)로 처리됩니다. <br>중첩 라우팅(Nested Routing): 경로를 다단계로 중첩시켜 계층적인 URL을 만들 수 있습니다. 예를 들어 /blog/category/[slug] 같은 경로는 세gment가 여러 층으로 이루어진 중첩 경로입니다. Next.js에서는 폴더를 중첩시켜 이러한 URL 세그먼트를 표현하고, 폴더 안에 페이지 파일을 넣어 각 세그먼트별 UI를 구성합니다<a data-tooltip-position="top" aria-label="https://nextjs.org/docs/app/getting-started/layouts-and-pages#:~:text=A%20nested%20route%20is%20a,is%20composed%20of%20three%20segments" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/app/getting-started/layouts-and-pages#:~:text=A%20nested%20route%20is%20a,is%20composed%20of%20three%20segments" target="_self">nextjs.org</a><a data-tooltip-position="top" aria-label="https://nextjs.org/docs/app/getting-started/layouts-and-pages#:~:text=In%20Next" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/app/getting-started/layouts-and-pages#:~:text=In%20Next" target="_self">nextjs.org</a>. 예를 들어 pages/blog/[slug].js는 /blog/x 경로에 대응하고, 더 깊은 중첩 경로 /blog/[slug]/[commentId]를 만들고 싶다면 pages/blog/[slug]/[commentId].js 처럼 폴더를 계층적으로 추가하면 됩니다. App Router에서도 마찬가지로 app 디렉터리 내에 폴더를 나란히/계층적으로 배치하여 중첩된 경로를 정의합니다. <br>Next.js에서는 프로젝트 폴더 내에 pages/ 디렉터리와(또는) app/ 디렉터리를 통해 라우트를 정의합니다. Next.js 13부터 도입된 app/ 디렉터리는 새로운 App Router를 활용하며, 기존의 pages/ 디렉터리는 Pages Router로 동작합니다<a data-tooltip-position="top" aria-label="https://nextjs.org/docs/app/guides/migrating/app-router-migration#:~:text=,a%20route%20segment%20publicly%20accessible" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/app/guides/migrating/app-router-migration#:~:text=,a%20route%20segment%20publicly%20accessible" target="_self">nextjs.org</a>. 두 디렉터리 모두 파일 시스템 기반으로 동작하지만, 구조와 규칙에 약간의 차이가 있습니다:<br>Pages Router (pages/ 디렉터리): pages 폴더 아래 파일 이름이 곧 URL 경로가 됩니다. 예를 들어 pages/index.js는 홈 경로(/), pages/about.js는 /about 페이지를 의미합니다. 하위에 폴더를 만들면 URL 경로에 해당 폴더 이름이 세그먼트로 추가됩니다. 또한 파일/폴더 이름에 대괄호 규칙을 적용하여 동적 경로를 만들 수 있습니다<a data-tooltip-position="top" aria-label="https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes#:~:text=A%20Dynamic%20Segment%20can%20be,slug" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes#:~:text=A%20Dynamic%20Segment%20can%20be,slug" target="_self">nextjs.org</a>. 파일명을 [param].js로 하면 동적 라우트, [...param].js로 하면 캐치올 라우트, [[...param]].js로 하면 옵셔널 캐치올 라우트로 동작합니다<a data-tooltip-position="top" aria-label="https://nextjs.org/docs/app/api-reference/file-conventions/dynamic-routes#:~:text=Optional%20Catch" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/app/api-reference/file-conventions/dynamic-routes#:~:text=Optional%20Catch" target="_self">nextjs.org</a>. Pages Router에서는 파일 하나가 하나의 페이지 컴포넌트이며, _app.js, _document.js 같은 특별한 파일로 전체 레이아웃이나 &lt;html&gt; 구조를 설정합니다. <br>App Router (app/ 디렉터리): app 폴더는 Next.js 13+ 버전에서 도입된 새로운 라우팅 방식으로, 폴더가 경로 세그먼트를 나타내고 그 내부의 page.js (혹은 page.tsx) 파일이 해당 경로의 페이지 내용을 담당합니다<a data-tooltip-position="top" aria-label="https://nextjs.org/docs/app/guides/migrating/app-router-migration#:~:text=,a%20route%20segment%20publicly%20accessible" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/app/guides/migrating/app-router-migration#:~:text=,a%20route%20segment%20publicly%20accessible" target="_self">nextjs.org</a>. 즉, 각 폴더마다 반드시 page.jsx/tsx 파일이 있어야 그 폴더 경로가 외부에 노출됩니다. 예를 들어 app/page.tsx는 / 경로의 페이지, app/about/page.tsx는 /about 페이지를 의미합니다<a data-tooltip-position="top" aria-label="https://www.frontendeng.dev/blog/26-difference-between-app-and-pages-in-nextjs#:~:text=App%20is%20the%20new%20directory,about" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.frontendeng.dev/blog/26-difference-between-app-and-pages-in-nextjs#:~:text=App%20is%20the%20new%20directory,about" target="_self">frontendeng.dev</a>. 동적 경로는 폴더 이름을 [param]으로 만들어 표현하고, 해당 폴더 안에 page.js를 두는 방식입니다 (예: app/blog/[slug]/page.tsx는 /blog/[임의값] 경로)<a data-tooltip-position="top" aria-label="https://nextjs.org/docs/app/getting-started/layouts-and-pages#:~:text=You%20can%20continue%20nesting%20folders,file" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/app/getting-started/layouts-and-pages#:~:text=You%20can%20continue%20nesting%20folders,file" target="_self">nextjs.org</a>. 마찬가지로 [...param] 폴더를 만들어 캐치올 경로를, [[...param]] 폴더로 옵셔널 캐치올 경로를 구현할 수 있습니다<a data-tooltip-position="top" aria-label="https://nextjs.org/docs/app/api-reference/file-conventions/dynamic-routes#:~:text=Catch,folderName" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/app/api-reference/file-conventions/dynamic-routes#:~:text=Catch,folderName" target="_self">nextjs.org</a>. App Router에서는 각 폴더별로 선택적으로 layout.js를 정의해 그 하위 경로들에 공통 레이아웃을 적용할 수 있고, pages/_app.js나 _document.js 대신 app/layout.js (루트 레이아웃)을 통해 앱 전역의 레이아웃과 &lt;html&gt;&lt;body&gt; 구조를 설정합니다. <br>아래는 pages/와 app/ 디렉터리 구조 예시입니다. 폴더와 파일의 이름이 어떻게 URL로 매핑되는지 주석으로 표시했습니다:<br>bash<br>복사편집<br>my-nextjs-project/ ├── pages/ # Pages Router 사용 시 │ ├── index.js // '/' (홈 페이지) │ ├── about.js // '/about' │ ├── blog/ │ │ ├── index.js // '/blog' │ │ ├── [slug].js // '/blog/:slug' (동적 라우팅) │ │ └── [[...slug]].js // '/blog' 및 '/blog/...'(옵셔널 캐치올) │ └── api/ │ └── hello.js // API 라우트 예시 ('/api/hello') └── app/ # App Router 사용 시 ├── layout.js // 루트 레이아웃 (모든 페이지에 공통 적용) ├── page.js // '/' (홈 페이지) ├── about/ │ └── page.js // '/about' └── blog/ ├── layout.js // '/blog' 관련 페이지 레이아웃 ├── page.js // '/blog' └── [slug]/ └── page.js // '/blog/:slug' (동적 라우팅)<br>위 구조에서 볼 수 있듯, pages 디렉터리에서는 파일 자체가 경로이고, app 디렉터리에서는 각 폴더가 경로 세그먼트이며 그 안의 page.js 파일이 실제 페이지를 담당합니다. 폴더/파일에 대괄호([])를 사용한 규칙은 양쪽에 공통으로 적용되어 동적 라우트나 캐치올 라우트를 만들 수 있습니다<a data-tooltip-position="top" aria-label="https://nextjs.org/docs/app/getting-started/layouts-and-pages#:~:text=Wrapping%20a%20folder%20name%20in,blog%20posts%2C%20product%20pages%2C%20etc" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/app/getting-started/layouts-and-pages#:~:text=Wrapping%20a%20folder%20name%20in,blog%20posts%2C%20product%20pages%2C%20etc" target="_self">nextjs.org</a>. 다만 App Router에서는 페이지 컴포넌트 파일명이 항상 page로 고정인 점이 다르고, 폴더 구조를 자유롭게 깊게 중첩하여 복잡한 경로도 표현할 수 있습니다 (예: app/products/[category]/[item]/page.tsx → /products/:category/:item 경로).<br>Next.js 13 버전에서 App Router (app/ 디렉터리)가 도입되면서 기존 Pages Router (pages/ 디렉터리)와 여러 측면에서 차이가 생겼습니다<a data-tooltip-position="top" aria-label="https://www.frontendeng.dev/blog/26-difference-between-app-and-pages-in-nextjs#:~:text=Nextjs%20introduced%20a%20new%20app,are%20starting%20a%20new%20project" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.frontendeng.dev/blog/26-difference-between-app-and-pages-in-nextjs#:~:text=Nextjs%20introduced%20a%20new%20app,are%20starting%20a%20new%20project" target="_self">frontendeng.dev</a>. 주요 차이점을 기능, 동작 방식 측면에서 정리하면 다음과 같습니다:<br>파일 구조 및 라우팅 방식: Pages Router는 pages 폴더에 파일을 생성하면 자동으로 라우트가 생성되는 관례 중심(convention)의 방식입니다. 반면 App Router는 app 폴더 내에 폴더와 특별한 파일명(page, layout 등)을 사용하여 라우트를 보다 구조적으로 정의합니다<a data-tooltip-position="top" aria-label="https://nextjs.org/docs/app/guides/migrating/app-router-migration#:~:text=,a%20route%20segment%20publicly%20accessible" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/app/guides/migrating/app-router-migration#:~:text=,a%20route%20segment%20publicly%20accessible" target="_self">nextjs.org</a>. Pages Router에서는 _app.js, _document.js, _error.js 등을 통해 전역 설정을 했지만, App Router에서는 이러한 파일들이 루트 레이아웃 (app/layout.js)이나 각 경로별 layout.js, 그리고 error.js, loading.js 등으로 대체되었습니다<a data-tooltip-position="top" aria-label="https://nextjs.org/docs/app/guides/migrating/app-router-migration#:~:text=,been%20replaced%20with%20a%20single" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/app/guides/migrating/app-router-migration#:~:text=,been%20replaced%20with%20a%20single" target="_self">nextjs.org</a>. 즉, App Router는 중첩 레이아웃과 에러 처리, 로딩 상태 등을 파일 시스템에 선언적으로 구성할 수 있습니다. <br>렌더링 방식 (클라이언트/서버 컴포넌트): App Router의 도입과 함께 React Server Components(RSC)가 기본적으로 활용됩니다. App Router의 페이지 컴포넌트는 기본적으로 서버 컴포넌트로 렌더링되어, 클라이언트로 불필요한 자바스크립트를 보내지 않고도 HTML을 그려내는 방식입니다<a data-tooltip-position="top" aria-label="https://www.frontendeng.dev/blog/26-difference-between-app-and-pages-in-nextjs#:~:text=,RSC" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.frontendeng.dev/blog/26-difference-between-app-and-pages-in-nextjs#:~:text=,RSC" target="_self">frontendeng.dev</a>. 이는 Pages Router 시절의 페이지 컴포넌트들이 항상 클라이언트 컴포넌트로 실행되던 것과 큰 차이점입니다. (Pages Router에서도 SSR을 지원하지만, SSR 결과를 하이드레이션하는 형태이고 컴포넌트 자체는 클라이언트에서 동작했습니다.) App Router에서는 "use client" 지시어를 통해 클라이언트 컴포넌트로 전환할 수 있고, 기본은 서버에서 렌더링됩니다. 이로 인해 초기 페이지 로드 성능과 코드 분할 측면에서 이점이 있지만, 반대로 Pages Router보다 개념이 다소 복잡해졌습니다<a data-tooltip-position="top" aria-label="https://dev.to/dcs-ink/nextjs-app-router-vs-pages-router-3p57#:~:text=Simplicity%20vs,suited%20for%20complex%20routing%20scenarios" rel="noopener nofollow" class="external-link is-unresolved" href="https://dev.to/dcs-ink/nextjs-app-router-vs-pages-router-3p57#:~:text=Simplicity%20vs,suited%20for%20complex%20routing%20scenarios" target="_self">dev.to</a>. <br>데이터 패칭(Data Fetching) 방식: Pages Router에서는 getStaticProps, getServerSideProps, getStaticPaths, getInitialProps 등의 특수한 데이터 패칭 함수를 페이지 컴포넌트에서 export하여 Next.js가 빌드 타임 혹은 요청 시 데이터를 공급했습니다. App Router에서는 이러한 함수를 지원하지 않으며, 대신 fetch API와 React의 비동기 컴포넌트 패턴을 사용한 간결한 데이터 패칭 방식으로 대체되었습니다<a data-tooltip-position="top" aria-label="https://www.frontendeng.dev/blog/26-difference-between-app-and-pages-in-nextjs#:~:text=The%20pages%20directory%20uses%20getServerSideProps,and%20async%20React%20Server%20Components" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.frontendeng.dev/blog/26-difference-between-app-and-pages-in-nextjs#:~:text=The%20pages%20directory%20uses%20getServerSideProps,and%20async%20React%20Server%20Components" target="_self">frontendeng.dev</a><a data-tooltip-position="top" aria-label="https://nextjs.org/docs/app/guides/migrating/app-router-migration#:~:text=,been%20replaced%20with%20a%20single" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/app/guides/migrating/app-router-migration#:~:text=,been%20replaced%20with%20a%20single" target="_self">nextjs.org</a>. 예를 들어 Pages Router에서 정적 데이터를 가져오려면 getStaticProps를 구현해야 했지만, App Router의 페이지 컴포넌트에서는 그냥 await fetch()를 호출하면 Next.js가 해당 데이터를 빌드 시 캐싱하여 SSR해주는 식입니다. 또한 getStaticPaths는 App Router에서 generateStaticParams라는 함수로 대체되어, 빌드 시 생성할 동적 경로 목록을 정의합니다<a data-tooltip-position="top" aria-label="https://nextjs.org/docs/app/guides/migrating/app-router-migration#:~:text=,been%20replaced%20with%20a%20single" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/app/guides/migrating/app-router-migration#:~:text=,been%20replaced%20with%20a%20single" target="_self">nextjs.org</a>. 요약하면, Pages Router는 명시적인 데이터 패칭 함수 기반, App Router는 React 컴포넌트 내에서 직접 비동기 처리를 하는 형태로 달라졌습니다. 이 변화로 인해 App Router 쪽이 데이터 패칭 코드가 간소화되고 타입스크립트 사용이 쉬워졌지만, 기존 Pages Router 함수를 사용하던 코드는 마이그레이션이 필요합니다. <br>레이아웃과 중첩 UI: Pages Router에서는 페이지 간 공통 레이아웃을 구현하기 위해 _app.js에서 모든 페이지에 공통 레이아웃을 넣거나, 각 페이지 컴포넌트를 감싸는 식으로 처리했습니다. 반면 App Router는 중첩 레이아웃(Nested Layout)을 프레임워크 차원에서 지원하여, 폴더마다 layout.js를 추가함으로써 해당 경로 이하의 모든 페이지에 자동으로 레이아웃이 적용되도록 합니다<a data-tooltip-position="top" aria-label="https://nextjs.org/docs/app/getting-started/layouts-and-pages#:~:text=Nesting%20layouts" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/app/getting-started/layouts-and-pages#:~:text=Nesting%20layouts" target="_self">nextjs.org</a><a data-tooltip-position="top" aria-label="https://nextjs.org/docs/app/getting-started/layouts-and-pages#:~:text=If%20you%20were%20to%20combine,slug%5D%2Fpage.js" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/app/getting-started/layouts-and-pages#:~:text=If%20you%20were%20to%20combine,slug%5D%2Fpage.js" target="_self">nextjs.org</a>. 예를 들어 app/dashboard/layout.js와 app/dashboard/page.js가 있다면 대시보드 레이아웃 안에 여러 페이지가 렌더링되며 상태도 보존됩니다. 또한 서로 다른 레이아웃을 병렬로 구성하는 Parallel Routes나 경로를 조건부로 바꾸는 Intercepting Routes 등 App Router만의 고급 라우팅 기능들도 제공됩니다. 이러한 유연성 덕분에 App Router는 복잡한 UI 구조나 대시보드형 앱 등에 적합합니다<a data-tooltip-position="top" aria-label="https://dev.to/dcs-ink/nextjs-app-router-vs-pages-router-3p57#:~:text=Simplicity%20vs,suited%20for%20complex%20routing%20scenarios" rel="noopener nofollow" class="external-link is-unresolved" href="https://dev.to/dcs-ink/nextjs-app-router-vs-pages-router-3p57#:~:text=Simplicity%20vs,suited%20for%20complex%20routing%20scenarios" target="_self">dev.to</a>. <br>권장 사용 및 마이그레이션: Next.js 13 이후 Vercel 측은 새로운 앱을 만들 때 App Router 사용을 권장하고 있습니다<a data-tooltip-position="top" aria-label="https://www.frontendeng.dev/blog/26-difference-between-app-and-pages-in-nextjs#:~:text=Nextjs%20introduced%20a%20new%20app,are%20starting%20a%20new%20project" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.frontendeng.dev/blog/26-difference-between-app-and-pages-in-nextjs#:~:text=Nextjs%20introduced%20a%20new%20app,are%20starting%20a%20new%20project" target="_self">frontendeng.dev</a>. App Router가 초기에는 실험적이었지만 현재는 안정화되었고, 향후 Next.js에서는 Pages Router보다 App Router 중심으로 발전이 예상됩니다 (장기적으로 Pages Router가 deprecated될 가능성이 높습니다<a data-tooltip-position="top" aria-label="https://www.frontendeng.dev/blog/26-difference-between-app-and-pages-in-nextjs#:~:text=official%20documentation%20here" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.frontendeng.dev/blog/26-difference-between-app-and-pages-in-nextjs#:~:text=official%20documentation%20here" target="_self">frontendeng.dev</a>). 기존 Pages Router 기반 프로젝트는 점진적으로 마이그레이션할 수 있습니다. Next.js는 두 라우터를 동시 사용하는 것도 허용하기 때문에 (pages/와 app/ 폴더를 함께 두는 방식), 일부 페이지부터 app/ 디렉터리로 옮겨가는 점진적 도입도 가능합니다<a data-tooltip-position="top" aria-label="https://nextjs.org/docs/app/guides/migrating/app-router-migration#:~:text=Next,exists%20with%20the%20%60pages%60%20directory" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/app/guides/migrating/app-router-migration#:~:text=Next,exists%20with%20the%20%60pages%60%20directory" target="_self">nextjs.org</a>. 마이그레이션 시에는 기존의 _app.js 설정을 app/layout.js로 이전하고, 데이터 패칭 로직은 앞서 언급한 새로운 방식으로 변경하는 등 단계별 작업이 필요합니다<a data-tooltip-position="top" aria-label="https://nextjs.org/docs/app/guides/migrating/app-router-migration#:~:text=,been%20replaced%20with%20a%20single" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/app/guides/migrating/app-router-migration#:~:text=,been%20replaced%20with%20a%20single" target="_self">nextjs.org</a>. Pages Router의 기존 페이지들은 app 디렉터리로 이동하지 않는 한 그대로 동작하므로, 업그레이드해도 당장 App Router로 전환할 필요는 없지만, 장기적으로는 App Router로 전환하는 것이 권장됩니다. <br>Next.js에서는 라우팅을 세부적으로 제어하기 위해 next.config.js 파일에서 몇 가지 옵션을 제공합니다. redirects, rewrites, headers가 그것으로, 경로를 바꾸거나 리다이렉트하며 특정 응답 헤더를 붙이는 등의 커스텀 라우팅 규칙을 정의할 수 있습니다. 이 설정들은 모두 비동기 함수 형태로 배열을 반환하는 패턴이며, Next.js 서버 빌드 시 적용됩니다. 각 옵션의 역할과 사용법은 다음과 같습니다:<br>리디렉션(redirects): 들어온 요청 경로를 다른 경로로 영구 혹은 일시적으로 이동시키는 규칙입니다. 예를 들어 오래된 URL 구조를 새로운 구조로 변경한 경우나 특정 페이지를 별도의 페이지로 이동시키고 싶을 때 사용합니다<a data-tooltip-position="top" aria-label="https://nextjs.org/docs/app/guides/redirecting#:~:text=The%20,are%20known%20ahead%20of%20time" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/app/guides/redirecting#:~:text=The%20,are%20known%20ahead%20of%20time" target="_self">nextjs.org</a>. next.config.js에서 async redirects() 함수를 export하고, 내부에서 source (기존 경로 패턴), destination (목표 경로), permanent (영구여부, true면 308 Permanent Redirect / false면 307 Temporary Redirect)를 지정하는 객체 목록을 반환하면 됩니다. 지정된 경로로 요청이 오면 브라우저가 새로운 경로로 리디렉션되며 URL도 변경됩니다<a data-tooltip-position="top" aria-label="https://nextjs.org/docs/app/api-reference/config/next-config-js/rewrites#:~:text=Rewrites%20allow%20you%20to%20map,to%20a%20different%20destination%20path" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/app/api-reference/config/next-config-js/rewrites#:~:text=Rewrites%20allow%20you%20to%20map,to%20a%20different%20destination%20path" target="_self">nextjs.org</a><a data-tooltip-position="top" aria-label="https://nextjs.org/docs/app/api-reference/config/next-config-js/rewrites#:~:text=Rewrites%20act%20as%20a%20URL,and%20show%20the%20URL%20changes" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/app/api-reference/config/next-config-js/rewrites#:~:text=Rewrites%20act%20as%20a%20URL,and%20show%20the%20URL%20changes" target="_self">nextjs.org</a>. 예시 – /about 경로를 홈(/)으로 영구 리디렉션: js 복사편집 // next.config.js module.exports = { async redirects() { return [ { source: '/about', destination: '/', permanent: true }, ]; }, }; 위 설정에 따르면 사용자가 /about으로 접속하면 브라우저가 상태 코드 308과 함께 / 경로로 이동하게 됩니다. (permanent: false로 설정하면 307 Redirect로 처리됩니다<a data-tooltip-position="top" aria-label="https://nextjs.org/docs/app/guides/redirecting#:~:text=,redirects%20at%20scale%20for%20more" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/app/guides/redirecting#:~:text=,redirects%20at%20scale%20for%20more" target="_self">nextjs.org</a>.) <br>리라이팅(rewrites): 특정 경로로 들어온 요청을 다른 경로의 콘텐츠로 매핑하지만, URL은 바꾸지 않고 그대로 유지시킵니다<a data-tooltip-position="top" aria-label="https://nextjs.org/docs/app/api-reference/config/next-config-js/rewrites#:~:text=Rewrites%20allow%20you%20to%20map,to%20a%20different%20destination%20path" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/app/api-reference/config/next-config-js/rewrites#:~:text=Rewrites%20allow%20you%20to%20map,to%20a%20different%20destination%20path" target="_self">nextjs.org</a>. 이를 통해 사용자에게는 URL이 그대로 보이면서, 내부적으로는 다른 페이지를 보여주거나 외부 사이트의 내용을 프록시할 수도 있습니다<a data-tooltip-position="top" aria-label="https://nextjs.org/docs/app/api-reference/config/next-config-js/rewrites#:~:text=Rewrites%20act%20as%20a%20URL,and%20show%20the%20URL%20changes" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/app/api-reference/config/next-config-js/rewrites#:~:text=Rewrites%20act%20as%20a%20URL,and%20show%20the%20URL%20changes" target="_self">nextjs.org</a>. 설정 방법은 async rewrites() 함수에서 source와 destination을 지정하는 것으로, redirects와 유사하지만 permanent 옵션이 없고 브라우저에 주소 변경을 알리지 않습니다. 예시 – /blog/:slug 경로의 내용을 내부적으로 /news/:slug 경로에서 가져오도록 rewrite: js 복사편집 // next.config.js module.exports = { async rewrites() { return [ { source: '/blog/:slug*', destination: '/news/:slug*' }, ]; }, }; 위처럼 설정하면 사용자가 /blog/hello로 접속했을 때 실제로는 /news/hello의 페이지 내용이 렌더되지만, 브라우저 주소 창에는 여전히 /blog/hello로 보이게 됩니다<a data-tooltip-position="top" aria-label="https://nextjs.org/docs/app/api-reference/config/next-config-js/rewrites#:~:text=Rewrites%20allow%20you%20to%20map,to%20a%20different%20destination%20path" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/app/api-reference/config/next-config-js/rewrites#:~:text=Rewrites%20allow%20you%20to%20map,to%20a%20different%20destination%20path" target="_self">nextjs.org</a>. Wildcard (*)나 정규식 그룹 등 고급 패턴 매칭도 지원하여 유연하게 경로를 매핑할 수 있습니다<a data-tooltip-position="top" aria-label="https://nextjs.org/docs/app/api-reference/config/next-config-js/rewrites#:~:text=To%20match%20a%20regex%20path,blog%2Fabc" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/app/api-reference/config/next-config-js/rewrites#:~:text=To%20match%20a%20regex%20path,blog%2Fabc" target="_self">nextjs.org</a><a data-tooltip-position="top" aria-label="https://nextjs.org/docs/app/api-reference/config/next-config-js/rewrites#:~:text=next" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/app/api-reference/config/next-config-js/rewrites#:~:text=next" target="_self">nextjs.org</a>. 또한 has/missing 필드를 사용하면 특정 헤더나 쿠키, 쿼리 파라미터 존재 여부에 따라 조건부로 rewrites를 적용할 수도 있습니다<a data-tooltip-position="top" aria-label="https://nextjs.org/docs/app/api-reference/config/next-config-js/rewrites#:~:text=module.exports%20%3D%20,has%3A%20%5B" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/app/api-reference/config/next-config-js/rewrites#:~:text=module.exports%20%3D%20,has%3A%20%5B" target="_self">nextjs.org</a><a data-tooltip-position="top" aria-label="https://nextjs.org/docs/app/api-reference/config/next-config-js/rewrites#:~:text=source%3A%20%27%2F%3Apath,destination%3A%20%27%2Fhome%3Fauthorized%3D%3Aauthorized%27%2C" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/app/api-reference/config/next-config-js/rewrites#:~:text=source%3A%20%27%2F%3Apath,destination%3A%20%27%2Fhome%3Fauthorized%3D%3Aauthorized%27%2C" target="_self">nextjs.org</a>. <br>헤더(headers): 특정 경로의 응답에 사용자 정의 HTTP 헤더를 추가하고 싶을 때 사용합니다. 주로 보안 헤더(CSP, X-Frame-Options 등)나 캐시 제어 헤더 등을 전역으로 적용할 때 유용합니다. async headers() 함수에서 source 경로 패턴과 headers 키 배열을 반환하면 되며, 각 헤더 객체는 key (헤더명)과 value (헤더값)로 구성됩니다<a data-tooltip-position="top" aria-label="https://nextjs.org/docs/pages/api-reference/config/next-config-js/headers#:~:text=Headers%20allow%20you%20to%20set,request%20on%20a%20given%20path" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/pages/api-reference/config/next-config-js/headers#:~:text=Headers%20allow%20you%20to%20set,request%20on%20a%20given%20path" target="_self">nextjs.org</a><a data-tooltip-position="top" aria-label="https://nextjs.org/docs/pages/api-reference/config/next-config-js/headers#:~:text=,header" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/pages/api-reference/config/next-config-js/headers#:~:text=,header" target="_self">nextjs.org</a>. 예시 – /about 페이지에 커스텀 헤더 추가: js 복사편집 // next.config.js module.exports = { async headers() { return [ { source: '/about', headers: [ { key: 'X-Custom-Header', value: 'my custom header value' }, { key: 'X-Another-Header', value: 'another value' }, ], }, ]; }, }; 위 설정은 /about 경로를 요청할 때 응답 헤더에 X-Custom-Header: my custom header value와 X-Another-Header: another value를 포함시킵니다. source에는 와일드카드 패턴 (/docs/:slug* 등)을 사용할 수도 있어 다수의 경로에 한꺼번에 헤더를 적용할 수 있습니다<a data-tooltip-position="top" aria-label="https://nextjs.org/docs/pages/api-reference/config/next-config-js/headers#:~:text=Path%20matches%20are%20allowed%2C%20for,world%60%20%28no%20nested%20paths" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/pages/api-reference/config/next-config-js/headers#:~:text=Path%20matches%20are%20allowed%2C%20for,world%60%20%28no%20nested%20paths" target="_self">nextjs.org</a><a data-tooltip-position="top" aria-label="https://nextjs.org/docs/pages/api-reference/config/next-config-js/headers#:~:text=Wildcard%20Path%20Matching" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/pages/api-reference/config/next-config-js/headers#:~:text=Wildcard%20Path%20Matching" target="_self">nextjs.org</a>. 헤더 설정은 파일 시스템 라우팅보다 우선 적용되며, 중복되는 헤더 키가 여러 규칙에 걸리면 마지막에 정의된 값으로 덮어쓰입니다<a data-tooltip-position="top" aria-label="https://nextjs.org/docs/pages/api-reference/config/next-config-js/headers#:~:text=Headers%20are%20checked%20before%20the,files" rel="noopener nofollow" class="external-link is-unresolved" href="https://nextjs.org/docs/pages/api-reference/config/next-config-js/headers#:~:text=Headers%20are%20checked%20before%20the,files" target="_self">nextjs.org</a>.]]></description><link>https://lts.kr/project/new-project/📍-next.js-page-router.html</link><guid isPermaLink="false">project/New Project/📍 Next.js Page Router.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Tue, 01 Jul 2025 07:46:03 GMT</pubDate></item><item><title><![CDATA[📴 AnoniChat FrontServer feat. Next.js]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:프로젝트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로젝트</a> <a class="tag" href="https://lts.kr/?query=tag:개발" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#개발</a> <a class="tag" href="https://lts.kr/?query=tag:프론트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프론트</a> <a class="tag" href="https://lts.kr/?query=tag:React" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#React</a> <a class="tag" href="https://lts.kr/?query=tag:Nextjs" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Nextjs</a> <a class="tag" href="https://lts.kr/?query=tag:Front" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Front</a> <a class="tag" href="https://lts.kr/?query=tag:언어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#언어</a> <a class="tag" href="https://lts.kr/?query=tag:프레임워크" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프레임워크</a> <a class="tag" href="https://lts.kr/?query=tag:FRAMWORK" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#FRAMWORK</a> <br> <a href="https://lts.kr?query=tag:프로젝트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로젝트">#프로젝트</a> <a href="https://lts.kr?query=tag:개발" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#개발">#개발</a> <a href="https://lts.kr?query=tag:프론트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프론트">#프론트</a> <a href="https://lts.kr?query=tag:React" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#React">#React</a> <a href="https://lts.kr?query=tag:Nextjs" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Nextjs">#Nextjs</a> <a href="https://lts.kr?query=tag:Front" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Front">#Front</a> <a href="https://lts.kr?query=tag:언어" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#언어">#언어</a> <a href="https://lts.kr?query=tag:프레임워크" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프레임워크">#프레임워크</a> <a href="https://lts.kr?query=tag:FRAMWORK" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#FRAMWORK">#FRAMWORK</a><br>
<br>프로젝트의 기본적인 골격은 다음과 같다.
<br><img alt="Pasted image 20250630173433.png" src="https://lts.kr/사진-및-문서/pasted-image-20250630173433.png" style="width: 950px; max-width: 100%;" target="_self"><br>프로젝트 구조<br>/
├── app/ # 페이지와 전역 레이아웃, 전역 CSS 위치
│ ├── favicon.ico
│ ├── globals.css
│ ├── layout.tsx
│ └── page.tsx
├── public/ # 정적 파일(이미지 등)
│ ├── file.svg
│ ├── globe.svg
│ ├── next.svg
│ ├── vercel.svg
│ └── window.svg
├── .gitignore
├── README.md
├── package.json
├── package-lock.json
├── next.config.ts
├── postcss.config.mjs
├── tsconfig.json
└── eslint.config.mjs
<br>
<br>Node 프로젝트의 핵심 설정 파일이며, Maven/Gradle의&nbsp;pom.xml과 비슷한 역할을 한다.
<br>스크립트 정의(dev,&nbsp;build,&nbsp;start,&nbsp;lint)와 의존성(react,&nbsp;next&nbsp;등)을 관리한다.
<br>
<br>Next.js 전용 설정 파일로, Spring Boot의&nbsp;application.properties/yml과 유사한 환경 설정을 담당합니다.
<br>현재는 기본 골격만 존재하며,&nbsp;nextConfig&nbsp;객체 안에 필요한 옵션을 채워 넣을 수 있습니다
<br>
<br>TypeScript 컴파일러 설정 파일로,&nbsp;strict&nbsp;모드 여부, 모듈 해석 방법 등을 정의합니다.
<br>Next.js 프로젝트에서 타입 체크와 경로 별칭 등을 제어합니다
<br>
<br>CSS 후처리를 위한 PostCSS 설정 파일입니다. 여기서는 TailwindCSS 플러그인만 활성화되어 있습니다
<br>
<br>코드 품질 관리를 위한 ESLint 설정 파일입니다.&nbsp;next/core-web-vitals와&nbsp;next/typescript&nbsp;규칙을 사용해 기본적인 린트 규칙을 적용합니다
<br>
<br>모든 페이지에 공통 적용되는 레이아웃 컴포넌트로, 전역 CSS를 불러오며&nbsp;&lt;html&gt;&nbsp;과&nbsp;&lt;body&gt;&nbsp;태그를 정의합니다. Spring Boot에서 공통 레이아웃(예:&nbsp;layout.jsp,&nbsp;layout.html)을 정의하는 것과 비슷합니다
<br>
<br>/&nbsp;경로의 기본 페이지를 나타냅니다. 간단히 “Hello AnoniChat” 메시지를 보여주는 컴포넌트가 들어 있습니다
<br>
<br>전역 스타일을 정의하는 CSS 파일입니다. TailwindCSS를 임포트하고 다크 모드 등 기본 변수를 설정합니다
<br>
<br>이미지 등의 정적 파일을 두는 곳으로, Spring Boot의&nbsp;resources/static&nbsp;폴더와 유사합니다.
<br>
<br>Git 관리에서 제외할 파일 목록을 정의합니다.&nbsp;node_modules,&nbsp;.next&nbsp;결과물 등 개발 시 불필요한 파일을 무시합니다]]></description><link>https://lts.kr/project/new-project/📴-anonichat-frontserver-feat.-next.js.html</link><guid isPermaLink="false">project/New Project/📴 AnoniChat FrontServer feat. Next.js.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Mon, 30 Jun 2025 08:39:13 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20250630173433.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20250630173433.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🍌 React와 Next.js]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="https://lts.kr/?query=tag:React" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#React</a> <a class="tag" href="https://lts.kr/?query=tag:Nextjs" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Nextjs</a> <a class="tag" href="https://lts.kr/?query=tag:Front" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Front</a> <a class="tag" href="https://lts.kr/?query=tag:언어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#언어</a> <a class="tag" href="https://lts.kr/?query=tag:프레임워크" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프레임워크</a> <a class="tag" href="https://lts.kr/?query=tag:FRAMWORK" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#FRAMWORK</a> <br> <a href="https://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="https://lts.kr?query=tag:React" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#React">#React</a> <a href="https://lts.kr?query=tag:Nextjs" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Nextjs">#Nextjs</a> <a href="https://lts.kr?query=tag:Front" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Front">#Front</a> <a href="https://lts.kr?query=tag:언어" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#언어">#언어</a> <a href="https://lts.kr?query=tag:프레임워크" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프레임워크">#프레임워크</a> <a href="https://lts.kr?query=tag:FRAMWORK" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#FRAMWORK">#FRAMWORK</a><br>
<br>JavaScript 기술 스택에서 React, Next.js, Node.js는 현대 웹 개발의 핵심을 이루는 요소이다.
<br>React는 UI 구축을 위한 프론트엔드 라이브러리이고, Node.js는 서버에서 JavaScript를 구동하는 백엔드 런타임이며, Next.js는 React와 Node.js를 결합한 풀스택 웹 프레임워크이다.
<br>
<br>정의: Facebook(현 Meta)이 개발한 자바스크립트 기반 UI 라이브러리.
<br>주요 목적: 사용자 인터페이스(UI) 구축에 초점. 컴포넌트 기반 구조 덕분에 UI를 재사용 가능하고 상태 관리가 직관적이다.
<br>주요 특징: <br>Virtual DOM으로 효율적 렌더링
<br>단방향 데이터 흐름
<br>Hooks 등 함수형 프로그래밍 스타일 지원 <br>
<br>정의: Chrome V8 자바스크립트 엔진 기반의 런타임 환경.
<br>주요 목적: 브라우저 밖에서도 JS 실행 가능하게 함 → 서버사이드 개발에 사용.
<br>주요 특징: <br>비동기 I/O → 고성능, 이벤트 기반
<br>npm(Node Package Manager)으로 방대한 패키지 생태계
<br>Express.js 같은 웹 프레임워크와 함께 주로 사용 <br>
<br>정의: React 애플리케이션 개발을 위한 프레임워크.
<br>주요 목적: SSR(Server-Side Rendering), SSG(Static Site Generation) 등을 지원해 React의 부족한 SEO와 초기 로딩 문제를 보완.
<br>주요 특징: <br>파일 기반 라우팅
<br>API Routes로 간단한 백엔드 기능 가능
<br>Image Optimization, Incremental Static Regeneration 등 고급 기능 내장 <br>React로 구축한 싱글 페이지 애플리케이션(SPA)은 기본적으로 클라이언트 측에서 화면을 렌더링하지만,<br>Next.js를 사용하면 SSR을 통해 서버에서 미리 렌더된 HTML을 클라이언트에 전달할 수 있다. 이는 SEO 향상과 초기 로드 속도 개선에 크게 도움을 주며, Next.js는 라우팅, 데이터 패칭 등을 간소화하여 블로그, 이커머스 등 SEO가 중요한 웹앱에 적합한 솔루션을 제공한다.<br>SEO 란?
SEO란 ‘Search Engine Optimizaion’으로 검색 엔진 최적화 라고 할 수 있다.<br>
이는, 웹 사이트나 웹페이지를 검색 엔진에서 더 잘 찾을 수 있도록 최적화 하는 과정을 말한다.
검색엔진에서 높은 순위를 차지하는 것은 더 많은 트레픽을 유도하고, 브랜드 인지도를 향상시키는데 가장 효과적인 방법 이다.
<br>Next.js 애플리케이션은 내부적으로 Node.js 환경에서 구동되어 SSR이나 API 라우트 같은 백엔드 처리를 수행한다. 요컨대 Node.js가 토대가 되고 그 위에 React와 Next.js가 프론트엔드를 담당하는 형태로 상호 보완적인 관계이다.<br>Node.js는 Next.js의 서버 사이드 로직을 실행하는 엔진 역할을 하여, 다수 사용자 접속 시에도 원활한 동작을 뒷받침한다.<br>
<br>React는 브라우저에서 동작하는 인터페이스 구현
<br>Node.js는 서버에서 동작하는 로직 구현
<br>Next.js는 이 둘을 연결하여 서버 사이드 렌더링과 풀스택 기능을 제공하는 프레임워크
<br> 이러한 조합으로 프론트엔드(React)와 백엔드(Node.js)를 단일 JavaScript 언어로 다룰 수 있으며, Next.js가 그 사이를 매끄럽게 이어주는 설계이다.<br>위에서 반복적으로 기술한 SSR, SSG 그리고 CDR이란 무엇일까?<br>
<br>클라이언트 사이드 렌더링은 HTML파일을 받아와서 Client(웹 브라우저)측에서 렌더링이 일어나는 방식이다.
<br>동작방식<br>유저 웹사이트 방문
<br>브라우저의 요청을 서버로 낸다.
<br>서버는 빈 뼈대의 HTML파일과 함꼐 js가 연결된 링크를 보낸다.
<br>브라우저는, 클라이언트가 파일을 받을 때 연결된 JS링크를 통해 서버로부터 JS를 다운받는다.
<br>이를 이용해 페이지(동적 DOM)을 만들어서 브라우저에 띄운다.
<br>웹 페이지의 내용에 DB데이터가 필요한 경우?
<br>→ 브라우저는 DB에 저장된 데이터를 가져와, 웹페이지에 랜더링 해야한다. API요청을 이용한다.<br>장점<br>필요한 부분만 가져오기 때문에, 랜더링 속도가 빠르다.
<br>data요청이 있을 때만 서버에 요청하기 때문에 초기 이후에 구동속도가 빠르고, 서버에 부담이 적다.
<br>서버가 빈뼈대의 HTML을 념겨주어 서버측 부하가 적다.
<br>단점<br>모든 JS파일을 다운받아와야 하기 때문에, 초기 로딩이 오래걸린다.
<br>맨처음 HTMl파일이 비어있어, 검색엔친 최적화(SEO)에 불리하다.
<br>
<br>서버 사이드 랜더링은 웹 페이지를 서버측에서 랜더링 하는 방식이다.
<br>SSR이 적합한 웹사이트는?
SSR은 요청할때 서버에서 매 번 HTML파일을 만들기 때문에 데이터가 수시로 달라져서,<br>
미리 만들어두기 어려운 페이지에 적합하다.
<br>동작방식<br>유저 웹사이트 방문
<br>브라우저가 서버측에 콘텐츠 요청
<br>서버에서는 페이지에 필요한 데이터와 CSS까지 모둑 적용후 렌더링 준비를 마치 HTML과 JS를 브라우저로 넘긴다.
<br>브라우저는 HTML을 랜더링하고 JS코드를 다운로드하며, HTML에 JS로직을 연결한다.
<br>웹피이지에 DB데이터가 필요한 경우
<br>→ 서버는 DB데이터를 불러온후 다음 웹페이지를 완전히 랜더링 된 페이지로 변환 후에 브라우저에 넘긴다.<br>장점<br>웹페이지 초기 로딩 지연시간을 줄일 수 있다.
<br>view를 서버에서 랜더링하여 가져오기 때문에 첫 로딩이 매우 짧다. <br>→ 이때, 뷰는 올라갔지만 랜더링 되지 않았을때 아무런 동작이 먹히지 않는 단점이 있다. <br>SEO가 많은 양의 웹 콘텐츠 정보를 수집하게 되므로, 검색사이트 상위 노출에 유리하다.
<br>단점<br>페이지를 요청할 때 마다 새로고침되어 사용자 경험(UX)가 떨어질 수 있다.
<br>요청이 많아지면 서버에 부담이 될 수 있다.
<br>
<br>SSR은 서버에 요청하는 시점에 랜더링을 시작한다.
<br>하지만, SSR방식은 페이지들을 서버에 미리 다 만들어놓고, 요청시에 응답하는 방식이다.(빌드시점)
<br>→ 업데이트가 자주 필요없는 정적인 사이트를 구축할 때 좋은 효율을 낸다. (SSR보다 훨씬 높은 효율)<br>하지만, 정적사이트도 재 빌드가 필요할 수 있다. 이때 사용하는 것이 ISR이다.<br> 장점<br>SEO성능이 높다.
<br>랜더링 속도가 매우 빠르다.
<br>단점<br>동적인 페이지에서 쓰면 성능상의 문제가 발생할 수 있다. <br>
<br>빌드 시점에 페이지를 미리 랜더링 한 후, 설정한 시간 주기 마다 페이지를 새로 랜더링 한다.
<br>ISR 은 SSG에 포함되는 개념이라고 할 수 있다.
<br>장점<br>SSG의 장점을 취하면서, 단점을 보완하는 방법이다.
<br>SSG의 빠른 응답속도와 SSR의 최신 데이터 반영이라는 두 가지 장점을 동시에 제공한다.
<br>프로젝트별 적절한 유효 기간을 선정한다면, 부하를 최소하 하면서도 최신 데이터 제공을 구현할 수 있다. <br>단점<br>SSR/ISR 캐싱 전략 등 운영 난이도가 있음
<br>
<br>Java, Python, PHP는 웹 백엔드 개발에 오래 사용되어 온 언어들로,
<br>Node.js 기반의 자바스크립트 스택과는 구조와 철학 면에서 차이가 있다.
<br>여기서는 Node.js(+JS 프론트엔드)와 이러한 전통적인 스택을 비교하여 차별화되는 특성을 위주로 기술하였다.
<br>
<br>Node.js의 가장 큰 특징은 프론트엔드와 백엔드를 하나의 언어(JavaScript)로 통일할 수 있다는 점이다.
<br>예를 들어, 전통적으로는 Java/Spring + JSP/Thymeleaf, Python/Django + JS/jQuery, PHP + HTML 등 서로 다른 언어/프레임워크 조합으로 클라이언트와 서버를 구현했지만, Node.js와 React/Next.js 조합을 쓰면 하나의 언어로 풀스택 구현이 가능하다.
<br>이는 개발 인력의 학습 부담을 줄이고, 프론트/백엔드 간 코드 재사용(예: 입력 검증 로직을 서버와 클라이언트에서 동일한 JS로 작성) 등의 이점을 제공한다.
<br>
<br>Java는 멀티스레드, Python(전통적인 CPython)은 GIL(Global Interpreter Lock)로 사실상 싱글 스레드, PHP는 각 요청을 개별 프로세스로 처리하는 방식으로 동시성을 다룬다.
<br>반면 Node.js는 이벤트 루프 기반 싱글 스레드 모델로 동작한다. <br>Java의 멀티스레드 모델은 CPU 코어를 활용한 병렬 연산에 강력하여 고성능 연산작업이나 멀티스레드 처리에 유리하다.
<br>반면, Node.js는 스레드 경합 없이 비동기로 I/O를 처리하므로 대량의 동시 접속이 있는 I/O 중심 서비스 (예: 채팅, 실시간 피드)에 적합하다. <br>Python은 간결한 문법과 방대한 데이터 사이언스 생태계가 강점이지만, GIL 때문에 하나의 프로세스에서 동시 멀티스레드 실행이 제한되어 고도 병렬성 측면에서는 한계가 있다.
<br>Node.js는 이벤트 루프와 스레드 풀(libuv를 통한 제한적 멀티스레드)을 활용해 논블로킹 I/O 처리의 효율성을 극대화하지만, 반대로 하나의 프로세스가 오래 도는 구조라 메모리 누수나 블로킹 코드에 취약하므로 세심한 관리가 필요하다.
<br>
<br>Java는 JIT 컴파일과 최적화된 JVM 덕분에 CPU 연산 성능이 매우 높고 대용량 트랜잭션 처리에 강하다.
<br>Node.js도 V8 엔진 기반 JIT 컴파일로 실행되므로 인터프리터 언어치고는 매우 빠르며, 특히 Python보다 속도가 우수하다는 평가가 많다. 실제로 Node.js가 Python보다 빠르게 실행되는 벤치마크들이 있으며, V8 엔진의 지속적인 최적화로 컴파일 언어와의 격차도 많이 좁혀진 상황이다.
<br>다만 Java가 여전히 순수 연산성능에서는 Node.js를 앞서는 경우가 많고, Python도 C로 작성된 라이브러리(np.ndarray 등)를 활용하면 특정 연산에서 높은 성능을 낼 수 있다.
<br>PHP는 PHP7 이후 엔진 최적화로 예전보다 속도가 향상되었으나, Node.js와 비교하면 동시 처리 효율이나 실시간 처리 면에서는 뒤처진다는 평가가 일반적이다. 한편 Node.js는 Bun, Deno같은 신생 JS 런타임들의 등장으로 성능 경쟁이 붙고 있지만, 방대한 npm 생태계와 안정성 측면에서 여전히 널리 쓰이고 있다.
<br>
<br>Python과 PHP는 문법이 간결하고 웹 프레임워크(Django, Laravel 등)가 체계화되어 있어 빠른 개발에 적합하다. Node.js 역시 경량의 Express.js 같은 프레임워크를 사용하면 설정이 단순하고, 무엇보다 프론트엔드와의 언어 통일로 팀 생산성이 높아지는 효과가 있다.
<br>Java는 엄격한 OOP 패러다임과 방대한 설정(Spring 등으로 보완 가능)을 요구하여 초기 개발 속도는 느릴 수 있지만, 대규모 시스템 개발 경험이 있는 조직에서는 풍부한 도구로 안정적인 생산성을 낸다.
<br>Node.js + React 조합은 MERN 스택으로 불리며, 스타트업에서 빠른 프로토타이핑과 실서비스 개발에 많이 채택된다. 이는 동일한 기술 스택으로 프론트와 백엔드를 동시에 개발하여 피드백 사이클을 단축하고, JSON을 주고받을 때 언어 간 변환이 필요 없다는 등의 이점 덕분이다.
<br>
<br>Java/Python/PHP 계열은 과거 멀티페이지 서버렌더링(Server-Side Rendering) 방식이 주류였다.
<br>Node.js+React는 싱글페이지 애플리케이션(SPA)과 API 서버 구조를 유행시켰다. <br>오늘날에는 Next.js 덕분에 Java/Python처럼 SSR 방식을 JavaScript 스택으로도 구현할 수 있게 되었고, 반대로 Java 진영도 React 등을 뷰 레이어로 사용하는 등, 혼합된 아키텍처가 흔하게 되었다. <br>Node.js는 언어 레벨에서 JSON 처리에 최적화되어 있고, NoSQL(MongoDB)과의 궁합이 좋으며, 경량 REST API 서버 또는 마이크로서비스로 많이 활용된다.
<br>PHP는 여전히 워드프레스와 같은 CMS로 콘텐츠 중심 웹사이트에 강세이고, Python은 데이터 처리/AI 파이프라인과의 연계가 필요한 서비스(예: ML 기반 웹서비스)에 종종 쓰인다.
<br>요약하면, Node.js/React 스택은 실시간 성능과 개발 민첩성에서, 전통 스택은 컴퓨팅 성능과 기존 인프라 활용 면에서 강점을 보이는 경향이 있다.
<br>]]></description><link>https://lts.kr/study/cs/🍌-react와-next.js.html</link><guid isPermaLink="false">study/CS/🍌 React와 Next.js.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Mon, 30 Jun 2025 08:33:32 GMT</pubDate></item></channel></rss>