<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><parsererror xmlns="http://www.w3.org/1999/xhtml" style="display: block; white-space: pre; border: 2px solid #c77; padding: 0 1em 0 1em; margin: 1em; background-color: #fdd; color: black"><h3>This page contains the following errors:</h3><div style="font-family:monospace;font-size:12px">error on line 1588 at column 581: Input is not proper UTF-8, indicate encoding !
Bytes: 0x1D 0xEC 0xA3 0xBC
</div><h3>Below is a rendering of the page up to the first error.</h3></parsererror><channel><title><![CDATA[blog]]></title><description><![CDATA[Obsidian digital garden]]></description><link>https://lts.kr/</link><image><url>https://lts.kr/lib/media/favicon.png</url><title>blog</title><link>https://lts.kr/</link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Fri, 02 May 2025 03:20:58 GMT</lastBuildDate><atom:link href="https://lts.kr/lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Fri, 02 May 2025 03:19:59 GMT</pubDate><copyright><![CDATA[taesung's Blog]]></copyright><ttl>60</ttl><dc:creator>taesung's Blog</dc:creator><item><title><![CDATA[🏠 taesung's Blog]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:home" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#home</a> <a class="tag" href="https://lts.kr/?query=tag:index" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#index</a> <a class="tag" href="https://lts.kr/?query=tag:blog" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#blog</a> <a class="tag" href="https://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <br> <a href="https://lts.kr?query=tag:home" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#home">#home</a> <a href="https://lts.kr?query=tag:index" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#index">#index</a> <a href="https://lts.kr?query=tag:blog" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#blog">#blog</a> <a href="https://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a><br><a data-tooltip-position="top" aria-label="https://github.com/LeeTaeSung0628" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/LeeTaeSung0628" target="_self"><span alt="prof2.jpg" src="prof2.jpg" class="internal-embed media-embed image-embed is-loaded" style="width: 250px; max-width: 100%;"></span></a><img alt="prof2.jpg" src="https://lts.kr/사진-및-문서/prof2.jpg" style="width: 250px; max-width: 100%;" target="_self"><br><a data-tooltip-position="top" aria-label="https://git.io/typing-svg" rel="noopener nofollow" class="external-link is-unresolved" href="https://git.io/typing-svg" target="_self"></a><img alt="Typing SVG" src="https://readme-typing-svg.demolab.com?font=Fira+Code&amp;pause=1000&amp;color=36A9F7&amp;random=false&amp;width=435&amp;lines=%EC%97%AC%EA%B8%B0%EB%8A%94+%EA%B3%B5%EB%B6%80%ED%95%98%EA%B3%A0%2C+%EA%B8%B0%EB%A1%9D%ED%95%98%EB%8A%94+%EA%B3%B3%EC%9E%85%EB%8B%88%EB%8B%A4" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br>]]></description><link>https://lts.kr/🏠-taesung's-blog.html</link><guid isPermaLink="false">🏠 taesung's Blog.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Fri, 02 May 2025 01:59:21 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/prof2.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/prof2.jpg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[📕 공부]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="https://lts.kr/?query=tag:모음" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#모음</a> <br> <a href="https://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="https://lts.kr?query=tag:모음" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#모음">#모음</a><br>공부
보고 배운 지식 중 공유하고 싶은 정보를 모아둔 카테고리 입니다.
<br>
<br><a data-href="🌩 Cloud-Native Architecture 분석" href="https://lts.kr/study/cs/🌩-cloud-native-architecture-분석.html" class="internal-link" target="_self" rel="noopener nofollow">🌩 Cloud-Native Architecture 분석</a> <br><a data-href="🐹 MSA(Microservices Architecture)" href="https://lts.kr/study/cs/🐹-msa(microservices-architecture).html" class="internal-link" target="_self" rel="noopener nofollow">🐹 MSA(Microservices Architecture)</a>
<br><a data-href="🐋 docker 란" href="https://lts.kr/tools/docker/🐋-docker-란.html" class="internal-link" target="_self" rel="noopener nofollow">🐋 docker 란</a>
<br><a data-href="🚢Kubernetes(k8s)란" href="https://lts.kr/tools/kubernetes/🚢kubernetes(k8s)란.html" class="internal-link" target="_self" rel="noopener nofollow">🚢Kubernetes(k8s)란</a>
<br><a data-href="👔 Jenkins란" href="https://lts.kr/tools/jenkins/👔-jenkins란.html" class="internal-link" target="_self" rel="noopener nofollow">👔 Jenkins란</a><br> <br><a data-href="🐡 Spring Security와 Filter" href="https://lts.kr/study/cs/🐡-spring-security와-filter.html" class="internal-link" target="_self" rel="noopener nofollow">🐡 Spring Security와 Filter</a>
<br><a data-href="🚨 RSA 암호화 방식의 이해와 적용 (feat.취약성점검)" href="https://lts.kr/issue_troubleshooting/🚨-rsa-암호화-방식의-이해와-적용-(feat.취약성점검).html" class="internal-link" target="_self" rel="noopener nofollow">🚨 RSA 암호화 방식의 이해와 적용 (feat.취약성점검)</a>
<br><a data-href="🍎 Redis로 Key관리하기" href="https://lts.kr/study/cs/🍎-redis로-key관리하기.html" class="internal-link" target="_self" rel="noopener nofollow">🍎 Redis로 Key관리하기</a>
<br><a data-href="🌋 OSIV와 영속성 컨텍스트" href="https://lts.kr/study/cs/🌋-osiv와-영속성-컨텍스트.html" class="internal-link" target="_self" rel="noopener nofollow">🌋 OSIV와 영속성 컨텍스트</a>
<br><a data-href="🐰 Java의 String과 SpringBuffer" href="https://lts.kr/study/cs/🐰-java의-string과-springbuffer.html" class="internal-link" target="_self" rel="noopener nofollow">🐰 Java의 String과 SpringBuffer</a>
<br><a data-href="🛬 JDK와 JRE, JVM" href="https://lts.kr/study/cs/🛬-jdk와-jre,-jvm.html" class="internal-link" target="_self" rel="noopener nofollow">🛬 JDK와 JRE, JVM</a>
<br><a data-href="🍊 Spring의 의존성 주입(DI)" href="https://lts.kr/study/cs/🍊-spring의-의존성-주입(di).html" class="internal-link" target="_self" rel="noopener nofollow">🍊 Spring의 의존성 주입(DI)</a>
<br><a data-href="🪕 JPA 관련 용어 정리" href="https://lts.kr/study/cs/🪕-jpa-관련-용어-정리.html" class="internal-link" target="_self" rel="noopener nofollow">🪕 JPA 관련 용어 정리</a>
<br>
<br><a data-href="☕ JAVA , OOP" href="https://lts.kr/study/cs/☕-java-,-oop.html" class="internal-link" target="_self" rel="noopener nofollow">☕ JAVA , OOP</a>
<br><a data-href="🍃 Spring" href="https://lts.kr/study/cs/🍃-spring.html" class="internal-link" target="_self" rel="noopener nofollow">🍃 Spring</a>
<br><a data-href="🎩 DevOps" href="https://lts.kr/study/cs/🎩-devops.html" class="internal-link" target="_self" rel="noopener nofollow">🎩 DevOps</a>
<br><a data-href="📔 DataBase" href="https://lts.kr/study/cs/📔-database.html" class="internal-link" target="_self" rel="noopener nofollow">📔 DataBase</a>
<br><a data-href="📭 Server" href="https://lts.kr/study/cs/📭-server.html" class="internal-link" target="_self" rel="noopener nofollow">📭 Server</a>
<br><a data-href="🐞 etc" href="https://lts.kr/study/cs/🐞-etc.html" class="internal-link" target="_self" rel="noopener nofollow">🐞 etc</a>
<br>
<br><a data-href="🤠 Coding Test 풀이 모음" href="https://lts.kr/study/coding-test/🤠-coding-test-풀이-모음.html" class="internal-link" target="_self" rel="noopener nofollow">🤠 Coding Test 풀이 모음</a>
<br><a data-href="👽 Algorithm" href="https://lts.kr/study/coding-test/👽-algorithm.html" class="internal-link" target="_self" rel="noopener nofollow">👽 Algorithm</a>
<br>
<br><a data-href="🔻 Redis 캐쉬 전략 - hello 서비스에 적용하여 성능개선 가능성" href="https://lts.kr/study/dev-seminar/🔻-redis-캐쉬-전략-hello-서비스에-적용하여-성능개선-가능성.html" class="internal-link" target="_self" rel="noopener nofollow">🔻 Redis 캐쉬 전략 - hello 서비스에 적용하여 성능개선 가능성</a>
<br><a data-href="🔐 상품 투자하기 서비스 Lock기법 개선안" href="https://lts.kr/issue_troubleshooting/🔐-상품-투자하기-서비스-lock기법-개선안.html" class="internal-link" target="_self" rel="noopener nofollow">🔐 상품 투자하기 서비스 Lock기법 개선안</a>
<br><a data-href="🔹 TDD에 대하여" href="https://lts.kr/study/dev-seminar/🔹-tdd에-대하여.html" class="internal-link" target="_self" rel="noopener nofollow">🔹 TDD에 대하여</a>
<br><a data-href="🍂 JPA, Mybatis , Dead Lock이슈" href="https://lts.kr/study/dev-seminar/🍂-jpa,-mybatis-,-dead-lock이슈.html" class="internal-link" target="_self" rel="noopener nofollow">🍂 JPA, Mybatis , Dead Lock이슈</a>
<br><a data-href="🥗 Spring Security_토큰-세션-쿠키-JWT 에 대하여" href="https://lts.kr/study/dev-seminar/🥗-spring-security_토큰-세션-쿠키-jwt-에-대하여.html" class="internal-link" target="_self" rel="noopener nofollow">🥗 Spring Security_토큰-세션-쿠키-JWT 에 대하여</a>
<br><a data-href="📔 DB 테이블 설계, 어떻게 하는게 옳은 방법인가" href="https://lts.kr/study/dev-seminar/📔-db-테이블-설계,-어떻게-하는게-옳은-방법인가.html" class="internal-link" target="_self" rel="noopener nofollow">📔 DB 테이블 설계, 어떻게 하는게 옳은 방법인가</a>]]></description><link>https://lts.kr/study/📕-공부.html</link><guid isPermaLink="false">study/📕 공부.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Fri, 02 May 2025 01:55:22 GMT</pubDate></item><item><title><![CDATA[🌩 Cloud-Native Architecture 분석]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="https://lts.kr/?query=tag:구조" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#구조</a> <a class="tag" href="https://lts.kr/?query=tag:설계" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#설계</a> <a class="tag" href="https://lts.kr/?query=tag:MSA" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#MSA</a> <a class="tag" href="https://lts.kr/?query=tag:CloudNative" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#CloudNative</a> <br> <a href="https://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="https://lts.kr?query=tag:구조" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#구조">#구조</a> <a href="https://lts.kr?query=tag:설계" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#설계">#설계</a> <a href="https://lts.kr?query=tag:MSA" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#MSA">#MSA</a> <a href="https://lts.kr?query=tag:CloudNative" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#CloudNative">#CloudNative</a><br>
<br>CNA는 클라우드 환경의 특성을 최대한 활용하여 애플리케이션을 설계하고 운영하는 접근 방식이다.
<br>이는 유연성, 확장성, 탄력성, 복원성 등의 장점을 극대화하여 빠르게 변화하는 비즈니스 요구에 대응할 수 있도록 하기 위함이다.
<br>
<br>클라우드(AWS, Azure 등..)의 보편화에 따라, 해당 환경(클라우드 시스템 환경)에 맞는 적절한 프로그램(애플리케이션)설계 기법이 필요해졌고, 그렇게 등장한 것이 클라우드 네이티브 아키텍처 CNA이다.
<br>우리 모두가 아는 ‘넷플릭스(NETFLIX)’의 사례를 보도록하자.<br> 넷플릭스는 2008년 매월 수천 편의 영상을, 수백만 명의 고객들에게 스트리밍 서비스로 제공하며, 데이터 량이 빠르게 늘어나고 있었다.<br>
이때, 넷플릭스는 자체적인 데이터 센터를 운영하고 있었는데 매일 급격하게 증가하는 볼륨을 감당하는데 무리가 있었고, 전체 서비스가 3일간 다운되는 큰 손실이 발생한 사례가 있다.<br>이후 넷플릭스는 사내 모든 컴퓨팅 인프라를 클라우드 환경으로 옮겨, 안정적인 스트리밍과 서비스 확장을 이뤄냈다.<br>꼭 매년 크게 성장하는 기업들 만이 클라우드 시스템에 유리한 것은 아니다.<br>
한가지 사례를 더 가정해보자.<br>평균적으로 매 시간 100만명의 유저가 서비스를 이용한다고 가정해보자.<br>
이때, 우리의 서버는 100만명을 수용할 수 있는 스펙이 되어야한다.<br>
하지만, 연말 연초 연휴에 서비스 사용자들이 크게 몰려 시간 당 1000만명 수준이 유지된다고 한다면 어떠한 선택을 해야할까?<br>일반적인 회사는 특정한 상황에 몰리는 사용자들을 위해 10배 이상의 서버를 증설할 여력이 없다.<br>
여기서 클라우드 컴퓨팅 시스템이 이러한 문제를 해결해 줄 수 있다.<br>
<br>클라우드는 온디맨드 셀프 서비스 (On-demand Self-Service) 를 지원한다.<br>
사용자는 필요한 자원을 요청하고 즉시 사용할 수 있다.<br>
때문에, 초기 인프라 구축 비용 없이 사용량만큼만 비용을 지불하여 하드웨어 운영 인건비를 절감할 수 있으며<br>
자본 기반 지출에서 → 운영 기반 지출로 지출 구조를 전환 할 수 있다.
주의점
하지만, 비용 예측의 어려움 또한 존재한다.<br>
사용량 기반 과금구조 이기 때문에, 과도한 사용시 요금이 폭주할 가능성이 있으며,<br>
리소스 낭비 및 Auto Scaling의 작동범위를 항상 주의하여 운영해야한다. <br>
<br>방금 기술했던 특징으로, 트래픽 증가시 손쉽게 리소스를 확장 가능하다.
<br>또한, 광범위한 네트워크 접근성으로 글로벌 서비스를 제공할 수 있다.
<br>
<br>DR(Disaster Recovery) 시스템을 손쉽게 구성할 수 있는 다양한 기능을 제공.
<br>스냅샷, 복제본 등 고가용성 및 복구 설계가 수월하다.
<br>
<br>클라우드 시스템들은 일정 수준 이상의 보안을 항상 유지해주기 때문에,<br>
하드웨어 보안에 필요한 노력을 줄일 수 있다.
<br>다음과 같은 기술들은 위에서 기술한 클라우드 시스템의 장점을 100%로 활용 가능하도록 도와준다.<br>
<br>상세한 설명 ▶▶ <a data-href="🐹 MSA(Microservices Architecture)" href="https://lts.kr/study/cs/🐹-msa(microservices-architecture).html" class="internal-link" target="_self" rel="noopener nofollow">🐹 MSA(Microservices Architecture)</a>
<br>애플리케이션은 API호출을 통해 세분화 되고, 느슨하게 결합된 구성 요소로 분해되어 관리된다.
<br>
<br>컨테이너 기술 ▶▶ <a data-href="🐋 docker 란" href="https://lts.kr/tools/docker/🐋-docker-란.html" class="internal-link" target="_self" rel="noopener nofollow">🐋 docker 란</a>
<br>CI/CD동안 모든 소프트웨어 어플리케이션과 모든 종속성은 컨테이너로써 관리되어<br>
환경 전반에 거린 솔루션의 이식성을 향상시킨다.
<br>
<br>오케스트레이션 기술 ▶▶ <a data-href="🚢Kubernetes(k8s)란" href="https://lts.kr/tools/kubernetes/🚢kubernetes(k8s)란.html" class="internal-link" target="_self" rel="noopener nofollow">🚢Kubernetes(k8s)란</a>
<br>컨테이너화된 어플리케이션을 실행하고 배포하고 확장하기 위한 클러스터를 관리하는 기술이다.
<br>많은 수의 컨테이너를 직접관리하지 않고 자동화 함으로 효율을 증대할 수 있다.
<br>
<br>개념 설명 ▶▶ <a data-href="CICD" href="https://lts.kr/짧은-키워드/cicd.html" class="internal-link" target="_self" rel="noopener nofollow">CICD</a>
<br>소프트웨어 릴리즈의 효율성을 높여준다.
<br>빈번하고 반복적인 릴리즈를 신속한 피드백과 함께 간소화하고 자동화 시킬 수 있다.
<br>
<br>클라우드 네이티브 아키텍천은 현대의 빠르게 변화하는 비즈니스 환경에서 유연하고 확장 가능한 시스템을 구축하는데, 필수적인 접근방식임은 틀림없다.
<br>이를 통해 기업은 빠른 서비스 출기, 안정적인 운영, 효율적인 리소스 활용등의 장점을 모두 취할 수 있다.]]></description><link>https://lts.kr/study/cs/🌩-cloud-native-architecture-분석.html</link><guid isPermaLink="false">study/CS/🌩 Cloud-Native Architecture 분석.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Fri, 02 May 2025 01:54:34 GMT</pubDate></item><item><title><![CDATA[🍎 Redis로 Key관리하기]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="https://lts.kr/?query=tag:Redis" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Redis</a> <a class="tag" href="https://lts.kr/?query=tag:Cash" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Cash</a> <a class="tag" href="https://lts.kr/?query=tag:memory" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#memory</a> <a class="tag" href="https://lts.kr/?query=tag:다중서버" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#다중서버</a> <a class="tag" href="https://lts.kr/?query=tag:NoSql" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#NoSql</a> <br> <a href="https://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="https://lts.kr?query=tag:Redis" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Redis">#Redis</a> <a href="https://lts.kr?query=tag:Cash" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Cash">#Cash</a> <a href="https://lts.kr?query=tag:memory" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#memory">#memory</a> <a href="https://lts.kr?query=tag:다중서버" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#다중서버">#다중서버</a> <a href="https://lts.kr?query=tag:NoSql" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#NoSql">#NoSql</a><br>
<br>주로 애플리케이션 캐시 또는 빠른 응답 데이터베이스로 사용되는 오픈소스,<br>
인매모리, NoSql &lt;키, 벨류&gt; 저장소이다.
<br>또한, redis는 보조기억장치(HDD / SSD)가 아닌 메모리에 데이터를 저장하여<br>
탁월한 속도, 안정성, 성능을 제공할 수 있다.<br> 애플이케이션이 외부 데이터 소스에 의존하는 경우 트레픽이 증가하거나, 애플리케이션이 확장될때 소스의 지연 시간과 처리량으로 인하여 병목현상이 발생할 수 있다.<br>
이때 Redis를 적용하면, 데이터를 메모리에 저장하여 읽거나 쓸때 지연 시간을 최소화 할 수 있다.<br>
<br>redis는 앱 성능 향상을 위해 특별히 설계되어, 기존 NoSQL 데이터 저장소와 차별화 되는 기능이 있다.
<br>
<br>MongoDB, PostgreSql 과 같은 NoSQL DB와 달리, 메모리를 저장소로 사용하여<br>
읽기 쓰기 성능이 월등히 높다. 또한 고가용성과 확장성을 보장하는데 도움이된다.
<br>고가용성 이란?
가용성 : 서버 또는 네트워크 등의 정보 시스템이 정상적으로 사용 가능한 정도를 의미.<br>
== 정상적인 사용시간 / 전체 사용시간 = 시스템 가동률(가용성) 여기서, 고가용성이란 가용성이 99%, 99.9% 등과 같이 높은 가용성을 지닌 시스템을 의미한다.
<br>
<br>redis는 웹 클라이언트가 평소보다 처리하는데 오래 걸릴 수 있는 작업을 대기열에 넣을 수 있다.<br>
요청/응답 주기의 백그라운드에서 실행되는 자동화된 프로세스를 쉽게 구현할 수 있는 것이다.
<br>
<br>redis는 기술적으로는 키/벨류 저장소 이지만, 여러 데이터 유형과 구조를 지원하는 데이터 구조 서버이다.
<br>
<br>고유하고 정렬되지 않은 문자열
<br>바이너리 세이프 데이터
<br>하이퍼로그
<br>비트 배열
<br>해시
<br>목록
<br>
<br>
<br>build.gradle에 의존성 추가 <br>implementation 'org.springframework.boot:spring-boot-starter-data-redis' <br>yml redis 속성 추가 <br>cache: type: redis redis: cache-null-values: true redis: host: `레디스 호스트`
port: `레디스 포트`
<br>
<br>@Configuration으로 redis사용에 필요한 셋팅을 Bean으로 등록할 클래스.
<br>@Configuration public class RedisConfiguration { @Value("${spring.redis.host}") private String host; @Value("${spring.redis.port}") private int port;
}
<br>Redis 서버와 연결을 생성 및 관리해주는 인터페이스<br>@Bean public RedisConnectionFactory redisConnectionFactory() { return new LettuceConnectionFactory(host, port); }
<br>어플리케이션 서버와 Redis 서버 간의 데이터 송수신을 하는 클라이언트
<br>대표적으로 Lettuce와 Jedis, Redisson 이 있다.
<br>
<br>비동기 및 논블로킹 I/O를 기반으로 하여 고부하, 다중 스레드 환경에 적합
<br>
<br>블로킹 I/O(동기) 방식을 사용.
<br>고부하나 비동기 처리가 중요한 환경에서는 효울이 떨어진다.
<br>
<br>단순히 Redis 연결을 관리하는 것을 넘어 분산 락, 분산 컬렉션, 분산 캐시 등 고급 기능을 제공.
<br>직접 RedisConnectionFactory로 사용하기보다는 RedissonClient를 빈으로 등록하고 이를 통해 분산 락이나 캐시 매니저를 구성.
<br> ▶ <a data-href="🔐 상품 투자하기 서비스 Lock기법 개선안" href="https://lts.kr/issue_troubleshooting/🔐-상품-투자하기-서비스-lock기법-개선안.html" class="internal-link" target="_self" rel="noopener nofollow">🔐 상품 투자하기 서비스 Lock기법 개선안</a><br>
<br>따라서 해당 코드에는 비동기 성능이 높은 좋은 Lettuce 선택.<br>Redis에 저장될 캐시의 기본 직렬화 및 만료 시간(TTL) 등의 설정을 담당.<br>private RedisCacheConfiguration redisCacheDefaultConfiguration() { return RedisCacheConfiguration .defaultCacheConfig() .serializeKeysWith(RedisSerializationContext.SerializationPair .fromSerializer(new StringRedisSerializer())) .serializeValuesWith(RedisSerializationContext.SerializationPair .fromSerializer(new GenericJackson2JsonRedisSerializer());
}
<br>serializeKeysWith : StringRedisSerializer를 사용하여 키를 문자열로 직렬화합니다.
<br>serializeValuesWith : GenericJackson2JsonRedisSerializer와 ObjectMapper를 사용해 JSON 형식으로 직렬화 GenericJackson2JsonRedisSerializer : 직렬화 방식 중 하나로, JSON형식을 지원. <br>여러 캐시 이름에 대해 각기 다른 TTL(Time To Live)을 동적으로 설정.<br>private Map&lt;String, RedisCacheConfiguration&gt; redisCacheConfigurationMap() { Map&lt;String, RedisCacheConfiguration&gt; cacheConfigurations = new HashMap&lt;&gt;(); for (Map.Entry&lt;String, Long&gt; cacheNameAndTimeout : cacheProperties.getTtl().entrySet()) { cacheConfigurations .put(cacheNameAndTimeout.getKey(), redisCacheDefaultConfiguration().entryTtl( Duration.ofSeconds(cacheNameAndTimeout.getValue()))); } return cacheConfigurations; }
<br>//cacheProperties.yml<br>cache: ttl: CacheName: 10 #만료 시간
<br>외부 설정(CacheProperties)에서 캐시별 TTL 정보를 읽어와 각 캐시의 만료 시간을 지정<br>
이를 통해 특정 캐시만 별도의 만료 정책 등을 적용할 수 있다.
<br>entryTtl : 기본 만료시간 설정
<br>Spring의 캐시 추상화에서 Redis를 캐시 저장소로 사용하기 위한 캐시 매니저를 생성<br>
위에서 설정한 redisCacheDefaultConfiguration과 cacheConfigurations(커스텀) 이 삽입된다.<br>@Bean
public CacheManager redisCacheManager(RedisConnectionFactory redisConnectionFactory) { return RedisCacheManager.RedisCacheManagerBuilder .fromConnectionFactory(redisConnectionFactory) .cacheDefaults(redisCacheDefaultConfiguration()) .withInitialCacheConfigurations(redisCacheConfigurationMap()) .build();
}
<br>withInitialCacheConfigurations : RedisCacheManager를 생성할 때 미리 정의된 특정 캐시 이름에 대해 개별적인 설정을 적용할 수 있도록 해주는 메서드입니다.
<br>▶ <a data-href="🚨 RSA 암호화 방식의 이해와 적용 (feat.취약성점검)" href="https://lts.kr/issue_troubleshooting/🚨-rsa-암호화-방식의-이해와-적용-(feat.취약성점검).html" class="internal-link" target="_self" rel="noopener nofollow">🚨 RSA 암호화 방식의 이해와 적용 (feat.취약성점검)</a> 에서 이어진다.<br>@Service public class TestServiceImpl { private final CacheManager cacheManager; private final RedisTemplate&lt;String, Object&gt; redisTemplate; public TestServiceImpl(CacheManager cacheManager, RedisTemplate&lt;String, Object&gt; redisTemplate) { this.cacheManager = cacheManager; this.redisTemplate = redisTemplate; }
}
<br>(생성자 주입)<br>위(RedisConfiguration)에서 생성한 CacheManager 및 RedisTemplate의 빈을 주입한다.
<br>주의
만약, Bean으로 생성된 CacheManager객체나, RedisTemplate객체가 여러개라면,<br>
@Qualifier 어노테이션으로 Bean이름을 명시해야한다. `ex) @Qualifier("CustomCacheManager") CacheManager cacheManager ...` <br>	Cache privateKeyCache = cacheManager.getCache("CacheName"); public void putCache() { if (privateKeyCache != null) { privateKeyCache.put(keyId, 벨류); } else { // 캐시가 없으면 예외 처리 또는 로깅 throw new IllegalStateException("privateKeyCache 가 유요하지 않습니다."); } } public void getCache() { if (privateKeyCache == null) { throw new IllegalStateException("rsaPrivateKeyCache 가 유요하지 않습니다."); } String privateKeyValue = privateKeyCache.get(keyId, String.class); // 1회용 사용을 위해 조회 후 캐시에서 제거할 수 있다. rsaPrivateKeyCache.evict(keyId); // 1회용 사용: 캐시에서 제거 }
<br>getCache.(CacheName)으로 캐쉬를 객체를 가져온다.
<br>put(keyId, 벨류); / get(keyId, String.class); 로 삽입 / 가져오기가 가능하다.
<br>.evict(keyId)로 삭제 ( 1회성 사용이 가능하다. )
<br>1회성으로 사용하는 이유
나의 경우에 RSA키를 매번 발급 받기 때문에 값을 꺼냄과 동시에 해당 키벨류를 삭제한다.<br>
Exception이 터지더라도, cacheProperties 에 설정한 TTL이 초과되면 삭제된다.
<br><img alt="Pasted image 20250328120415.png" src="https://lts.kr/사진-및-문서/pasted-image-20250328120415.png" target="_self"><br>application.yml / properties ↓
CacheProperties (ttl map 관리) ↓
redisCacheConfigurationMap() → 캐시별 TTL 매핑 ↓
redisCacheDefaultConfiguration() → 기본 설정 (ex: serializer, 기본 TTL) ↓
redisCacheManager() → 최종 CacheManager 생성
<br>다음과 같이 TTL 시간 및 <a data-href="Redis 만료 정책" href="https://lts.kr/짧은-키워드/redis-만료-정책.html" class="internal-link" target="_self" rel="noopener nofollow">Redis 만료 정책</a>을 맵핑 할 수 있다.]]></description><link>https://lts.kr/study/cs/🍎-redis로-key관리하기.html</link><guid isPermaLink="false">study/CS/🍎 Redis로 Key관리하기.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 30 Apr 2025 07:23:51 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20250328120415.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20250328120415.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🐹 MSA(Microservices Architecture)]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="https://lts.kr/?query=tag:구조" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#구조</a> <a class="tag" href="https://lts.kr/?query=tag:설계" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#설계</a> <a class="tag" href="https://lts.kr/?query=tag:MSA" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#MSA</a> <a class="tag" href="https://lts.kr/?query=tag:CloudNative" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#CloudNative</a> <br> <a href="https://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="https://lts.kr?query=tag:구조" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#구조">#구조</a> <a href="https://lts.kr?query=tag:설계" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#설계">#설계</a> <a href="https://lts.kr?query=tag:MSA" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#MSA">#MSA</a> <a href="https://lts.kr?query=tag:CloudNative" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#CloudNative">#CloudNative</a><br>
<br>msa는 대규모 애플리케이션을 독립적으로 배포 가능한 작은 서비스들의 집합으로 구성하는 소프트웨어 설계 접근 방식이다.
<br>각 서비스는 특정 비즈니스 기능을 담당하며, 자체 데이터 저장소를 보유하고(선택), 독립적으로 개발 및 배포가 가능하다.
<br>msa는 확장성, 유지보수성, 유연성 향상 등의 이점을 제공하지만 복잡한 운영과 통신 관리 등의 문제도 동반하고있다.
<br>모놀리식 아키텍처(Monolithic Architecture)
모든 기능이 단일 코드베이스에 포함되어 하나의 배포 단위로 운영되는 방식. <br>초기개발과 배포가 빠르고 간단하지만, 애플리케이션이 비대화 될 수록 다음과 같은 문제 발생 <br>확장성 제한: 전체 애플리케이션을 확장해야 하므로 자원 낭비가 발생할 수 있음
<br>배포 리스크 증가: 작은 변경도 전체 시스템의 재배포를 요구하여 위험이 증가
<br>유지보수 어려움: 코드베이스가 커지면 이해와 수정이 어려워짐 <br>MSA는 애플리케이션을 작은 서비스로 분리하여, 각 서비스가 독립적으로 개발, 배포, 확장 될 수 있도록 한다.<br>
즉, 위의 모놀리식 아키텍처의 단점을 모두 보완하는 특징을 갖고 있다.<br>
<br>배포
<br>서비스별 개별 배포가 가능(배포시 전체 서비스의 중단이 없음)
<br>특정 서비스의 요구사항만을 반영하여, 빠르게 배포 가능
<br>&nbsp;<br>
2. 확장<br>특정 서비스에 대한 확장성(scale-out)이 유리하다.
<br>Cloud Native Architecture에 적합하다. <br>&nbsp;<br>장애
<br>일부 장애가 전체 서비스로 확장될 가능성이 적다.(장애 격리가 쉽다)
<br>&nbsp;<br>
4. 그 외<br>새로운 기술을 적용하기 유연하다.(전체 서비스가 아닌 특정 서비스만 별도의 기술 또는 언어로 구현 가능)
<br>각각의 서비스에 대한 구조 파악 및 분석이 모놀리식 구조에 비해 쉽다.
<br>
<br>설계의 어려움
<br>MSA는 모놀리식에 비해 상대적으로 많이 복잡하다. 또한, 통신의 장애와 서버의 부하 등을 고려하여 transaction을 유지할지 결정해야 한다.
<br>&nbsp;<br>
2. 성능<br>서비스 간 호출 시 API를 사용하므로, 통신 비용이나 Latency에 대해 이슈가 존재.
<br>&nbsp;<br>
3. 테스트/데이터 트랜잭션<br>모놀리식에서는 단일 트랜잭션을 유지하면 됐지만 MSA에서는 비즈니스에 대한 DB를 가지고 있는 서비스도 각기 다르고, 서비스의 연결을 위해서는 통신이 포함되기 때문에 트랜잭션을 일관되게 유지하며 개발하는게 어렵다. <br>통합 테스트가 어렵다. 개발 환경과 실제 운영환경을 동일하게 가져가는 것의 어려움 <br>&nbsp;<br>
4. 데이터 관리<br>데이터가 여러 서비스에 분산되어 있어 관리하는데 어려움이 있다.
<br>그래서 msa가 무조건 좋은것인가? <br>설계방식에 대한 정답은 없다. 하지만, 많은 기업들이 MSA를 적용하여 글로벌 서비스를 성공적으로 확장시켰다는 것은 확실하다. <br>또한, Cloud 기반의 서비스에 매우적합한 방식이라는 것도 자명하다. 하지만, MSA를 무조건 적으로 적용하는 것 보다는 현재프로젝트의 규모, 통신 방식등을 적절하게 산정/예상하여 단점보다 장점이 커 보인다고 생각될 때 적용하는 것이 바람직 해 보인다. <br>
<br>MSA는 단순히 서비스를 여러 개로 나누는 것이 아니라, 개별 서비스가 독립적으로 개발, 배포, 운영될 수 있도록 설계하는 것이 핵심이다.
<br>그렇지 않으면 모놀리식 아키텍처와 다를 바 없다. 따라서, 적절한 설계 원칙을 적용하여 설계를 진행하여야 한다.<br> SRP는 각 서비스가 하나의 명확한 역할을 수행해야 한다는 원칙이다. 이를 따르지 않으면 서비스가 점점 커지면서 결국 모놀리식 구조와 다름없어질 수 있음을 알아야 한다.<br>
<br>서비스 내부의 응집도는 높이고, 서비스 간의 결합도는 낮춰야 한다. 응집도가 높은 서비스는 유지보수가 용이하며, 변경 시 다른 기능에 영향을 최소화할 수 있다. 반면, 결합도가 높으면 서비스 간 변경 사항이 전파되면서 독립적인 배포가 어려워지고, 장애 전파의 위험도 커진다.
<br>
<br>각 서비스는 명확한 도메인 역할을 가져야 한다(DDD). 예를 들어, 주문 서비스는 주문 관련 로직만을 담당하고, 결제 서비스는 결제와 관련된 기능만을 처리해야 한다. 이를 통해 개발, 배포, 확장이 용이해지고, 운영 비용을 절감할 수 있다.<br>
<br>서비스는 서로 독립적으로 운영될 수 있어야 한다. 특정 서비스가 다운되더라도 전체 시스템이 영향을 받지 않도록 설계하는 것이 중요하다.<br>
<br>서비스 간 통신은 동기 호출보다는 비동기 메시징 또는 이벤트 기반 방식을 활용하는 것이 좋다. 이를 통해 특정 서비스가 응답하지 않아도 전체 시스템이 멈추지 않도록 할 수 있다.
<br>
<br>서비스 간의 직접적인 의존성을 최소화해야 한다. 예를 들어, 한 서비스가 다른 서비스의 데이터베이스에 직접 접근하는 것은 피해야 하며, API나 이벤트 기반 방식으로 데이터를 교환해야 한다.<br>
<br>MSA 환경에서는 특정 서비스에서 장애가 발생하더라도 다른 서비스로 확산되지 않도록 격리하는 것이 필수적이다.<br>
<br>서킷 브레이커는 특정 서비스가 응답하지 않을 때, 일정 횟수 이상 요청이 실패하면 추가 요청을 차단하는 패턴이다. 이를 통해 과부하를 방지하고, 장애가 확산되는 것을 막을 수 있다.
<br>
<br>서비스 장애 발생 시, 기본적인 대체 응답을 제공하는 폴백 전략을 사용하면 사용자 경험을 유지할 수 있다. 예를 들어, 추천 서비스가 장애가 발생하면 기본 인기 상품 목록을 반환하는 식.
<br>
<br>서비스의 상태를 지속적으로 모니터링하여 장애 발생을 사전에 감지하고 대응할 수 있도록 해야 한다.
<br>MSA에서는 수많은 서비스가 존재하므로 수작업으로 운영하기에는 한계가 있다. 따라서 <a data-href="CICD" href="https://lts.kr/짧은-키워드/cicd.html" class="internal-link" target="_self" rel="noopener nofollow">CICD</a> 파이프라인과 Kubernetes 기반의 자동화가 필수적이다.<br>
<br>코드 변경 사항을 빠르게 배포할 수 있도록 지속적인 통합 및 배포(CI/CD)를 구축해야 한다. 이를 통해 배포 속도를 높이고, 변경에 대한 위험을 줄일 수 있다.
<br>
<br>Kubernetes를 활용하면 서비스 배포, 확장, 롤백을 자동화할 수 있다. 이를 통해 인프라 관리의 복잡도를 줄이고, 서비스 안정성을 확보할 수 있다.
<br>MSA에서는 서비스가 분산되어 있기 때문에, 효과적인 모니터링과 로깅이 필수적이다.<br>
<br>서비스 간 요청 흐름을 추적하기 위해 분산 추적 시스템(OpenTelemetry, Jaeger)을 활용하여 성능 저하 원인을 빠르게 파악할 수 있다.
<br>
<br>각 서비스에서 발생하는 로그를 한곳에 수집하여 관리해야 한다. 중앙 집중식 로깅 시스템(ELK Stack, Grafana Loki)을 활용하면 장애 발생 시 원인을 빠르게 분석할 수 있다.
<br>
<br>서비스의 CPU, 메모리 사용량, 응답 시간 등을 지속적으로 모니터링하고, 이상 징후를 사전에 감지하여 대응할 수 있도록 해야 한다.
<br> <br>MSA를 설계할 때, 적절한 서비스 분해 전략을 선택하는 것 또한 매우 중요하다.<br>
일반적인 분해 전략은 다음과 같다.<br>비즈니스 기능 기반 분해: 각 서비스가 특정 비즈니스 기능을 담당하도록 분해한다. 예를 들어, 주문 관리, 결제 처리, 사용자 인증 등을 각각의 서비스로 나눌 수 있다.<br>
<br>하위 도메인 기반 분해: 도메인 주도 설계(DDD)를 활용하여 하위 도메인별로 서비스를 분리한다. 고객이 발생시키는 이벤트를 시작점으로 하여 Path를 발경하는 Event Storming 기법도 있다.<br>
<br>트랜잭션 경계 기반 분해: 트랜잭션 경계를 기준으로 서비스를 분리하여 데이터 일관성을 유지한다.
<br>이러한 분해 전략을 통해 서비스 간의 결합도를 낮추고, 독립적인 개발과 배포가 가능하도록 설계할 수 있다.<br>주의점
MSA를 도입하며, 기능(도메인)의 경계를 명확히 하는것은 생각보다 쉽지 않다.<br>
특히 핵심 기능을 분리할 때 어려운 점이 있다. <br>핵심 기능은 다른 기능들과의 결합도가 높다
<br>핵심 기능일 수록 장기간의 유지보수로 인하여, 도메인간의 경계가 명확하지 않을 가능성이 높다 이러한 핵심 기능들은 사람의 눈으로만 판단하는데 어려움이 있기 떄문에, 다양한 정적 분석도구를 활용하면 좋다.<br>
<br>다음은 MSA에서 유연성과 확장성을 확보하기 위한 주요 서비스 분리 원칙이다.<br>
<br>분리 대상 서비스를 확정하고 나서는, 기존 모놀리식 코드를 재사용 할것인지, 재개발 할것인지를 고민해야한다.
<br>일반적으로 코드를 재사용하여 서비스를 구성하는 것이 효율적으로 보이지만 오히려 비효율을 초래할 가능성이 크다.
<br>오랜 기간 유지보수 된 코드의 문제점<br>
- 기술부채가 많이 쌓여있고, 기술 자체가 오래되었을 가능성이 큼<br>
- 수없이 변경된 요구사항으로, 비즈니스 도메인이 명확하게 반영되어있지 않을 가능성이 큼<br>
<br>기능의 완전한 재작성의 장점<br>
- 요구사항을 다시 파악하여 해당 기능에 대한 비즈니스 도메인을 명확히 할 수 있음<br>
- 비즈니스에 대한 더놓은 이해를 바탕으로 아키텍처 재설계 가능<br>
- 기존의 기술부채 해결<br>
- 새로운 기술 스텍을 도입할 수 있음<br>
<br>모놀리식으로 구현되어있는 코드 전체를 MSA로 전환하는 것은 아주 길고 비용이 많이 드는 일이다.<br>
때문에, 작고 명확한 계획의 여러단계를 만들어 진행하는 것이 유리하다.<br>또한, 서비스를 분리할 때 서비스 범위를 너무 좁게 잡으면 각서비스는 응집도 높은 비즈니스 없이 CRUD만 수행하며 개수는 크게 증가하여 복잡도만 높아질 수 있다.<br>
<br>우선 서비스 단위를 크게 분리한 후, 이후에 설계에 대한 고민을 반복적으로 수행하며 분리작업을 점진적으로 진행하는 것이 가장 바람직 하다고 볼 수 있겠다.
<br> <br>마이크로서비스 아키텍처에서는 서비스 간 통신과 데이터 관리가 중요한 이슈이다.<br>
<br>동기 통신: <a data-href="RESTful API" href="https://lts.kr/짧은-키워드/restful-api.html" class="internal-link" target="_self" rel="noopener nofollow">RESTful API</a>, gRPC 등을 사용하여 실시간으로 요청과 응답을 주고받는 방식. 구현이 간단하지만, 서비스 간의 강한 결합을 초래할 수 있다.<br>
<br>비동기 통신: 메시지 큐(Kafka, RabbitMQ 등)를 활용하여 비동기적으로 메시지를 전달하는 방식. 이는 서비스 간 결합도를 낮추고, 시스템의 확장성과 탄력성을 향상시킨다.
<br>
<br>데이터베이스 분리: 각 서비스는 자체 데이터베이스를 보유하여 데이터 독립성을 확보한다.<br>
<br>데이터 일관성 유지: 분산 트랜잭션을 피하기 위해 SAGA 패턴, 이벤트 소싱 등을 활용하여 데이터 일관성을 유지한다.
<br>MSA는 단순히 시스템을 여러 개의 서비스로 나누는 것이 아니라, 서비스의 독립성, 장애 격리, 자동화, 모니터링 등의 원칙을 철저히 준수하는 것이 핵심이다. 이러한 원칙이 지켜지지 않으면, 시스템은 오히려 더 복잡해지고 운영 비용이 증가할 뿐 아니라 장애 대응도 어려워진다.<br>특히 단일 책임 원칙, 서비스 독립성, 장애 격리, 자동화, 모니터링은 MSA에서 반드시 적용해야 하는 필수 요소이다. 이 원칙들을 바탕으로 MSA를 설계하면 유연한 확장성, 높은 가용성, 효율적인 운영이 가능한 시스템을 구축할 수 있겠다.]]></description><link>https://lts.kr/study/cs/🐹-msa(microservices-architecture).html</link><guid isPermaLink="false">study/CS/🐹 MSA(Microservices Architecture).md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 30 Apr 2025 07:14:14 GMT</pubDate></item><item><title><![CDATA[정의]]></title><description><![CDATA[<br><br>
<br>CI/CD는 지속적 통합(Continuous Integration) 및 지속적 제공/배포(Continuous Delivery/Deployment) 를 의미하며, 소프트웨어 개발 라이프사이클을 간소화하고 가속화하는 것을 목표로 한다.
<br><br>
<br>코드 변경 사항을 공유 소스 코드 리포지토리에 자동으로 자주 통합하는 사례를 나타낸다. <br><br>
<br>코드 변경 사항의 통합, 테스트, 제공을 나타내는 프로세스로, 두 가지 부분으로 구성된다. 지속적 제공에는 자동 프로덕션 배포 기능이 없는 반면, 지속적 배포는 업데이트를 프로덕션 환경에 자동으로 릴리스된다.
<br><br><br><br><br><br>]]></description><link>https://lts.kr/짧은-키워드/cicd.html</link><guid isPermaLink="false">짧은 키워드/CICD.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 30 Apr 2025 06:50:46 GMT</pubDate></item><item><title><![CDATA[RESTful API]]></title><link>https://lts.kr/짧은-키워드/restful-api.html</link><guid isPermaLink="false">짧은 키워드/RESTful API.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 30 Apr 2025 06:15:43 GMT</pubDate></item><item><title><![CDATA[🐡 Spring Security와 Filter]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:프로젝트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로젝트</a> <a class="tag" href="https://lts.kr/?query=tag:개발" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#개발</a> <a class="tag" href="https://lts.kr/?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <a class="tag" href="https://lts.kr/?query=tag:Security" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Security</a> <a class="tag" href="https://lts.kr/?query=tag:Filter" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Filter</a> <br> <a href="https://lts.kr?query=tag:프로젝트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로젝트">#프로젝트</a> <a href="https://lts.kr?query=tag:개발" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#개발">#개발</a> <a href="https://lts.kr?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a> <a href="https://lts.kr?query=tag:Security" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Security">#Security</a> <a href="https://lts.kr?query=tag:Filter" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Filter">#Filter</a><br>
<br>Spring Security는 Java기반 웹 어플리케이션의 보안을 제공하는 강력한 프레임워크다.
<br>웹보안(HTTP인증, 접근제어) 뿐 아니라, 메소드 레벨 보안, 세션 관리, JWT 등 다양한 보안 시나리오를 제공한다.
<br>Spring Security는 Filter기반 아키텍처를 사용한다.
<br>Filter를 통해 HTTP요청과 응답을 가로채어 인증(Authentication), 인가(Authorization) 과정을 수행한다.<br>먼저, 스프링 시큐리티가 동작하기 위해서는 Filter가 필요하다.<br>
여기서 Servlet Filter는 Spring의 관리에서 벗어나기 때문에, DI사용에 한계가 있다.<br><img alt="do-messenger_screenshot_2025-04-29_15_37_33.png" src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-04-29_15_37_33.png" target="_self"><br>
이에 따라 스프링은, 요청을 위임하는 DelegatingFilterProxy 를 만들었다.<br>
<br>Servlet Container(Tomcat 등..)는 오직 Servlet Filter만 인식할 수 있다.<br>
이때, Spring Security의 인증, 인가 로직은 Spring Bean으로 만들어진다.
<br>즉, <br>Tomcat입장에서는 Spring Bean을 직접 호출할 방법이 없다.
<br>Spring입장에서는 Servlet Filter Chain에 진입하여야 한다.
<br>이 두개를 연결해 주는 역할을 하는것이 DelegatingFilterProxy 이다. <br>
<br>클라이언트가 서버로 HTTP 요청을 보낸다.
<br>톰캣(Servlet Container)이 Filter Chain을 조회하여 DelegatingFilterProxy를 호출한다.
<br>DelegatingFilterProxy는 <br>Spring ApplicationContext에서 자신이 참조할 Bean 이름(보통 "springSecurityFilterChain")을 찾는다.
<br>해당 이름의 Bean을 가져온다.
<br>가져온 Bean(보통 FilterChainProxy)의 doFilter() 메서드를 호출하여 실제 보안 처리를 진행한다. <br>FilterChainProxy는 내부에 등록된 다수의 SecurityFilter 들을 순서대로 호출한다.
<br>이때 DelegatingFilterProxy가 직접 보안 로직을 수행하는 것이 아닌,<br>
"Spring의 필터야, 이 요청 처리 좀 해줘" 하고 넘긴다.<br>[ Client Request ] ↓
[ Servlet Container Filter Chain ] ↓
[ DelegatingFilterProxy (web.xml 등록) ] ↓ (Spring Bean 호출)
[ FilterChainProxy (Spring Security 설정에 따라 동작) ] ↓
[ Security Filter1 → Security Filter2 → ... → Security FilterN ] ↓
[ DispatcherServlet ] ↓
[ Controller 처리 ]
<br>사용자가 누구인지를 확인하는 과정. ex) 아이디와 비밀번호로 로그인하여 사용자를 식별.
<br>사용자가 로그인 폼을 통해 아이디와 비밀번호를 제출
<br>UsernamePasswordAuthenticationFilter가 이 요청을 가로챔
<br>사용자 입력값을 바탕으로 UsernamePasswordAuthenticationToken 생성
<br>AuthenticationManager에 인증 요청을 위임
<br>AuthenticationProvider가 UserDetailsService를 통해 사용자 정보를 로드
<br>PasswordEncoder로 비밀번호 비교
<br>인증 성공 시 Authentication 객체를 SecurityContextHolder에 저장
<br>인증된 사용자가 어떤 리소스에 접근할 수 있는지 결정하는 과정. ex) 일반 사용자는 `/admin/**`에 접근 불가, ROLE_ADMIN 만 접근 가능
<br>요청이 들어옴
<br>FilterSecurityInterceptor가 요청 URL에 대한 접근 권한 체크
<br>인증된 Authentication 객체에 포함된 권한(GrantedAuthority) 목록과 비교
<br>인가 실패 시 AccessDeniedException 발생 → AccessDeniedHandler로 위임
<br>SecurityContext는 현재 사용자에 대한 보안 정보를 저장하는 객체다.<br>
Spring Security는 이 컨텍스트를 통해 현재 요청이 어떤 사용자에 의해 수행되는지 알 수 있다.<br>저장 위치:<br>기본적으로 ThreadLocal을 사용
<br>이는 각 스레드마다 고유한 컨텍스트를 유지할 수 있도록 해준다
<br>Spring Security의 인증 상태를 나타내는 핵심 인터페이스다. 주요 구성 요소는 다음과 같다<br>Spring Security는 비밀번호를 절대 평문으로 비교하지 않는다.<br>
항상 PasswordEncoder를 통해 암호화된 상태로 비교해야 한다.<br>기본적으로 BCryptPasswordEncoder가 권장되며, 단방향 해시 함수로 안전하다.<br>@Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); }
<br>인증 시 비밀번호 비교는 이렇게 이뤄진다<br>String raw = "plain_pw"; String hashed = userDetails.getPassword(); boolean match = passwordEncoder.matches(raw, hashed);]]></description><link>https://lts.kr/study/cs/🐡-spring-security와-filter.html</link><guid isPermaLink="false">study/CS/🐡 Spring Security와 Filter.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Tue, 29 Apr 2025 09:10:58 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-04-29_15_37_33.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-04-29_15_37_33.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Servlet이란 무엇인가]]></title><description><![CDATA[<br><br>Servlet은 간단히 말하면,<br>
"자바로 작성된 웹 요청/응답을 처리하는 서버 측 프로그램"이다.
<br>
<br>Servlet = Server + Applets의 합성어.<br> <br>웹 브라우저의 요청(Request)을 받고, 그에 대한 응답(Response)을 생성하는 자바 클래스.<br> <br>HTTP 통신 기반으로 동작한다. (하지만 이론상은 TCP 기반도 가능)<br> <br>공식적 정의:<br>
서블릿은 Java 언어로 작성된 서버 측 컴포넌트로서, HTTP 요청을 받아 처리하고, HTTP 응답을 생성하는 역할을 한다.<br>
(Java Servlet Specification, 현재 버전은 6.0)
<br><br>
<br>서버 시작 시 또는 요청 시 로딩 <br>톰캣(Tomcat) 같은 서블릿 컨테이너가 Servlet 클래스를 메모리에 로딩하고 객체를 생성한다.<br> <br>init() 호출 <br>생성된 서블릿 인스턴스에 대해 init(ServletConfig config) 메서드가 1회 호출된다.<br> <br>초기화 작업(리소스 연결 등)을 한다.<br> <br>요청마다 service() 호출 <br>클라이언트 요청이 들어오면 service(ServletRequest req, ServletResponse res)가 호출된다.<br> <br>여기서 HTTP 요청 종류(GET, POST 등)에 따라 알맞은 메서드(doGet, doPost 등)가 분기 호출된다.<br> <br>서버 종료 시 destroy() 호출 <br>서버 종료나 재배포 시, destroy() 메서드가 호출되어 리소스 정리(clean-up)한다. <br><br><br>Servlet 컨테이너는 Servlet의 생명주기를 관리하고 HTTP 요청을 대신 받아 Servlet에 연결해준다.<br>컨테이너가 하는 일은:<br>
<br>HTTP 요청 수신<br> <br>URL 매핑 → 해당 Servlet 호출<br> <br>Servlet 인스턴스 생성/관리<br> <br>멀티 스레드로 각 요청 처리<br> <br>Servlet API 제공 (HttpServletRequest, HttpServletResponse 등)<br> <br>대표적인 Servlet 컨테이너: Apache Tomcat, Jetty, Undertow, WildFly 등]]></description><link>https://lts.kr/짧은-키워드/servlet.html</link><guid isPermaLink="false">짧은 키워드/Servlet.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Tue, 29 Apr 2025 06:58:38 GMT</pubDate></item><item><title><![CDATA[GitOps]]></title><description><![CDATA[<br>
<br>
DevOps(개발과 운영을 통합하여 효율성,협력,안정성을 개선하는 개발/운영 방법론)의 실천 방법중 하나로, 애플리케이션 배포와 운영에 관련된 모든요소를 Git에서 관리(Opertation)한다는 뜻이다. <br>
Git의 버전관리 시스템과 운영환경간의 일관성을 유지하여 소프트웨어간의 불일치 문제를해결할 수 있다. ]]></description><link>https://lts.kr/짧은-키워드/gitops.html</link><guid isPermaLink="false">짧은 키워드/GitOps.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Tue, 29 Apr 2025 06:55:23 GMT</pubDate></item><item><title><![CDATA[🪓 도구]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:Tools" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Tools</a> <a class="tag" href="https://lts.kr/?query=tag:모음" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#모음</a> <a class="tag" href="https://lts.kr/?query=tag:도구" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#도구</a> <br> <a href="https://lts.kr?query=tag:Tools" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Tools">#Tools</a> <a href="https://lts.kr?query=tag:모음" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#모음">#모음</a> <a href="https://lts.kr?query=tag:도구" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#도구">#도구</a><br>툴 모음
제가 사용하고 있는 편리/유용한 TOOL을 소개하고 설명하는 곳 입니다.
<br>
<br><a data-href="🍊 aws EC2란" href="https://lts.kr/tools/aws/🍊-aws-ec2란.html" class="internal-link" target="_self" rel="noopener nofollow">🍊 aws EC2란</a>
<br><a data-href="🌥 aws(EC2)셋팅부터 배포까지" href="https://lts.kr/tools/aws/🌥-aws(ec2)셋팅부터-배포까지.html" class="internal-link" target="_self" rel="noopener nofollow">🌥 aws(EC2)셋팅부터 배포까지</a>
<br><a data-href="🍌 Elastic IP(탄력적 IP)란" href="https://lts.kr/tools/aws/🍌-elastic-ip(탄력적-ip)란.html" class="internal-link" target="_self" rel="noopener nofollow">🍌 Elastic IP(탄력적 IP)란</a>
<br>
<br><a data-href="🐋 docker 란" href="https://lts.kr/tools/docker/🐋-docker-란.html" class="internal-link" target="_self" rel="noopener nofollow">🐋 docker 란</a>
<br><a data-href="📘 SpringBoot &amp; Docker + Reids 연동" href="https://lts.kr/tools/docker/📘-springboot-&amp;-docker-+-reids-연동.html" class="internal-link" target="_self" rel="noopener nofollow">📘 SpringBoot &amp; Docker + Reids 연동</a>
<br>
<br><a data-href="👔 Jenkins란" href="https://lts.kr/tools/jenkins/👔-jenkins란.html" class="internal-link" target="_self" rel="noopener nofollow">👔 Jenkins란</a>
<br>
<br><a data-href="🚢Kubernetes(k8s)란" href="https://lts.kr/tools/kubernetes/🚢kubernetes(k8s)란.html" class="internal-link" target="_self" rel="noopener nofollow">🚢Kubernetes(k8s)란</a>
<br>
<br><a data-href="🍎 Redis로 Key관리하기" href="https://lts.kr/study/cs/🍎-redis로-key관리하기.html" class="internal-link" target="_self" rel="noopener nofollow">🍎 Redis로 Key관리하기</a>
<br><a data-href="🔐 상품 투자하기 서비스 Lock기법 개선안" href="https://lts.kr/issue_troubleshooting/🔐-상품-투자하기-서비스-lock기법-개선안.html" class="internal-link" target="_self" rel="noopener nofollow">🔐 상품 투자하기 서비스 Lock기법 개선안</a>
<br><a data-href="🔻 Redis 캐쉬 전략 - hello 서비스에 적용하여 성능개선 가능성" href="https://lts.kr/study/dev-seminar/🔻-redis-캐쉬-전략-hello-서비스에-적용하여-성능개선-가능성.html" class="internal-link" target="_self" rel="noopener nofollow">🔻 Redis 캐쉬 전략 - hello 서비스에 적용하여 성능개선 가능성</a>
<br>
<br><a data-href="🎵 Obsidian" href="https://lts.kr/tools/🎵-obsidian.html" class="internal-link" target="_self" rel="noopener nofollow">🎵 Obsidian</a>
<br><a data-href="👻 Obsidian 정적호스팅 CICD 과정" href="https://lts.kr/project/note-ci_cd/👻-obsidian-정적호스팅-cicd-과정.html" class="internal-link" target="_self" rel="noopener nofollow">👻 Obsidian 정적호스팅 CICD 과정</a>
<br>
<br>🩹추가예정!!]]></description><link>https://lts.kr/tools/🪓-도구.html</link><guid isPermaLink="false">Tools/🪓 도구.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Thu, 24 Apr 2025 00:49:30 GMT</pubDate></item><item><title><![CDATA[🚢Kubernetes(k8s)란]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:Tools" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Tools</a> <a class="tag" href="https://lts.kr/?query=tag:Kubernetes" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Kubernetes</a> <a class="tag" href="https://lts.kr/?query=tag:k8s" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#k8s</a> <br> <a href="https://lts.kr?query=tag:Tools" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Tools">#Tools</a> <a href="https://lts.kr?query=tag:Kubernetes" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Kubernetes">#Kubernetes</a> <a href="https://lts.kr?query=tag:k8s" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#k8s">#k8s</a><br>
<br>과거에는 서버 1대에 하나의 앱을 설치하는 방식 → 리소스 낭비
<br>가상화(VM)는 개선책이었지만 느리고 무겁다
<br>
<br>Docker를 사용한 컨테이너(꼭 Docker가 아니더라도..) 기술은 경량화된 격리 실행환경 제공
<br>문제: 수백~수천 개의 컨테이너를 관리, 스케줄링, 모니터링를 사람이 직접 한다는것은 많이 어렵다.
<br>
<br>구글이 자사 서비스에서 10년 넘게 써온 내부 컨테이너 오케스트레이터 “Borg”의 아이디어를 오픈소스로 풀어낸 것이 Kubernetes(줄여서 k8s)이다.
<br>
<br>위에서 설명했듯 여러개의 컨테이너를 자동으로 배포, 스케일링, 복구, 관리하는 컨테이너 오케스트레이션 플랫폼이다.
<br> +-------------------+ | Master Node | |-------------------| | - API Server | | - Scheduler | | - Controller Mgr | | - etcd (DB) | +---------+---------+ | ┌────────────┴────────────┐ ↓ ↓ +-------------+ +---------------+ | Worker Node| | Worker Node | |-------------| |---------------| | kubelet | | kubelet | | kube-proxy | | kube-proxy | | containerd | | containerd | +-------------+ +---------------+ ↓ ↓ [Pod: 컨테이너 + 네트워크 + 볼륨]
<br>k8s가 컨테이너 오케스트레이션 플랫폼 (어디에, 어떠게 배포할지 결정 )이라면,<br>
argoCD는 <a data-href="GitOps" href="https://lts.kr/짧은-키워드/gitops.html" class="internal-link" target="_self" rel="noopener nofollow">GitOps</a>기반의 Continuous Delivery 도구 (무엇을, 언제, 어떤 방식으로 배포할지 관리) 이다.<br>
<br>k8s의 모든 배포는 yaml파일을 통해 이뤄진다.<br>
→이때, 배포를 수행하는 개발자마다 각자의 PC에서 yaml파일을 만들어 관리한다면, 많은 노력이 들어가게 된다.<br>
따라서, <a data-href="GitOps" href="https://lts.kr/짧은-키워드/gitops.html" class="internal-link" target="_self" rel="noopener nofollow">GitOps</a>방법론에 따라, 배포와 관련된 모든 코드를 Git을 통해 관리하도록 하는것이다.
<br>즉, ArgoCD는 Kubernetes를 위한 GitOps 자동 배포 계층이다.<br>Git Repository (Manifest 저장) ← (감시) ← Argo CD → (반영) → Kubernetes Cluster<br>
<br>Argo CD는 Kubernetes의 배포 자동화 담당
<br>Kubernetes는 애플리케이션을 실행하고, Argo CD는 그것을 배포/관리함
<br>Git을 소스 오브 트루스로 삼고, Argo CD는 상태를 감시하고 Kubernetes와 싱크 맞춤
<br>실시간 배포 이력 추적, 자동 복구, 롤백, 멀티클러스터 지원 등 GitOps 핵심 도구
<br>Kubernetes를 쓰는 조직이라면 Argo CD는 필수에 가까움 (Jenkins는 CI로만 남게 됨)
<br>]]></description><link>https://lts.kr/tools/kubernetes/🚢kubernetes(k8s)란.html</link><guid isPermaLink="false">Tools/Kubernetes/🚢Kubernetes(k8s)란.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 23 Apr 2025 09:14:09 GMT</pubDate></item><item><title><![CDATA[👔 Jenkins란]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:Tools" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Tools</a> <a class="tag" href="https://lts.kr/?query=tag:도커" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#도커</a> <a class="tag" href="https://lts.kr/?query=tag:Docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Docker</a> <br> <a href="https://lts.kr?query=tag:Tools" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Tools">#Tools</a> <a href="https://lts.kr?query=tag:도커" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#도커">#도커</a> <a href="https://lts.kr?query=tag:Docker" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Docker">#Docker</a><br>
<br>Jenkins는 오픈소스 기반의 자동화 서버로, 주로 지속적 통합(CI: Continuous Integration)과 지속적 배포(CD: Continuous Delivery/Deployment)를 자동화하기 위해 사용된다.
<br>특징<br>java기반으로 만들어져, OS에 상관없이 실행 가능
<br>파이프라인 기반으로 소프트웨어 빌드, 테스트, 배포 자동화
<br>플러그인 아키텍처로 확장성이 뛰어남
<br>
<br>개발자가 코드 변경 시 자동으로 빌드 + 테스트 수행
<br>코드 병합 시 문제 조기 탐지
<br>코드 품질 유지 + 릴리즈 주기 단축
<br>
<br>테스트 통과 후 자동으로 스테이징 또는 운영 서버에 배포
<br>릴리즈 주기 자동화 → 빠른 피드백 루프
<br>
<br>빌드 → 테스트 → 배포 → 모니터링까지의 전체 과정을 파이프라인으로 시각화<br>
<img alt="Pasted image 20250421164348.png" src="https://lts.kr/사진-및-문서/pasted-image-20250421164348.png" style="width: 750px; max-width: 100%;" target="_self">
<br>Git Hook, Cron, Webhook, Polling 등 다양한 트리거 지원
<br>Webhook vs Polling
폴링(Poliing) : 일정 시간 간격으로 저장소의 변경사항을 확인<br>
웹훅(Webhook) : 저장소(Git 등)에 변경사항이 발생했을 때, 젠킨스에 즉시 알려주는 방식
<br>이를 설정하는 방법은 젠킨스의 파이프 라인 설정을 통해 이루어 진다.<br>파이프라인 구조 예시
<br>pipeline { agent any triggers { // GitHub에서 Webhook을 통해 이벤트가 올 때 트리거됨 githubPush() } stages { stage('Checkout') { steps { git url: 'https://github.com/your-org/your-repo.git', branch: 'main' } } stage('Build') { steps { sh 'echo Building...' } } } ---- agent any triggers { // 5분마다 Git 변경사항 확인 (cron 표현식) pollSCM('H/5 * * * *') } stages { stage('Checkout') { steps { git url: 'https://github.com/your-org/your-repo.git', branch: 'main' } } stage('Build') { steps { sh 'echo Building...' } } }
}
<br>
<br>Freestyle Job: 기본 작업 단위 (빌드, 테스트, 배포 설정)
<br>Pipeline: Groovy 기반 DSL로 멀티스텝 작업 정의
<br>Multibranch Pipeline: 브랜치마다 파이프라인 분기 설정
<br>
<br>1,800개 이상의 공식 플러그인
<br>주요 플러그인: <br>Git / GitHub / Bitbucket
<br>Docker
<br>Slack / Email Notification
<br>Kubernetes
<br>SonarQube
<br>Artifactory / Nexus <br>
<br>이메일, Slack, Teams, Webhook 등 다양한 알림 지원
<br>실패/성공/경고 상태에 따라 조건부 메시지 전송 가능
<br>
<br>작업당 빌드 결과 로그 저장
<br>실패 시 어떤 스텝에서 실패했는지 명확히 추적 가능
<br>
<br>LDAP, Active Directory 연동
<br>Role 기반 접근 제어 (RBAC)
<br>Job/Folder 단위 권한 설정 <br>
<br>Master는 Job 스케줄링 및 관리
<br>Agent (노드)는 실제 빌드 실행 담당
<br>스케일아웃 구조로 부하 분산 가능
<br>젠킨스와 도커는 서버 자동화(CI/CD)환경에서 매우 자주 함께 활용된다.<br>
두 도구의 역할은 서로 다르지만 서로를 보완해주는 역할을 한다.<br>먼저 도커의 주 역할은 애플리케이션 실행 환경의 캡슐화 이다.<br>
이렇게 캡슐화된 것을 이미지 또는 컨테이너라고 한다.<br>이미지와 컨테이너?
이미지와 컨테이너는 사실상 같은 개념을 가리키는 용어이다.
도커 이미지 : Docker라는 특정 기술/플랫폼을 통해 생성되고 관리되는 이미지. Docker에 종속적<br>
컨테이너 : 보다 일반적인 용어로, 컨테이너 기술을 사용하는 모든 플랫폼의 이미지를 뜻한다.
<br>즉, 젠킨스와 도커의 관계를 요약하자면<br>
Jenkins는 Docker를 사용해 컨테이너 환경에서 빌드와 테스트를 실행하거나, 애플리케이션을 Docker 이미지로 빌드하고 레지스트리에 배포하며, 필요 시 Jenkins 자체도 Docker 컨테이너로 실행할 수 있다.<br>
<br>파이프라인 실행 트리거 <br>GitHub/GitLab에서 코드 변경 발생 시: <br>✅ Webhook: 변경 사항을 Jenkins에 즉시 알림
<br>✅ Polling: Jenkins가 주기적으로 변경 여부 확인<br>소스코드 + Dockerfile 가져오기 <br>트리거 감지 후 Jenkins가 Git 저장소에서 코드와 Dockerfile을 `checkout <br>dockerfile
→ 컨테이너 이미지를 만들기 위한 설정 파일(스크립트)<br>
쉽게 말해, “어떤 OS에, 어떤 앱을 설치하고, 어떤 명령을 실행할 것인지”를 정의한 레시피라고 볼 수 있다.
<br>Docker 이미지 빌드 <br>docker build -t my-app . 명령으로 컨테이너 이미지 생성<br>컨테이너 기반 테스트 수행 (선택) <br>docker run으로 테스트 자동화 실행<br>Docker 이미지 푸시 <br>DockerHub, ECR 등에 docker push 수행<br>서버 또는 클러스터에 배포 <br>SSH, Docker Compose, Kubernetes 등을 통해 자동 배포<br>
▶ <a data-href="🚢Kubernetes(k8s)란" href="https://lts.kr/tools/kubernetes/🚢kubernetes(k8s)란.html" class="internal-link" target="_self" rel="noopener nofollow">🚢Kubernetes(k8s)란</a> <br>알림 및 로그 저장 <br>Slack, Email 알림 전송 + Jenkins에 빌드 로그 기록]]></description><link>https://lts.kr/tools/jenkins/👔-jenkins란.html</link><guid isPermaLink="false">Tools/Jenkins/👔 Jenkins란.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 23 Apr 2025 06:30:56 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20250421164348.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20250421164348.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🐋 docker 란]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:Tools" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Tools</a> <a class="tag" href="https://lts.kr/?query=tag:도커" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#도커</a> <a class="tag" href="https://lts.kr/?query=tag:Docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Docker</a> <br> <a href="https://lts.kr?query=tag:Tools" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Tools">#Tools</a> <a href="https://lts.kr?query=tag:도커" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#도커">#도커</a> <a href="https://lts.kr?query=tag:Docker" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Docker">#Docker</a><br><img alt="Pasted image 20250221114743.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114743.png" target="_self"><br>...aws의 설명에 의하면<br>
<br>애플리케이션을 신속하게 구축, 테스트 및 배포할 수 있는 소프트웨어 플랫폼이다.
<br>소프트웨어를&nbsp;컨테이너&nbsp;라는 표준화된 유닛으로 패키징하여 관리한다.<br>
2-1. 컨테이너에는 라이브러리, 시스템 도구, 코드, 런타임 등 소프트웨어를 실행하는 데 필요한 모든것이 포함되어 있다.
<br>Docker는 AWS와 협업하여 다양한 규모에서 안정적이고 저렴하게 애플리케이션을 구축, 제공할 수 있게 한다.
<br>
<br>코드, 런타임, 시스템도구 등등등 소프트웨어를 실행하는 데 필요한 모든 것을 포함하는 독립 실행형 실행 가능 패키지 이다.
<br>다른컨테이너나 호스트 시스템을 방해하지 않고, Docker runtime을 사용하여 모든 호스트에서 실행할 수 있는 소프트웨어의 격리된 단위로 설계되어있다.
<br>
<br>별도의 하드웨어 에뮬레이션 없이 리눅스 커널을 공유해 컨테이너를 실행한다.
<br>
<br>하드웨어 에뮬레이션이 없어서 매우 빠르다. 또한 하나의 머신에서 프로세스만큼 많이 실행하는 것이 가능하다.
<br>
<br>컨테이너는 호스트의 환경이 아닌 독자적인 실행환경을 갖고 있다.
<br>이 환경은 파일(Dockerfile)들로 구성되며, 공유될 수 있다.
<br>
<br>모든 이미지에는 계층이 있으며, 현재의 이미지가 적절하지 않은 경우 이전 버전으로 롤백이 가능하다.
<br>CI/CD를 수행하는 데 도움을 준다.
<br>
<br>
서버를 처음 설정할때, OS, 라이브러리, 컴파일러 등 많은 설정이 필요하고, 버전으 변경되고 업데이트 될 때 마다 다시 재설정이 필요하다. <br>
하지만, 이러한 설정 등을 도커 컨테이너 위에서 진행한다면, 호스트 OS에 아무런 영향을 주지 않는다.<br>
즉, 로컬 환경의 간섭 없이 독립적으로 구동된다! <br>
또한 다른 서버로 이사를 가는 상황에서 이미지만을 가져와 새로운 서버에 컨테이너를 만들어 쉽게 동일한 환경을 구성할 수 있다. <br>
<br>마이크로 서비스 구조로, 애플리케이션이 독립적인 구성 요소로 구축되어 각 애플리케이션 프로세스가 서비스로 실행된다.
<br>
<br>도커는 각 환경마다 쓸 수 있는 자원이 고정적으로 정해져 있지 않기 때문에, 유동적으로 자원을 할당하여 기존의 가상화 방식보다 훨씬 자원적, 성능적으로 뛰어나다
<br>]]></description><link>https://lts.kr/tools/docker/🐋-docker-란.html</link><guid isPermaLink="false">Tools/docker/🐋 docker 란.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Mon, 21 Apr 2025 07:39:44 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20250221114743.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20250221114743.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[📘 SpringBoot &amp; Docker + Reids 연동]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:Tools" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Tools</a> <a class="tag" href="https://lts.kr/?query=tag:도커" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#도커</a> <a class="tag" href="https://lts.kr/?query=tag:Docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Docker</a> <a class="tag" href="https://lts.kr/?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <a class="tag" href="https://lts.kr/?query=tag:Boot" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Boot</a> <a class="tag" href="https://lts.kr/?query=tag:Redis" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Redis</a> <br> <a href="https://lts.kr?query=tag:Tools" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Tools">#Tools</a> <a href="https://lts.kr?query=tag:도커" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#도커">#도커</a> <a href="https://lts.kr?query=tag:Docker" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Docker">#Docker</a> <a href="https://lts.kr?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a> <a href="https://lts.kr?query=tag:Boot" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Boot">#Boot</a> <a href="https://lts.kr?query=tag:Redis" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Redis">#Redis</a> <br><img alt="Pasted image 20250221114306.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114306.png" target="_self"><br>먼저 도커에 대한 간단한 이전 글!<br>aws의 설명에 의하면 Docker란 <br>애플리케이션을 신속하게 구축, 테스트 및 배포할 수 있는 소프트웨어 플랫폼이다. <br>소프트웨어를 컨테이너 라는 표준화된 유닛으로 패키징하여 관리한다. <br><a data-tooltip-position="top" aria-label="https://docs.docker.com/desktop/install/mac-install/" rel="noopener nofollow" class="external-link is-unresolved" href="https://docs.docker.com/desktop/install/mac-install/" target="_self">도커 다운로드 링크</a><br>각 기기에 맞는 docker 버전을 다운로드 받는다.<br>
<img alt="Pasted image 20250221114324.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114324.png" target="_self"><br>다운로드 받은 후 명령어를 입력하여 docker의 현재 버전을 볼 수 있다.<br>※ 터미널에 'docker' 를 입력하게 되면 다양한 명령어들을 확인할 수 있다.<br>
<img alt="Pasted image 20250221114327.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114327.png" target="_self"><br>제대로 다운로드 받았다면 docker에 기본적으로 만들어져있는 이미지들을 확인 할수 있다. 밑에 사진은 도커 데스트톱 이라는 앱이다.<br><img alt="Pasted image 20250221114334.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114334.png" target="_self"><br>터미널에서도 확인할 수 있다.<br><img alt="Pasted image 20250221114339.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114339.png" target="_self"><br>이제&nbsp;도커 파일&nbsp;을 이용하여&nbsp;도커 이미지를 생성한 후, 이미지를 빌드하여&nbsp;컨테이너를 생성해 줄것이다.<br>여기서 여러 용어들이 나오는데...<br>용어들에 대한 설명이다<br><img alt="Pasted image 20250221114345.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114345.png" target="_self"><br><img alt="Pasted image 20250221114353.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114353.png" target="_self"><br>Dockerfile을 생성하기에 앞서, .jar 파일을 생성해야한다.<br>gradle 이나 maven 을 사용하여 프로젝트를 빌드 할것이다.<br>여기서는 Maven 을 사용한다.<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://maven.apache.org/download.cgi" target="_self">https://maven.apache.org/download.cgi</a><br>홈페이지에서 직접 다운받아도 되고, brew를 사용해 각자 다운받으면 된다.<br>이후에, 프로젝트의 루트 디렉토리에서 'mvn install' 명령어를 사용하여 프로젝트를 빌드 할 수 있다.<br><img alt="Pasted image 20250221114400.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114400.png" target="_self"><br>빌드를 마치면, 프로젝트 내에&nbsp;target이 생성 됨을 볼 수 있다.<br><img alt="Pasted image 20250221114406.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114406.png" target="_self"><br>그 후, 루트 디렉토리에 'Dockerfile' 을 생성하여 준다.<br><img alt="Pasted image 20250221114411.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114411.png" target="_self"><br><img alt="Pasted image 20250221114423.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114423.png" target="_self"><br>Dockerfile 생성시 사용되는 명령어들은 다음과 같다.<br><img alt="Pasted image 20250221114428.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114428.png" target="_self"><br>나는 기본적인 옵션만 넣어서 test 하였다.<br>FROM 태그에 나의 java(jdk)버전을 확인하여 baseimage를 지정하고<br>
( dockerRpository에서 다양한 이미지를 가져다 사용할 수 있으므로 찾아보세요)<br>ADD 태그에 maven을 통해 생성된 .jar파일과 경로를 입력한다<br>이외에 태그는 자유롭게 작성해 줄 수 있다.<br>프롬프트에 <br>docker build -t ${"도커파일 명"} ${"디렉토리"} <br>형식으로 사용할 수 있다.<br><img alt="Pasted image 20250221114434.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114434.png" target="_self"><br><img alt="Pasted image 20250221114439.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114439.png" target="_self"><br>해당 단계를 마치면 이미지가 생성된 것을 확인할 수 있다.<br>프롬프트에 <br>docker run -p ${사용할 포트번호} ${이미지 명}
<br>을 사용한다.<br>본인은 8000번 포트를 직접 사용하여 8080포트인 도커 컨테이너에 접근할 것이다.<br><img alt="Pasted image 20250221114443.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114443.png" target="_self"><br>짜잔!&nbsp; &nbsp;정상적으로 동작한다.<br>
<img alt="Pasted image 20250221114501.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114501.png" target="_self"><br>
<img alt="Pasted image 20250221114448.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114448.png" target="_self"><br>docker는 다운받아져 있는걸로 알고..&nbsp;<br>'docker pull redis:latest' 명령어를 사용하여 최신버전의 redis를 받아온다.<br><img alt="Pasted image 20250221114522.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114522.png" target="_self"><br>그 다음, <br>docker network create redis-network --driver bridge
<br>명령어를 사용하여 네트워크를 생성해 준다.<br>※ docker network : 컨테이너간의 통신 및 데이터 공유를 위한 가상 네트워크<br><img alt="Pasted image 20250221114527.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114527.png" target="_self"><br>이제, 'sudo vim redis.conf' 명령어를 사용하여 redis.conf 파일을 수정하여 설정을 잡아준다.<br><img alt="Pasted image 20250221114531.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114531.png" target="_self"><br>docker run \ -d \ --name redis \ -p 6379:6379 \ --network redis-network \ -v ~/${데이터를 저장할 파일 경로} /redis.conf:/etc/redis/redis.conf \ -v redis_data:/data \
redis:latest redis-server /etc/redis/redis.conf
<br><img alt="Pasted image 20250221114535.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114535.png" target="_self"><br>포트번호와, 방금 설정한 네트워크, 데이터 저장 경로를 잡아준다.<br>이렇게 설정을 마쳤으면 redis 이미지가 생성되었음을 확인할 수 있다.<br><img alt="Pasted image 20250221114539.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114539.png" target="_self"><br>최종적으로 생성된 이미지로 컨테이너를 만들어 준다.<br><img alt="Pasted image 20250221114543.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114543.png" target="_self"><br>docker run --name myredis \ -p 6379:6379 \ --network redis-network \ -v /Users/lts/Desktop/docker/redis:/data \ -d redis:latest redis-server \ --appendonly yes
<br><img alt="Pasted image 20250221114600.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114600.png" target="_self"><br>컨테이너까지 생성완료!<br>docker exec -it myredis redis-cli --raw
<br>명령어를 사용하여 컨테이너 실행<br><img alt="Pasted image 20250221114605.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114605.png" target="_self"><br>프롬프트를 보면 정상적으로 접속됨을 확인할 수 있다.<br>※ 해당 프로젝트는 Maven 을 사용한 프로젝트이다.<br>spring.cache.type=redis
spring.redis.host=localhost
spring.redis.port=6379
<br><img alt="Pasted image 20250221114610.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114610.png" target="_self"><br><img alt="Pasted image 20250221114616.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114616.png" target="_self"><br>import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.serializer.StringRedisSerializer; @Configuration
public class RedisConfig { @Value("${spring.redis.host}") private String host; @Value("${spring.redis.port}") private int port; @Bean public LettuceConnectionFactory redisConnectionFactory() { return new LettuceConnectionFactory(host, port); } @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate() { RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.setValueSerializer(new StringRedisSerializer()); redisTemplate.setConnectionFactory(redisConnectionFactory()); return redisTemplate; } @Bean public StringRedisTemplate stringRedisTemplate() { final StringRedisTemplate stringRedisTemplate = new StringRedisTemplate(); stringRedisTemplate.setKeySerializer(new StringRedisSerializer()); stringRedisTemplate.setValueSerializer(new StringRedisSerializer()); stringRedisTemplate.setConnectionFactory(redisConnectionFactory()); return stringRedisTemplate; }
}
<br><img alt="Pasted image 20250221114621.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114621.png" target="_self"><br>import lombok.AllArgsConstructor; import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.Id;
import org.springframework.data.redis.core.RedisHash;
import org.springframework.data.redis.core.index.Indexed; import java.time.LocalDateTime; @Getter
@RedisHash(value = "resultHistory", timeToLive = 3600) // Redis Repository 사용을 위한
@AllArgsConstructor
@NoArgsConstructor
public class ResultHistory { @Id private String id; @Indexed // 필드 값으로 데이터를 찾을 수 있도록 설정 (findByAccessToken) private String ip; private String originalText; private String translatedText; @Indexed private LocalDateTime createDateTime; @Builder public ResultHistory(String ip, String originalText, String translatedText, LocalDateTime createDateTime) { this.ip = ip; this.originalText = originalText; this.translatedText = translatedText; this.createDateTime = createDateTime; }
}
<br><img alt="Pasted image 20250221114628.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114628.png" target="_self"><br>import com.teamTS.funfun.model.ResultHistory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository; import java.util.List;
import java.util.Optional; @Repository
public interface ResultRedisRepository extends JpaRepository&lt;ResultHistory, String&gt; { Optional&lt;List&lt;ResultHistory&gt;&gt; findByIpOrderByCreateDateTimeAsc(String ip);
}
<br><img alt="Pasted image 20250221114633.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114633.png" target="_self"><br> @GetMapping("/hello") public String HelloWorld(Model model) { redisConnectionTest(); List&lt;TestModel&gt; tm = testRepository.getTestData(); model.addAttribute("data", tm.get(0).getTitle()); return "home/homeView"; } void redisConnectionTest() { final String key = "a"; final String data = "1"; final ValueOperations&lt;String, String&gt; valueOperations = redisTemplate.opsForValue(); valueOperations.set(key, data); final String s = valueOperations.get(key); } }
<br><img alt="Pasted image 20250221114638.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114638.png" target="_self"><br>Error starting ApplicationContext. To display the condition evaluation report re-run your application with 'debug' enabled.
<br>원인은 기존 MapperRepository와 Redis용 JpaRepository에서<br>@Repository
<br>해당 어노테이션을 사용하여 충돌한듯 하다.<br>
이럴때는<br>spring.main.allow-bean-definition-overriding=true
<br>한 줄을 추가하여 준다.<br><img alt="Pasted image 20250221114644.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114644.png" target="_self"><br>성공적인 실행.<br><img alt="Pasted image 20250221114648.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114648.png" target="_self"><br>&nbsp;이후 ' keys * ' 명령어를 사용하여 데이터가 정상적으로 추가된 것을 확인할 수 있다.<br>]]></description><link>https://lts.kr/tools/docker/📘-springboot-&amp;-docker-+-reids-연동.html</link><guid isPermaLink="false">Tools/docker/📘 SpringBoot &amp; Docker + Reids 연동.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Mon, 21 Apr 2025 07:39:42 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20250221114306.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20250221114306.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3.1 스프링 컨테이너 생성]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:SpringCoreBasic" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SpringCoreBasic</a> <a class="tag" href="https://lts.kr/?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <a class="tag" href="https://lts.kr/?query=tag:lectur" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#lectur</a> <a class="tag" href="https://lts.kr/?query=tag:강의" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#강의</a> <a class="tag" href="https://lts.kr/?query=tag:컨테이너" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#컨테이너</a> <a class="tag" href="https://lts.kr/?query=tag:Bean" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Bean</a> <a class="tag" href="https://lts.kr/?query=tag:빈" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#빈</a> <br> <a href="https://lts.kr?query=tag:SpringCoreBasic" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SpringCoreBasic">#SpringCoreBasic</a> <a href="https://lts.kr?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a> <a href="https://lts.kr?query=tag:lectur" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#lectur">#lectur</a> <a href="https://lts.kr?query=tag:강의" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#강의">#강의</a> <a href="https://lts.kr?query=tag:컨테이너" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#컨테이너">#컨테이너</a> <a href="https://lts.kr?query=tag:Bean" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Bean">#Bean</a> <a href="https://lts.kr?query=tag:빈" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#빈">#빈</a><br>//스프링 컨테이너 생성
ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
<br>ApplicationContext 를 스프링 컨테이너라 한다. ApplicationContext 는 인터페이스이다. <br>스프링 컨테이너는 XML을 기반으로 만들 수 있고, 애노테이션 기반의 자바 설정 클래스로 만들 수 있다. <br>자바 설정 클래스를 기반으로 스프링 컨테이너(ApplicationContext)를 만들어보자. <br>new AnnotationConfigApplicationContext(AppConfig.class);<br>
-&gt; 이 클래스는 ApplicationContext 인터페이스의 구현체이다.]]></description><link>https://lts.kr/lectur/3.1-스프링-컨테이너-생성.html</link><guid isPermaLink="false">lectur/3.1 스프링 컨테이너 생성.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Mon, 21 Apr 2025 05:20:07 GMT</pubDate></item><item><title><![CDATA[🥇 정보처리 기사 실기 키워드]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:정보처리기사" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정보처리기사</a> <a class="tag" href="https://lts.kr/?query=tag:실기" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#실기</a> <a class="tag" href="https://lts.kr/?query=tag:키워드" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#키워드</a> <a class="tag" href="https://lts.kr/?query=tag:정리" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정리</a> <br> <a href="https://lts.kr?query=tag:정보처리기사" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정보처리기사">#정보처리기사</a> <a href="https://lts.kr?query=tag:실기" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#실기">#실기</a> <a href="https://lts.kr?query=tag:키워드" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#키워드">#키워드</a> <a href="https://lts.kr?query=tag:정리" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정리">#정리</a><br>
<br>시제품을 끊임없이 제작하며 사이클을 반복하는 개발 방법론
<br>워터폴과 대조적이며, 소프트웨어 개발을 넘어 기업 경영 전반에서 사용되고 있다.
<br>고객의 변화하는 요구사항과 환경 변화에 능동적인 소프트웨어 개발 방법론
<br>
<br>소프트웨어 공학에서 리펙토링(Refactoring)을 하는 목적에 대해 간략히 서술하시오.
<br>
리펙토링의 목적은 프로그램을 쉽게 이해하고 수정하여 빠르게 개발할 수 있도록 하기 위함이다.
<br>
<br>( 1 ) 요구사항은 시스템이 무엇을 하는지, 어떤 기능을 하는지 등 사용자가 시스템을 통해 제공받기를 원하는 기능이나 시스템이 반드시 수행해야하는 기능을 의미한다.
<br>( 2 ) 요구사항은 품질이나 제약사항과 관련된 요구사항으로, 시스템의 장비 구성, 성능, 인터페이스, 테스트, 보안 등의 요구사항을 말한다.
<br>
<br>UML에 관한 다음 괄호에 공통으로 들어갈 알맞은 용어는?
<br>( ) 다이어그램은 UML다이어그램중 객체(Object)들을 ( )로 추상화하여 표현하는 다이어그램으로, 대표적인 구조적 다이어그램이다.
<br>( )는 각각의 객체들이 갖는 속성과 메소드를 표현한 것으로 3개의 구획으로 나눠 이름, 속성, 메서드를 표기한다.
<br>
<br>UML은 시스템 분석, 설계, 구현 등 시스템 개발 과정에서 시스템 개발자와 고객 또는 개발자 상호 간의 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어로 사물, ( 1 ), 다이어그램 으로 이루어져있다.
<br>( 1 )는 사물과 사물사이의 연관성을 표현하는 것으로 연관, 집합, 포함, 일반화 등 다양한 형태의 ( 1 )가 존재한다.
<br>( 2 )는 UML에 표현되는 사물의 하나로, 객체가 갖는 속성과 동작을 표현한다. 일반적으로 직사각형으로 표현하며, 직사각형 안에 이름, 속성, 동작을 표기한다.
<br>( 3 )는 ( 2 )와 같은 UML에 표현되는 사물의 하나로, ( 2 )나 컴포넌트의 동작을 모아놓은 것이며, 외부적으로 가시화되는 행동을 표현한다. 단독으로 사용되는 경우는 없으며, ( 3 )구현을 위한 ( 2 )또는 컴포넌트와 함께 사용된다.
<br>
<br>관계(Relationship)는 사물과 사물 사이의 연관성을 표현하는 것이다.
<br>1 - 하나의 사물이 다른 사물에 포함되어 있는 관계로, 전체와 부분으로 구분되어지며, 서로 독립적이다.
<br>2 - 상위 모듈이 하위 모듈보다 더 일반적인 개념을 가지고 있으며, 하위 모듈이 상위 모듈보다 더 구체적인 개념을 가진다.
<br>
[보기]<br>
-Association(연관 관계) : 객체간의 기본적인 관계를 나타낸다.<br>
-Dependency(의존 관계) : 한 객체가 다른 객체에 의존하거나 영향을 받는다.<br>
-Aggregation(집합 관계) : 부분과 전체의 관계를 나타내며, 부분이 독립적으로 존재할 수 있는 경우를 말한다.<br>
-Realization(실체화 관계) : 인터페이스와 이를 구현하는 클래스 간의 관계<br>
-Composition(합성 관계) : 집합관계의 특수한 형태로, 부분이 전체와 생명 주기를 공유하며 독립적으로 존재할 수 없는 경우<br>
-Generalization(일반화 관계) : 상위 클래스와 하위 클래스 간의 관계로, 상속을 통해 일반적인 특성을 공유한다.
<br>
<br>UML을 이용한 다이어그램 중 다음 그림에 해당하는 다이어그램을 쓰시오.
<br>[ ] &lt;&lt;import&gt;&gt; [Security]
Order ----------------&gt; +(Credentials) / ( ) +(MDSCrupt)
<br>
<br>LOC기법에 의하여 예측된 총 라인 수가 30,000라인, 개발에 참여할 프로그래머가 5명, 프로그래머들의 평균 생산성이 월간 300라인일 때 개발에 소요되는 기간을 계산식과 함께 쓰시오.
<br>
<br>데이터베이스 스키마(Schema)에 대해 간략히 서술하시오.
<br>
스키마는 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 것이다.
<br>
<br>DB 설계에 대한 설명. 괄호를 채우시오
<br>( 1 ) : 논리적 구조로 표현된 데이터를 디스크 등의 저장장치에 저장할 수 있는 데이터로 변환하는 과정으로, 파일의 저장 구조 및 엑세스 경로를 결정하며, 테이블 정의서 및 명세서가 산출된다.
<br>( 2 ) : 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정으로, 개념 스키마 모델링과 트렌젝션 모델링을 수행하며, 요구 조건 명세를 E-R 다이어그램으로 작성한다.
<br>( 3 ) : 현실의 자료를 특정 DBMS가 지원하는 자료구조로 변환하는 과정으로, 트렌젝션의 인터페이스를 설계하고, 정규화를 통해 스키마를 평가 및 정제한다.
<br>
<br>다음은 데이터베이스 구축까지의 과정을 나열한 것이다. 순서대로 괄호를 채우시오. 요구분석 → ( ) → ( ) → ( ) → 구현 <br>
<br>데이터 모델이 구성 요소에 대한 다음 설명에서 괄호(1, 2)에 들어갈 용어를 쓰시오
<br>( 1 )은 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세서로서 데이터베이스를 조작하는 기본 도구에 해당된다.
<br>( 2 )는 논리적으로 표현된 객체 타입들 간의 관계로서 데이터의 구성 및 정적 성질을 표현한다.
<br>제약조건은 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건을 의미한다.
<br><img alt="do-messenger_screenshot_2025-02-10_15_04_45.png" src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-02-10_15_04_45.png" target="_self"><br>
-다음 E-R다이어그램을 참고하여 괄호(1~5)의 설명에 적합한 요소를 찾아 기호로 표시<br>( 1 ) : 관계 집합을 의미한다.
<br>( 2 ) : 관계 집합과 속성을 연결한다.
<br>( 3 ) : 개체 집합을 의미하며, 키로 사용되는 항목에는 밑줄을 표시한다.
<br>( 4 ) : 관계 집합의 속성을 의미한다.
<br>( 5 ) : 개체 집합과 집합을 연결한다.
<br>
1 → ㄴ<br>
2 → ㄷ<br>
3 → ㄱ<br>
4 → ㄹ<br>
5 → ㅁ
<br>-키(Key)에 대한 다음 설명에서 괄호(1, 2)에 들어갈 용어를 쓰시오.<br>키는 데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 기준이 되는 속성을 말한다.
<br>슈퍼키는 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키로, 릴레이션을 구성하는 모든 튜플에 대해 ( 1 )을 만족한다.
<br>후보키(Candidate Key)는 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해 사용되는 속성들의 부분집합으로, ( 1 )과 ( 2 )을 만족하는 특징이 있다.
<br>
<br>
관계대수란 관계형 데이터베이스에서 원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절차적인 언어이다. 관계 대수에 사용되는 연산은 다음과 같다. <br>
합집합(UNION)은 두 릴레이션에 존재하는 튜플의 합집합을 구하되, 결과로 생성된 릴레이션에서 중복되는 튜플은 제되는 연산으로, 기호는 ( 1 )이다. <br>
차집합(DIFFERENCCE)은 두 릴레이션에 존재하는 튜플의 차집합을 구하는 연산으로, 사용하는 기호는 ( 2 )이다. <br>
교차곱(CARTESIAN PRODUCT)은 두 릴레이션에 있는 튜플들의 순서쌍을 구하는 연산으로, 사용하는 기호는 ( 3 )이다. <br>
프로젝트(PROJECT)는 주어진 릴레이션에서 속성 리스트(Attribute List)에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 연산으로, 사용하는 기호는 ( 4 )이다. <br>
조인(JOIN)은 공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산으로, 사용하는 기호는 ( 5 )이다. <br>
1 → U<br>
2 → ㅡ<br>
3 → x<br>
4 → ㅠ<br>
5 → |&gt;&lt;|
<br>
<br>릴레이션 A, B가 있을 때, 릴레이션 B의조건에 맞는 것들만 릴레이션 A에서 분리하여 프로젝션을 하는 연산은?
<br>
<br>( )은 관계 데이터의 연산을 표현하는 방법으로, 관계 데이터 모델의 제안자인 코드(E. F. Codd)가 수학의 술어 해석(Predicate Calculus)에 기반을 두고 관계 데이터베이스를 위해 제안했다.
<br>원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성을 지니며, 원하는 정보를 정의할 때 계산 수식을 사용한다.
<br>튜플 해석식을 사용하는 튜플 ( )과 도메인 해석식을 사용하는 도메인 ( )으로 구분된다.
<br>
<br>데이터의 중복으로 인해 테이블 조작 시 문제가 발생하는 현상을 이상(Anomaly)이라고 한다. 이상 중 삭제 이상(Deletion Anomaly)에 대해 간략히 서술하시오.
<br>
테이블에서 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는 현상.
<br>
<br>데이터베이스의 이상(Anomaly)의 종류 3가지를 쓰시오.
<br>
삽입 이상(Insertion Anomaly)<br>
삭제 이상(Deletion Anomaly)<br>
갱신 이상(Update Anomaly)
<br><img alt="do-messenger_screenshot_2025-02-10_17_10_58.png" src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-02-10_17_10_58.png" target="_self"><br>테이블 &lt;R&gt;에서 성적은 기본키인 {학생, 학과}에 대해 ( 1 ) Functional Dependency이다.
<br>테이블 &lt;R&gt;에서 학년은 기본키인 {학생, 학과} 중 학생만으로 식별이 가능하므로 기본키에 대해 ( 2 ) Functional Dependency이다.
<br>임이의 테이블에 속성 A, B, C가 있을 떄, A → B이고 B → C일 때 A → C인 관계는 ( 3 )Functional Dependency이다.
<br> <br>Full - 완전 함수 종속
<br>Partial - 부분 함수 종속
<br>Transitive - 이행적 함수 종속 <br>
<br>데이터베이스에서 비(반)정규화(Denormalization)의 개념을 서술하시오.
<br>
비정규화는 정규화된 데이터 모델을 통합, 중복, 분리 하는 과정으로, 의도적으로 정규화 원칙을 위배하는 행위이다.
<br>
<br>데이터베이스의 상태 변화를 일으키는 트렌젝션(Transaction)의 특성
<br> <br>원자성 : <br>트렌젝션의 연산은 데이터베이스에 모두 반영되도록 완료(Commit)되든지 아니면 전혀 반영되지 않도록 복구(Rollback)되어야 한다. <br>일관성 : <br>트렌젝션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다. <br>독립성 : <br>둘 이상의 트렌젝션이 동시에 병행 실행되는 경우 어느 하나의 트렌젝션 실행중에 다른 트렌젝션의 연산이 끼어들 수 없다. <br>지속성 <br>성공적으로 완료된 트렌젝션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다. <br>
<br>파일의 구조는 파일을 구성하는 레코드들이 보조기억장치에 편성되는 방식을 의미하는 것으로, 크게 순차, ( ), 해싱으로 구분한다.
<br>( ) 파일 구조는 &lt;값, 주소&gt; 쌍으로 구성되는 데이터 구조를 활용하여 데이터에 접근하는 방식으로, 자기 디스크서 주로 활용된다.
<br>
<br>비상 상황이 발생한 경우 비상사태 또는 업무중단 시점부터 업무가 복구되어 다시 정상 가동 될 때까지의 시간을 의미한다.
<br>
<br>접근통제는 데이터가 저장된 객체와 이를 사용하려는 주체 사이의 정보 흐름을 제한하는 것이다. 이러한 접근통제에 관한 기술 중 ( )는 데이터에 접근하는 사용자의 신원에 따라 접근 권한을 부여하여 제어하는 방식으로, 데이터의 소유자가 접근통제 권한을 지정하고 제어한다.
<br>객체를 생성한 사용자가 생성된 객체에 대한 모든 권한을 부여받고, 부여된 권한을 다른 사용자에게 허가할 수도 있다.
<br>
<br>DBMS는 데이터베이스에 치명적인 손실이 발생했을 때 이를 복구하기 위해 데이터베이스의 처리내용이나 이용 상황 등 상태 변화를 시간의 흐름에 따라 기록한 로그를 생성한다.
<br>( 1 ) : 데이터베이스가 비정상적으로 종료되었을 때, 디스크에 저장된 로그를 분석하여 트렌젝션의 시작(start)과 완료(commit)에 대한 기록이 있는 트렌젝션들의 작업을 재작업 한다. 즉, 로그를 이용하여 해당 데이터 항목에 대해 이전 값을 이후값으로 변경하는 연산이다.
<br>( 2 ) : 데이터베이스가 비정상적으로 종료되었을 때, 디스크에 저장된 로그를 분석하여 트렌젝션의 시작을 나타는 'start'는 있지만 완료를 나타내는 'commit' 기록이 없는 트렌젝션들이 작업한 내용들을 모두 취소한다. 즉 로그를 이용하여 해당 데이터 항목에 대해 이후 값을 이전 값으로 변경한다.
<br>
<br>웹 페이지의 기본 형식인 HTML의 문법이 각 웹 브라우저에서 상호 호환적이지 못한다는 문제와 SGML의 복잡함을 해결하기 위하여 개발된 ( )은 다른 특수한 목적을 갖는 마크업 언어이다.
<br>원활한 데이터의 연계를 위해 송.수신 시스템 간에 전송되는 데이터가 동일한 구조로 구성될 수 있도록 형태를 정의는 역할을 수행하며, 다음과 같은 특징이 있다.
<br>
<br>텍스트 데이터 형식으로 유니코드를 사용하여 전 세계 언어를 지원한다.
<br>
<br>대다수의 웹 브라우저가 해석을 위한 번역기(Parser)를 내장하고 있다.
<br>
<br>XML문서의 문자들은 마크업과 내용으로 구분된다.
<br>일반적으로 마크업은 &lt;로 시작하여 &gt;로 끝나는 태그(Tag)를 의미하고, 그 외의 문자열은 내용에 해당한다.
<br>
<br>마크업과 내용으로 이루어지는 하나의 요소를 의미한다.
<br>
<br>통합 구현과 관련하여 다음 설명의 괄호에 공통으로 들어갈 알맞은 용어는?
<br>( )는 HTTP, HTTPS, SMTP 등을 사용하여 xml 기반의 메시지를 네트워크상에서 교환하는 프로토콜이다.
<br>( ) envelope, 헤더, 바디 등이 추가된 xml 문서이다.
<br>( )는 복잡하고 무거운 구조로 구성되어 있어, ( )보다는 RESTful 프로토콜을 이용하기도 한다.
<br>
<br>웹 서비스와 관련된 다음 설명에 해당되는 용어는?
<br>웹 서비스와 관련된 서식이나 프로토콜 등을 표준적인 방법으로 기술하고 게시하기 위한 언어.
<br>XML로 작성되며 UDDI의 기초가 된다. SOAP, XML 스키마와 결합하여 인터넷에서 웹 서비스를 제공하기 위해 사용되며, 클라이언트는 이것을 통해 서버에서 어떠한 조작이 가능한지를 파악할 수 있다.
<br>Tip!
XML에서 언어이면 WSDL / 프로토콜이면 SOAP
<br>다음 럼바우 데이터 모델링에 대한 설명에서 각 지문(1~3)에 해당하는 모델링을 매칭시키기<br>ㄱ. 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링<br>
ex) 자료흐름도(DFD)<br>ㄴ. 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링<br>
ex) 상태 변화도(STD), 사건 추적도<br>ㄷ. 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 표시하는 모델링<br>
ex) ER 다이어그램(ERD)<br>
1 → Function(기능)<br>
2 → Dynamic(동적)<br>
3 → Information(객체) <br>
<br>자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다는 객체지향 설계 원칙 중 하나다.
<br>예를 들어 프린터, 펙스, 복사 기능을 가진 복합기의 경우 3가지 기능을 모두 가지 범용 인터페이스보다는, 프린터 인터페이스, 팩스 인터페이스, 복사 인터페이스로 분리함으로써 하나의 기능 변경으로 인해 다른기능이 영향을 받지 않도록 해야한다.
<br>
<br>결합도(Coupling)의 종류 중 단순 처리 대상인 데이터만 전달되는 것이 아니라, 어떻게 처리해야 하는지를 결정하는 제어 요소가 전달되는 경우의 결합도를 영문으로 쓰면?
<br>
<br>( 1 )는 모듈간의 인터페이스로, 데이터,지역변수 등을 직접 참조하거나 수정할 때의 결합도다.
<br>( 2 )는 모듈간의 인터페이스로, 배열이나 레코드 등의 자료구조가 전달될 때의 결합도다.
<br>( 3 )는 모듈간의 인터페이스로, 파라미터가 아닌 모듈 밖에 선언된 전역 변수를 사용하여 전역 변수를 갱신하는 방식으로 상호작용하는 때의 결합도다.
<br>
1 → 내용 결합도<br>
2 → 스탬프 결합도<br>
3 → 공통 결합도
<br>
<br>내부의 요소들이 기능적으로 연관성은 없으나, 순차적으로 실행될 때의 응집도 <br>서로 다른 기능을 수행하지만 동일한 입력과 출력을 사용할 때의 응집도 <br>하나의 기능에 밀접하게 관련되어 있거나 연관되어 있을 때의 응집도 <br>우연적 응집도 &lt; 논리적 응집도 &lt; 시간적 응집도 &lt; 절차적 응집도 &lt; 통신적 응집도 &lt; 순차적 응집도 &lt; 기능적 응집도<br>기능적 응집도(Functional Cohesion) <br>모듈 내부의 모든 기능이 단일한 목적을 위해 수행되는 경우 <br>순차적 응집도(Sequential Cohesion) <br>모듈 내의 한 활동으로부터 나온 출력값을 모듈 내의 다른 활동이 사용할 경우 <br>교환적 응집도(Communicational Cohesion) <br>서로 다른 기능을 수행하지만 동일한 입력과 출력을 사용하는 활동들이 모여있을 경우 <br>절차적 응집도(Procedural Cohesion) <br>모듈 안의 구성요소들이 서로 다른 기능을 하지만 그 기능을 순차적으로 수행할 경우 <br>시간적 응집도(Temporal Cohesion) <br>연관된 기능이라기 보단 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리할 경우 <br>논리적 응집도(Logical Cohesion) <br>실제와 달리 논리적으로만 같은 그룹으로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우 <br>우연적 응집도(Coincidental Cohesion) <br>모듈 내부의 각 구성요소들이 연관이 없을 경우 <br>
1 → 절차적 응집도<br>
2 → 교환적 응집도<br>
3 → 기능적 응집도
<br>
<br>모듈간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합이다.
<br>복수의 프로세스를 수행하며 이뤄지는 프로세스 간 통신까지 구현이 가능하다.
<br>대표적인 메소드에는 공뮤 메모리(Shared Memory), 소켓, 세마포어, 파이프와 네임드 파이프, 메세지 큐잉이 있다.
<br>IPC(Inter-Process Communication)<br>
<br>( )패턴은 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴이다.
<br>상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당한다.
<br>다른 이름으로는 가상 생성자(Virtual Constructor) 패턴 이라고도 한다.
<br>Factory Method 패턴<br>
<br>( 1 )패턴은 구현부에서 추상층을 분리하여, 서로가 독립적으로 확장할 수 있도록 구성한 패턴으로, 기능과 구현을 두 개의 별도 클래스로 구현한다는 특징이 있다.
<br>( 2 )패턴은 한 객체의 상태가 변화하면 객체의 상속된 다른 객체들에게 변화된 상태를 전달하는 패턴으로, 일대다의 의존성을 정의한다. 주로 시스템 간에 이벤트를 생성.발행(Publish)하고, 이를 수신(Subscribe)해야할 떄 이용된다.
<br>
1 → Bridge 패턴<br>
2 → Observer 패턴
<br>
<br>디자인 패턴은 모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예젤를 의미한다. <br>그 중 ( )패턴은 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴으로, Interpreter, Observer, Command 등이 그 예에 해당한다.
<br>디자인 패턴(Design Patterns) : GoF(생 구 행) <br>&nbsp; 1.&nbsp;생성(Creational) : 객체 생성 과정 캡슐화(싱 팩 추 빌 프)<br>
-싱글톤(Singleton) : 1객체<br>
-팩토리 메서드(Factory Method) : 책임 위임<br>
-추상 팩토리(Abstract Factory) : 여러 객체그룹 생성<br>
-빌더(Builder) : 생성 단계 캡슐화<br>
-프로토타입(Prototype) : 원본 객체 복사<br>&nbsp; 2.&nbsp;구조(Structural) : 클래스 객체 조합(어 데 퍼 프 브 컴 플)<br>
-어댑터(Adapter) : 클래스 연결<br>
-데코레이터(decorator) : 소스 변경X, 기능확장<br>
-퍼사드(Facade) : 단순화된 1인터페이스 제공<br>
-프록시(Proxy) : 원 객체작업 대신처리 / 대리<br>
-브릿지(Bridge) : 구현부 추상층 분리, 독립적 확장, 결합도 낮춤<br>
-컴포지트(Composite) : 개별 객체와 복합 객체를 동일 / 트리<br>
-플라이웨이트(Flyweight) : 공유<br>&nbsp; 3.&nbsp;행동(Behavioral) : 상호작용, 역할분담(옵 스 커 템 스 메 중 인 방 책 이)<br>
-옵저버(Observer) : 다른객체 알림 및 자동갱신<br>
-스트래티지(Strategy) : 알고리즘 캡슐화<br>
-커맨드(Command) : 요청을 객체로 캡슐화<br>
-템플릿 메서드(Template Method) : 구조 - 상위 / 구현 - 하위<br>
-스테이트(State) : 객체 상태에 따라 다른 행동 / 다형성<br>
-메멘토(Memento) : 객체상태 미리 저장 후 복구<br>
-중재자(Mediator) : 객체간 상호작용 조정<br>
-인터프리터(Interpreter) : 문법 정의 및 구문 해석<br>
-방문자(Visitor) : 객체 구조 및 처리기능 분리 / 캡슐화 위배<br>
-책임 연쇄(Chain of Responsibility) : 객체간 연결고리 / 연속적<br>
-이터레이터(Iterator) : 순차적 접근 / 반복 캡슐 / Cursor<br>&nbsp;&nbsp;&nbsp; <br>행위(Behavioral)<br>
<br>기업 내 각종 어플리케이션 및 플랫폼 간의 정보 전달, 연계, 통합 등 상호 연동이 가능하게 해주는 솔루션.
<br>Point-to-Point, Hub&amp;Spoke, Message Bus, Hybrid 등의 다양한 방식으로 구축이 가능한 모듈 연계 방법.
<br>EAI(Enterprise Application Integration)<br><img alt="do-messenger_screenshot_2025-02-11_13_47_16.png" src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-02-11_13_47_16.png" style="width: 900px; max-width: 100%;" target="_self"><br>EAI(Enterprise Application Integration)는 기업 내 비즈니스 간 통합 및 연계성을 증대시켜 효율성 및 각 시스템 간의 확정성(Determinacy)을 높여 준다. EAI의 구축 유형은 위와 같다.
<br>
1 → Point-to-Point<br>
2 → Hub &amp; Spoke
<br>
<br>네트워크 트래픽에 대해 IP(Internet Protocol) 계층에서 IP패킷 단위의 데이터 변조 및 은닉 기능을 제공하는 네트워크 계층에서의 보안 통신 규약을 쓰시오.
<br>IPSec(Internet Protocol Security)<br>
<br>Kent Beck과 Erich Gamma 등이 개발한 자바 프로그래밍 언어용 유닛 테스트 프레임워크.
<br>xUnit계열의 한 종류이다. 같은 테스트 코드를 여러 번 작성하지 않게 도와주며, 테스트마다 예상 결과를 기억 할 필요가 없는 자동화된 해법을 제공한다.
<br>JUnit<br>
<br>사용자 인터페이스 UI(User Interface)의 설계 원칙
<br>
직관성 : 누구나 쉽게 이해하고 사용할 수 있어야 한다<br>
유효성 : 사용자의 목적을 정확하고 완벽하게 달성해야 한다<br>
학습성 : 누구나 쉽게 배우고 익힐 수 있어야 한다<br>
유연성 : 사용자의 요구사항을 최대한 수용하고 실수를 최소화해야 한다
<br>
<br>애플리케이션 테스트에서 사용되는 살충제 패러독스(Pesticide Paradox)의 개념을 간략히 설명
<br> <br>살충제 패러독스는 동일한 테스트 케이스로 동일한 테스트를 반복하면 더 이상 결함이 발견되지 않는 현상을 의미한다. <br>
<br>테스트에 대한 다음 설명에서 각 (1~3)에 해당되는 커버리지(기준)을 찾으시오.
<br>최소 한번은 모든 문장이 수행되도록 구성하는 검증 기준
<br>조건식이 참 / 거짓일 때 수행되도록 구성하는 검증 기준
<br>2번과 달리 조건식에 상관없이 개별 조건이 참 / 거짓일 때 수행되도록 구성하는 검증기준
<br>
1 → 구문(문장) 커버리지<br>
2 → 결정(분기) 커버리지<br>
3 → 조건 커버리지
<br>
<br>소프트웨어가 수행할 특정 기능을 알기 위해서 각 기능이 완전히 작동되는 것을 입증하는 테스트.
<br>동치 클래스 분해 및 경계값 분석을 이용하는 테스트 기법이다.
<br><img alt="do-messenger_screenshot_2025-02-11_15_32_34.png" src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-02-11_15_32_34.png" target="_self"><br>다음 중 블랙박스 테스트에 속하는 녀석들은?
<br>
경계값 분석(Boundary Value Analysis)<br>
입력값의 경계 부분(최소, 최대값 등)에서 오류가 발생할 가능성이 높다는 점을 이용하여 테스트하는 기법<br>
동등(동치) 분할(Equivalence Partitioning)<br>
입력값을 유사한 동작을 하는 그룹으로 나누고 각 그룹에서 대표값을 선택해 테스트하는 기법<br>
원인-결과 그래프(Cause-Effect Graph)<br>
그래프를 활용하여 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한 다음 효용성이 높은 테스트 케이스를 선정하여 검사하는 기법
<br>
<br>테스트 기법 중 다음과 같이 평가 점수표를 미리 정해 놓은 후 각 영역에 해당하는 입력 값을 넣고, 예상되는 출력값이 나오는지 실제 값과 비교하는 명세 기밥 테스트 기법을 쓰시오.
<br><img alt="do-messenger_screenshot_2025-02-11_16_31_10.png" src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-02-11_16_31_10.png" style="width: 1025px; max-width: 100%;" target="_self"><br>개발 단계에 따른 애플리케이션 테스트에 대한 다음 V-모델에서 (1~4)에 들어갈 알맞은 테스트를 작성하시오.
<br>
1 → 단위 테스트(Unit Test)<br>
- 코딩 직후 소프트웨어 설계의 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 수행하는 테스트<br>
2 → 통합 테스트(Integration Test)<br>
- 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트<br>
3 → 시스템 테스트(System Test)<br>
4 → 인수 테스트(Acceptance Test)
<br>
<br>인수 테스트는 개발한 소프트웨어가 사용자의 요구사항을 충족하는지에 중점을 두고 테스트한다.
<br>( 1 ) : 선정된 최종 사용자가 여러 명의 사용자 앞에서 행하는 테스트 기법으로, 실제 업무를 가지고 사용자가 직접 테스트한다.
<br>( 2 ) : 개발자의 장소에서 사용자가 개발자 앞에서 행하는 테스트 기법으로, 테스트는 통제된 환경에서 행해지며, 오류와 사용상의 문제점을 사용자와 개발자가 함께 확인하면서 기록한다.
<br>
1 → 베타 테스트(Beta Test)<br>
2 → 알파 테스트(Alpha Test)
<br>
<br>통합 테스트 기법 중, 두 방법에 대한 설명이다.
<br>상향식 통합 테스트는 미완성이거나 문제가 있는 상위 모듈을 대체할 수 있는 테스트 드라이버가 있다.
<br>하향식 통합 테스트는 미완성이거나 문제가 있는 하위 모듈을 대체할 수 있는 테스트 ( )가 있어야 한다.
<br>
<br>통합 테스트로 인해 변경된 모듈이나 컴포넌트에 새로운 오류가 있는지 확인하는 테스트.
<br>이미 테스트된 프로그램의 테스팅을 반복하는 것이다.
<br>수정한 모듈이나 컴포넌트가 다른 부분에 영향을 미치는지, 오류가 생기지 않았는지 테스트하여 새로운 오류가 발생하지 않음을 보증하기 위해 반복 테스트한다.
<br>
<br>특정한 몇몇 테스트 케이스의 입력 값들에 대해서만 기대하는 결과를 제공하는 오라클로, 전수 테스트가 불가능한 경우 사용하고, 경계값 및 구간별 예상값 결과 작성시 사용하는 오라클은?
<br>
<br>애플리케이션 성능 측정의 지표에 대한 다음 설명을 채우십시오<br>
( 1 ) - 일정 시간 내에 애플리케이션이 처리하는 일의 양을 의미한다.<br>
( 2 ) - 애플리케이션에 요청을 전달한 시간부터 응답이 도착할 때까지 걸린 시간을 의미한다.<br>
( 3 ) - 애플리케이션에 작업을 의뢰한 시간부터 처리가 완료될 떄까지 걸린 시간을 의미한다.<br>
자원 활용률 - 애플리케이션이 의뢰한 작업을 처리하는 동안의 CPU, 메모리, 네트워크 등의 자원 사용률을 의미.
<br>
1 → 처리량(Throughput)<br>
2 → 응답 시간(Response Time)<br>
3 → 경과 시간(Turn Around Time)
<br>
<br>소스 코드의 코딩 스타일, 코드에 설정된 코딩 표준, 코드의 복잡도, 코드에 존재하는 메모리 누수 현상, 스레드 결함 등을 발견하기 위해 사용하는 분석 도구이다.
<br>각각 소스코드 품질 분석에 대한 정의를 작성하세요.
<br>
<br>작성한 소스 코드를 실행하지 않고, 코딩 표준이나 코딩 스타일, 결함 등을 확인하는 코드 분석 도구.
<br>
<br>소스 코드를 직접 실행하여 프로그램의 동작이나 반응을 추적하고 보고하는 분석 도구로, 프로그램 모니터링 기능이나 스냅샷 생성 기능을 포함하고 있다.
<br>
<br>데이터를 제어하는 DCL의 하나인 GRANT의 기능에 대해 간략히 서술하시오.
<br>
GRANT는 데이터베이스 관리자가 데이터베이스 사용자에게 권한을 부여하는 데 사용하는 명령어 이다.
<br>
<br>데이터를 제어하는 DCL의 하나인 ROLLBACK에 대해 간략히 서술하시오.
<br>
ROLLBACK은 트렌젝션이 실패한 경우 작업을 취소하고 이전 상태로 되돌리기 위한 명령어이다.
<br>
<br>데이터베이스 보안에서 가용성(Availability)에 대해 간략히 서술하시오.
<br>
자산이 적절한 시간에 인가된 당사자에게 접근 가능 해야 하는 것.<br>
위협요소 - Dos/DDoS 공격 등
<br>추가
기밀성 - 자산이 인가된 당사자에 의해서만 접근하는 것을 보장하는 것.<br>
무결성 - 자산이 인가된 당사자에 의해서, 인가된 방법으로만 변경 가능한것.
<br>
<br>보안 위협의 하나인 SQL Injection에 대해 간략히 서술하시오.
<br>
SQL Injection은 웹 응용 프로그램에 SQL 구문을 삽입하여 내부 DB서버의 데이터를 유출 및 변조하고 관리자 인증을 우회하는 공격 기법이다.
<br>
<br>
다음은 암호화 알고리즘에 대한 설명이다. 괄호를 채우시오. <br>
암호화 알고리즘은 패스워드, 주민번호, 은행계좌와 같은 중요 정보를 보호하기 위해 평문을 암호화된 문장으 만드는 절차 또는 방법을 말한다. <br>
스위스의 라이(Lai)와 메시(Messey)는 1990년 PES를 발표하고, 이후 이를 개선한 IPES를 발표하였다. IPES는 128비트의 Key를 사용하여 64비트 블록을 암호화하는 알고리즘이며 현재는 ( 1 )라고 불린다. <br>
( 2 )은 국가 안전 보장국(NSA)에서 개발한 암호화 알고리즘으로, 클리퍼 칩(Clipper Chip)이라는 IC 칩에 내장되어 있다. 80비트의 Key를 사용하여 64비트 블록을 암호화하며, 주로 전화기와 같은 음성 통신 장비에 삽입되어 음성 데이터를 암호화 한다. <br>
전화기와 같은 음성을 암호화하는데 주로 사용된다. <br>
1 → IDEA(Internetional Data Encryption Algorithm)<br>
2 → Skipjack(가다랑어)
<br>
<br>무선랜 보안에 사용된 WEP 방식을 보완한 데이터 보안 프로토콜로, 임시 키 무결성 프로토콜이라도 한다.
<br>WEP의 취약성을 보완하기 위해 암호 알고리즘의 입력 키 길이를 128비트로 늘리고 패킷당 키할당, 키값 재설정 등 키 관리 방식을 개선하였다.
<br>
<br>1974년 IBM이 개발하고, 1975년 NBS에 의해 미국의 국가 표준으로 발표된 암호화 알고리즘
<br>블록 크기는 64비트, 키 길이는 56비트이며, 16회의 라운드를 수행한다.
<br>컴퓨터 기술이 발달함에 따라 해독이 쉬워지면서 미국의 국가 표준이 2001년 AES로 대체되었다.
<br>
<br>2001년 미국 표준 기술 연구소(NIST)에서 발표한 대칭키 암호화 알고리즘이다.
<br>DES의 한계를 느낀 NIST에서 공모한 후 발표하였다.
<br>블록 크기는 128비트이며, 키 길이에 따라 128, 192, 256으로 분류된다.
<br>
<br>1991년 R.ricest가 MD4를 개선한 암호화 알고리즘으로, 각각의 512비트짜리 입력 메세지 블록에 대해 차례동작한다.
<br>각 512비트 입력 메시지 블록을 처리하고 나면 128비트 스테이트(stat)의 값이 변하는 암호화 알고리즘이다.
<br>
<br>( ) 스푸핑은 로컬 네트워크(LAN)에서 사용하는 ( )프로토콜의 취약점을 이용한 공격 기법으로, 자신의 물리적 주소(MAC)를 변조하여 다른 PC에게 도달해야 하는 데이터 패킷을 가로채거나 방해한다.
<br>이 공격은 데이터 링크 상의 프로토콜인 ( )를 이용하기 때문에 근거리상의 통신에서만 사용할 수 있는 공격이다.
<br>
<br>아래의 패킷 로그와 같이, 공격자가 패킷의 출발지 주소(Address) 또는 포트를 임의로 변경하여 송신측 IP주소 또는 포트를 동일하게 함으로써, 송신 IP주소가 자신이므로 자신에게 응답을 수행하게 된다.
<br>자신에 대해 무한히 응답하는 패킷을 계속 전송하여 컴퓨터의 실행 속도를 느리게 하거나 동작을 마비 시켜 서비스 거부 상태에 빠지도록 하는 네워크 공격 유형은?
<br>#### source : 192.168.1.200
#### destination : 192.168.1.200
#### protocol : 6
#### src port : 21845
#### dst port : 21845
<br>
<br>( 1 )은 컴퓨터 보안에 있어서, 인간 상호 작용(사회)의 깊은 신뢰를 바탕으로 사람들을 속여 정상 보안 절차를 깨트리기 위한 비기술적 시스템 침입 수단을 의미한다.
<br>( 2 )는 특정 목적을 가지고 데이터를 수집하였으나, 이후 활용되지 않고 저장만 되어있는 대량의 데이터를 의미한다. 미래에 사용될 가능성을 고려하여 저장 공간에서 삭제되지 않고 보관되어 있으나, 이는 저장 공간의 낭비뿐만 아니라 보안 위험을 초래할 수도 있다.
<br>
1 → 사회 공학(Social Engineering)<br>
2 → 다크 데이터(Dark Data)
<br>
<br>( )은 ‘세션을 가로채다’라는 의미로, 정상적인 연결을 RST패킷을 통해 종료시킨 후 재연결 시 희생자가 아닌 공격자에게 연결하는 공격 기법이다.
<br>TCP ( )은 공격자가 TCP 3-Way-Handshake과정에 끼어듦으로써 서버와 상호 간의 동기화된 시퀀스 번호를 갖고 인가되지 않은 시스템의 기능을 이용하거나 중요한 정보에 접근할 수 있게 된다.
<br>
<br>목표 조직이 자주 방문하는 웹 사이트를 사전에 감염시켜(웅덩이), 목표 조직의 일원이 웹 사이트에 방문했을 때 악성 코드에 감연되게 한다.
<br>이후에는 감염된 PC를 기반으로 조직의 중요 시스템에 접근하거나 불능으로 만드는 등의 영향력을 행사하는 웹 기반 공격이다.
<br>
<br>AAA서버는 사용자의 컴퓨터 자원 접근 처리와 서비스 제공에 있어서의 다음 3가지 기능을 제공하는 서버이다.
<br>접근하는 사용자의 신원을 검증하는 기능
<br>신원이 검증된 사용자에게 특정된 권한과 서비스를 허용하는 기능
<br>사용자가 어떤 종류의 서비스를 이용했고, 얼마만큼의 자원을 사용했는지 기록 및 보관하는 기능
<br>각각 무엇인지 ?
<br>
1 → Authentication - 검증<br>
2 → Authorization - 권한 부여<br>
3 → Accounting - 기록
<br>
<br>다양한 장비에서 발생하는 로그 및 보안 이벤트를 통합하여 관리하는 보안 솔루션으로, 방화벽, IDS, IPS, 웹 방화벽, VPN 등에서 발생한 로그 및 보안 이벤트를 통합하여 관리함으로써 비용 및 자원을 절약할 수 있는 특징이 있다.
<br>보안 솔루션 간의 상호 연동을 통해 종합적인 보안 관리 체계를 수립할 수 있다.
<br>머신러닝 기술을 이용하여 it시스템에서 발생하는 대량의 로그를 통합 관리한다.
<br>이상 징후 미리 감지
<br>
<br>헝가리안 표기법(Hungarian Notation)에 대해 간략히 서술.
<br>
헝가리안 표기법은 변수명 작성시 변수의 자료형을 알 수 있도록 자료형을 의미하는 문자를 포함하여 작성하는 방법.<br>
ex) bool bIsTrue / int nCnt
<br>
<br>스니핑(Sniffing)은 사전적 의미로 ‘코를 킁킁 거리다, 냄새를 맡다’이다. 네트워크 보안에서 스니핑에 대한 개념을 간략히 작성.
<br>
스니핑은 네트워크의 중간에서 남의 패킷 정보를 도청하는 해킹 유형의 하나로 수동적 공격에 해당한다.
<br>
<br>C++에서 생성자에 대해 간략히 서술하시오.
<br>
생성자는 객체 변수 생성에 사용되는 메소드로, 객체 변수를 생성하면서 초기화를 수행한다.
<br>
<br>1960년대 AT&amp;T 벨(Bell) 연구소가 MIT, GM사와 함께 공동 개발한 운영체제 이다.
<br>시분할 시스템(Time Sharing System)을 위해 설계된 대화식 운영체제 이다.
<br>대부분 c언어로 작성되어 있어 이식성이 높으며, 장치/프로세스 간의 호환성이 높다.
<br>트리 구조의 파일 시스템을 갖는다.
<br><img alt="do-messenger_screenshot_2025-02-12_14_04_58.png" src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-02-12_14_04_58.png" target="_self"><br>
1 → 준비(Ready)<br>
2 → 실행(Run)<br>
3 → 대기(Wait)
<br>
<br>HRN 비선점형 스케줄링 우선순위를 구하는 계삭식을 쓰시오.
<br>
<br>( 1 )는 준비상태 큐에서 기다리고 있는 프로세스들 중에서 실행시간이 가장 짧은 프로세스에게 먼저 CPU를 할당하는 기법이다. 가장 적은 평균 대기 시간을 제공하는 최적 알고리즘이지만, 실행 시간이 긴 프로세스는 실행 시간이 짧은 프로세스에게 할당 순위가 밀려 무한 연기 상태가 발생 될 수 있다.
<br>
<br>( 2 )은 시분할 시스템을 위해 고안된 방식으로, 준비상태 큐에 먼저 들어온 프로세스가 먼저 CPU를 할당받지만 각 프로세스는 시간 할당량 동안만 실행한 후 실행이 완료되지 않으면 다음 프로세스에게 CPU를 넘겨고 준비상태 큐의 가장 뒤로 배치된다. 할당되는 시간이 작을 경우 문맥 교환 및 오버헤드가 자주 발생되어 요청된 작업을 신속히 처리할 수 없다.
<br>
<br>( 3 )는 현재 실행중인 프로세스의 남은 시간과 준비상태 큐에 새로 도착한 프로세스의 실행시간을 비교하 가장 짧은 실행 시간을 요구하는 프로세스에게 CPU를 할당하는 기법으로, 시분할 시스템에 유용하다. 준비상태 큐에 있는 각 프로세스의 실행 시간을 추적하여 보유하고 있어야 하므로 오버헤드가 증가한다.
<br>
1 → SJF(Shortest Job First)<br>
2 → RR(Round Robin)<br>
3 → SRT(Shortest Remaining Time)
<br>
<br>리눅스 또는 유닉스에서 a.txt 파일에 대해 다음 처리 조건과 같이 권한을 부여하고자 한다.
<br>사용자에게 읽기,쓰기,실행 권한을 부여한다.
<br>그룹에게 읽기,실행 권한을 부여한다.
<br>기타 사용자에게 실행 권한을 부여한다.
<br>한 줄로 작성하고, 8진법 숫자를 이용한 명령문을 이용한다.
<br>
<br>192.168.1.0/24 네트워크를 FLSM 방식으로 3개의 Subnet으로 나누는 방법
<br>즉, 64개씩 호스트를 할당하면,<br>
<br>여분의 서브넷 = 192.168.1.192/26
<br>
<br>서브넷팅(Subnetting)에 대한 설명
<br>현재 IP주소가 192.168.1.132이고, 서브넷 마스크가 255.255.255.192 일 때, 네트워크 주소와 사용가능 호스트 개수는?
<br>
<br>A Class - 0~127 / 기본 서브넷 - 255.0.0.0 (/8)
<br>B Class - 128~191 / 기본 서브넷 - 255.255.0.0 (/16)
<br>C Class - 192~223 / 기본 서브넷 - 255.255.255.0 (/24)
<br>D Class - 224~239 / 기본 서브넷 - 멀티캐스트 전용 (서브넷 X)
<br>이 때, 네트워크 개수는 2^2(추가된 1의 개수) = 4개<br>호스트개수는 256 / 4(네트워크 개수) = 64개<br>즉, 이를 표로 나타내면 →<br>여기서 192.168.1.13 는 3번째 네트워크 주소에 속하므로,<br>
네트워크 주소는 192.168.1.128 이며, 사용 가능 호스트 주소는 네트워크와 브로드캐스트 주소를 뺀 64-2 <br>
<br>OSI 7 Layer에 대한 설명
<br>
물리적으로 연결된 두 개의 인접한 개방 시스템들 간에 신뢰성 있고 효율적인 정보 전송을 할 수 있도록 연결 설정, 데이터 전송, 오류 제어 등의 기능을 수행한다. <br>
개방 시스템들 간의 네트워크 연결을 관리하며, 경로 제어, 패킷 교환, 트래픽 제어 등의 기능을 수행한다. <br>
서로 다른 데이터 표현 형태를 갖는 시스템 간의 상호 접속을 위해 필요한 계층으로, 코드변환, 데이터 암호화, 데이터 압축, 구문 검색 등의 기능을 수행한다. <br>
다양한 전송매체를 통해 비트 스트림을 전송. 전송에 필요한 두 장치 간의 실제 접속과 절단 등 기계적, 전기적, 기능적, 절차적 특성에 대한 규칙을 정의한다. <br>
1 → 데이터 링크 계층(Data Link Layer)<br>
2 → 네트워크 계층(Network Layer)<br>
3 → 표현 계층(Presentation Layer)<br>
4 → 물리 계층(Physical Layer)
<br>
<br>심리학자 톰 마릴은 컴퓨터가 메시지를 전달하고, 메시지가 제대로 도착했는지 확인하며, 도착하지 않았을 경우 메시지를 재전송하는 일련의 방법을 ‘기술적 은어’를 뜻하는 ( )이라는 용어로 정의하였다.
<br>
<br>프로토콜은 서로다른 기기들 간의 데이터 교환을 원활하게 수행할 수 있도록 표준화 시켜놓은 통신 규약이다. 프로토콜의 기본요소 3가지를 쓰시오.
<br>
구문(Syntex)<br>
의미(Semantics)<br>
시간(Timing)
<br>
<br>( 1 ) : 연결형 통신에서 주로 사용되는 방식으로, 출발지와 목적지의 전송 경로를 미리 연결하여 논리적으로 고정한 후 통신하는 방식
<br>( 2 ) : 비연결형 통신에서 주로 사용되는 방식으로, 사전에 접속 절차를 수행하지 않고 헤더에 출발지에서 목적지까지의 경로 지정을 위한 충분한 정보를 붙여서 개별적으로 전달하는 방식
<br>
1 → 가상 회선(Virtual Circuit)<br>
2 → 데이터그램(Datagram)
<br>
<br>인터넷 환경에서의 호스트 상호 간 통신에서 연결된 네트워크 접속 장치의 물리적 주소인 MAC 주소를 이용하여 IP주소를 찾는 인터넷 계층의 프로토콜로, 역순 주소 결정 프로토콜이라 불린다.
<br>
RARP(Reverse Address Resolution protocol)
<br>
<br>( )는 한 번의 로그인으로 개인이 가입한 모든 사이트를 이용할 수 있게 해주는 시스템을 말한다.
<br>개인의 경우, 사이트에 접속하기 위하여 아이디와 패스워드는 물론 이름, 전화번호 등 개인정보를 각 사이트마다 일일이 기록해야 하던 것이 한 번의 작업으로 끝나므로 불편함이 해소되며, 기업에서는 회원에 대한 통합관리가 가능해 마케딩을 극대화시킬 수 있다는 장점이 있다.
<br>
SSO(Single Sign On)
<br>
<br>재난 및 군사 현장과 같이 별도의 고정된 유선망을 구축할 수 없는 장소에서 모바일 호스트만을 이용하여 구성한 네트워크.
<br>망을 구성한 후 단기간 사용되는 경우나 유선망을 구성하기 어려운 경우에 적합하다.
<br>멀티 홉 라우팅 기능을 지원한다.
<br>
애드 혹 네트워크(Ad-hoc Network)
<br>
<br>우리말로 번역하면 '네트워크 주소 변환'이라는 의미의 영문 3글자 약자이다.
<br>1개의 정식 IP 주소에 다량의 가상 사설 IP 주소를 할당 및 연결하는 방식이다.
<br>1개의 IP 주소를 사용해서 외부에 접속할 수 있는 노드는 어느 시점에서 1개만으로 제한되는 문제가 있으나, 이 때에는 IP 마스커레이드(Masquerade)를 이용하면 된다.
<br>
NAT(Network Address Translation)
<br>
<br>
정의<br>
웹상에 존재하는 데이터를 개별 URI로 식별하고, 각 URI에 링크 정보를 부여함으로써 상호 연결된 웹을 지향하는 모형이다.<br>
링크 기능이 강조된 시맨틱웹의 모형에 속한다고 볼 수 있으며, 팀 버너스 리의 W3C를 중심으로 발전하고있다. <br>
주요 기능 <br>공개된 데이터를 이용하면 내가 원하는 데이터가 이미 존재하는지, 어디에 존재하는지 알 수 있다.
<br>URI로 구별되는 데이터 리소스의 자유로운 접근 및 이용이 가능하므로 큰 노력 없이 데이터의 매쉬업이 가능하다.
<br>내가 만든 데이터가 아니라도 URI를 이용하여 링크만 해주면 이용할 수 있다. <br>
4대 원칙 <br>통합 자원 식별자(URI)를 사용한다,
<br>URI는 HTTP 프로토콜을 통해 접근할 수 있어야 한다.
<br>RDF나 스파클 같은 표준을 사용한다,
<br>풍부한 링크 정보가 있어야 한다. <br>
Linked Data와 Open Data를 결합한 용어이다. <br>
LOD(개방형 링크드 데이터)
<br>
<br>경로 제어 프로토콜은 크게 자율 시스템 내부의 라우팅에 사용되는 (①) 와 <br>자율 시스템 간의 라우팅에 사용되는 (②) 로 구분할 수 있다.
<br>설명 <br>(①) 는 소규모 동종 자율 시스템에서 효율적인 RIP와 대규모 자유 시스템에서 많이 사용되는 (③) 로 나누어진다.
<br>(③) 는 링크 상태(Link State)를 실시간으로 반영하여 최단 경로로 라우팅을 지원하는 특징이 있다.
<br>(④) 는 (②) 의 단점을 보완하여 만들어진 라우팅 프로토콜로, 처음 연결될 때는 전체 라우팅 테이블을 교환하고, 이후에는 변환된 정보만을 교환한다. <br>
<br>BGP
<br>AS
<br>HOP
<br>OSPF
<br>NAT
<br>ISP
<br>EGP
<br>IGP
<br> <br>IGP
<br>EGP
<br>OSPF
<br>BGP <br>
<br>P2P 네트워크를 이용하여 온라인 금융 거래 정보를 온라인 네트워크 참여자(Peer)의 디지털 장비에 분산 저장하는 기술은?
<br>
블록체인(Blockchain)
<br>
<br>정보 자산을 안전하게 보호하기 위한 보호 절차와 대책으로, 정보보호 관리 체계라고 한다.
<br>조직에 맞는 정보보호 정책을 수립하고, 위험에 상시 대응하는 여러 보안 대책을 통합 관리한다.
<br>공공 부문과 민간 기업 부문에서 이것을 평가하고 인증하는 사업을 한국인터넷진흥원(KISA)에서 운영중이다.
<br>
<br>( 1 )은 칩 설계 회사인 ARM에서 개발한 기술로, 하나의 프로세서 내에 일반 애플리케이션을 처리하는 일반 구역과, 보안이 필요한 애플리케이션을 처리하는 보안 구역으로 분할하여 관리하는 하드웨어 기반의 보안기술이다.
<br>( 2 )은 네티즌들이 사이트에 접속할 때 주소를 잘못 입력하거나 철자를 빠뜨리는 실수를 이용하기 위해 이와 유사한 유명 도메인을 미리 등록하는 것으로 URL하이재킹이라고도 한다. <br>
<br>Pharming
<br>Typosquatting
<br>Ransomware
<br>Tvishing
<br>Hacktivism
<br>CSRF
<br>Trustzone
<br>Watering Hole
<br>APT
<br>Smurfing
<br> <br>Trustzone
<br>Typosquatting <br>
<br>RAID(Redundant Array of Independent Disks)란 여러개의 하드디스크를 조합하여 성능 향상과 데이터 보호기능을 제공하는 기술이다.
<br> <br>RAID 0: 성능 최우선, 데이터 보호 없음.
<br>RAID 1: 데이터 안정성 높음, 저장 용량 절반 사용.
<br>RAID 5: 성능과 안정성 균형, 최소 3개 디스크 필요.
<br>RAID 6: RAID 5보다 높은 안정성, 최소 4개 디스크 필요.
<br>RAID 10: RAID 0과 RAID 1의 조합, 고성능과 고안정성 제공. <br>
<br>오픈 소스 기반 분산 컴퓨팅 플랫폼 이다.
<br>분산 저장된 데이터들은 클러스터 환경에서 병렬 처리된다.
<br>일반 PC급 컴퓨터들로 가상화된 대형 스토리지를 형성하고 그 안에 보관된 거대한 데이터 세트를 병렬로 처리할 수 있도록 개발되었다.
<br>더그 커팅과 마이크 캐퍼렐라가 개발했으며, 구글의 맵리듀스(MapReduce) 엔진을 사용하고 있다.
<br>
<br>데이터 마이닝(Data Mining)의 개념을 간략히 서술하시오.
<br>
데이터 마이닝은 대량의 데이터를 분석하여 데이터에 내재된 변수 사이의 상호관계를 규명하여 일정한 패턴을 찾아내는 기법이다.
<br>
<br>데이터베이스 회복(Recovery) 기법에 관련된 내용.
<br>( )은 트렌젝션이 데이터를 변경하면, 트렌젝션이 부분 완료되기 전이라도 즉시 실제 DB에 그 내용을 반영하는 기법.
<br>장애가 발생하여 회복 작업할 경우를 대비하여 갱신된 내용들을 로그에 보관시킨다.
<br>( )에서 회복 작업을 수행할 경우 Redo와 Undo 모두 수행이 가능하다.
<br>
즉각 갱신 기법(Immediate Update)
<br>
<br>데이터베이스 병행제어(Concurrency Control) 기법 중 하나로이다.
<br>접근한 데이터에 대한 연산을 모두 마칠 때 까지 추가적인 접근을 제한함으로써 상호 배타적으로 접근하여 작업을 수행하도록 하는 기법이다.
<br>
<br>
릴리즈 노트는 개발 과정에서 정리된 릴리즈 정보를 고객과 공유하기 위한 문서이다. <br>
릴리즈 노트는 정확하고 완전한 정보를 기반으로 개발팀에서 직접 현재 시제로 작성해야 한다. <br>
릴리즈 노트 작성시 노트 이름, 소프트웨어, 릴리즈 버전, 릴리즈 날짜, 릴리즈 노트 날짜, 버전 등이 포함되는 항목은? <br>
<br>소프트웨어 개발에서의 작업 중 형상 통제에 대해 간략히 서술하시오.
<br>
형상 통제는 식별된 형상 항목에 대한 변경 요구를 검토하여 현재의 기준선이 잘 반영될 수 있도록 조정하는 작업이다.
<br>
<br>소프트웨어 ( )는 소프트웨어 개발 단계의 각 과정에서 만들어지는 프로그램, 문서, 데이터등을 관리하는 것을 말한다.
<br>소프트웨어의 개발 과정에서 만들어지는 여러 버전들의 변경사항을 관리하는 일련의 활동이며 이를 지원하는 도구로 Git, SVN 등이 있다.
<br>
형상관리(SCM)
<br> 다음 설명하는 네트워크 공격 방법은?<br>ICMP, 송신 주소를 공격 대상의 IP 주소로 위장하고, 수신 주소를 해당 네트워크 라우터의 브로드캐스트 주소로 설정하는 공격으로 과부화 시키는 기법은? ICMP 패킷을 크게 만들어서 과부화 시키는 죽음의 핑과 같은 서비스 공격 유형이다.
<br>
스머핑(Smurfing)
<br>다음으로 알맞은 용어는?<br>인터넷을 통해 장치 간 사설 네트워크 연결을 생성하는 서비스로 장치의 실제 IP 주소를 가상 IP 주소로 대체하고, 데이터를 암호화하고, 데이터를 전 세계 보안 네트워크로 라우팅함으로써 정보를 보호하는 기법
<br>디바이스 간에 사설 네트워크 연결을 생성, 안전하게 익명으로 전송하는데 사용
<br>
VPN
<br>
<br>
코드 내의 각 분기점이 true 또는 false로 평가될 때마다 해당 분기점이 모두 테스트 되는 것을 목표로 한다. 각 분기점이 모든 가능한 경로로 실행되었는지 확인하는 데 사용되는 커버리지 ( ) <br>
코드의 흐름을 여러 갈래로 나누는 조건문 또는 선택문을 의미한다. 예를 들어, if-else 문이나 switch 문에서 조건에 따라 실행 경로가 달라질 때를 의미한다. ( ) <br>
개별 조건문 내에 있는 각각의 조건이 true와 false 모두를 만족하도록 테스트하는 것을 의미한다. 예를 들어, if (A &amp;&amp; B)와 같은 구문에서 A와 B가 각각 true와 false가 되는 경우를 테스트하는 것이 목표이다. ( ) <br>(보기)<br>
㉠ 조건/결정 커버리지<br>
㉡ 결정 커버리지<br>
㉢ 조건 커버리지<br>
㉣ 분기 커버리지<br>
㉤ 변경 조건/결정 커버리지<br>
㉥ 문장 커버리지<br>
㉧ 다중 조건 커버리지<br> <br>문장 / 2. 분기 / 3. 조건 <br>
<br>다음 라우터 A에서 라우터 F까지 경로를 설정하기 위해 RIP 방식을 사용한다고 할 때, 라우터가 지나가는 경로를 순서대로 쓰시오.(단, 간선 위의 숫자는 라우터 간의 거리를 의미한다.)<br>
<img alt="스크린샷 2025-04-14 오전 12.06.09.png" src="https://lts.kr/사진-및-문서/스크린샷-2025-04-14-오전-12.06.09.png" target="_self">
<br>RIP 는 최단 경로 탐색이다. (거리 벡터 라우팅 프로토콜)
<br>조건 1. 홉의 수가 최단이 되어야 한다. 그래서 C -&gt; E -&gt; F 로 가지 않고, C -&gt; F 로 간다.
<br>조건 2. 홉의 수가 같다면 비용을 최소로 한다.
<br>조건 3. 홉의 수가 15가 넘는다면 불가능으로 판단한다.
<br>
A -&gt; D -&gt; C -&gt; F
<br>
<br>대표적인 링크 상태 라우팅 프로토콜이다. 이것은 인터넷에서 연결된 링크의 상태를 감시하여 최적의 경로를 선택한다는것이다.
<br>단일 자율 시스템 내에서 라우팅 정보를 배포하는 데 사용되는 내부 게이트웨이 프로토콜이다.
<br>모든 대상에 도달하기 위한 최단 경로를 구축하고 계산하며 최단 경로는 Dijkstra 알고리즘을 사용하여 계산된다.
<br> &nbsp;아래 내용의 각각의 설명에 대한 답을 작성하시오.<br>(1) 조인에 참여하는 두 릴레이션의 속성 값을 비교하여 조건을 만족하는 튜플만 반환한다.<br>(2) 조건이 정확하게 '=' 등호로 일치하는 결과를 반환한다. <br>(3) ( (2) ) 조인에서 조인에 참여한 속성이 두 번 나오지 않도록 중복된 속성을 제거한 결과를 반환한다.<br>-조인에 참여하는 두 릴레이션의 속성 값을 비교하여 조건을 만족하는 투플만 반환한다.<br>-동등조인의 결과 릴레이션의 차수는 첫 번째 릴레이션과 두 번째 릴레이션의 차수를 합한 것.<br>-동등조인에서 조인에 참여한 속성이 두 번 나오지 않도록 중복된 속성(두 번째 속성)을 제거한 결과를 반환<br> -왼쪽 외부조인(left outer join):<br>
왼쪽 투플 기준으로 자연조인 시 실패한 투플을 모두 보여주되 값이 없는 대응 속성에는 NULL 값을 채워서 반환한다.<br>
-오른쪽 외부조인(right outer join):<br>
오른쪽 투플 기준으로 자연조인 시 실패한 투플을 모두 보여주되 값이 없는 대응 속성에는 NULL 값을 채워서 반환한다.<br>
-완전 외부조인(full outer join):<br>
양쪽 투플 기준으로 자연조인 시 실패한 투플을 모두 보여주되 값이 없는 대응 속성에는 NULL 값을 채워서 반환한다.<br>-자연조인을 한 후 두 릴레이션 중 한쪽 릴레이션의 결과만 반환<br> <br>세타 조인
<br>동등 조인
<br>자연 조인 <br>
<br>다음 아래 내용을 보고 보기에서 알맞는 용어를 골라 작성하시오.
<br>인터넷 공격자의 존재를 숨기면서 이 공격자에게 시스템에 대한 무제한 접근 권한을 부여하는 악성 프로그램이다.<br>
해커가 자신의 존재를 숨기면서 허가되지 않은 컴퓨터나 소프트웨어에 접근할 수 있도록 설계된 도구이다.<br>
일반적으로 펌웨어, 가상화 계층 등의 다양한 시스템 영역에서 작동하며, 운영체제의 시스템콜을 해킹하여 악성코드의 실행여부를 숨겨 안티바이러스 탐지를 우회할 수 있다.<br>
백도어(Backdoor)
<br>
<br>다음 아래 내용에 알맞는 공격 방법은?
<br>
불특정 다수가 아닌 명확한 표적을 정하여 지속적인 정보수집 후 공격감행할 수 있다. <br>
시스템에 직접 침투하는 것뿐 아니라 표적 내부직원들이 이용하는 다양한 단말을 대상으로 한다. <br>
한가지 기술만이 아닌 Zero-day 취약점, 악성코드 등 다양한 보안 위협 공격 기술을 사용한다. <br>
일반적으로 공격은 침투, 검색, 수집 및 유출의 4단계로 실행되며, 각 단계별로 다양한 공격 기술을 사용한다. <br>
APT
<br>
<br>다음이 설명하는 디자인 페턴은? <br>
구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴이다. <br>
연관성이 있는 객체 군이 여러개 있을 경우 이들을 묶어 추상화하고, 어떤 구체적인 상황이 주어지면 팩토리 객체에서 집합으로 묶은 객체 군을 구현화 하는 생성 패턴이다 <br>
관련성 있는 여러 종류의 객체를 일관된 방식으로 생성하는 경우에 유용하다. <br>kit라고도 불린다.<br>
추상펙토리 패턴(Abstract Factory)
<br>
<br>
다음 설명은 서버 접근 통제의 유형이다. 괄호 안에 들어갈 용어를 작성하시오. ('영어 약자'로 작성하시오.) <br>
( ① )은/는 규칙 기반(Rule-Based) 접근통제 정책으로, 객체에 포함된 정보의 허용 등급과 접근 정보에 대하여 주체가 갖는 접근 허가 권한에 근거하여 객체에 대한 접근을 제한하는 방법이다. <br>
( ② )은/는 중앙 관리자가 사용자와 시스템의 상호관계를 통제하며 조직 내 맡은 역할(Role)에 기초하여 자원에 대한 접근을 제한하는 방법이다. <br>
( ③ )은/는 신분 기반(Identity-Based) 접근통제 정책으로, 주체나 그룹의 신분에 근거하여 객체에 대한 접근을 제한하는 방법이다. <br>
1 → MAC<br>
2 → RDAC<br>
3 → DAC
<br>
<br>다음 설명에 대해 괄호 안에 알맞는 용어를 작성하시오. ('영어 약자' 로 작성하시오.)
<br>
( )은/는 자료를 일정한 크기로 정하여 순서대로 전송하는 자료의 전송 방식이다. <br>
셀이라 부르는 고정 길이 패킷을 이용하여 처리가 단순하고 고속망에 적합하며, 연속적으로 셀을 보낼 때 다중화를 하지 않고 셀단위로 동기가 이루어지지만 경우에 따라 동기식 시간 분할 다중화를 사용하기도 한다. <br>
가상 채널 (Virtual Channel) 기반의 연결 지향 서비스로 셀이라 부르는 고정 길이(53바이트) 패킷을 사용하며 통계적 다중화 방식을 이용한다. <br>
ATM
<br>
<br>&nbsp;IP 패킷에서 외부의 공인 IP주소와 포트 주소에 해당하는 내부 IP주소를 재기록하여 라우터를 통해 네트워크 트래픽을 주고받는 기술은 무엇인가?
<br>
NAT
<br>
<br>다음은 클라우드에 대한 유형 문제이다. 괄호안에 알맞는 답을 보기에 골라 작성하시오.
<br><img alt="Pasted image 20250415182923.png" src="https://lts.kr/사진-및-문서/pasted-image-20250415182923.png" target="_self"><br>PaaS / SaaS / IaaS
<br>IaaS : 서비스로서의 인프라, 개발 및 테스트 환경의 구축 및 제거가 빠르고 유연, AWS, Azure, GC가 대표적, 사용자가 컨트롤할 수 있는 범위가 넓음 - os, middleware runtime, data, applications<br>PaaS : 서비스로서의 플랫폼, 제공업체가 자체 인프라에서 하드웨어와 소프트웨어를 호스팅, Elastic Beanstalk, Heroku, Red Hat OpenShift, 사용자가 컨트롤할 수 있는 범위 - Applications, Data<br>SaaS : 서비스로서의 소프트웨어, 모든 애플리케이션은 제공업체가 관리, 웹 브라우저를 통해 제공, 사용자는 대시보드 또는 API를 통해 애플리케이션에 연결, 개별 시스템에 소프트웨어를 설치할 필요가 없음, Dropbox, salesforce, google apps, red hat insights<br> <br>→ IaaS
<br>→ PaaS
<br>→ SaaS <br>
<br>&nbsp;다음은 데이터베이스에 관련된 문제이다. 괄호 안에 알맞는 답을 작성하시오.
<br>
( ) 무결성은 관계 데이터베이스 관계 모델에서 2개의 관련 있던 관계 변수(테이블) 간의<br>
일관성(데이터 무결성)을 말한다. <br>
종종 기본 키 또는 키가 아닌 후보 키와 외래 키의 조합으로 강제 적용된다. <br>
외래 키가 선언된 관계 변수의 외래 키를 구성하는 속성(열)의 값은 그 관계 변수의 부모가 되는 관계 변수의 기본 키 값 또는 기본 키가 아닌 후보 키 값으로 존재해야 한다. <br>
참조 무결성
<br>
<br>다음 보기는 암호화 알고리즘에 대한 내용이다. 대칭키와 비대칭키에 해당하는 용어를 보기의 내용 참고하여 작성하시오.
<br>[보기]<br>
DES, RSA, AES, ECC, PKI, ARIA, SEED<br>
대칭키 : ( ) <br>
비대칭키 : ( ) <br>
대칭키 → DES / AES / ARIA / SEED<br>
비대칭키 → RSA / ECC
<br>
<br>아래 내용을 확인하여 알맞는 답을 작성하시오.<br>
○ 2 계층(데이터링크 계층)에서 구현되는 터널링 기술 중 하나<br>
○ L2F와 PPTP가 결합된 프로토콜로 VPN과 인터넷 서비스 제공자(ISP)가 이용<br>
○ IPsec을 함께 사용하면 PPTP보다 훨씬 안전하지만 보안보다 익명화에 더 적합
<br>
L2TP
<br>
<br>다음 설명에 해당하는 알맞은 용어를 영문 3글자로 쓰시오.
<br>○ 다른 컴퓨터에 로그인, 원격 명령 실행, 파일 복사 등을 수행할 수 있도록 다양한 기능을 지원하는 프로토콜 또는 이를 이용한 응용 프로그램이다.<br>○ 데이터 암호화와 강력한 인증 방법으로 보안성이 낮은 네트워크에서도 안전하게 통신할 수 있다.<br>○ 키(Key)를 통한 인증 방법으로 사용하려면 사전에 클라이언트의 공개키를 서버에 등록해야 한다.<br>○기본적으로는 22번 포트를 사용한다.<br>
SSH
<br>
<br>다음 보안 관련 설명으로 괄호안에 알맞는 용어를 작성하시오.
<br>( )은/는 TCP/IP에서 IP 패킷을 처리할 때 발생되는 문제를 알려주는 프로토콜이다.<br>( ) 프로토콜은 보통 다른 호스트나 게이트웨이 와 연결된 네트웍에 문제가 있는지 확인하기 위한 목적으로 주로 사용된다.<br>( ) 을/를 이용한 공격에는 ( ) Flooding가 있는데 ping 명령어를 통한 ( ) 패킷을 연속적으로 계속 보내어 서버의 요청에 응답으로 인한 다른작업을 하지 못하도록 하는 공격이다.<br>
ICMP
<br>
<br>다음 설명하는 디자인 패턴은?<br>
( )은/는 복잡한 시스템을 개발하기 쉽도록 클래스나 객체을 조합하는 패턴에 속하며,<br>
대리라는 이름으로도 불린다. 내부에서는 객체 간의 복잡한 관계를 단순하게 정리해 주고,<br>
외부에서는 객체의 세부인 내용을 숨기는 역할을 한다.
<br>
proxy
<br>
<br>다음 파이썬 코드의 알맞는 출력값을 작성하시오.
<br>a = {'한국', '중국', '일본'}
a.add('베트남')
a.add('중국')
a.remove('일본')
a.update({'홍콩', '한국', '태국'})
print(a)
<br>
{'한국,'중국','베트남',홍콩','태국'}
<br>
<br>&nbsp;다음은 스키마와 관련된 내용이다. 각 괄호안에 알맞는 답을 작성하시오.<br>
<img alt="Pasted image 20250416171828.png" src="https://lts.kr/사진-및-문서/pasted-image-20250416171828.png" target="_self">
<br>
1 → 외부스키마<br>
2 → 개념스키마<br>
3 → 내부스키마
<br>
<br>다음 아래 제어 흐름 그래프가 분기 커버리지를 만족하기 위한 테스팅 순서를 쓰시오.<br>
<img alt="Pasted image 20250416172118.png" src="https://lts.kr/사진-및-문서/pasted-image-20250416172118.png" target="_self">
<br>
1234561<br>
124567
<br>
<br>다음 관계 대수 항목에 대해 괄호안에 들어갈 기호를 쓰시오.
<br>
U
<br>X<br>
π<br>
⋈
<br>
<br>&nbsp;다음은 디자인 패턴에 대한 설명이다. 괄호안에 알맞는 답을 작성하시오.
<br>( 1 )은/는 기능을 처리하는 클래스와 구현을 담당하는 추상 클래스로 구별한다.<br>
구현뿐 아니라 추상화도 독립적 변경이 필요할 때 ( 1 ) 패턴을 사용한다.<br>
기존 시스템에 부수적인 새로운 기능들을 지속적으로 추가할 때 사용하면 유용하며,<br>
새로운 인터페이스를 정의하여 기존 프로그램의 변경 없이 기능을 확장할 수 있다.<br>( 2 )은/는 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달해주는 패턴이다.<br>
일대다 관계를 가지며, ​주로 분산된 시스템 간에 이벤트를 생성·발행(Publish)하고, 이를 수신(Subscribe)해야 할 때 이용한다.<br>
1 → 브릿지<br>
2 → 옵저버
<br>
<br>. 다음 보기 중 형상 관리 도구에 해당하는 것을 모두 고르시오.
<br>ATM, CVS, OLAP, DDOS, SVN, Cyber Kill Chain, OLTP, Git<br>
SVN / GIT / CVS
<br>
<br>다음은 스케줄링에 관한 내용이다. 괄호안에 알맞는 답을 작성하시오.<br>
<img alt="Pasted image 20250416181833.png" src="https://lts.kr/사진-및-문서/pasted-image-20250416181833.png" target="_self">
<br>
A → FCFS<br>
B → SJF<br>
C → RR<br>
D → SRT
<br>
<br>다음은 E-R다이어그램의 표기 방법이다. 각 칸에 들어갈 알맞은 답을 골라 쓰시오.<br>
<img alt="Pasted image 20250416182123.png" src="https://lts.kr/사진-및-문서/pasted-image-20250416182123.png" target="_self">
<br>
A → 개체 타입<br>
B → 약한 개체 타입<br>
C → 관계 타입<br>
D → 약한 관계 타입<br>
E → 속성<br>
F → 키 속성<br>
G → 다중값 속성
<br>-&nbsp;아래에서 설명하는 내용을 영문 약자로 쓰시오.<br>키보드나 마우스와 같은 장치 없이 말이나 행동 그리고 감정과 같은 인간의 자연스러운 표현으로 컴퓨터나 장치를 제어할 수 있는 환경?<br>
NUI
<br>
<br>OSI 7 Layer에 대한 설명이다. 다음 각 설명에 해당되는 계층을 적으시오.
<br>(1) 물리계층을 통해 송수신되는 정보의 오류와 흐름을 관리하여 안전한 정보의 전달을 수행할 수 있도록 도와주는 역할<br>
(2) 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능<br>
(3) 수신자에서 데이터의 압축을 풀수 있는 방식으로 된 데이터 압축<br>물리 - 기계적, 전기적 특성. X.21, 리피터, 허브<br>
데이터 링크 - 흐름 제어, 오류 검출과 회복, HDLC, MAC, 랜카드, 브리지, 스위치<br>
네트워크 - 경로 설정(Routing), 트래픽 제어, 패킷, X.25, IP, 라우터<br>
전송 - 다중화, 오류 제어, 흐름 제어, TCP, UDP, 게이트웨이<br>
세션 - 송수신 측 간의 관련성을 유지, 대화 제어<br>
표현 - 데이터 암호화, 데이터 압축, 형식 변환<br>
응용 - 파일 전송, 전자 사서함(메일), 정보 교환, 가상 터미널<br>
★ 데이터 링크는 노드 사이의 흐름과 오류 제어.<br>
★ 전송은 단말기 사이의 흐름과 오류 제어.****<br>
1 → 데이터링크 계층<br>
2 → 네트워크 계층<br>
3 → 표현계층
<br>
<br>데이터 모델 구성요소 3가지를 쓰시오.
<br>개체 데이터 모델에서는 ( A ) 을/를 이용하여 실제 데이터를 처리하는 작업에 대한 명세를 나타내는데 논리 데이터 모델에서는 ( B ) 을/를 어떻게 나타낼 것인지 표현한다.<br>
( C ) 은/는 데이터 무결성 유지를 위한 데이터베이스의 보편적 방법으로 릴레이션의 특정 칼럼에 설정하는 제약을 의미하며, 개체무결성과 참조 무결성 등이 있다.<br>
A → 연산<br>
B → 구조<br>
C → 제약조건
<br>
<br>다음은 결합도에 대한 설명이다. 빈칸에 들어갈 알맞은 용어를 보기에서 찾아 쓰시오.
<br>( A ) 은/는 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우의 결합도<br>
( B ) 은/는 모듈 간의 인터페이스로 배열이나 객체, 구조 등이 전달되는 경우의 결합도<br>
( C ) 은/는 파라미터가 아닌 모듈 밖에 선언된 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호작용하는 경우의 결합도<br>[보기] : 자료 결합도 / 스탬프 결합도 / 제어 결합도 / 공통 결합도 / 내용 결합도 / 외부 결합도<br>내용 → 내부에 있는 변수/기능<br>
공통 → 전역 변수<br>
외부 → 외부, 다른 어쩌구<br>
제어 → 제어 어쩌구<br>
스탬프 → 배열, 구조 어쩌구<br>
자료 → 파라미터 만 의존<br>
A - 내용 결합도<br>
B - 스탬프 결합도<br>
C - 공통 결합도
<br>다음 내용에 해당하는 알맞는 답을 작성하시오.<br>
소프트웨어에서 워터마크 삭제 등과 같이 소프트웨어가 불법으로 변경(unauthorized modifications)되었을 경우, 그 소프트웨어가 정상 수행되지 않게 하는 기법이다. <br>
소프트웨어 변조 공격을 방어하기 위해 프로그램에 변조검증코드(tamper-proofing code)를 삽입하는 것도 한 방법으로, 변조검증코드의 용도는 첫째 프로그램이 변경되었는지를 탐지하는 것이고, 둘째는 변조가 탐지되었다면 프로그램이 실행되지 않게 한다. <br>
소프트웨어의 위변조 방지 역공학 기술의 일종으로 디지털 콘텐츠의 관련 산업이나 전자상거래 또는 보호해야 할 소프트웨어가 있는 다양한 산업 분야에 적용된다. <br>
템퍼 프루핑 (Tamper Proofing)
<br>시스템 분석 및 설계, 또는 문서화에 사용되는 기법으로 시스템 실행 과정인 입력, 처리, 출력의 기능을 표현한 용어를 영문약어로 쓰시오.<br>
HIPO(Hierarchy Input Process Output)
<br>
<br>
BIA(Business Impact Analysis) - 장애나 재해로 인해 운영상의 주요 손실을 볼 것을 가정하여 시간 흐름에 따른 영향도 및 손실평가를 조사하는 BCP를 구축하기 위한 비즈니스 영향 분석 <br>
RTO(Recovery Time Objective) - 업무중단 시점부터 업무가 복구되어 다시 가동될 때까지의 시간 <br>
RPO(Recovery Point Objective) - 업무중단 시점부터 데이터가 복구되어 다시 정상가동될 때 데이터의 손실 허용 시점 <br>
DRP(Disaster Recovery Plan) - 재난으로 장기간에 걸쳐 시설의 운영이 불가능한 경우를 대비한 재난 복구 계획 <br>
DRS(Disaster Recovery System) - 재해복구계획의 원활한 수행을 지원하기 위하여 평상시에 확보하여 두는 인적,물적 자원 및 이들에 대한 지속적인 관리체계가 통합된 재해복구센터 <br>(비즈니스 연속성 계획(BCP)이란 각종 재해나 재난발생에 대비하여 핵심 업무 기능수행의 연속성을 유지하여 고객 서비스의 지속성 보장과 고객에 대한 신뢰도를 높이는 신속한 절차와 체계를 구축해 기업의 가치를 최대화 해주는 방법론)<br>구조적 방법론(Structured Development) - 전체 시스템을 기능에 따라 나누어 개발하고, 이를 통합하는 분할과 정복 접근 방식의 방법론<br>정보공학 방법론(Information Engineering Development) - 정보시스템 개발에 필요한 관리 절차와 작업 기반을 체계화한 방법론<br>개체지향 방법론(Object-Oriented Development) - '객체'라는 기본 단위로 시스템을 분석 및 설계하는 방법론<br>컴포넌트 기반 방법론(CBD : Component Based Development) - 소프트웨어를 구성하는 컴포넌트를 조립해서 하나의 새로운 응용 프로그램을 작성하는 방법론<br>애자일 방법론(Agile Development) - 절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적용하면서 효율적으로 시스템을 개발할 수 있는 신속 적응적 경량 개발방법론<br>제품 계열 방법론(Product Line Development) - 특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론<br>참 오라클 - 모든 입력값에 대하여 기대하는 결과를 생성함으로써 발행된 오류를 모두 검출할 수 있는 오라클<br>샘플링 오라클 - 특정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공해주는 오라클<br>휴리스틱 오라클 - 샘플링 오라클을 개선한 오라클로, 특정 입력값에 대해 올바른 결과를 제공하고, 나머지 값들에 대해서는 휴리스틱(추정)으로 처리하는 오라클<br>일관성 검사 오라클 - 애플리케이션 변경이 있을 때, 수행 전과 후의 결과값이 동일한지 확인하는 오라클<br>(테스트 오라클은 테스트의 결과가 참인지 거짓인지를 판단하기 위해서 사전에 정의된 참값을 입력하여 비교하는 기법입니다.)<br>IP (Internet Protocol) - 송수신 간의 패킷 단위로 데이터를 교환하는 네트워크에서 정보를 주고받는 데 사용하는 통신 프로토콜<br>ARP (Address Resolution Protocol) - IP 네트워크상에서 IP 주소를 MAC 주소(물리 주소)로 변환하는 프로토콜<br>RARP (Reverse Address Resolution Protocol) - IP 호스트가 자신의 물리 네트워크 주소(MAC)는 알지만 IP주소를 모르는 경우, 서버로부터 IP 주소를 요청하기 위해 사용하는 프로토콜<br>ICMP (Internet Control Message Protocol) - IP 패킷을 처리할 때 발생하는 문제를 알려주는 프로토콜 메세지 형식은 8bit 헤더와 가변 길이의 데이터 영역으로 분리<br>IGMP (Internet Group Management Protocol) - 인터넷 그룹 관리 프로토콜은 호스트 컴퓨터와 인접 라우터가 멀캐스트 그룹 멤버십을 구성하는데 사용하는 통신 프로토콜<br>라우팅 프로토콜 (Routing Protocol) - 데이터 전송을 위해 목적지까지 갈 수 있는 여러 경로 중 최적의 경로를 설정해 주는 라우터 간의 상호 통신 프로토콜]]></description><link>https://lts.kr/study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-키워드.html</link><guid isPermaLink="false">study/정보처리기사/정보처리기사 실기/🥇 정보처리 기사 실기 키워드.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Mon, 21 Apr 2025 01:40:00 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-02-10_15_04_45.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-02-10_15_04_45.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🥇 정보처리 기사 실기 SQL 문제]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:정보처리기사" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정보처리기사</a> <a class="tag" href="https://lts.kr/?query=tag:실기" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#실기</a> <a class="tag" href="https://lts.kr/?query=tag:SQL" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SQL</a> <a class="tag" href="https://lts.kr/?query=tag:정리" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정리</a> <br> <a href="https://lts.kr?query=tag:정보처리기사" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정보처리기사">#정보처리기사</a> <a href="https://lts.kr?query=tag:실기" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#실기">#실기</a> <a href="https://lts.kr?query=tag:SQL" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SQL">#SQL</a> <a href="https://lts.kr?query=tag:정리" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정리">#정리</a><br>CREATE TABLE 부서 ( 부서코드 INT PRIMARY KEY, 부서명 VARCHAR(20)
); CREATE TABLE 직원 ( 직원코드 INT PRIMARY KEY, 부서코드 INT, 직원명 VARCHAR(20), FOREIGN KEY(부서코드) REFERENCES 부서(부서코드) ON DELETE CASCADE
); INSERT INTO 부서 VALUES(10, '영업부');
INSERT INTO 부서 VALUES(20, '기획부');
INSERT INTO 부서 VALUES(30, '개발부'); INSERT INTO 직원 VALUES(1001, 10, '이진수');
INSERT INTO 직원 VALUES(1002, 10, '곽명경');
INSERT INTO 직원 VALUES(1003, 20, '김건길');
INSERT INTO 직원 VALUES(1004, 20, '최민수');
INSERT INTO 직원 VALUES(1005, 20, '이용광');
INSERT INTO 직원 VALUES(1006, 30, '한성광');
INSERT INTO 직원 VALUES(1007, 30, '박미경');
<br>SELECT DISTINCT COUNT(부서코드) FROM 직원 WHERE 부서코드 = 20;
<br>결과: 3<br>해설 :<br>DISTINCT(중복 제거)는 부서코드가 아닌 COUNT(부서코드)에 적용되므로, 여전히 부서코드가 20인 컬럼의 수 '3'이 된다.
<br>DELETE FROM 부서 WHERE 부서코드 = 20;
SELECT DISTINCT COUNT(부서코드) FROM 직원;
<br>결과: 4<br>해설 :<br>부서코드가 20인 컬럼을 삭제한 후, 모든 직원테이블의 부서코드 개수를 센다. 이때 DISTINCT(중복 제거)는 COUNT에 적용되므로<br>
여전히 '4'이다.
<br>
<br>DEPT는 '학과'를 뜻한다
<br>가정: 전기과 학생 50명, 전자과 학생 100명, 전산과 학생 50명<br>SELECT DEPT FROM STUDENT;
<br>결과: 200<br>SELECT DISTINCT DEPT FROM STUDENT;
<br>결과: 3<br>해설 :<br>전기/전자/화학 3가지 종류로 이루어진 DEPT 속성의 중복을 제거하면 '3'이 남는다.
<br>SELECT COUNT(DISTINCT DEPT) FROM STUDENT WHERE DEPT = '전산과';
<br>결과: 1<br>해설 :<br>전산과인 학생들의 학과를 뽑는다. 이후 해당 학과의 중복을 제거하면 1개만 남게 된다.
<br>
<br>'H'제조사의 '단가' 보다 높은 '단가'를 가진 제품의 정보를 조회하는 SQL문이다.
<br>SELECT 제품명, 단가, 제조사
FROM 제품
WHERE 단가 &gt; ( ) (SELECT 단가 FROM 제품 WHERE 제조사 = 'H');
<br>답: ALL<br>해설 :<br>해당 쿼리는, where절의 하위 질의에 결과를 반영하여 본 질의의 조건에 추가하는 SQL이다.
<br>만약 서브쿼리에서 'H'제조사의 제품의 단다가 100/200/400 이 나왔다면,
<br>해당 단가들 보다 높은 단가를 찾기 위해서는 100/200/400을 모두 비교하여야 한다.
<br>따라서 ALL키워드가 들어간다면 모든 단가를 비교할 수 있다.
<br>서브쿼리 앞에 아무 키워드도 붙지 않는다면, 서브쿼리가 다중 행일때 오류를 발생시킨다.<br>
이때, ANY나 ALL 연산자를 사용하여 다중행을 비교할 수 있다.<br>ANY -&gt; 서브쿼리 결과 중 하나라도 참이면 해당 행은 참<br>
ALL -&gt; 서브쿼리 결과 중 모든 것에 참이어야 해당 행은 참<br>TABLE<br>SELECT COUNT(COL2)
FROM TABLE
WHERE COL1 IN (2, 3) OR COL2 IN (3, 5);
<br>결과: 3<br>해설 :<br>COL1 컬럼에 2나 3이 포함되었거나, COL2컬럼에 3이나 5가 포함된 컬럼 (4개)를 찾는다,
<br>
<br>여기서 NULL은 COUNT에 집계가 되지 않으므로 답은 '3'이다.
<br><img alt="Pasted image 20250225161448.png" src="https://lts.kr/사진-및-문서/pasted-image-20250225161448.png" target="_self"><br>결과 :<br>① TTL - ② 부장 - ③ 대리 - ④ 과장 - ⑤ 차장
<br>해설 :<br>해당 관계 대수식의 파이는 속성 리스트에 제시된 속성값만을 추출하여 새로운 릴레이션을 만드는 PROJECT연산이다
<br>따라서, TTL속성이 추출되어 속성명인 TTL부터 모든 속성값이 결과로 나타난다.<br>
= SELECT TTL FROM EMPLOYEE
<br>이 연산들은 관계형 데이터베이스의 데이터를 검색하고 변형하는 데 사용됩니다.<br>관계 대수에서 테이블을 하나의 집합(Set)으로 간주하고 수행하는 연산입니다.<br>(단, SQL문은 ISO/IEC 9075 표준을 기반으로 작성하시오.) <br>( 1 ) TABLE 학생 ( 2 ) 주소 VARCHAR(20);
<br>답 :<br>
1 -&gt; ALTER<br>
2 -&gt; ADD<br>해설 :<br>속성을 추가한다 -&gt; 테이블을 수정한다 -&gt; ALTER
<br>ALTER + ADD 속성 추가.
<br>
<br>3, 4학년의 학번, 이름을 조회한다.
<br>IN 예약어를 사용해야 한다.
<br>속성명 아래의 괄호는 속성의 자료형을 의미한다.
<br>정답 :<br>SELECT 학번, 이름 FROM 학생 WHERE 학년 IN (3, 4);
<br>해설 :<br>IN예약어는 WHERE절과 함께 쓰이며, WHERE 속성 IN (조건,조건,...) 방식으로 사용된다.
<br>해당 조건을 포함하고 있는 모든 속성이 선택되게 된다.
<br>student 테이블<br>정답 :<br>CREATE INDEX idx_name ON student(name);
<br>해설 :<br>인덱스 생성 문법 :<br>
CREATE INDEX 인덱스명 ON 테이블명(속성);
<br>(단, 아래의 실행 결과가 되도록 한다.)<br>
<br>
WHERE 조건절은 사용할 수 없다. <br>
GROUP BY는 반드시 포함한다. <br>
집계함수(Aggregation Function)를 적용한다. <br>
학과별튜플수 컬럼명을 출력에 Alias(AS)를 활용한다. <br>
문장 끝의 세미콜론(;)은 생략해도 무방하다. <br>
인용부호 사용이 필요한 경우 단일 따옴표(' ')를 사용한다.
정답 : <br>SELECT 학과, COUNT(*) AS 학과별튜플수
FROM 학생
GROUP BY 학과;
<br>&lt;처리 조건&gt;을 참고하여 적합한 SQL문을 작성하시오.<br>
<br>WHERE문은 사용하지 않는다.
<br>GROUP BY와 HAVING을 이용한다.
<br>집계함수(Aggregation Function)를 사용하여 명령문을 구성한다.
<br>최소점수, 최대점수는 별칭(Alias)을 위한 AS문을 이용한다.
<br>명령문 마지막의 세미콜론(;)은 생략 가능하다.
<br>인용 부호가 필요한 경우 작은따옴표(')를 사용한다.
<br>정답 :<br>SELECT 과목이름, MIN(점수) AS 최소점수, MAX(점수) AS 최대점수 FROM 성적 GROUP BY 과목이름 HAVING AVG(점수) &gt;= 90;
<br>해설 :<br>과목이름별로 여러 점수의 통계를 내는것 이기 때문에, GROUP BY 과목이름을 사용한다.
<br>이때, GROUP BY ~ HAVING 조건 을 사용하여, 해당 그릅화된 데이터 중 다음 조건을 만족하는 그룹만 포함한다.
<br>SELECT COUNT(*) CNT FROM A CROSS JOIN B WHERE A.NAME LIKE B.RULE;
<br>답 : 4<br>해설 :<br>SELECT COUNT(*) CNT 에서 CNT는 as CNT 가 생략된 형태이다.
<br>CROSS JOIN이란 카디션 프로덕트(곱)을 수행하는 조인방식으로써,<br>
A테이블의 모든 행과, B테이블의 모든 행의 모든 가능한 조합을 구한다.
<br>따라서, 저 중 a.name컬럼이 b.rule을 따르는(like 연산을 했을 때, 참인 결과는)<br>총 4개이다.<br>
<br>. 다음 빈칸에 들어갈 UNION 연산의 결과값을 작성하시오.<br>
<img alt="Pasted image 20250415181225.png" src="https://lts.kr/사진-및-문서/pasted-image-20250415181225.png" target="_self">
<br>[쿼리]
SELECT A FROM T1
UNION
SELECT A FROM T2
ORDER BY A DESC;
<br>UNION → 중복 제거
<br>UNION ALL → 중복 허용
<br>
4<br>
3<br>
1
<br>
<br>다음 조건을 참고하여, SQL문에서 괄호안에 알맞는 단어를 작성하시오.
<br>[조건]<br>
학생 테이블을 참조하는 다른 VIEW나 제약 조건까지 모두 삭제되어야 한다.<br>
단, 용어의 대·소문자는 상관하지 않는다.<br>DROP VIEW 학생 ( )<br>
CASCADE
<br>
<br>
다음은, 테이블에서 조건값을 실행한 화면이다. 이에 대한 알맞는 결과값을 작성하시오.<br>
<img alt="Pasted image 20250417121150.png" src="https://lts.kr/사진-및-문서/pasted-image-20250417121150.png" target="_self"> <br>
CROSS JOIN 은 카디션 곱으로, 각 행으로 만들수 있는 모든 경우 즉 6개의 행이 생긴다. <br>
그 중, s로 시작하고 , t를 포함하고 있는 컬럼은 총 4개이다. <br>
4
<br>]]></description><link>https://lts.kr/study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-sql-문제.html</link><guid isPermaLink="false">study/정보처리기사/정보처리기사 실기/🥇 정보처리 기사 실기 SQL 문제.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Fri, 18 Apr 2025 08:20:16 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20250225161448.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20250225161448.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🥇 정보처리 기사 실기 기타문제]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:정보처리기사" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정보처리기사</a> <a class="tag" href="https://lts.kr/?query=tag:실기" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#실기</a> <a class="tag" href="https://lts.kr/?query=tag:키워드" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#키워드</a> <a class="tag" href="https://lts.kr/?query=tag:정리" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정리</a> <br> <a href="https://lts.kr?query=tag:정보처리기사" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정보처리기사">#정보처리기사</a> <a href="https://lts.kr?query=tag:실기" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#실기">#실기</a> <a href="https://lts.kr?query=tag:키워드" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#키워드">#키워드</a> <a href="https://lts.kr?query=tag:정리" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정리">#정리</a><br>7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1
<br>LRU(Least Recently Used)​​는 가장 오랫동안 사용되지 않는 녀석을 교체한다.
<br>LFU(Least Frequently Used)는 최소 사용횟수 우선 교체 이다. 동일한 빈도의 경우, 가장오래된 페이지를 선택. 주의
부재 횟수를 구할떄, 초기 비어있는 프레임에 페이지가 삽입될때도 횟수를 센다. <br>**[테이블]**
사원 [사원번호(PK), 이름, 나이, 부서]
부서 [사원번호(PK), 이름, 주소, 나이] ① 신입사원이 들어와서 부서 테이블에 새로운 사람을 추가
INSERT INTO 부서 (사원번호, 이름, 주소, 나이) **( ① )** (240728, '홍길동', '서울', 30); ② 부서 테이블에서 추가한 사원을 검색한 후 사원 테이블에 추가
INSERT INTO 사원 (사원번호, 이름, 나이, 부서)
**( ② )** 사원번호, 이름, 나이, ‘영업’ FROM 부서 WHERE 이름 = '홍길동'; ③ 전체 사원 테이블 조회
SELECT * **( ③ )** 사원; ④ 사원의 퇴사로 인해 부서에 해당하는 값을 '퇴사'로 변경
UPDATE 사원 **( ④ )** 부서 = '퇴사' WHERE 사원번호 = 240728;
<br> <br>values
<br>select
<br>from
<br>set <br>
<br>다음은 운영체제 페이지 순서를 참고하여 할당된 프레임의 수가 3개일 때 LRU와 LFU 알고리즘의 페이지 부재 횟수를 작성하시오.
<br> 페이지 참조 순서 : 1, 2, 3, 1, 2, 4, 1, 2, 5, 7
<br>
(1) LRU : 6<br>
(2) LFU : 6
<br>class Parent { int x, y; Parent(int x, int y) { //1 this.x=x; this y=y; } int getT() { //2 return x*y; }
} ​class Child extend Parent { int x; Child (int x) { //3 super(x+1, x); this.x=x; } int getT(int n){ //4 return super.getT()+n; }
} class Main { public static void main(String[] args) { //5 Parent parent = new Child(3); //6 System.out.println(parent.getT()); //7 }
} 실행 순서 : 5 → ( ) → ( ) → ( ) → ( ) → ( )
<br>new Child(3)로 Child클래스의 생성자가 실행된다. 6 → 3
<br>이후 super에서 Parent의 생성자가 실행된다. 3 → 1
<br>그리고 7번 print가 실행되면, 다형성에 의해 2번 getT가 실행된다. 7 → 2
<br>
5 → 6 → 3 → 1 → 7 → 2
<br>]]></description><link>https://lts.kr/study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-기타문제.html</link><guid isPermaLink="false">study/정보처리기사/정보처리기사 실기/🥇 정보처리 기사 실기 기타문제.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Tue, 15 Apr 2025 08:09:13 GMT</pubDate></item><item><title><![CDATA[🥇 정보처리 기사 실기 프로그래밍-포인터]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:정보처리기사" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정보처리기사</a> <a class="tag" href="https://lts.kr/?query=tag:실기" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#실기</a> <a class="tag" href="https://lts.kr/?query=tag:프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로그래밍</a> <a class="tag" href="https://lts.kr/?query=tag:정리" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정리</a> <a class="tag" href="https://lts.kr/?query=tag:포인터" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#포인터</a> <br> <a href="https://lts.kr?query=tag:정보처리기사" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정보처리기사">#정보처리기사</a> <a href="https://lts.kr?query=tag:실기" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#실기">#실기</a> <a href="https://lts.kr?query=tag:프로그래밍" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로그래밍">#프로그래밍</a> <a href="https://lts.kr?query=tag:정리" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정리">#정리</a> <a href="https://lts.kr?query=tag:포인터" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#포인터">#포인터</a><br>#include &lt;stdio.h&gt; int len(char* p);
int main( ) { char* p1 = "2022"; char* p2 = "202207"; int a = len(p1); int b = len(p2); printf("%d", a + b);
} int len(char* p) { int r = 0; while (*p != '\0') { p++; r++; } return r;
}
<br>int len(char* p); -&gt; len() 함수의 프로토타입 선언이다.
<br>p1과 p2는 문자형 포인터 변수로 각 문자가 저장된 주소의 주소로 초기화 된다.<br>
<img alt="Pasted image 20250312144444.png" src="https://lts.kr/사진-및-문서/pasted-image-20250312144444.png" target="_self"><br>
ex) p1에는 '2'가 저장되어있는 1000번째 주소가 삽입되어있으며,<br>
p1+1 은 '0' , p1+4 는 1004번째 주소로, '\0'이 들어가 있다.
<br>즉, 4 + 6 <br>#include &lt;stdio.h&gt; int main( ) { int a[4] = { 0, 2, 4, 8 }; int b[3]; int* p; int sum = 0; for (int i = 1; i &lt; 4; i++) { p = a + i; b[i - 1] = *p - a[i - 1]; sum = sum + b[i - 1] + a[i]; } printf("%d", sum); }
<br>p -&gt; 정수형 포인터 변수
<br>i = 1,2,3 반복문
<br>첫번째 반복 i = 1 `p = a + i` =&gt; a배열의 두번째 요소의 주소 저장 `b[0]` = (*p =&gt; p의 주소가 가리키는곳의 값)2 - 0 = 2 sum = 0 + 2 + 2 = 4
두번째 반복 i = 2 a배열의 세번째요소 4 `b[1]` = 4 - 2 = 2 sum = 4 + 2 + 4 = 10
세번째 반복 i = 3 a배열의 네번째요소 8의 주소 'b[2]' = 8 - 4 = 4 sum = 10 + 4 + 8 = 22 <br>포인터 변수로 선언된 p에 배열을 직접대입하는것은 주소값을 넣는것이다.
<br>포인터 변수를 사용할때 p*처럼 사용하면, 해당 주소값 내의 값을 의미한다.<br>
p에 직접 대입할 때 말고는 다 배열과 사칙연산이다.
<br>#include &lt;stdio.h&gt; int main() { int* array[3]; int a = 12, b = 24, c = 36; array[0] = &amp;a; array[1] = &amp;b; array[2] = &amp;c; printf("%d", *array[1] + **array + 1);
}
<br>정수형 포인터를 저장하는 배열 array [ , , ]
<br>array[0] = &amp;a;는 a의 시작 주소를 삽입하는 것이다.
<br>array[1] 은 &amp;b(b의 주소값)이고, *array[1] 은 그 주소가 지니고 있는 실제 값 24이다.
<br>**array + 1 =&gt; <br>array : 배열의 이름만 지정하면 배열의 첫 번째 요소의 주소인 &amp;array[0], 즉 array의 첫주소값
<br>*array : array의 첫주소값(array)이 가지는 실제 값 &amp;a 즉 int a의 주소값.
<br>**array : int a의 주소값의 실제 지니고 있는값 12이다. <br>즉, 24 + 12 + 1<br>#include &lt;stdio.h&gt; int main() { int ary[3]; int s = 0; *(ary + 0) = 1; ary[1] = *(ary + 0) + 2; ary[2] = *ary + 3; for (int i = 0; i &lt; 3; i++) s = s + ary[i]; printf("%d", s); }
<br>*(ary + 0) = 1; -&gt; arr의 첫 주소값의 실제값에 1 대입 / arr[1 , , ]
<br>ary[1] = *(ary + 0) + 2; -&gt; arr[1]에 1+2 대입 / arr[1 , 3 , ]
<br>ary[2] = *ary + 3; -&gt; arr[2]에 1+3 대입 / arr[1 , 3 , 4]
<br>1+3+4 = 8<br>#include &lt;stdio.h&gt; main() { char* p = "KOREA"; printf("%s\n", p); printf("%s\n", p + 3); printf("%c\n", *p); printf("%c\n", *(p + 3)); printf("%c\n", *p + 2); }
<br>문자열을 저장하는 경우 문자열의 끝을 의미하는 널 문자\0 가 추가로 저장되며,<br>
출력시 널 문자는 표시되 지 않는다.
<br>printf("%s", P) 의 %s는 널(\0) 문자가 나올 때까지 문자열을 출력한다.
<br>[K , O , R , E , A , \0]<br>P : 문자형 포인터 변수 p 의 시작주소값 -&gt; KOREA
<br>P + 3 : p의 시작주소값의 3번째 뒤의 주소 -&gt; E의 시작 주소값 -&gt; EA
<br>*P : p 의 시작주소값의 실제 값 -&gt; K
<br>*(P + 3) : P의 시작주소값의 3번째 뒤의 주소의 실제 값 -&gt; E
<br>*P + 2 : P의 시작 주소의 실제값 K(ASCII 코드 75) + 2 =&gt; 77 =&gt; M
<br>KOREA
EA
K
E
M
<br>]]></description><link>https://lts.kr/study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-프로그래밍-포인터.html</link><guid isPermaLink="false">study/정보처리기사/정보처리기사 실기/🥇 정보처리 기사 실기 프로그래밍-포인터.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Tue, 15 Apr 2025 03:14:10 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20250312144444.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20250312144444.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🥇 정보처리 기사 실기 프로그래밍-사용자 정의 함수]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:정보처리기사" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정보처리기사</a> <a class="tag" href="https://lts.kr/?query=tag:실기" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#실기</a> <a class="tag" href="https://lts.kr/?query=tag:프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로그래밍</a> <a class="tag" href="https://lts.kr/?query=tag:정리" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정리</a> <a class="tag" href="https://lts.kr/?query=tag:함수" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#함수</a> <br> <a href="https://lts.kr?query=tag:정보처리기사" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정보처리기사">#정보처리기사</a> <a href="https://lts.kr?query=tag:실기" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#실기">#실기</a> <a href="https://lts.kr?query=tag:프로그래밍" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로그래밍">#프로그래밍</a> <a href="https://lts.kr?query=tag:정리" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정리">#정리</a> <a href="https://lts.kr?query=tag:함수" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#함수">#함수</a><br>public class Test { public static void main(String[] args) { System.out.print(Test.check(1)); } "( 1 )" String check(int num){ return (num &gt;= 0) ? "positive" : "negative"; }
}
<br>static은 클래스 이름으로 메소드에 접근하기 위해 사용되는 예약어이다.
<br>main메서드는 static이다. 즉 객체를 생성하지 않고 바로 실행된다. 이떄,,,, <br>메소드를 사용하기 위해서는 메소드가 포함된 클래스의 객체 변수를 선언한 후<br>
[객체변수].[메소드]의 방식으로 접근해야하지만,<br>
static을 이용한다면 객체변수 없이 [클래스이름].[메소드]방식으로 접근하는것이 가능하다.
<br>즉 메인 메서드가 아니더라도, static메서드 안에서 일반 메서드를 호출하면 오류를 야기한다.<br>int increment() { static int x = 0; x += 2; return x;
} int main() { int x = 1; int sum = 0; for (int i = 0; i &lt; 4; i++) { x++; sum += increment(); } printf("%d", sum);
}
<br>static int x는 "static" 으로 선언하여 전역변수(어느곳에서든 참조가능한 변수)로 사용되어 호출(사용) 이후에도 초기화 되지않는다.
<br>즉 2+4+6+8
<br>def test(v): if type(v) == type(""): return len(v) elif type(v) == type(100): return 101 else: return 20
a = "100.0" b = 100.0 c = (100.0, 200.0)
print(test(a) + test(b) + test(c))
<br>type(v) == type("") : v가 문자열 타입이면
<br>type(v) == type(100) : v가 정수형 타입이면
<br>100.0은 실수형으로, 정수형 타입이 아니다. <br>a : 문자열 / b : 실수형 / c : 실수형 - 5 + 20 + 20
<br>public class Main { public static void main(String[] args) { int sum = 0; try { func(); } catch(NullPointerException e) { sum = sum + 1; } catch(Exception e) { sum = sum + 10; } finally { sum = sum + 100; } System.out.print(sum); } static void func() throws Exception { throw new NullPointerException(); }
}
<br>func함수는 NullPointerException을 발생시키는 함수이다.
<br>두 개의 catch함수는 익셥션을 감지한다.
<br>이 때, Exception 타입은 모든 익셉션을 가지고 있다.
<br>하지만, 순서대로 NullPointerException이 catch되고, 한개의 case가 catch되었으므로,
<br>finally로 이동한다.
<br>class B { int x = 3; int getX() { return x * 2; }
} class A extends B { int x = 7; @Override int getX() { return x * 3; }
} public class Annotation { public static void main(String[] args) { B b1 = new A(); A b2 = new A(); System.out.print(b1.getX() + b1.x + b2.getX() + b2.x); }
}
<br>b1객체는 B객체이지만 함수는 오버라이딩 된다. 즉, 필드 변수는 3 함수는 21<br>
-B객체이지만, A로 초기화를 할때, 오바라이딩 된다고 이해하면 된다.
<br>b2객체는 필드변수 7, 함수는 21
<br>21 + 3 + 21 + 7
<br>#include void swap() { int a = 11; int b = 19; int t = a; a = b; b = t;
} int main() { int a = 11; int b = 19; swap(); switch(a) { case 1: b += 1; case 11: b += 2; default: b += 3; break; } printf("%d", a-b);
}
<br>swap함수는 출력도 없으며, 리턴도 없음 ( c언어는 콜바이벨류 이다. 이때는 변수를 새로 선언했기 때문에 그에도 해댱하지 않는다.)
<br>따라서 a 는 11로 case문을 타게 되고, break문이 없으므로 default문을 타게된다.
<br>(break 가 있었으면 default문을 타지 않는다.)
<br>class Connection { private static Connection _inst = null; private int count = 0; static public Connection get() { if(_inst == null) { _inst = new Connection(); return _inst; } return _inst; } public void count() { count++; } public int getCount() { return count; }
} public class main { public static void main(String[] args) { Connection conn1 = Connection.get(); conn1.count(); Connection conn2 = Connection.get(); conn2.count(); Connection conn3 = Connection.get(); conn3.count(); conn1.count(); System.out.print(conn1.getCount()); } }
<br>싱글톤 패턴을 구현한 것으로 보인다.
<br>conn1/2/3/4 모두 한 객체이므로 count를 공유한다.
<br>]]></description><link>https://lts.kr/study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-프로그래밍-사용자-정의-함수.html</link><guid isPermaLink="false">study/정보처리기사/정보처리기사 실기/🥇 정보처리 기사 실기 프로그래밍-사용자 정의 함수.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Tue, 15 Apr 2025 03:11:02 GMT</pubDate></item><item><title><![CDATA[🥇 정보처리 기사 실기 프로그래밍-제어문]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:정보처리기사" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정보처리기사</a> <a class="tag" href="https://lts.kr/?query=tag:실기" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#실기</a> <a class="tag" href="https://lts.kr/?query=tag:프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로그래밍</a> <a class="tag" href="https://lts.kr/?query=tag:정리" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정리</a> <br> <a href="https://lts.kr?query=tag:정보처리기사" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정보처리기사">#정보처리기사</a> <a href="https://lts.kr?query=tag:실기" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#실기">#실기</a> <a href="https://lts.kr?query=tag:프로그래밍" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로그래밍">#프로그래밍</a> <a href="https://lts.kr?query=tag:정리" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정리">#정리</a><br>#include &lt;stdio.h&gt;
main() { int s, el = 0; for (int i = 6; i &lt;= 30; i++) { s = 0; for (int j = 1; j &lt;= i / 2; j++) if (i % j == 0) s = s + j; if (s == i) el++; } printf("%d", el);
}
<br>j &lt;= i / 2; -&gt; 나머지가 몇이든 버린다.
<br>하나하나 분석하면, <br>6~30까지 자신의 약수(나누어 떨어지는 수)를 모두 더한다
<br>모두 더한 수와 자신이 같은지 판단하여 출력한다.
<br>6과 28이 해당한다.
<br>public class Test { public static void main(String[] args) { int r = 0; for (int i = 1; i &lt; 999; i++) { if (i % 3 == 0 &amp;&amp; i % 2 == 0) r = i; } System.out.print(r); } }
<br>1 ~ 998까지
<br>3으로 나누어 떨어지면서,
<br>2로도 나누어 떨어지는 녀석 즉, 2와 3의 공배수(6의 배수)
<br>일때, 가장 큰수(매번 초기화 하므로)를 구한다.
<br>public class Test { public static void main(String[] args) { int i = 3, k = 1; switch(i) { case 1: k++; case 2: k -= 3; case 3: k = 0; case 4: k += 3; case 5: k -= 10; default: k--; } System.out.print(k); }
}
<br>i가 3이므로 case3을 찾아간다.
<br>break문이 없으므로 그 밑으로 쭉 수행한다 ( 조건식에 부합하지 않더라도, )
<br>1234의 역순은 4321이다. 단 1230처럼 0으로 끝나는 정수는 고려하지 않는다.<br>#include &lt;stdio.h&gt; int main() { int number = 1234; int div = 10, result = 0; while (number "( 1 )" 0) { result = result * div; result = result + number "( 2 )" div; number = number "( 3 )" div; } printf("%d", result); }
<br>한자리수씩 커지면서 바꾸는거다.
<br>&gt; : 0보다 클때까지 반복한다.
<br>% : 나머지를 가져온다
<br>/ : 나누고, 나머지를 버린다.
<br>첫 사이클
0
4
123
<br>두 번쨰
40
43
12
<br>세 번째
430
432
1
<br>네 번째
4320
4321
0
<br>public class Test { public static void main(String[] args) { int w = 3, x = 4, y = 3, z = 5; if((w == 2 | w == y) &amp; !(y &gt; z) &amp; (1 == x ^ y != z)) { w = x + y; if(7 == x ^ y != w) System.out.println(w); else System.out.println(x); } else { w = y + z; if(7 == y ^ z != w) System.out.println(w); else System.out.println(z); } } }
<br>
&amp; , | -&gt; 비트 연산으로써, 2진법을 비트연산하면 된다. <br>
x ^ y 연산은 비트 XOR연산으로써,<br>
001 -&gt; y != z<br>
000 -&gt; 1 == x<br>
--- (같으면 0 / 다르면 1)<br>
001 -&gt; 4 가 된다. <br>a = 100 result = 0 for i in range(1,3): result = a &gt;&gt; i result = result + 1 print(result)
<br>i = 1,2 수행
<br>a &gt;&gt; i 는 오른쪽 시프트 연산자로써, a값을 오른쪽으로 i비트 움직인다는 뜻이다.
<br>파이썬에서 정수는 4Byte이므로, 8bit x 32개 로 계산하면 된다.
<br>
100을 먼저 2진수로 변환<br>
0000 ... 0001100100 -&gt; 100 (4 + 32 + 64) <br>
시프트 연산을 한번 수행하면<br>
0000 ... 0000110010 -&gt; 50 (2 + 16 + 32)<br>
+1 을 하면 51 -&gt; 110011 <br>
한번 더 수행하면 100을 두칸 시프트 한다<br>
0000 ... 0000011001 -&gt; 25 (1 + 8 + 16)<br>
25+1 = 26 <br>파이썬의 print 기본적으로 파이썬의 print는 print(end='\n') 이 포함된 식이다. (줄바꿈 디펄트)<br>
즉 print("123", end=' ')로 표현하면 줄바꿈 대신 공백이 삽입된다.
<br>public class Test { public static void main(String[]args) { int a[] = new int[8]; int i = 0; int n = 10; while( "( 1 )" ) { a[i++] = "( 2 )"; n /= 2; } for(i = 7; i &gt;= 0; i--) System.out.print(a[i]); } }
<br>n /= 2;란 n = n / 2랑 동일한 문법이다.
<br>먼저, 10진수를 2진수로 변환하기 위해서는, 2로 계속해서 나누어, 나머지를 삽입하면된다.<br>10 / 2 = 5(0)
5 / 2 = 2(1)
2 / 2 = 1(0) (1)
10 -&gt; 1010 (8+2) 19 / 2 = 9(1)
9 / 2 = 4(1)
4 / 2 = 2(0)
2 / 2 = 1(0)
(1)
19 -&gt; 10011 (16+2+1)
<br>JAVA는 배열 선언시 초기화를 하지 않으면 0 이 삽입된다<br>
a[i++] = x 를 수행하면 i번째 자리에 값 삽입 후, i값을 증가시킨다.<br>첫번째 조건식에는 n &gt; 0을 넣는다.
<br>16일때, a[] 배열에는 11001 순서로 들어가게된다.
<br>n % 2(나머지가 계속 들어간다.)<br>
10 -&gt; 5 -&gt; 2 -&gt; 1 -&gt; 0(조건식에 부합) 실행 X<br>
0 1 0 1<br>
a = [0,1,0,1,0,0,0,0]
<br>를 역순으로 출력하면 1010 이 된다.<br>
출력은 00001010이 된다.
<br>public class Main { static void func(String[] m, int n) { for (int i = 1; i &lt; n; i++) { if (m[i-1].equals(m[i])) { System.out.print("O"); } else { System.out.print("N"); } } for (String mo : m) { System.out.print(mo); } } public static void main(String[] args) { String[] m = new String[3]; m[0] = "A"; m[1] = "A"; m[2] = new String("A"); func(m, 3); }
}
<br>JAVA에서 .equals함수는 객체가 아닌 값 자체를 비교하기 때문에 같은 값으로 취급한다.
<br>def test(lst): for i in range(len(lst) // 2): lst[i], lst[-i-1] = lst[-i-1], lst[i]
ls = [1,2,3,4,5,6]
test(ls)
print(sum(ls[::2]) - sum(ls[1::2]))
<br>파이썬에서 list[a::b]형태는 a부터 시작해서(없다면 0) b칸씩 건너 뛰어 가져오는 것.
<br>따라서, test함수로 리버스된 리스트 [::2] -&gt; 6,4,2 / [1::2] -&gt; 5,3,1 이다.
<br>]]></description><link>https://lts.kr/study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-프로그래밍-제어문.html</link><guid isPermaLink="false">study/정보처리기사/정보처리기사 실기/🥇 정보처리 기사 실기 프로그래밍-제어문.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Mon, 14 Apr 2025 09:18:55 GMT</pubDate></item><item><title><![CDATA[💻 프로젝트]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:프로젝트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로젝트</a> <a class="tag" href="https://lts.kr/?query=tag:모음" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#모음</a> <br> <a href="https://lts.kr?query=tag:프로젝트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로젝트">#프로젝트</a> <a href="https://lts.kr?query=tag:모음" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#모음">#모음</a><br>프로젝트
public하게 공개할 수 있는 프로젝트의 제작 과정입니다.
<br>
<br><a data-href="🏹 예치금 차액 비교 Spring Batch 리펙토링" href="https://lts.kr/project/hello-batch/🏹-예치금-차액-비교-spring-batch-리펙토링.html" class="internal-link" target="_self" rel="noopener nofollow">🏹 예치금 차액 비교 Spring Batch 리펙토링</a>⭐
<br><a data-href="🏹 예치금 차액 비교 Spring Batch 리펙토링 부록" href="https://lts.kr/project/hello-batch/🏹-예치금-차액-비교-spring-batch-리펙토링-부록.html" class="internal-link" target="_self" rel="noopener nofollow">🏹 예치금 차액 비교 Spring Batch 리펙토링 부록</a>
<br><a data-href="✏ Chunk_Partitioning Batch 구조 드로잉" href="https://lts.kr/project/hello-batch/✏-chunk_partitioning-batch-구조-드로잉.html" class="internal-link" target="_self" rel="noopener nofollow">✏ Chunk_Partitioning Batch 구조 드로잉</a>
<br>
<br><a data-href="👩‍👧‍👦 marketing Analytics 공통모듈 제작기" href="https://lts.kr/project/hello-marketing/👩‍👧‍👦-marketing-analytics-공통모듈-제작기.html" class="internal-link" target="_self" rel="noopener nofollow">👩‍👧‍👦 marketing Analytics 공통모듈 제작기</a>⭐
<br><a data-href="👩‍👧‍👦 Analytics 공통모듈 ADMIN용 데이터 추출" href="https://lts.kr/project/hello-marketing/👩‍👧‍👦-analytics-공통모듈-admin용-데이터-추출.html" class="internal-link" target="_self" rel="noopener nofollow">👩‍👧‍👦 Analytics 공통모듈 ADMIN용 데이터 추출</a>
<br>
<br><a data-href="👻 Obsidian 정적호스팅 CICD 과정" href="https://lts.kr/project/note-ci_cd/👻-obsidian-정적호스팅-cicd-과정.html" class="internal-link" target="_self" rel="noopener nofollow">👻 Obsidian 정적호스팅 CICD 과정</a>
<br>
<br><a data-href="📘 SpringBoot &amp; Docker + Reids 연동" href="https://lts.kr/tools/docker/📘-springboot-&amp;-docker-+-reids-연동.html" class="internal-link" target="_self" rel="noopener nofollow">📘 SpringBoot &amp; Docker + Reids 연동</a>
<br><a data-href="🌥 aws(EC2)셋팅부터 배포까지" href="https://lts.kr/tools/aws/🌥-aws(ec2)셋팅부터-배포까지.html" class="internal-link" target="_self" rel="noopener nofollow">🌥 aws(EC2)셋팅부터 배포까지</a>]]></description><link>https://lts.kr/project/💻-프로젝트.html</link><guid isPermaLink="false">project/💻 프로젝트.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Mon, 14 Apr 2025 05:39:12 GMT</pubDate></item><item><title><![CDATA[🥇 정보처리 기사 실기 프로그래밍-구조체(structuer)]]></title><description/></item></channel></rss>