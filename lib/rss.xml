<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[blog]]></title><description><![CDATA[Obsidian digital garden]]></description><link>https://lts.kr/</link><image><url>https://lts.kr/lib/media/favicon.png</url><title>blog</title><link>https://lts.kr/</link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Mon, 21 Apr 2025 09:14:09 GMT</lastBuildDate><atom:link href="https://lts.kr/lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Mon, 21 Apr 2025 09:13:50 GMT</pubDate><copyright><![CDATA[taesung's Blog]]></copyright><ttl>60</ttl><dc:creator>taesung's Blog</dc:creator><item><title><![CDATA[🏉 Jenkins란]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:Tools" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Tools</a> <a class="tag" href="https://lts.kr/?query=tag:도커" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#도커</a> <a class="tag" href="https://lts.kr/?query=tag:Docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Docker</a> <br> <a href="https://lts.kr?query=tag:Tools" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Tools">#Tools</a> <a href="https://lts.kr?query=tag:도커" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#도커">#도커</a> <a href="https://lts.kr?query=tag:Docker" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Docker">#Docker</a><br>
<br>Jenkins는 오픈소스 기반의 자동화 서버로, 주로 지속적 통합(CI: Continuous Integration)과 지속적 배포(CD: Continuous Delivery/Deployment)를 자동화하기 위해 사용된다.
<br>특징<br>java기반으로 만들어져, OS에 상관없이 실행 가능
<br>파이프라인 기반으로 소프트웨어 빌드, 테스트, 배포 자동화
<br>플러그인 아키텍처로 확장성이 뛰어남
<br>
<br>개발자가 코드 변경 시 자동으로 빌드 + 테스트 수행
<br>코드 병합 시 문제 조기 탐지
<br>코드 품질 유지 + 릴리즈 주기 단축
<br>
<br>테스트 통과 후 자동으로 스테이징 또는 운영 서버에 배포
<br>릴리즈 주기 자동화 → 빠른 피드백 루프
<br>
<br>빌드 → 테스트 → 배포 → 모니터링까지의 전체 과정을 파이프라인으로 시각화<br>
<img alt="Pasted image 20250421164348.png" src="https://lts.kr/사진-및-문서/pasted-image-20250421164348.png" style="width: 750px; max-width: 100%;" target="_self">
<br>Git Hook, Cron, Webhook, Polling 등 다양한 트리거 지원
<br>Webhook vs Polling
폴링(Poliing) : 일정 시간 간격으로 저장소의 변경사항을 확인<br>
웹훅(Webhook) : 저장소(Git 등)에 변경사항이 발생했을 때, 젠킨스에 즉시 알려주는 방식
<br>이를 설정하는 방법은 젠킨스의 파이프 라인 설정을 통해 이루어 진다.<br>파이프라인 구조 예시
<br>pipeline { agent any triggers { // GitHub에서 Webhook을 통해 이벤트가 올 때 트리거됨 githubPush() } stages { stage('Checkout') { steps { git url: 'https://github.com/your-org/your-repo.git', branch: 'main' } } stage('Build') { steps { sh 'echo Building...' } } } ---- agent any triggers { // 5분마다 Git 변경사항 확인 (cron 표현식) pollSCM('H/5 * * * *') } stages { stage('Checkout') { steps { git url: 'https://github.com/your-org/your-repo.git', branch: 'main' } } stage('Build') { steps { sh 'echo Building...' } } }
}
<br>
<br>Freestyle Job: 기본 작업 단위 (빌드, 테스트, 배포 설정)
<br>Pipeline: Groovy 기반 DSL로 멀티스텝 작업 정의
<br>Multibranch Pipeline: 브랜치마다 파이프라인 분기 설정
<br>
<br>1,800개 이상의 공식 플러그인
<br>주요 플러그인: <br>Git / GitHub / Bitbucket
<br>Docker
<br>Slack / Email Notification
<br>Kubernetes
<br>SonarQube
<br>Artifactory / Nexus <br>
<br>이메일, Slack, Teams, Webhook 등 다양한 알림 지원
<br>실패/성공/경고 상태에 따라 조건부 메시지 전송 가능
<br>
<br>작업당 빌드 결과 로그 저장
<br>실패 시 어떤 스텝에서 실패했는지 명확히 추적 가능
<br>
<br>LDAP, Active Directory 연동
<br>Role 기반 접근 제어 (RBAC)
<br>Job/Folder 단위 권한 설정 <br>
<br>Master는 Job 스케줄링 및 관리
<br>Agent (노드)는 실제 빌드 실행 담당
<br>스케일아웃 구조로 부하 분산 가능
<br>젠킨스와 도커는 서버 자동화(CI/CD)환경에서 매우 자주 함께 활용된다.<br>
두 도구의 역할은 서로 다르지만 서로를 보완해주는 역할을 한다.<br>먼저 도커의 주 역할은 애플리케이션 실행 환경의 캡슐화 이다.<br>
이렇게 캡슐화된 것을 이미지 또는 컨테이너라고 한다.<br>이미지와 컨테이너?
이미지와 컨테이너는 사실상 같은 개념을 가리키는 용어이다.
도커 이미지 : Docker라는 특정 기술/플랫폼을 통해 생성되고 관리되는 이미지. Docker에 종속적<br>
컨테이너 : 보다 일반적인 용어로, 컨테이너 기술을 사용하는 모든 플랫폼의 이미지를 뜻한다.
<br>즉, 젠킨스와 도커의 관계를 요약하자면<br>
Jenkins는 Docker를 사용해 컨테이너 환경에서 빌드와 테스트를 실행하거나, 애플리케이션을 Docker 이미지로 빌드하고 레지스트리에 배포하며, 필요 시 Jenkins 자체도 Docker 컨테이너로 실행할 수 있다.<br>
<br>파이프라인 실행 트리거 <br>GitHub/GitLab에서 코드 변경 발생 시: <br>✅ Webhook: 변경 사항을 Jenkins에 즉시 알림
<br>✅ Polling: Jenkins가 주기적으로 변경 여부 확인<br>소스코드 + Dockerfile 가져오기 <br>트리거 감지 후 Jenkins가 Git 저장소에서 코드와 Dockerfile을 `checkout <br>dockerfile
→ 컨테이너 이미지를 만들기 위한 설정 파일(스크립트)<br>
쉽게 말해, “어떤 OS에, 어떤 앱을 설치하고, 어떤 명령을 실행할 것인지”를 정의한 레시피라고 볼 수 있다.
<br>Docker 이미지 빌드 <br>docker build -t my-app . 명령으로 컨테이너 이미지 생성<br>컨테이너 기반 테스트 수행 (선택) <br>docker run으로 테스트 자동화 실행<br>Docker 이미지 푸시 <br>DockerHub, ECR 등에 docker push 수행<br>서버 또는 클러스터에 배포 <br>SSH, Docker Compose, Kubernetes 등을 통해 자동 배포<br>알림 및 로그 저장 <br>Slack, Email 알림 전송 + Jenkins에 빌드 로그 기록]]></description><link>https://lts.kr/tools/jenkins/🏉-jenkins란.html</link><guid isPermaLink="false">Tools/Jenkins/🏉 Jenkins란.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Mon, 21 Apr 2025 09:13:27 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20250421164348.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20250421164348.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🐋 docker 란]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:Tools" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Tools</a> <a class="tag" href="https://lts.kr/?query=tag:도커" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#도커</a> <a class="tag" href="https://lts.kr/?query=tag:Docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Docker</a> <br> <a href="https://lts.kr?query=tag:Tools" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Tools">#Tools</a> <a href="https://lts.kr?query=tag:도커" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#도커">#도커</a> <a href="https://lts.kr?query=tag:Docker" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Docker">#Docker</a><br><img alt="Pasted image 20250221114743.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114743.png" target="_self"><br>...aws의 설명에 의하면<br>
<br>애플리케이션을 신속하게 구축, 테스트 및 배포할 수 있는 소프트웨어 플랫폼이다.
<br>소프트웨어를&nbsp;컨테이너&nbsp;라는 표준화된 유닛으로 패키징하여 관리한다.<br>
2-1. 컨테이너에는 라이브러리, 시스템 도구, 코드, 런타임 등 소프트웨어를 실행하는 데 필요한 모든것이 포함되어 있다.
<br>Docker는 AWS와 협업하여 다양한 규모에서 안정적이고 저렴하게 애플리케이션을 구축, 제공할 수 있게 한다.
<br>
<br>코드, 런타임, 시스템도구 등등등 소프트웨어를 실행하는 데 필요한 모든 것을 포함하는 독립 실행형 실행 가능 패키지 이다.
<br>다른컨테이너나 호스트 시스템을 방해하지 않고, Docker runtime을 사용하여 모든 호스트에서 실행할 수 있는 소프트웨어의 격리된 단위로 설계되어있다.
<br>
<br>별도의 하드웨어 에뮬레이션 없이 리눅스 커널을 공유해 컨테이너를 실행한다.
<br>
<br>하드웨어 에뮬레이션이 없어서 매우 빠르다. 또한 하나의 머신에서 프로세스만큼 많이 실행하는 것이 가능하다.
<br>
<br>컨테이너는 호스트의 환경이 아닌 독자적인 실행환경을 갖고 있다.
<br>이 환경은 파일(Dockerfile)들로 구성되며, 공유될 수 있다.
<br>
<br>모든 이미지에는 계층이 있으며, 현재의 이미지가 적절하지 않은 경우 이전 버전으로 롤백이 가능하다.
<br>CI/CD를 수행하는 데 도움을 준다.
<br>
<br>
서버를 처음 설정할때, OS, 라이브러리, 컴파일러 등 많은 설정이 필요하고, 버전으 변경되고 업데이트 될 때 마다 다시 재설정이 필요하다. <br>
하지만, 이러한 설정 등을 도커 컨테이너 위에서 진행한다면, 호스트 OS에 아무런 영향을 주지 않는다.<br>
즉, 로컬 환경의 간섭 없이 독립적으로 구동된다! <br>
또한 다른 서버로 이사를 가는 상황에서 이미지만을 가져와 새로운 서버에 컨테이너를 만들어 쉽게 동일한 환경을 구성할 수 있다. <br>
<br>마이크로 서비스 구조로, 애플리케이션이 독립적인 구성 요소로 구축되어 각 애플리케이션 프로세스가 서비스로 실행된다.
<br>
<br>도커는 각 환경마다 쓸 수 있는 자원이 고정적으로 정해져 있지 않기 때문에, 유동적으로 자원을 할당하여 기존의 가상화 방식보다 훨씬 자원적, 성능적으로 뛰어나다
<br>]]></description><link>https://lts.kr/tools/docker/🐋-docker-란.html</link><guid isPermaLink="false">Tools/docker/🐋 docker 란.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Mon, 21 Apr 2025 07:39:44 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20250221114743.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20250221114743.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🪓 도구]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:Tools" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Tools</a> <a class="tag" href="https://lts.kr/?query=tag:모음" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#모음</a> <a class="tag" href="https://lts.kr/?query=tag:도구" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#도구</a> <br> <a href="https://lts.kr?query=tag:Tools" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Tools">#Tools</a> <a href="https://lts.kr?query=tag:모음" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#모음">#모음</a> <a href="https://lts.kr?query=tag:도구" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#도구">#도구</a><br>툴 모음
제가 사용하고 있는 편리/유용한 TOOL을 소개하고 설명하는 곳 입니다.
<br>
<br><a data-href="🍊 aws EC2란" href="https://lts.kr/tools/aws/🍊-aws-ec2란.html" class="internal-link" target="_self" rel="noopener nofollow">🍊 aws EC2란</a>
<br><a data-href="🌥 aws(EC2)셋팅부터 배포까지" href="https://lts.kr/tools/aws/🌥-aws(ec2)셋팅부터-배포까지.html" class="internal-link" target="_self" rel="noopener nofollow">🌥 aws(EC2)셋팅부터 배포까지</a>
<br><a data-href="🍌 Elastic IP(탄력적 IP)란" href="https://lts.kr/tools/aws/🍌-elastic-ip(탄력적-ip)란.html" class="internal-link" target="_self" rel="noopener nofollow">🍌 Elastic IP(탄력적 IP)란</a>
<br>
<br><a data-href="🐋 docker 란" href="https://lts.kr/tools/docker/🐋-docker-란.html" class="internal-link" target="_self" rel="noopener nofollow">🐋 docker 란</a>
<br><a data-href="📘 SpringBoot &amp; Docker + Reids 연동" href="https://lts.kr/tools/docker/📘-springboot-&amp;-docker-+-reids-연동.html" class="internal-link" target="_self" rel="noopener nofollow">📘 SpringBoot &amp; Docker + Reids 연동</a>
<br>
<br><a data-href="🏉 Jenkins란" href="https://lts.kr/tools/jenkins/🏉-jenkins란.html" class="internal-link" target="_self" rel="noopener nofollow">🏉 Jenkins란</a>
<br>
<br><a data-href="🍎 Redis로 Key관리하기" href="https://lts.kr/study/cs/🍎-redis로-key관리하기.html" class="internal-link" target="_self" rel="noopener nofollow">🍎 Redis로 Key관리하기</a>
<br><a data-href="🔐 상품 투자하기 서비스 Lock기법 개선안" href="https://lts.kr/issue_troubleshooting/🔐-상품-투자하기-서비스-lock기법-개선안.html" class="internal-link" target="_self" rel="noopener nofollow">🔐 상품 투자하기 서비스 Lock기법 개선안</a>
<br><a data-href="🔻 Redis 캐쉬 전략 - hello 서비스에 적용하여 성능개선 가능성" href="https://lts.kr/study/dev-seminar/🔻-redis-캐쉬-전략-hello-서비스에-적용하여-성능개선-가능성.html" class="internal-link" target="_self" rel="noopener nofollow">🔻 Redis 캐쉬 전략 - hello 서비스에 적용하여 성능개선 가능성</a>
<br>
<br><a data-href="🎵 Obsidian" href="https://lts.kr/tools/🎵-obsidian.html" class="internal-link" target="_self" rel="noopener nofollow">🎵 Obsidian</a>
<br><a data-href="👻 Obsidian 정적호스팅 CICD 과정" href="https://lts.kr/project/note-ci_cd/👻-obsidian-정적호스팅-cicd-과정.html" class="internal-link" target="_self" rel="noopener nofollow">👻 Obsidian 정적호스팅 CICD 과정</a>
<br>
<br>🩹추가예정!!]]></description><link>https://lts.kr/tools/🪓-도구.html</link><guid isPermaLink="false">Tools/🪓 도구.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Mon, 21 Apr 2025 07:39:42 GMT</pubDate></item><item><title><![CDATA[📘 SpringBoot &amp; Docker + Reids 연동]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:Tools" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Tools</a> <a class="tag" href="https://lts.kr/?query=tag:도커" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#도커</a> <a class="tag" href="https://lts.kr/?query=tag:Docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Docker</a> <a class="tag" href="https://lts.kr/?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <a class="tag" href="https://lts.kr/?query=tag:Boot" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Boot</a> <a class="tag" href="https://lts.kr/?query=tag:Redis" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Redis</a> <br> <a href="https://lts.kr?query=tag:Tools" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Tools">#Tools</a> <a href="https://lts.kr?query=tag:도커" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#도커">#도커</a> <a href="https://lts.kr?query=tag:Docker" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Docker">#Docker</a> <a href="https://lts.kr?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a> <a href="https://lts.kr?query=tag:Boot" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Boot">#Boot</a> <a href="https://lts.kr?query=tag:Redis" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Redis">#Redis</a> <br><img alt="Pasted image 20250221114306.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114306.png" target="_self"><br>먼저 도커에 대한 간단한 이전 글!<br>aws의 설명에 의하면 Docker란 <br>애플리케이션을 신속하게 구축, 테스트 및 배포할 수 있는 소프트웨어 플랫폼이다. <br>소프트웨어를 컨테이너 라는 표준화된 유닛으로 패키징하여 관리한다. <br><a data-tooltip-position="top" aria-label="https://docs.docker.com/desktop/install/mac-install/" rel="noopener nofollow" class="external-link is-unresolved" href="https://docs.docker.com/desktop/install/mac-install/" target="_self">도커 다운로드 링크</a><br>각 기기에 맞는 docker 버전을 다운로드 받는다.<br>
<img alt="Pasted image 20250221114324.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114324.png" target="_self"><br>다운로드 받은 후 명령어를 입력하여 docker의 현재 버전을 볼 수 있다.<br>※ 터미널에 'docker' 를 입력하게 되면 다양한 명령어들을 확인할 수 있다.<br>
<img alt="Pasted image 20250221114327.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114327.png" target="_self"><br>제대로 다운로드 받았다면 docker에 기본적으로 만들어져있는 이미지들을 확인 할수 있다. 밑에 사진은 도커 데스트톱 이라는 앱이다.<br><img alt="Pasted image 20250221114334.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114334.png" target="_self"><br>터미널에서도 확인할 수 있다.<br><img alt="Pasted image 20250221114339.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114339.png" target="_self"><br>이제&nbsp;도커 파일&nbsp;을 이용하여&nbsp;도커 이미지를 생성한 후, 이미지를 빌드하여&nbsp;컨테이너를 생성해 줄것이다.<br>여기서 여러 용어들이 나오는데...<br>용어들에 대한 설명이다<br><img alt="Pasted image 20250221114345.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114345.png" target="_self"><br><img alt="Pasted image 20250221114353.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114353.png" target="_self"><br>Dockerfile을 생성하기에 앞서, .jar 파일을 생성해야한다.<br>gradle 이나 maven 을 사용하여 프로젝트를 빌드 할것이다.<br>여기서는 Maven 을 사용한다.<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://maven.apache.org/download.cgi" target="_self">https://maven.apache.org/download.cgi</a><br>홈페이지에서 직접 다운받아도 되고, brew를 사용해 각자 다운받으면 된다.<br>이후에, 프로젝트의 루트 디렉토리에서 'mvn install' 명령어를 사용하여 프로젝트를 빌드 할 수 있다.<br><img alt="Pasted image 20250221114400.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114400.png" target="_self"><br>빌드를 마치면, 프로젝트 내에&nbsp;target이 생성 됨을 볼 수 있다.<br><img alt="Pasted image 20250221114406.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114406.png" target="_self"><br>그 후, 루트 디렉토리에 'Dockerfile' 을 생성하여 준다.<br><img alt="Pasted image 20250221114411.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114411.png" target="_self"><br><img alt="Pasted image 20250221114423.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114423.png" target="_self"><br>Dockerfile 생성시 사용되는 명령어들은 다음과 같다.<br><img alt="Pasted image 20250221114428.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114428.png" target="_self"><br>나는 기본적인 옵션만 넣어서 test 하였다.<br>FROM 태그에 나의 java(jdk)버전을 확인하여 baseimage를 지정하고<br>
( dockerRpository에서 다양한 이미지를 가져다 사용할 수 있으므로 찾아보세요)<br>ADD 태그에 maven을 통해 생성된 .jar파일과 경로를 입력한다<br>이외에 태그는 자유롭게 작성해 줄 수 있다.<br>프롬프트에 <br>docker build -t ${"도커파일 명"} ${"디렉토리"} <br>형식으로 사용할 수 있다.<br><img alt="Pasted image 20250221114434.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114434.png" target="_self"><br><img alt="Pasted image 20250221114439.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114439.png" target="_self"><br>해당 단계를 마치면 이미지가 생성된 것을 확인할 수 있다.<br>프롬프트에 <br>docker run -p ${사용할 포트번호} ${이미지 명}
<br>을 사용한다.<br>본인은 8000번 포트를 직접 사용하여 8080포트인 도커 컨테이너에 접근할 것이다.<br><img alt="Pasted image 20250221114443.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114443.png" target="_self"><br>짜잔!&nbsp; &nbsp;정상적으로 동작한다.<br>
<img alt="Pasted image 20250221114501.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114501.png" target="_self"><br>
<img alt="Pasted image 20250221114448.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114448.png" target="_self"><br>docker는 다운받아져 있는걸로 알고..&nbsp;<br>'docker pull redis:latest' 명령어를 사용하여 최신버전의 redis를 받아온다.<br><img alt="Pasted image 20250221114522.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114522.png" target="_self"><br>그 다음, <br>docker network create redis-network --driver bridge
<br>명령어를 사용하여 네트워크를 생성해 준다.<br>※ docker network : 컨테이너간의 통신 및 데이터 공유를 위한 가상 네트워크<br><img alt="Pasted image 20250221114527.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114527.png" target="_self"><br>이제, 'sudo vim redis.conf' 명령어를 사용하여 redis.conf 파일을 수정하여 설정을 잡아준다.<br><img alt="Pasted image 20250221114531.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114531.png" target="_self"><br>docker run \ -d \ --name redis \ -p 6379:6379 \ --network redis-network \ -v ~/${데이터를 저장할 파일 경로} /redis.conf:/etc/redis/redis.conf \ -v redis_data:/data \
redis:latest redis-server /etc/redis/redis.conf
<br><img alt="Pasted image 20250221114535.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114535.png" target="_self"><br>포트번호와, 방금 설정한 네트워크, 데이터 저장 경로를 잡아준다.<br>이렇게 설정을 마쳤으면 redis 이미지가 생성되었음을 확인할 수 있다.<br><img alt="Pasted image 20250221114539.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114539.png" target="_self"><br>최종적으로 생성된 이미지로 컨테이너를 만들어 준다.<br><img alt="Pasted image 20250221114543.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114543.png" target="_self"><br>docker run --name myredis \ -p 6379:6379 \ --network redis-network \ -v /Users/lts/Desktop/docker/redis:/data \ -d redis:latest redis-server \ --appendonly yes
<br><img alt="Pasted image 20250221114600.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114600.png" target="_self"><br>컨테이너까지 생성완료!<br>docker exec -it myredis redis-cli --raw
<br>명령어를 사용하여 컨테이너 실행<br><img alt="Pasted image 20250221114605.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114605.png" target="_self"><br>프롬프트를 보면 정상적으로 접속됨을 확인할 수 있다.<br>※ 해당 프로젝트는 Maven 을 사용한 프로젝트이다.<br>spring.cache.type=redis
spring.redis.host=localhost
spring.redis.port=6379
<br><img alt="Pasted image 20250221114610.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114610.png" target="_self"><br><img alt="Pasted image 20250221114616.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114616.png" target="_self"><br>import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.serializer.StringRedisSerializer; @Configuration
public class RedisConfig { @Value("${spring.redis.host}") private String host; @Value("${spring.redis.port}") private int port; @Bean public LettuceConnectionFactory redisConnectionFactory() { return new LettuceConnectionFactory(host, port); } @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate() { RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.setValueSerializer(new StringRedisSerializer()); redisTemplate.setConnectionFactory(redisConnectionFactory()); return redisTemplate; } @Bean public StringRedisTemplate stringRedisTemplate() { final StringRedisTemplate stringRedisTemplate = new StringRedisTemplate(); stringRedisTemplate.setKeySerializer(new StringRedisSerializer()); stringRedisTemplate.setValueSerializer(new StringRedisSerializer()); stringRedisTemplate.setConnectionFactory(redisConnectionFactory()); return stringRedisTemplate; }
}
<br><img alt="Pasted image 20250221114621.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114621.png" target="_self"><br>import lombok.AllArgsConstructor; import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.Id;
import org.springframework.data.redis.core.RedisHash;
import org.springframework.data.redis.core.index.Indexed; import java.time.LocalDateTime; @Getter
@RedisHash(value = "resultHistory", timeToLive = 3600) // Redis Repository 사용을 위한
@AllArgsConstructor
@NoArgsConstructor
public class ResultHistory { @Id private String id; @Indexed // 필드 값으로 데이터를 찾을 수 있도록 설정 (findByAccessToken) private String ip; private String originalText; private String translatedText; @Indexed private LocalDateTime createDateTime; @Builder public ResultHistory(String ip, String originalText, String translatedText, LocalDateTime createDateTime) { this.ip = ip; this.originalText = originalText; this.translatedText = translatedText; this.createDateTime = createDateTime; }
}
<br><img alt="Pasted image 20250221114628.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114628.png" target="_self"><br>import com.teamTS.funfun.model.ResultHistory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository; import java.util.List;
import java.util.Optional; @Repository
public interface ResultRedisRepository extends JpaRepository&lt;ResultHistory, String&gt; { Optional&lt;List&lt;ResultHistory&gt;&gt; findByIpOrderByCreateDateTimeAsc(String ip);
}
<br><img alt="Pasted image 20250221114633.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114633.png" target="_self"><br> @GetMapping("/hello") public String HelloWorld(Model model) { redisConnectionTest(); List&lt;TestModel&gt; tm = testRepository.getTestData(); model.addAttribute("data", tm.get(0).getTitle()); return "home/homeView"; } void redisConnectionTest() { final String key = "a"; final String data = "1"; final ValueOperations&lt;String, String&gt; valueOperations = redisTemplate.opsForValue(); valueOperations.set(key, data); final String s = valueOperations.get(key); } }
<br><img alt="Pasted image 20250221114638.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114638.png" target="_self"><br>Error starting ApplicationContext. To display the condition evaluation report re-run your application with 'debug' enabled.
<br>원인은 기존 MapperRepository와 Redis용 JpaRepository에서<br>@Repository
<br>해당 어노테이션을 사용하여 충돌한듯 하다.<br>
이럴때는<br>spring.main.allow-bean-definition-overriding=true
<br>한 줄을 추가하여 준다.<br><img alt="Pasted image 20250221114644.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114644.png" target="_self"><br>성공적인 실행.<br><img alt="Pasted image 20250221114648.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114648.png" target="_self"><br>&nbsp;이후 ' keys * ' 명령어를 사용하여 데이터가 정상적으로 추가된 것을 확인할 수 있다.<br>]]></description><link>https://lts.kr/tools/docker/📘-springboot-&amp;-docker-+-reids-연동.html</link><guid isPermaLink="false">Tools/docker/📘 SpringBoot &amp; Docker + Reids 연동.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Mon, 21 Apr 2025 07:39:42 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20250221114306.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20250221114306.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3.1 스프링 컨테이너 생성]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:SpringCoreBasic" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SpringCoreBasic</a> <a class="tag" href="https://lts.kr/?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <a class="tag" href="https://lts.kr/?query=tag:lectur" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#lectur</a> <a class="tag" href="https://lts.kr/?query=tag:강의" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#강의</a> <a class="tag" href="https://lts.kr/?query=tag:컨테이너" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#컨테이너</a> <a class="tag" href="https://lts.kr/?query=tag:Bean" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Bean</a> <a class="tag" href="https://lts.kr/?query=tag:빈" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#빈</a> <br> <a href="https://lts.kr?query=tag:SpringCoreBasic" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SpringCoreBasic">#SpringCoreBasic</a> <a href="https://lts.kr?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a> <a href="https://lts.kr?query=tag:lectur" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#lectur">#lectur</a> <a href="https://lts.kr?query=tag:강의" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#강의">#강의</a> <a href="https://lts.kr?query=tag:컨테이너" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#컨테이너">#컨테이너</a> <a href="https://lts.kr?query=tag:Bean" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Bean">#Bean</a> <a href="https://lts.kr?query=tag:빈" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#빈">#빈</a><br>//스프링 컨테이너 생성
ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
<br>ApplicationContext 를 스프링 컨테이너라 한다. ApplicationContext 는 인터페이스이다. <br>스프링 컨테이너는 XML을 기반으로 만들 수 있고, 애노테이션 기반의 자바 설정 클래스로 만들 수 있다. <br>자바 설정 클래스를 기반으로 스프링 컨테이너(ApplicationContext)를 만들어보자. <br>new AnnotationConfigApplicationContext(AppConfig.class);<br>
-&gt; 이 클래스는 ApplicationContext 인터페이스의 구현체이다.]]></description><link>https://lts.kr/lectur/3.1-스프링-컨테이너-생성.html</link><guid isPermaLink="false">lectur/3.1 스프링 컨테이너 생성.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Mon, 21 Apr 2025 05:20:07 GMT</pubDate></item><item><title><![CDATA[🥇 정보처리 기사 실기 키워드]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:정보처리기사" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정보처리기사</a> <a class="tag" href="https://lts.kr/?query=tag:실기" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#실기</a> <a class="tag" href="https://lts.kr/?query=tag:키워드" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#키워드</a> <a class="tag" href="https://lts.kr/?query=tag:정리" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정리</a> <br> <a href="https://lts.kr?query=tag:정보처리기사" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정보처리기사">#정보처리기사</a> <a href="https://lts.kr?query=tag:실기" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#실기">#실기</a> <a href="https://lts.kr?query=tag:키워드" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#키워드">#키워드</a> <a href="https://lts.kr?query=tag:정리" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정리">#정리</a><br>
<br>시제품을 끊임없이 제작하며 사이클을 반복하는 개발 방법론
<br>워터폴과 대조적이며, 소프트웨어 개발을 넘어 기업 경영 전반에서 사용되고 있다.
<br>고객의 변화하는 요구사항과 환경 변화에 능동적인 소프트웨어 개발 방법론
<br>
<br>소프트웨어 공학에서 리펙토링(Refactoring)을 하는 목적에 대해 간략히 서술하시오.
<br>
리펙토링의 목적은 프로그램을 쉽게 이해하고 수정하여 빠르게 개발할 수 있도록 하기 위함이다.
<br>
<br>( 1 ) 요구사항은 시스템이 무엇을 하는지, 어떤 기능을 하는지 등 사용자가 시스템을 통해 제공받기를 원하는 기능이나 시스템이 반드시 수행해야하는 기능을 의미한다.
<br>( 2 ) 요구사항은 품질이나 제약사항과 관련된 요구사항으로, 시스템의 장비 구성, 성능, 인터페이스, 테스트, 보안 등의 요구사항을 말한다.
<br>
<br>UML에 관한 다음 괄호에 공통으로 들어갈 알맞은 용어는?
<br>( ) 다이어그램은 UML다이어그램중 객체(Object)들을 ( )로 추상화하여 표현하는 다이어그램으로, 대표적인 구조적 다이어그램이다.
<br>( )는 각각의 객체들이 갖는 속성과 메소드를 표현한 것으로 3개의 구획으로 나눠 이름, 속성, 메서드를 표기한다.
<br>
<br>UML은 시스템 분석, 설계, 구현 등 시스템 개발 과정에서 시스템 개발자와 고객 또는 개발자 상호 간의 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어로 사물, ( 1 ), 다이어그램 으로 이루어져있다.
<br>( 1 )는 사물과 사물사이의 연관성을 표현하는 것으로 연관, 집합, 포함, 일반화 등 다양한 형태의 ( 1 )가 존재한다.
<br>( 2 )는 UML에 표현되는 사물의 하나로, 객체가 갖는 속성과 동작을 표현한다. 일반적으로 직사각형으로 표현하며, 직사각형 안에 이름, 속성, 동작을 표기한다.
<br>( 3 )는 ( 2 )와 같은 UML에 표현되는 사물의 하나로, ( 2 )나 컴포넌트의 동작을 모아놓은 것이며, 외부적으로 가시화되는 행동을 표현한다. 단독으로 사용되는 경우는 없으며, ( 3 )구현을 위한 ( 2 )또는 컴포넌트와 함께 사용된다.
<br>
<br>관계(Relationship)는 사물과 사물 사이의 연관성을 표현하는 것이다.
<br>1 - 하나의 사물이 다른 사물에 포함되어 있는 관계로, 전체와 부분으로 구분되어지며, 서로 독립적이다.
<br>2 - 상위 모듈이 하위 모듈보다 더 일반적인 개념을 가지고 있으며, 하위 모듈이 상위 모듈보다 더 구체적인 개념을 가진다.
<br>
[보기]<br>
-Association(연관 관계) : 객체간의 기본적인 관계를 나타낸다.<br>
-Dependency(의존 관계) : 한 객체가 다른 객체에 의존하거나 영향을 받는다.<br>
-Aggregation(집합 관계) : 부분과 전체의 관계를 나타내며, 부분이 독립적으로 존재할 수 있는 경우를 말한다.<br>
-Realization(실체화 관계) : 인터페이스와 이를 구현하는 클래스 간의 관계<br>
-Composition(합성 관계) : 집합관계의 특수한 형태로, 부분이 전체와 생명 주기를 공유하며 독립적으로 존재할 수 없는 경우<br>
-Generalization(일반화 관계) : 상위 클래스와 하위 클래스 간의 관계로, 상속을 통해 일반적인 특성을 공유한다.
<br>
<br>UML을 이용한 다이어그램 중 다음 그림에 해당하는 다이어그램을 쓰시오.
<br>[ ] &lt;&lt;import&gt;&gt; [Security]
Order ----------------&gt; +(Credentials) / ( ) +(MDSCrupt)
<br>
<br>LOC기법에 의하여 예측된 총 라인 수가 30,000라인, 개발에 참여할 프로그래머가 5명, 프로그래머들의 평균 생산성이 월간 300라인일 때 개발에 소요되는 기간을 계산식과 함께 쓰시오.
<br>
<br>데이터베이스 스키마(Schema)에 대해 간략히 서술하시오.
<br>
스키마는 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 것이다.
<br>
<br>DB 설계에 대한 설명. 괄호를 채우시오
<br>( 1 ) : 논리적 구조로 표현된 데이터를 디스크 등의 저장장치에 저장할 수 있는 데이터로 변환하는 과정으로, 파일의 저장 구조 및 엑세스 경로를 결정하며, 테이블 정의서 및 명세서가 산출된다.
<br>( 2 ) : 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정으로, 개념 스키마 모델링과 트렌젝션 모델링을 수행하며, 요구 조건 명세를 E-R 다이어그램으로 작성한다.
<br>( 3 ) : 현실의 자료를 특정 DBMS가 지원하는 자료구조로 변환하는 과정으로, 트렌젝션의 인터페이스를 설계하고, 정규화를 통해 스키마를 평가 및 정제한다.
<br>
<br>다음은 데이터베이스 구축까지의 과정을 나열한 것이다. 순서대로 괄호를 채우시오. 요구분석 → ( ) → ( ) → ( ) → 구현 <br>
<br>데이터 모델이 구성 요소에 대한 다음 설명에서 괄호(1, 2)에 들어갈 용어를 쓰시오
<br>( 1 )은 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세서로서 데이터베이스를 조작하는 기본 도구에 해당된다.
<br>( 2 )는 논리적으로 표현된 객체 타입들 간의 관계로서 데이터의 구성 및 정적 성질을 표현한다.
<br>제약조건은 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건을 의미한다.
<br><img alt="do-messenger_screenshot_2025-02-10_15_04_45.png" src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-02-10_15_04_45.png" target="_self"><br>
-다음 E-R다이어그램을 참고하여 괄호(1~5)의 설명에 적합한 요소를 찾아 기호로 표시<br>( 1 ) : 관계 집합을 의미한다.
<br>( 2 ) : 관계 집합과 속성을 연결한다.
<br>( 3 ) : 개체 집합을 의미하며, 키로 사용되는 항목에는 밑줄을 표시한다.
<br>( 4 ) : 관계 집합의 속성을 의미한다.
<br>( 5 ) : 개체 집합과 집합을 연결한다.
<br>
1 → ㄴ<br>
2 → ㄷ<br>
3 → ㄱ<br>
4 → ㄹ<br>
5 → ㅁ
<br>-키(Key)에 대한 다음 설명에서 괄호(1, 2)에 들어갈 용어를 쓰시오.<br>키는 데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 기준이 되는 속성을 말한다.
<br>슈퍼키는 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키로, 릴레이션을 구성하는 모든 튜플에 대해 ( 1 )을 만족한다.
<br>후보키(Candidate Key)는 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해 사용되는 속성들의 부분집합으로, ( 1 )과 ( 2 )을 만족하는 특징이 있다.
<br>
<br>
관계대수란 관계형 데이터베이스에서 원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절차적인 언어이다. 관계 대수에 사용되는 연산은 다음과 같다. <br>
합집합(UNION)은 두 릴레이션에 존재하는 튜플의 합집합을 구하되, 결과로 생성된 릴레이션에서 중복되는 튜플은 제되는 연산으로, 기호는 ( 1 )이다. <br>
차집합(DIFFERENCCE)은 두 릴레이션에 존재하는 튜플의 차집합을 구하는 연산으로, 사용하는 기호는 ( 2 )이다. <br>
교차곱(CARTESIAN PRODUCT)은 두 릴레이션에 있는 튜플들의 순서쌍을 구하는 연산으로, 사용하는 기호는 ( 3 )이다. <br>
프로젝트(PROJECT)는 주어진 릴레이션에서 속성 리스트(Attribute List)에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 연산으로, 사용하는 기호는 ( 4 )이다. <br>
조인(JOIN)은 공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산으로, 사용하는 기호는 ( 5 )이다. <br>
1 → U<br>
2 → ㅡ<br>
3 → x<br>
4 → ㅠ<br>
5 → |&gt;&lt;|
<br>
<br>릴레이션 A, B가 있을 때, 릴레이션 B의조건에 맞는 것들만 릴레이션 A에서 분리하여 프로젝션을 하는 연산은?
<br>
<br>( )은 관계 데이터의 연산을 표현하는 방법으로, 관계 데이터 모델의 제안자인 코드(E. F. Codd)가 수학의 술어 해석(Predicate Calculus)에 기반을 두고 관계 데이터베이스를 위해 제안했다.
<br>원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성을 지니며, 원하는 정보를 정의할 때 계산 수식을 사용한다.
<br>튜플 해석식을 사용하는 튜플 ( )과 도메인 해석식을 사용하는 도메인 ( )으로 구분된다.
<br>
<br>데이터의 중복으로 인해 테이블 조작 시 문제가 발생하는 현상을 이상(Anomaly)이라고 한다. 이상 중 삭제 이상(Deletion Anomaly)에 대해 간략히 서술하시오.
<br>
테이블에서 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는 현상.
<br>
<br>데이터베이스의 이상(Anomaly)의 종류 3가지를 쓰시오.
<br>
삽입 이상(Insertion Anomaly)<br>
삭제 이상(Deletion Anomaly)<br>
갱신 이상(Update Anomaly)
<br><img alt="do-messenger_screenshot_2025-02-10_17_10_58.png" src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-02-10_17_10_58.png" target="_self"><br>테이블 &lt;R&gt;에서 성적은 기본키인 {학생, 학과}에 대해 ( 1 ) Functional Dependency이다.
<br>테이블 &lt;R&gt;에서 학년은 기본키인 {학생, 학과} 중 학생만으로 식별이 가능하므로 기본키에 대해 ( 2 ) Functional Dependency이다.
<br>임이의 테이블에 속성 A, B, C가 있을 떄, A → B이고 B → C일 때 A → C인 관계는 ( 3 )Functional Dependency이다.
<br> <br>Full - 완전 함수 종속
<br>Partial - 부분 함수 종속
<br>Transitive - 이행적 함수 종속 <br>
<br>데이터베이스에서 비(반)정규화(Denormalization)의 개념을 서술하시오.
<br>
비정규화는 정규화된 데이터 모델을 통합, 중복, 분리 하는 과정으로, 의도적으로 정규화 원칙을 위배하는 행위이다.
<br>
<br>데이터베이스의 상태 변화를 일으키는 트렌젝션(Transaction)의 특성
<br> <br>원자성 : <br>트렌젝션의 연산은 데이터베이스에 모두 반영되도록 완료(Commit)되든지 아니면 전혀 반영되지 않도록 복구(Rollback)되어야 한다. <br>일관성 : <br>트렌젝션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다. <br>독립성 : <br>둘 이상의 트렌젝션이 동시에 병행 실행되는 경우 어느 하나의 트렌젝션 실행중에 다른 트렌젝션의 연산이 끼어들 수 없다. <br>지속성 <br>성공적으로 완료된 트렌젝션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다. <br>
<br>파일의 구조는 파일을 구성하는 레코드들이 보조기억장치에 편성되는 방식을 의미하는 것으로, 크게 순차, ( ), 해싱으로 구분한다.
<br>( ) 파일 구조는 &lt;값, 주소&gt; 쌍으로 구성되는 데이터 구조를 활용하여 데이터에 접근하는 방식으로, 자기 디스크서 주로 활용된다.
<br>
<br>비상 상황이 발생한 경우 비상사태 또는 업무중단 시점부터 업무가 복구되어 다시 정상 가동 될 때까지의 시간을 의미한다.
<br>
<br>접근통제는 데이터가 저장된 객체와 이를 사용하려는 주체 사이의 정보 흐름을 제한하는 것이다. 이러한 접근통제에 관한 기술 중 ( )는 데이터에 접근하는 사용자의 신원에 따라 접근 권한을 부여하여 제어하는 방식으로, 데이터의 소유자가 접근통제 권한을 지정하고 제어한다.
<br>객체를 생성한 사용자가 생성된 객체에 대한 모든 권한을 부여받고, 부여된 권한을 다른 사용자에게 허가할 수도 있다.
<br>
<br>DBMS는 데이터베이스에 치명적인 손실이 발생했을 때 이를 복구하기 위해 데이터베이스의 처리내용이나 이용 상황 등 상태 변화를 시간의 흐름에 따라 기록한 로그를 생성한다.
<br>( 1 ) : 데이터베이스가 비정상적으로 종료되었을 때, 디스크에 저장된 로그를 분석하여 트렌젝션의 시작(start)과 완료(commit)에 대한 기록이 있는 트렌젝션들의 작업을 재작업 한다. 즉, 로그를 이용하여 해당 데이터 항목에 대해 이전 값을 이후값으로 변경하는 연산이다.
<br>( 2 ) : 데이터베이스가 비정상적으로 종료되었을 때, 디스크에 저장된 로그를 분석하여 트렌젝션의 시작을 나타는 'start'는 있지만 완료를 나타내는 'commit' 기록이 없는 트렌젝션들이 작업한 내용들을 모두 취소한다. 즉 로그를 이용하여 해당 데이터 항목에 대해 이후 값을 이전 값으로 변경한다.
<br>
<br>웹 페이지의 기본 형식인 HTML의 문법이 각 웹 브라우저에서 상호 호환적이지 못한다는 문제와 SGML의 복잡함을 해결하기 위하여 개발된 ( )은 다른 특수한 목적을 갖는 마크업 언어이다.
<br>원활한 데이터의 연계를 위해 송.수신 시스템 간에 전송되는 데이터가 동일한 구조로 구성될 수 있도록 형태를 정의는 역할을 수행하며, 다음과 같은 특징이 있다.
<br>
<br>텍스트 데이터 형식으로 유니코드를 사용하여 전 세계 언어를 지원한다.
<br>
<br>대다수의 웹 브라우저가 해석을 위한 번역기(Parser)를 내장하고 있다.
<br>
<br>XML문서의 문자들은 마크업과 내용으로 구분된다.
<br>일반적으로 마크업은 &lt;로 시작하여 &gt;로 끝나는 태그(Tag)를 의미하고, 그 외의 문자열은 내용에 해당한다.
<br>
<br>마크업과 내용으로 이루어지는 하나의 요소를 의미한다.
<br>
<br>통합 구현과 관련하여 다음 설명의 괄호에 공통으로 들어갈 알맞은 용어는?
<br>( )는 HTTP, HTTPS, SMTP 등을 사용하여 xml 기반의 메시지를 네트워크상에서 교환하는 프로토콜이다.
<br>( ) envelope, 헤더, 바디 등이 추가된 xml 문서이다.
<br>( )는 복잡하고 무거운 구조로 구성되어 있어, ( )보다는 RESTful 프로토콜을 이용하기도 한다.
<br>
<br>웹 서비스와 관련된 다음 설명에 해당되는 용어는?
<br>웹 서비스와 관련된 서식이나 프로토콜 등을 표준적인 방법으로 기술하고 게시하기 위한 언어.
<br>XML로 작성되며 UDDI의 기초가 된다. SOAP, XML 스키마와 결합하여 인터넷에서 웹 서비스를 제공하기 위해 사용되며, 클라이언트는 이것을 통해 서버에서 어떠한 조작이 가능한지를 파악할 수 있다.
<br>Tip!
XML에서 언어이면 WSDL / 프로토콜이면 SOAP
<br>다음 럼바우 데이터 모델링에 대한 설명에서 각 지문(1~3)에 해당하는 모델링을 매칭시키기<br>ㄱ. 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링<br>
ex) 자료흐름도(DFD)<br>ㄴ. 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링<br>
ex) 상태 변화도(STD), 사건 추적도<br>ㄷ. 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 표시하는 모델링<br>
ex) ER 다이어그램(ERD)<br>
1 → Function(기능)<br>
2 → Dynamic(동적)<br>
3 → Information(객체) <br>
<br>자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다는 객체지향 설계 원칙 중 하나다.
<br>예를 들어 프린터, 펙스, 복사 기능을 가진 복합기의 경우 3가지 기능을 모두 가지 범용 인터페이스보다는, 프린터 인터페이스, 팩스 인터페이스, 복사 인터페이스로 분리함으로써 하나의 기능 변경으로 인해 다른기능이 영향을 받지 않도록 해야한다.
<br>
<br>결합도(Coupling)의 종류 중 단순 처리 대상인 데이터만 전달되는 것이 아니라, 어떻게 처리해야 하는지를 결정하는 제어 요소가 전달되는 경우의 결합도를 영문으로 쓰면?
<br>
<br>( 1 )는 모듈간의 인터페이스로, 데이터,지역변수 등을 직접 참조하거나 수정할 때의 결합도다.
<br>( 2 )는 모듈간의 인터페이스로, 배열이나 레코드 등의 자료구조가 전달될 때의 결합도다.
<br>( 3 )는 모듈간의 인터페이스로, 파라미터가 아닌 모듈 밖에 선언된 전역 변수를 사용하여 전역 변수를 갱신하는 방식으로 상호작용하는 때의 결합도다.
<br>
1 → 내용 결합도<br>
2 → 스탬프 결합도<br>
3 → 공통 결합도
<br>
<br>내부의 요소들이 기능적으로 연관성은 없으나, 순차적으로 실행될 때의 응집도 <br>서로 다른 기능을 수행하지만 동일한 입력과 출력을 사용할 때의 응집도 <br>하나의 기능에 밀접하게 관련되어 있거나 연관되어 있을 때의 응집도 <br>우연적 응집도 &lt; 논리적 응집도 &lt; 시간적 응집도 &lt; 절차적 응집도 &lt; 통신적 응집도 &lt; 순차적 응집도 &lt; 기능적 응집도<br>기능적 응집도(Functional Cohesion) <br>모듈 내부의 모든 기능이 단일한 목적을 위해 수행되는 경우 <br>순차적 응집도(Sequential Cohesion) <br>모듈 내의 한 활동으로부터 나온 출력값을 모듈 내의 다른 활동이 사용할 경우 <br>교환적 응집도(Communicational Cohesion) <br>서로 다른 기능을 수행하지만 동일한 입력과 출력을 사용하는 활동들이 모여있을 경우 <br>절차적 응집도(Procedural Cohesion) <br>모듈 안의 구성요소들이 서로 다른 기능을 하지만 그 기능을 순차적으로 수행할 경우 <br>시간적 응집도(Temporal Cohesion) <br>연관된 기능이라기 보단 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리할 경우 <br>논리적 응집도(Logical Cohesion) <br>실제와 달리 논리적으로만 같은 그룹으로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우 <br>우연적 응집도(Coincidental Cohesion) <br>모듈 내부의 각 구성요소들이 연관이 없을 경우 <br>
1 → 절차적 응집도<br>
2 → 교환적 응집도<br>
3 → 기능적 응집도
<br>
<br>모듈간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합이다.
<br>복수의 프로세스를 수행하며 이뤄지는 프로세스 간 통신까지 구현이 가능하다.
<br>대표적인 메소드에는 공뮤 메모리(Shared Memory), 소켓, 세마포어, 파이프와 네임드 파이프, 메세지 큐잉이 있다.
<br>IPC(Inter-Process Communication)<br>
<br>( )패턴은 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴이다.
<br>상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당한다.
<br>다른 이름으로는 가상 생성자(Virtual Constructor) 패턴 이라고도 한다.
<br>Factory Method 패턴<br>
<br>( 1 )패턴은 구현부에서 추상층을 분리하여, 서로가 독립적으로 확장할 수 있도록 구성한 패턴으로, 기능과 구현을 두 개의 별도 클래스로 구현한다는 특징이 있다.
<br>( 2 )패턴은 한 객체의 상태가 변화하면 객체의 상속된 다른 객체들에게 변화된 상태를 전달하는 패턴으로, 일대다의 의존성을 정의한다. 주로 시스템 간에 이벤트를 생성.발행(Publish)하고, 이를 수신(Subscribe)해야할 떄 이용된다.
<br>
1 → Bridge 패턴<br>
2 → Observer 패턴
<br>
<br>디자인 패턴은 모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예젤를 의미한다. <br>그 중 ( )패턴은 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴으로, Interpreter, Observer, Command 등이 그 예에 해당한다.
<br>디자인 패턴(Design Patterns) : GoF(생 구 행) <br>&nbsp; 1.&nbsp;생성(Creational) : 객체 생성 과정 캡슐화(싱 팩 추 빌 프)<br>
-싱글톤(Singleton) : 1객체<br>
-팩토리 메서드(Factory Method) : 책임 위임<br>
-추상 팩토리(Abstract Factory) : 여러 객체그룹 생성<br>
-빌더(Builder) : 생성 단계 캡슐화<br>
-프로토타입(Prototype) : 원본 객체 복사<br>&nbsp; 2.&nbsp;구조(Structural) : 클래스 객체 조합(어 데 퍼 프 브 컴 플)<br>
-어댑터(Adapter) : 클래스 연결<br>
-데코레이터(decorator) : 소스 변경X, 기능확장<br>
-퍼사드(Facade) : 단순화된 1인터페이스 제공<br>
-프록시(Proxy) : 원 객체작업 대신처리 / 대리<br>
-브릿지(Bridge) : 구현부 추상층 분리, 독립적 확장, 결합도 낮춤<br>
-컴포지트(Composite) : 개별 객체와 복합 객체를 동일 / 트리<br>
-플라이웨이트(Flyweight) : 공유<br>&nbsp; 3.&nbsp;행동(Behavioral) : 상호작용, 역할분담(옵 스 커 템 스 메 중 인 방 책 이)<br>
-옵저버(Observer) : 다른객체 알림 및 자동갱신<br>
-스트래티지(Strategy) : 알고리즘 캡슐화<br>
-커맨드(Command) : 요청을 객체로 캡슐화<br>
-템플릿 메서드(Template Method) : 구조 - 상위 / 구현 - 하위<br>
-스테이트(State) : 객체 상태에 따라 다른 행동 / 다형성<br>
-메멘토(Memento) : 객체상태 미리 저장 후 복구<br>
-중재자(Mediator) : 객체간 상호작용 조정<br>
-인터프리터(Interpreter) : 문법 정의 및 구문 해석<br>
-방문자(Visitor) : 객체 구조 및 처리기능 분리 / 캡슐화 위배<br>
-책임 연쇄(Chain of Responsibility) : 객체간 연결고리 / 연속적<br>
-이터레이터(Iterator) : 순차적 접근 / 반복 캡슐 / Cursor<br>&nbsp;&nbsp;&nbsp; <br>행위(Behavioral)<br>
<br>기업 내 각종 어플리케이션 및 플랫폼 간의 정보 전달, 연계, 통합 등 상호 연동이 가능하게 해주는 솔루션.
<br>Point-to-Point, Hub&amp;Spoke, Message Bus, Hybrid 등의 다양한 방식으로 구축이 가능한 모듈 연계 방법.
<br>EAI(Enterprise Application Integration)<br><img alt="do-messenger_screenshot_2025-02-11_13_47_16.png" src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-02-11_13_47_16.png" style="width: 900px; max-width: 100%;" target="_self"><br>EAI(Enterprise Application Integration)는 기업 내 비즈니스 간 통합 및 연계성을 증대시켜 효율성 및 각 시스템 간의 확정성(Determinacy)을 높여 준다. EAI의 구축 유형은 위와 같다.
<br>
1 → Point-to-Point<br>
2 → Hub &amp; Spoke
<br>
<br>네트워크 트래픽에 대해 IP(Internet Protocol) 계층에서 IP패킷 단위의 데이터 변조 및 은닉 기능을 제공하는 네트워크 계층에서의 보안 통신 규약을 쓰시오.
<br>IPSec(Internet Protocol Security)<br>
<br>Kent Beck과 Erich Gamma 등이 개발한 자바 프로그래밍 언어용 유닛 테스트 프레임워크.
<br>xUnit계열의 한 종류이다. 같은 테스트 코드를 여러 번 작성하지 않게 도와주며, 테스트마다 예상 결과를 기억 할 필요가 없는 자동화된 해법을 제공한다.
<br>JUnit<br>
<br>사용자 인터페이스 UI(User Interface)의 설계 원칙
<br>
직관성 : 누구나 쉽게 이해하고 사용할 수 있어야 한다<br>
유효성 : 사용자의 목적을 정확하고 완벽하게 달성해야 한다<br>
학습성 : 누구나 쉽게 배우고 익힐 수 있어야 한다<br>
유연성 : 사용자의 요구사항을 최대한 수용하고 실수를 최소화해야 한다
<br>
<br>애플리케이션 테스트에서 사용되는 살충제 패러독스(Pesticide Paradox)의 개념을 간략히 설명
<br> <br>살충제 패러독스는 동일한 테스트 케이스로 동일한 테스트를 반복하면 더 이상 결함이 발견되지 않는 현상을 의미한다. <br>
<br>테스트에 대한 다음 설명에서 각 (1~3)에 해당되는 커버리지(기준)을 찾으시오.
<br>최소 한번은 모든 문장이 수행되도록 구성하는 검증 기준
<br>조건식이 참 / 거짓일 때 수행되도록 구성하는 검증 기준
<br>2번과 달리 조건식에 상관없이 개별 조건이 참 / 거짓일 때 수행되도록 구성하는 검증기준
<br>
1 → 구문(문장) 커버리지<br>
2 → 결정(분기) 커버리지<br>
3 → 조건 커버리지
<br>
<br>소프트웨어가 수행할 특정 기능을 알기 위해서 각 기능이 완전히 작동되는 것을 입증하는 테스트.
<br>동치 클래스 분해 및 경계값 분석을 이용하는 테스트 기법이다.
<br><img alt="do-messenger_screenshot_2025-02-11_15_32_34.png" src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-02-11_15_32_34.png" target="_self"><br>다음 중 블랙박스 테스트에 속하는 녀석들은?
<br>
경계값 분석(Boundary Value Analysis)<br>
입력값의 경계 부분(최소, 최대값 등)에서 오류가 발생할 가능성이 높다는 점을 이용하여 테스트하는 기법<br>
동등(동치) 분할(Equivalence Partitioning)<br>
입력값을 유사한 동작을 하는 그룹으로 나누고 각 그룹에서 대표값을 선택해 테스트하는 기법<br>
원인-결과 그래프(Cause-Effect Graph)<br>
그래프를 활용하여 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한 다음 효용성이 높은 테스트 케이스를 선정하여 검사하는 기법
<br>
<br>테스트 기법 중 다음과 같이 평가 점수표를 미리 정해 놓은 후 각 영역에 해당하는 입력 값을 넣고, 예상되는 출력값이 나오는지 실제 값과 비교하는 명세 기밥 테스트 기법을 쓰시오.
<br><img alt="do-messenger_screenshot_2025-02-11_16_31_10.png" src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-02-11_16_31_10.png" style="width: 1025px; max-width: 100%;" target="_self"><br>개발 단계에 따른 애플리케이션 테스트에 대한 다음 V-모델에서 (1~4)에 들어갈 알맞은 테스트를 작성하시오.
<br>
1 → 단위 테스트(Unit Test)<br>
- 코딩 직후 소프트웨어 설계의 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 수행하는 테스트<br>
2 → 통합 테스트(Integration Test)<br>
- 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트<br>
3 → 시스템 테스트(System Test)<br>
4 → 인수 테스트(Acceptance Test)
<br>
<br>인수 테스트는 개발한 소프트웨어가 사용자의 요구사항을 충족하는지에 중점을 두고 테스트한다.
<br>( 1 ) : 선정된 최종 사용자가 여러 명의 사용자 앞에서 행하는 테스트 기법으로, 실제 업무를 가지고 사용자가 직접 테스트한다.
<br>( 2 ) : 개발자의 장소에서 사용자가 개발자 앞에서 행하는 테스트 기법으로, 테스트는 통제된 환경에서 행해지며, 오류와 사용상의 문제점을 사용자와 개발자가 함께 확인하면서 기록한다.
<br>
1 → 베타 테스트(Beta Test)<br>
2 → 알파 테스트(Alpha Test)
<br>
<br>통합 테스트 기법 중, 두 방법에 대한 설명이다.
<br>상향식 통합 테스트는 미완성이거나 문제가 있는 상위 모듈을 대체할 수 있는 테스트 드라이버가 있다.
<br>하향식 통합 테스트는 미완성이거나 문제가 있는 하위 모듈을 대체할 수 있는 테스트 ( )가 있어야 한다.
<br>
<br>통합 테스트로 인해 변경된 모듈이나 컴포넌트에 새로운 오류가 있는지 확인하는 테스트.
<br>이미 테스트된 프로그램의 테스팅을 반복하는 것이다.
<br>수정한 모듈이나 컴포넌트가 다른 부분에 영향을 미치는지, 오류가 생기지 않았는지 테스트하여 새로운 오류가 발생하지 않음을 보증하기 위해 반복 테스트한다.
<br>
<br>특정한 몇몇 테스트 케이스의 입력 값들에 대해서만 기대하는 결과를 제공하는 오라클로, 전수 테스트가 불가능한 경우 사용하고, 경계값 및 구간별 예상값 결과 작성시 사용하는 오라클은?
<br>
<br>애플리케이션 성능 측정의 지표에 대한 다음 설명을 채우십시오<br>
( 1 ) - 일정 시간 내에 애플리케이션이 처리하는 일의 양을 의미한다.<br>
( 2 ) - 애플리케이션에 요청을 전달한 시간부터 응답이 도착할 때까지 걸린 시간을 의미한다.<br>
( 3 ) - 애플리케이션에 작업을 의뢰한 시간부터 처리가 완료될 떄까지 걸린 시간을 의미한다.<br>
자원 활용률 - 애플리케이션이 의뢰한 작업을 처리하는 동안의 CPU, 메모리, 네트워크 등의 자원 사용률을 의미.
<br>
1 → 처리량(Throughput)<br>
2 → 응답 시간(Response Time)<br>
3 → 경과 시간(Turn Around Time)
<br>
<br>소스 코드의 코딩 스타일, 코드에 설정된 코딩 표준, 코드의 복잡도, 코드에 존재하는 메모리 누수 현상, 스레드 결함 등을 발견하기 위해 사용하는 분석 도구이다.
<br>각각 소스코드 품질 분석에 대한 정의를 작성하세요.
<br>
<br>작성한 소스 코드를 실행하지 않고, 코딩 표준이나 코딩 스타일, 결함 등을 확인하는 코드 분석 도구.
<br>
<br>소스 코드를 직접 실행하여 프로그램의 동작이나 반응을 추적하고 보고하는 분석 도구로, 프로그램 모니터링 기능이나 스냅샷 생성 기능을 포함하고 있다.
<br>
<br>데이터를 제어하는 DCL의 하나인 GRANT의 기능에 대해 간략히 서술하시오.
<br>
GRANT는 데이터베이스 관리자가 데이터베이스 사용자에게 권한을 부여하는 데 사용하는 명령어 이다.
<br>
<br>데이터를 제어하는 DCL의 하나인 ROLLBACK에 대해 간략히 서술하시오.
<br>
ROLLBACK은 트렌젝션이 실패한 경우 작업을 취소하고 이전 상태로 되돌리기 위한 명령어이다.
<br>
<br>데이터베이스 보안에서 가용성(Availability)에 대해 간략히 서술하시오.
<br>
자산이 적절한 시간에 인가된 당사자에게 접근 가능 해야 하는 것.<br>
위협요소 - Dos/DDoS 공격 등
<br>추가
기밀성 - 자산이 인가된 당사자에 의해서만 접근하는 것을 보장하는 것.<br>
무결성 - 자산이 인가된 당사자에 의해서, 인가된 방법으로만 변경 가능한것.
<br>
<br>보안 위협의 하나인 SQL Injection에 대해 간략히 서술하시오.
<br>
SQL Injection은 웹 응용 프로그램에 SQL 구문을 삽입하여 내부 DB서버의 데이터를 유출 및 변조하고 관리자 인증을 우회하는 공격 기법이다.
<br>
<br>
다음은 암호화 알고리즘에 대한 설명이다. 괄호를 채우시오. <br>
암호화 알고리즘은 패스워드, 주민번호, 은행계좌와 같은 중요 정보를 보호하기 위해 평문을 암호화된 문장으 만드는 절차 또는 방법을 말한다. <br>
스위스의 라이(Lai)와 메시(Messey)는 1990년 PES를 발표하고, 이후 이를 개선한 IPES를 발표하였다. IPES는 128비트의 Key를 사용하여 64비트 블록을 암호화하는 알고리즘이며 현재는 ( 1 )라고 불린다. <br>
( 2 )은 국가 안전 보장국(NSA)에서 개발한 암호화 알고리즘으로, 클리퍼 칩(Clipper Chip)이라는 IC 칩에 내장되어 있다. 80비트의 Key를 사용하여 64비트 블록을 암호화하며, 주로 전화기와 같은 음성 통신 장비에 삽입되어 음성 데이터를 암호화 한다. <br>
전화기와 같은 음성을 암호화하는데 주로 사용된다. <br>
1 → IDEA(Internetional Data Encryption Algorithm)<br>
2 → Skipjack(가다랑어)
<br>
<br>무선랜 보안에 사용된 WEP 방식을 보완한 데이터 보안 프로토콜로, 임시 키 무결성 프로토콜이라도 한다.
<br>WEP의 취약성을 보완하기 위해 암호 알고리즘의 입력 키 길이를 128비트로 늘리고 패킷당 키할당, 키값 재설정 등 키 관리 방식을 개선하였다.
<br>
<br>1974년 IBM이 개발하고, 1975년 NBS에 의해 미국의 국가 표준으로 발표된 암호화 알고리즘
<br>블록 크기는 64비트, 키 길이는 56비트이며, 16회의 라운드를 수행한다.
<br>컴퓨터 기술이 발달함에 따라 해독이 쉬워지면서 미국의 국가 표준이 2001년 AES로 대체되었다.
<br>
<br>2001년 미국 표준 기술 연구소(NIST)에서 발표한 대칭키 암호화 알고리즘이다.
<br>DES의 한계를 느낀 NIST에서 공모한 후 발표하였다.
<br>블록 크기는 128비트이며, 키 길이에 따라 128, 192, 256으로 분류된다.
<br>
<br>1991년 R.ricest가 MD4를 개선한 암호화 알고리즘으로, 각각의 512비트짜리 입력 메세지 블록에 대해 차례동작한다.
<br>각 512비트 입력 메시지 블록을 처리하고 나면 128비트 스테이트(stat)의 값이 변하는 암호화 알고리즘이다.
<br>
<br>( ) 스푸핑은 로컬 네트워크(LAN)에서 사용하는 ( )프로토콜의 취약점을 이용한 공격 기법으로, 자신의 물리적 주소(MAC)를 변조하여 다른 PC에게 도달해야 하는 데이터 패킷을 가로채거나 방해한다.
<br>이 공격은 데이터 링크 상의 프로토콜인 ( )를 이용하기 때문에 근거리상의 통신에서만 사용할 수 있는 공격이다.
<br>
<br>아래의 패킷 로그와 같이, 공격자가 패킷의 출발지 주소(Address) 또는 포트를 임의로 변경하여 송신측 IP주소 또는 포트를 동일하게 함으로써, 송신 IP주소가 자신이므로 자신에게 응답을 수행하게 된다.
<br>자신에 대해 무한히 응답하는 패킷을 계속 전송하여 컴퓨터의 실행 속도를 느리게 하거나 동작을 마비 시켜 서비스 거부 상태에 빠지도록 하는 네워크 공격 유형은?
<br>#### source : 192.168.1.200
#### destination : 192.168.1.200
#### protocol : 6
#### src port : 21845
#### dst port : 21845
<br>
<br>( 1 )은 컴퓨터 보안에 있어서, 인간 상호 작용(사회)의 깊은 신뢰를 바탕으로 사람들을 속여 정상 보안 절차를 깨트리기 위한 비기술적 시스템 침입 수단을 의미한다.
<br>( 2 )는 특정 목적을 가지고 데이터를 수집하였으나, 이후 활용되지 않고 저장만 되어있는 대량의 데이터를 의미한다. 미래에 사용될 가능성을 고려하여 저장 공간에서 삭제되지 않고 보관되어 있으나, 이는 저장 공간의 낭비뿐만 아니라 보안 위험을 초래할 수도 있다.
<br>
1 → 사회 공학(Social Engineering)<br>
2 → 다크 데이터(Dark Data)
<br>
<br>( )은 ‘세션을 가로채다’라는 의미로, 정상적인 연결을 RST패킷을 통해 종료시킨 후 재연결 시 희생자가 아닌 공격자에게 연결하는 공격 기법이다.
<br>TCP ( )은 공격자가 TCP 3-Way-Handshake과정에 끼어듦으로써 서버와 상호 간의 동기화된 시퀀스 번호를 갖고 인가되지 않은 시스템의 기능을 이용하거나 중요한 정보에 접근할 수 있게 된다.
<br>
<br>목표 조직이 자주 방문하는 웹 사이트를 사전에 감염시켜(웅덩이), 목표 조직의 일원이 웹 사이트에 방문했을 때 악성 코드에 감연되게 한다.
<br>이후에는 감염된 PC를 기반으로 조직의 중요 시스템에 접근하거나 불능으로 만드는 등의 영향력을 행사하는 웹 기반 공격이다.
<br>
<br>AAA서버는 사용자의 컴퓨터 자원 접근 처리와 서비스 제공에 있어서의 다음 3가지 기능을 제공하는 서버이다.
<br>접근하는 사용자의 신원을 검증하는 기능
<br>신원이 검증된 사용자에게 특정된 권한과 서비스를 허용하는 기능
<br>사용자가 어떤 종류의 서비스를 이용했고, 얼마만큼의 자원을 사용했는지 기록 및 보관하는 기능
<br>각각 무엇인지 ?
<br>
1 → Authentication - 검증<br>
2 → Authorization - 권한 부여<br>
3 → Accounting - 기록
<br>
<br>다양한 장비에서 발생하는 로그 및 보안 이벤트를 통합하여 관리하는 보안 솔루션으로, 방화벽, IDS, IPS, 웹 방화벽, VPN 등에서 발생한 로그 및 보안 이벤트를 통합하여 관리함으로써 비용 및 자원을 절약할 수 있는 특징이 있다.
<br>보안 솔루션 간의 상호 연동을 통해 종합적인 보안 관리 체계를 수립할 수 있다.
<br>머신러닝 기술을 이용하여 it시스템에서 발생하는 대량의 로그를 통합 관리한다.
<br>이상 징후 미리 감지
<br>
<br>헝가리안 표기법(Hungarian Notation)에 대해 간략히 서술.
<br>
헝가리안 표기법은 변수명 작성시 변수의 자료형을 알 수 있도록 자료형을 의미하는 문자를 포함하여 작성하는 방법.<br>
ex) bool bIsTrue / int nCnt
<br>
<br>스니핑(Sniffing)은 사전적 의미로 ‘코를 킁킁 거리다, 냄새를 맡다’이다. 네트워크 보안에서 스니핑에 대한 개념을 간략히 작성.
<br>
스니핑은 네트워크의 중간에서 남의 패킷 정보를 도청하는 해킹 유형의 하나로 수동적 공격에 해당한다.
<br>
<br>C++에서 생성자에 대해 간략히 서술하시오.
<br>
생성자는 객체 변수 생성에 사용되는 메소드로, 객체 변수를 생성하면서 초기화를 수행한다.
<br>
<br>1960년대 AT&amp;T 벨(Bell) 연구소가 MIT, GM사와 함께 공동 개발한 운영체제 이다.
<br>시분할 시스템(Time Sharing System)을 위해 설계된 대화식 운영체제 이다.
<br>대부분 c언어로 작성되어 있어 이식성이 높으며, 장치/프로세스 간의 호환성이 높다.
<br>트리 구조의 파일 시스템을 갖는다.
<br><img alt="do-messenger_screenshot_2025-02-12_14_04_58.png" src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-02-12_14_04_58.png" target="_self"><br>
1 → 준비(Ready)<br>
2 → 실행(Run)<br>
3 → 대기(Wait)
<br>
<br>HRN 비선점형 스케줄링 우선순위를 구하는 계삭식을 쓰시오.
<br>
<br>( 1 )는 준비상태 큐에서 기다리고 있는 프로세스들 중에서 실행시간이 가장 짧은 프로세스에게 먼저 CPU를 할당하는 기법이다. 가장 적은 평균 대기 시간을 제공하는 최적 알고리즘이지만, 실행 시간이 긴 프로세스는 실행 시간이 짧은 프로세스에게 할당 순위가 밀려 무한 연기 상태가 발생 될 수 있다.
<br>
<br>( 2 )은 시분할 시스템을 위해 고안된 방식으로, 준비상태 큐에 먼저 들어온 프로세스가 먼저 CPU를 할당받지만 각 프로세스는 시간 할당량 동안만 실행한 후 실행이 완료되지 않으면 다음 프로세스에게 CPU를 넘겨고 준비상태 큐의 가장 뒤로 배치된다. 할당되는 시간이 작을 경우 문맥 교환 및 오버헤드가 자주 발생되어 요청된 작업을 신속히 처리할 수 없다.
<br>
<br>( 3 )는 현재 실행중인 프로세스의 남은 시간과 준비상태 큐에 새로 도착한 프로세스의 실행시간을 비교하 가장 짧은 실행 시간을 요구하는 프로세스에게 CPU를 할당하는 기법으로, 시분할 시스템에 유용하다. 준비상태 큐에 있는 각 프로세스의 실행 시간을 추적하여 보유하고 있어야 하므로 오버헤드가 증가한다.
<br>
1 → SJF(Shortest Job First)<br>
2 → RR(Round Robin)<br>
3 → SRT(Shortest Remaining Time)
<br>
<br>리눅스 또는 유닉스에서 a.txt 파일에 대해 다음 처리 조건과 같이 권한을 부여하고자 한다.
<br>사용자에게 읽기,쓰기,실행 권한을 부여한다.
<br>그룹에게 읽기,실행 권한을 부여한다.
<br>기타 사용자에게 실행 권한을 부여한다.
<br>한 줄로 작성하고, 8진법 숫자를 이용한 명령문을 이용한다.
<br>
<br>192.168.1.0/24 네트워크를 FLSM 방식으로 3개의 Subnet으로 나누는 방법
<br>즉, 64개씩 호스트를 할당하면,<br>
<br>여분의 서브넷 = 192.168.1.192/26
<br>
<br>서브넷팅(Subnetting)에 대한 설명
<br>현재 IP주소가 192.168.1.132이고, 서브넷 마스크가 255.255.255.192 일 때, 네트워크 주소와 사용가능 호스트 개수는?
<br>
<br>A Class - 0~127 / 기본 서브넷 - 255.0.0.0 (/8)
<br>B Class - 128~191 / 기본 서브넷 - 255.255.0.0 (/16)
<br>C Class - 192~223 / 기본 서브넷 - 255.255.255.0 (/24)
<br>D Class - 224~239 / 기본 서브넷 - 멀티캐스트 전용 (서브넷 X)
<br>이 때, 네트워크 개수는 2^2(추가된 1의 개수) = 4개<br>호스트개수는 256 / 4(네트워크 개수) = 64개<br>즉, 이를 표로 나타내면 →<br>여기서 192.168.1.13 는 3번째 네트워크 주소에 속하므로,<br>
네트워크 주소는 192.168.1.128 이며, 사용 가능 호스트 주소는 네트워크와 브로드캐스트 주소를 뺀 64-2 <br>
<br>OSI 7 Layer에 대한 설명
<br>
물리적으로 연결된 두 개의 인접한 개방 시스템들 간에 신뢰성 있고 효율적인 정보 전송을 할 수 있도록 연결 설정, 데이터 전송, 오류 제어 등의 기능을 수행한다. <br>
개방 시스템들 간의 네트워크 연결을 관리하며, 경로 제어, 패킷 교환, 트래픽 제어 등의 기능을 수행한다. <br>
서로 다른 데이터 표현 형태를 갖는 시스템 간의 상호 접속을 위해 필요한 계층으로, 코드변환, 데이터 암호화, 데이터 압축, 구문 검색 등의 기능을 수행한다. <br>
다양한 전송매체를 통해 비트 스트림을 전송. 전송에 필요한 두 장치 간의 실제 접속과 절단 등 기계적, 전기적, 기능적, 절차적 특성에 대한 규칙을 정의한다. <br>
1 → 데이터 링크 계층(Data Link Layer)<br>
2 → 네트워크 계층(Network Layer)<br>
3 → 표현 계층(Presentation Layer)<br>
4 → 물리 계층(Physical Layer)
<br>
<br>심리학자 톰 마릴은 컴퓨터가 메시지를 전달하고, 메시지가 제대로 도착했는지 확인하며, 도착하지 않았을 경우 메시지를 재전송하는 일련의 방법을 ‘기술적 은어’를 뜻하는 ( )이라는 용어로 정의하였다.
<br>
<br>프로토콜은 서로다른 기기들 간의 데이터 교환을 원활하게 수행할 수 있도록 표준화 시켜놓은 통신 규약이다. 프로토콜의 기본요소 3가지를 쓰시오.
<br>
구문(Syntex)<br>
의미(Semantics)<br>
시간(Timing)
<br>
<br>( 1 ) : 연결형 통신에서 주로 사용되는 방식으로, 출발지와 목적지의 전송 경로를 미리 연결하여 논리적으로 고정한 후 통신하는 방식
<br>( 2 ) : 비연결형 통신에서 주로 사용되는 방식으로, 사전에 접속 절차를 수행하지 않고 헤더에 출발지에서 목적지까지의 경로 지정을 위한 충분한 정보를 붙여서 개별적으로 전달하는 방식
<br>
1 → 가상 회선(Virtual Circuit)<br>
2 → 데이터그램(Datagram)
<br>
<br>인터넷 환경에서의 호스트 상호 간 통신에서 연결된 네트워크 접속 장치의 물리적 주소인 MAC 주소를 이용하여 IP주소를 찾는 인터넷 계층의 프로토콜로, 역순 주소 결정 프로토콜이라 불린다.
<br>
RARP(Reverse Address Resolution protocol)
<br>
<br>( )는 한 번의 로그인으로 개인이 가입한 모든 사이트를 이용할 수 있게 해주는 시스템을 말한다.
<br>개인의 경우, 사이트에 접속하기 위하여 아이디와 패스워드는 물론 이름, 전화번호 등 개인정보를 각 사이트마다 일일이 기록해야 하던 것이 한 번의 작업으로 끝나므로 불편함이 해소되며, 기업에서는 회원에 대한 통합관리가 가능해 마케딩을 극대화시킬 수 있다는 장점이 있다.
<br>
SSO(Single Sign On)
<br>
<br>재난 및 군사 현장과 같이 별도의 고정된 유선망을 구축할 수 없는 장소에서 모바일 호스트만을 이용하여 구성한 네트워크.
<br>망을 구성한 후 단기간 사용되는 경우나 유선망을 구성하기 어려운 경우에 적합하다.
<br>멀티 홉 라우팅 기능을 지원한다.
<br>
애드 혹 네트워크(Ad-hoc Network)
<br>
<br>우리말로 번역하면 '네트워크 주소 변환'이라는 의미의 영문 3글자 약자이다.
<br>1개의 정식 IP 주소에 다량의 가상 사설 IP 주소를 할당 및 연결하는 방식이다.
<br>1개의 IP 주소를 사용해서 외부에 접속할 수 있는 노드는 어느 시점에서 1개만으로 제한되는 문제가 있으나, 이 때에는 IP 마스커레이드(Masquerade)를 이용하면 된다.
<br>
NAT(Network Address Translation)
<br>
<br>
정의<br>
웹상에 존재하는 데이터를 개별 URI로 식별하고, 각 URI에 링크 정보를 부여함으로써 상호 연결된 웹을 지향하는 모형이다.<br>
링크 기능이 강조된 시맨틱웹의 모형에 속한다고 볼 수 있으며, 팀 버너스 리의 W3C를 중심으로 발전하고있다. <br>
주요 기능 <br>공개된 데이터를 이용하면 내가 원하는 데이터가 이미 존재하는지, 어디에 존재하는지 알 수 있다.
<br>URI로 구별되는 데이터 리소스의 자유로운 접근 및 이용이 가능하므로 큰 노력 없이 데이터의 매쉬업이 가능하다.
<br>내가 만든 데이터가 아니라도 URI를 이용하여 링크만 해주면 이용할 수 있다. <br>
4대 원칙 <br>통합 자원 식별자(URI)를 사용한다,
<br>URI는 HTTP 프로토콜을 통해 접근할 수 있어야 한다.
<br>RDF나 스파클 같은 표준을 사용한다,
<br>풍부한 링크 정보가 있어야 한다. <br>
Linked Data와 Open Data를 결합한 용어이다. <br>
LOD(개방형 링크드 데이터)
<br>
<br>경로 제어 프로토콜은 크게 자율 시스템 내부의 라우팅에 사용되는 (①) 와 <br>자율 시스템 간의 라우팅에 사용되는 (②) 로 구분할 수 있다.
<br>설명 <br>(①) 는 소규모 동종 자율 시스템에서 효율적인 RIP와 대규모 자유 시스템에서 많이 사용되는 (③) 로 나누어진다.
<br>(③) 는 링크 상태(Link State)를 실시간으로 반영하여 최단 경로로 라우팅을 지원하는 특징이 있다.
<br>(④) 는 (②) 의 단점을 보완하여 만들어진 라우팅 프로토콜로, 처음 연결될 때는 전체 라우팅 테이블을 교환하고, 이후에는 변환된 정보만을 교환한다. <br>
<br>BGP
<br>AS
<br>HOP
<br>OSPF
<br>NAT
<br>ISP
<br>EGP
<br>IGP
<br> <br>IGP
<br>EGP
<br>OSPF
<br>BGP <br>
<br>P2P 네트워크를 이용하여 온라인 금융 거래 정보를 온라인 네트워크 참여자(Peer)의 디지털 장비에 분산 저장하는 기술은?
<br>
블록체인(Blockchain)
<br>
<br>정보 자산을 안전하게 보호하기 위한 보호 절차와 대책으로, 정보보호 관리 체계라고 한다.
<br>조직에 맞는 정보보호 정책을 수립하고, 위험에 상시 대응하는 여러 보안 대책을 통합 관리한다.
<br>공공 부문과 민간 기업 부문에서 이것을 평가하고 인증하는 사업을 한국인터넷진흥원(KISA)에서 운영중이다.
<br>
<br>( 1 )은 칩 설계 회사인 ARM에서 개발한 기술로, 하나의 프로세서 내에 일반 애플리케이션을 처리하는 일반 구역과, 보안이 필요한 애플리케이션을 처리하는 보안 구역으로 분할하여 관리하는 하드웨어 기반의 보안기술이다.
<br>( 2 )은 네티즌들이 사이트에 접속할 때 주소를 잘못 입력하거나 철자를 빠뜨리는 실수를 이용하기 위해 이와 유사한 유명 도메인을 미리 등록하는 것으로 URL하이재킹이라고도 한다. <br>
<br>Pharming
<br>Typosquatting
<br>Ransomware
<br>Tvishing
<br>Hacktivism
<br>CSRF
<br>Trustzone
<br>Watering Hole
<br>APT
<br>Smurfing
<br> <br>Trustzone
<br>Typosquatting <br>
<br>RAID(Redundant Array of Independent Disks)란 여러개의 하드디스크를 조합하여 성능 향상과 데이터 보호기능을 제공하는 기술이다.
<br> <br>RAID 0: 성능 최우선, 데이터 보호 없음.
<br>RAID 1: 데이터 안정성 높음, 저장 용량 절반 사용.
<br>RAID 5: 성능과 안정성 균형, 최소 3개 디스크 필요.
<br>RAID 6: RAID 5보다 높은 안정성, 최소 4개 디스크 필요.
<br>RAID 10: RAID 0과 RAID 1의 조합, 고성능과 고안정성 제공. <br>
<br>오픈 소스 기반 분산 컴퓨팅 플랫폼 이다.
<br>분산 저장된 데이터들은 클러스터 환경에서 병렬 처리된다.
<br>일반 PC급 컴퓨터들로 가상화된 대형 스토리지를 형성하고 그 안에 보관된 거대한 데이터 세트를 병렬로 처리할 수 있도록 개발되었다.
<br>더그 커팅과 마이크 캐퍼렐라가 개발했으며, 구글의 맵리듀스(MapReduce) 엔진을 사용하고 있다.
<br>
<br>데이터 마이닝(Data Mining)의 개념을 간략히 서술하시오.
<br>
데이터 마이닝은 대량의 데이터를 분석하여 데이터에 내재된 변수 사이의 상호관계를 규명하여 일정한 패턴을 찾아내는 기법이다.
<br>
<br>데이터베이스 회복(Recovery) 기법에 관련된 내용.
<br>( )은 트렌젝션이 데이터를 변경하면, 트렌젝션이 부분 완료되기 전이라도 즉시 실제 DB에 그 내용을 반영하는 기법.
<br>장애가 발생하여 회복 작업할 경우를 대비하여 갱신된 내용들을 로그에 보관시킨다.
<br>( )에서 회복 작업을 수행할 경우 Redo와 Undo 모두 수행이 가능하다.
<br>
즉각 갱신 기법(Immediate Update)
<br>
<br>데이터베이스 병행제어(Concurrency Control) 기법 중 하나로이다.
<br>접근한 데이터에 대한 연산을 모두 마칠 때 까지 추가적인 접근을 제한함으로써 상호 배타적으로 접근하여 작업을 수행하도록 하는 기법이다.
<br>
<br>
릴리즈 노트는 개발 과정에서 정리된 릴리즈 정보를 고객과 공유하기 위한 문서이다. <br>
릴리즈 노트는 정확하고 완전한 정보를 기반으로 개발팀에서 직접 현재 시제로 작성해야 한다. <br>
릴리즈 노트 작성시 노트 이름, 소프트웨어, 릴리즈 버전, 릴리즈 날짜, 릴리즈 노트 날짜, 버전 등이 포함되는 항목은? <br>
<br>소프트웨어 개발에서의 작업 중 형상 통제에 대해 간략히 서술하시오.
<br>
형상 통제는 식별된 형상 항목에 대한 변경 요구를 검토하여 현재의 기준선이 잘 반영될 수 있도록 조정하는 작업이다.
<br>
<br>소프트웨어 ( )는 소프트웨어 개발 단계의 각 과정에서 만들어지는 프로그램, 문서, 데이터등을 관리하는 것을 말한다.
<br>소프트웨어의 개발 과정에서 만들어지는 여러 버전들의 변경사항을 관리하는 일련의 활동이며 이를 지원하는 도구로 Git, SVN 등이 있다.
<br>
형상관리(SCM)
<br> 다음 설명하는 네트워크 공격 방법은?<br>ICMP, 송신 주소를 공격 대상의 IP 주소로 위장하고, 수신 주소를 해당 네트워크 라우터의 브로드캐스트 주소로 설정하는 공격으로 과부화 시키는 기법은? ICMP 패킷을 크게 만들어서 과부화 시키는 죽음의 핑과 같은 서비스 공격 유형이다.
<br>
스머핑(Smurfing)
<br>다음으로 알맞은 용어는?<br>인터넷을 통해 장치 간 사설 네트워크 연결을 생성하는 서비스로 장치의 실제 IP 주소를 가상 IP 주소로 대체하고, 데이터를 암호화하고, 데이터를 전 세계 보안 네트워크로 라우팅함으로써 정보를 보호하는 기법
<br>디바이스 간에 사설 네트워크 연결을 생성, 안전하게 익명으로 전송하는데 사용
<br>
VPN
<br>
<br>
코드 내의 각 분기점이 true 또는 false로 평가될 때마다 해당 분기점이 모두 테스트 되는 것을 목표로 한다. 각 분기점이 모든 가능한 경로로 실행되었는지 확인하는 데 사용되는 커버리지 ( ) <br>
코드의 흐름을 여러 갈래로 나누는 조건문 또는 선택문을 의미한다. 예를 들어, if-else 문이나 switch 문에서 조건에 따라 실행 경로가 달라질 때를 의미한다. ( ) <br>
개별 조건문 내에 있는 각각의 조건이 true와 false 모두를 만족하도록 테스트하는 것을 의미한다. 예를 들어, if (A &amp;&amp; B)와 같은 구문에서 A와 B가 각각 true와 false가 되는 경우를 테스트하는 것이 목표이다. ( ) <br>(보기)<br>
㉠ 조건/결정 커버리지<br>
㉡ 결정 커버리지<br>
㉢ 조건 커버리지<br>
㉣ 분기 커버리지<br>
㉤ 변경 조건/결정 커버리지<br>
㉥ 문장 커버리지<br>
㉧ 다중 조건 커버리지<br> <br>문장 / 2. 분기 / 3. 조건 <br>
<br>다음 라우터 A에서 라우터 F까지 경로를 설정하기 위해 RIP 방식을 사용한다고 할 때, 라우터가 지나가는 경로를 순서대로 쓰시오.(단, 간선 위의 숫자는 라우터 간의 거리를 의미한다.)<br>
<img alt="스크린샷 2025-04-14 오전 12.06.09.png" src="https://lts.kr/사진-및-문서/스크린샷-2025-04-14-오전-12.06.09.png" target="_self">
<br>RIP 는 최단 경로 탐색이다. (거리 벡터 라우팅 프로토콜)
<br>조건 1. 홉의 수가 최단이 되어야 한다. 그래서 C -&gt; E -&gt; F 로 가지 않고, C -&gt; F 로 간다.
<br>조건 2. 홉의 수가 같다면 비용을 최소로 한다.
<br>조건 3. 홉의 수가 15가 넘는다면 불가능으로 판단한다.
<br>
A -&gt; D -&gt; C -&gt; F
<br>
<br>대표적인 링크 상태 라우팅 프로토콜이다. 이것은 인터넷에서 연결된 링크의 상태를 감시하여 최적의 경로를 선택한다는것이다.
<br>단일 자율 시스템 내에서 라우팅 정보를 배포하는 데 사용되는 내부 게이트웨이 프로토콜이다.
<br>모든 대상에 도달하기 위한 최단 경로를 구축하고 계산하며 최단 경로는 Dijkstra 알고리즘을 사용하여 계산된다.
<br> &nbsp;아래 내용의 각각의 설명에 대한 답을 작성하시오.<br>(1) 조인에 참여하는 두 릴레이션의 속성 값을 비교하여 조건을 만족하는 튜플만 반환한다.<br>(2) 조건이 정확하게 '=' 등호로 일치하는 결과를 반환한다. <br>(3) ( (2) ) 조인에서 조인에 참여한 속성이 두 번 나오지 않도록 중복된 속성을 제거한 결과를 반환한다.<br>-조인에 참여하는 두 릴레이션의 속성 값을 비교하여 조건을 만족하는 투플만 반환한다.<br>-동등조인의 결과 릴레이션의 차수는 첫 번째 릴레이션과 두 번째 릴레이션의 차수를 합한 것.<br>-동등조인에서 조인에 참여한 속성이 두 번 나오지 않도록 중복된 속성(두 번째 속성)을 제거한 결과를 반환<br> -왼쪽 외부조인(left outer join):<br>
왼쪽 투플 기준으로 자연조인 시 실패한 투플을 모두 보여주되 값이 없는 대응 속성에는 NULL 값을 채워서 반환한다.<br>
-오른쪽 외부조인(right outer join):<br>
오른쪽 투플 기준으로 자연조인 시 실패한 투플을 모두 보여주되 값이 없는 대응 속성에는 NULL 값을 채워서 반환한다.<br>
-완전 외부조인(full outer join):<br>
양쪽 투플 기준으로 자연조인 시 실패한 투플을 모두 보여주되 값이 없는 대응 속성에는 NULL 값을 채워서 반환한다.<br>-자연조인을 한 후 두 릴레이션 중 한쪽 릴레이션의 결과만 반환<br> <br>세타 조인
<br>동등 조인
<br>자연 조인 <br>
<br>다음 아래 내용을 보고 보기에서 알맞는 용어를 골라 작성하시오.
<br>인터넷 공격자의 존재를 숨기면서 이 공격자에게 시스템에 대한 무제한 접근 권한을 부여하는 악성 프로그램이다.<br>
해커가 자신의 존재를 숨기면서 허가되지 않은 컴퓨터나 소프트웨어에 접근할 수 있도록 설계된 도구이다.<br>
일반적으로 펌웨어, 가상화 계층 등의 다양한 시스템 영역에서 작동하며, 운영체제의 시스템콜을 해킹하여 악성코드의 실행여부를 숨겨 안티바이러스 탐지를 우회할 수 있다.<br>
백도어(Backdoor)
<br>
<br>다음 아래 내용에 알맞는 공격 방법은?
<br>
불특정 다수가 아닌 명확한 표적을 정하여 지속적인 정보수집 후 공격감행할 수 있다. <br>
시스템에 직접 침투하는 것뿐 아니라 표적 내부직원들이 이용하는 다양한 단말을 대상으로 한다. <br>
한가지 기술만이 아닌 Zero-day 취약점, 악성코드 등 다양한 보안 위협 공격 기술을 사용한다. <br>
일반적으로 공격은 침투, 검색, 수집 및 유출의 4단계로 실행되며, 각 단계별로 다양한 공격 기술을 사용한다. <br>
APT
<br>
<br>다음이 설명하는 디자인 페턴은? <br>
구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴이다. <br>
연관성이 있는 객체 군이 여러개 있을 경우 이들을 묶어 추상화하고, 어떤 구체적인 상황이 주어지면 팩토리 객체에서 집합으로 묶은 객체 군을 구현화 하는 생성 패턴이다 <br>
관련성 있는 여러 종류의 객체를 일관된 방식으로 생성하는 경우에 유용하다. <br>kit라고도 불린다.<br>
추상펙토리 패턴(Abstract Factory)
<br>
<br>
다음 설명은 서버 접근 통제의 유형이다. 괄호 안에 들어갈 용어를 작성하시오. ('영어 약자'로 작성하시오.) <br>
( ① )은/는 규칙 기반(Rule-Based) 접근통제 정책으로, 객체에 포함된 정보의 허용 등급과 접근 정보에 대하여 주체가 갖는 접근 허가 권한에 근거하여 객체에 대한 접근을 제한하는 방법이다. <br>
( ② )은/는 중앙 관리자가 사용자와 시스템의 상호관계를 통제하며 조직 내 맡은 역할(Role)에 기초하여 자원에 대한 접근을 제한하는 방법이다. <br>
( ③ )은/는 신분 기반(Identity-Based) 접근통제 정책으로, 주체나 그룹의 신분에 근거하여 객체에 대한 접근을 제한하는 방법이다. <br>
1 → MAC<br>
2 → RDAC<br>
3 → DAC
<br>
<br>다음 설명에 대해 괄호 안에 알맞는 용어를 작성하시오. ('영어 약자' 로 작성하시오.)
<br>
( )은/는 자료를 일정한 크기로 정하여 순서대로 전송하는 자료의 전송 방식이다. <br>
셀이라 부르는 고정 길이 패킷을 이용하여 처리가 단순하고 고속망에 적합하며, 연속적으로 셀을 보낼 때 다중화를 하지 않고 셀단위로 동기가 이루어지지만 경우에 따라 동기식 시간 분할 다중화를 사용하기도 한다. <br>
가상 채널 (Virtual Channel) 기반의 연결 지향 서비스로 셀이라 부르는 고정 길이(53바이트) 패킷을 사용하며 통계적 다중화 방식을 이용한다. <br>
ATM
<br>
<br>&nbsp;IP 패킷에서 외부의 공인 IP주소와 포트 주소에 해당하는 내부 IP주소를 재기록하여 라우터를 통해 네트워크 트래픽을 주고받는 기술은 무엇인가?
<br>
NAT
<br>
<br>다음은 클라우드에 대한 유형 문제이다. 괄호안에 알맞는 답을 보기에 골라 작성하시오.
<br><img alt="Pasted image 20250415182923.png" src="https://lts.kr/사진-및-문서/pasted-image-20250415182923.png" target="_self"><br>PaaS / SaaS / IaaS
<br>IaaS : 서비스로서의 인프라, 개발 및 테스트 환경의 구축 및 제거가 빠르고 유연, AWS, Azure, GC가 대표적, 사용자가 컨트롤할 수 있는 범위가 넓음 - os, middleware runtime, data, applications<br>PaaS : 서비스로서의 플랫폼, 제공업체가 자체 인프라에서 하드웨어와 소프트웨어를 호스팅, Elastic Beanstalk, Heroku, Red Hat OpenShift, 사용자가 컨트롤할 수 있는 범위 - Applications, Data<br>SaaS : 서비스로서의 소프트웨어, 모든 애플리케이션은 제공업체가 관리, 웹 브라우저를 통해 제공, 사용자는 대시보드 또는 API를 통해 애플리케이션에 연결, 개별 시스템에 소프트웨어를 설치할 필요가 없음, Dropbox, salesforce, google apps, red hat insights<br> <br>→ IaaS
<br>→ PaaS
<br>→ SaaS <br>
<br>&nbsp;다음은 데이터베이스에 관련된 문제이다. 괄호 안에 알맞는 답을 작성하시오.
<br>
( ) 무결성은 관계 데이터베이스 관계 모델에서 2개의 관련 있던 관계 변수(테이블) 간의<br>
일관성(데이터 무결성)을 말한다. <br>
종종 기본 키 또는 키가 아닌 후보 키와 외래 키의 조합으로 강제 적용된다. <br>
외래 키가 선언된 관계 변수의 외래 키를 구성하는 속성(열)의 값은 그 관계 변수의 부모가 되는 관계 변수의 기본 키 값 또는 기본 키가 아닌 후보 키 값으로 존재해야 한다. <br>
참조 무결성
<br>
<br>다음 보기는 암호화 알고리즘에 대한 내용이다. 대칭키와 비대칭키에 해당하는 용어를 보기의 내용 참고하여 작성하시오.
<br>[보기]<br>
DES, RSA, AES, ECC, PKI, ARIA, SEED<br>
대칭키 : ( ) <br>
비대칭키 : ( ) <br>
대칭키 → DES / AES / ARIA / SEED<br>
비대칭키 → RSA / ECC
<br>
<br>아래 내용을 확인하여 알맞는 답을 작성하시오.<br>
○ 2 계층(데이터링크 계층)에서 구현되는 터널링 기술 중 하나<br>
○ L2F와 PPTP가 결합된 프로토콜로 VPN과 인터넷 서비스 제공자(ISP)가 이용<br>
○ IPsec을 함께 사용하면 PPTP보다 훨씬 안전하지만 보안보다 익명화에 더 적합
<br>
L2TP
<br>
<br>다음 설명에 해당하는 알맞은 용어를 영문 3글자로 쓰시오.
<br>○ 다른 컴퓨터에 로그인, 원격 명령 실행, 파일 복사 등을 수행할 수 있도록 다양한 기능을 지원하는 프로토콜 또는 이를 이용한 응용 프로그램이다.<br>○ 데이터 암호화와 강력한 인증 방법으로 보안성이 낮은 네트워크에서도 안전하게 통신할 수 있다.<br>○ 키(Key)를 통한 인증 방법으로 사용하려면 사전에 클라이언트의 공개키를 서버에 등록해야 한다.<br>○기본적으로는 22번 포트를 사용한다.<br>
SSH
<br>
<br>다음 보안 관련 설명으로 괄호안에 알맞는 용어를 작성하시오.
<br>( )은/는 TCP/IP에서 IP 패킷을 처리할 때 발생되는 문제를 알려주는 프로토콜이다.<br>( ) 프로토콜은 보통 다른 호스트나 게이트웨이 와 연결된 네트웍에 문제가 있는지 확인하기 위한 목적으로 주로 사용된다.<br>( ) 을/를 이용한 공격에는 ( ) Flooding가 있는데 ping 명령어를 통한 ( ) 패킷을 연속적으로 계속 보내어 서버의 요청에 응답으로 인한 다른작업을 하지 못하도록 하는 공격이다.<br>
ICMP
<br>
<br>다음 설명하는 디자인 패턴은?<br>
( )은/는 복잡한 시스템을 개발하기 쉽도록 클래스나 객체을 조합하는 패턴에 속하며,<br>
대리라는 이름으로도 불린다. 내부에서는 객체 간의 복잡한 관계를 단순하게 정리해 주고,<br>
외부에서는 객체의 세부인 내용을 숨기는 역할을 한다.
<br>
proxy
<br>
<br>다음 파이썬 코드의 알맞는 출력값을 작성하시오.
<br>a = {'한국', '중국', '일본'}
a.add('베트남')
a.add('중국')
a.remove('일본')
a.update({'홍콩', '한국', '태국'})
print(a)
<br>
{'한국,'중국','베트남',홍콩','태국'}
<br>
<br>&nbsp;다음은 스키마와 관련된 내용이다. 각 괄호안에 알맞는 답을 작성하시오.<br>
<img alt="Pasted image 20250416171828.png" src="https://lts.kr/사진-및-문서/pasted-image-20250416171828.png" target="_self">
<br>
1 → 외부스키마<br>
2 → 개념스키마<br>
3 → 내부스키마
<br>
<br>다음 아래 제어 흐름 그래프가 분기 커버리지를 만족하기 위한 테스팅 순서를 쓰시오.<br>
<img alt="Pasted image 20250416172118.png" src="https://lts.kr/사진-및-문서/pasted-image-20250416172118.png" target="_self">
<br>
1234561<br>
124567
<br>
<br>다음 관계 대수 항목에 대해 괄호안에 들어갈 기호를 쓰시오.
<br>
U
<br>X<br>
π<br>
⋈
<br>
<br>&nbsp;다음은 디자인 패턴에 대한 설명이다. 괄호안에 알맞는 답을 작성하시오.
<br>( 1 )은/는 기능을 처리하는 클래스와 구현을 담당하는 추상 클래스로 구별한다.<br>
구현뿐 아니라 추상화도 독립적 변경이 필요할 때 ( 1 ) 패턴을 사용한다.<br>
기존 시스템에 부수적인 새로운 기능들을 지속적으로 추가할 때 사용하면 유용하며,<br>
새로운 인터페이스를 정의하여 기존 프로그램의 변경 없이 기능을 확장할 수 있다.<br>( 2 )은/는 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달해주는 패턴이다.<br>
일대다 관계를 가지며, ​주로 분산된 시스템 간에 이벤트를 생성·발행(Publish)하고, 이를 수신(Subscribe)해야 할 때 이용한다.<br>
1 → 브릿지<br>
2 → 옵저버
<br>
<br>. 다음 보기 중 형상 관리 도구에 해당하는 것을 모두 고르시오.
<br>ATM, CVS, OLAP, DDOS, SVN, Cyber Kill Chain, OLTP, Git<br>
SVN / GIT / CVS
<br>
<br>다음은 스케줄링에 관한 내용이다. 괄호안에 알맞는 답을 작성하시오.<br>
<img alt="Pasted image 20250416181833.png" src="https://lts.kr/사진-및-문서/pasted-image-20250416181833.png" target="_self">
<br>
A → FCFS<br>
B → SJF<br>
C → RR<br>
D → SRT
<br>
<br>다음은 E-R다이어그램의 표기 방법이다. 각 칸에 들어갈 알맞은 답을 골라 쓰시오.<br>
<img alt="Pasted image 20250416182123.png" src="https://lts.kr/사진-및-문서/pasted-image-20250416182123.png" target="_self">
<br>
A → 개체 타입<br>
B → 약한 개체 타입<br>
C → 관계 타입<br>
D → 약한 관계 타입<br>
E → 속성<br>
F → 키 속성<br>
G → 다중값 속성
<br>-&nbsp;아래에서 설명하는 내용을 영문 약자로 쓰시오.<br>키보드나 마우스와 같은 장치 없이 말이나 행동 그리고 감정과 같은 인간의 자연스러운 표현으로 컴퓨터나 장치를 제어할 수 있는 환경?<br>
NUI
<br>
<br>OSI 7 Layer에 대한 설명이다. 다음 각 설명에 해당되는 계층을 적으시오.
<br>(1) 물리계층을 통해 송수신되는 정보의 오류와 흐름을 관리하여 안전한 정보의 전달을 수행할 수 있도록 도와주는 역할<br>
(2) 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능<br>
(3) 수신자에서 데이터의 압축을 풀수 있는 방식으로 된 데이터 압축<br>물리 - 기계적, 전기적 특성. X.21, 리피터, 허브<br>
데이터 링크 - 흐름 제어, 오류 검출과 회복, HDLC, MAC, 랜카드, 브리지, 스위치<br>
네트워크 - 경로 설정(Routing), 트래픽 제어, 패킷, X.25, IP, 라우터<br>
전송 - 다중화, 오류 제어, 흐름 제어, TCP, UDP, 게이트웨이<br>
세션 - 송수신 측 간의 관련성을 유지, 대화 제어<br>
표현 - 데이터 암호화, 데이터 압축, 형식 변환<br>
응용 - 파일 전송, 전자 사서함(메일), 정보 교환, 가상 터미널<br>
★ 데이터 링크는 노드 사이의 흐름과 오류 제어.<br>
★ 전송은 단말기 사이의 흐름과 오류 제어.****<br>
1 → 데이터링크 계층<br>
2 → 네트워크 계층<br>
3 → 표현계층
<br>
<br>데이터 모델 구성요소 3가지를 쓰시오.
<br>개체 데이터 모델에서는 ( A ) 을/를 이용하여 실제 데이터를 처리하는 작업에 대한 명세를 나타내는데 논리 데이터 모델에서는 ( B ) 을/를 어떻게 나타낼 것인지 표현한다.<br>
( C ) 은/는 데이터 무결성 유지를 위한 데이터베이스의 보편적 방법으로 릴레이션의 특정 칼럼에 설정하는 제약을 의미하며, 개체무결성과 참조 무결성 등이 있다.<br>
A → 연산<br>
B → 구조<br>
C → 제약조건
<br>
<br>다음은 결합도에 대한 설명이다. 빈칸에 들어갈 알맞은 용어를 보기에서 찾아 쓰시오.
<br>( A ) 은/는 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우의 결합도<br>
( B ) 은/는 모듈 간의 인터페이스로 배열이나 객체, 구조 등이 전달되는 경우의 결합도<br>
( C ) 은/는 파라미터가 아닌 모듈 밖에 선언된 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호작용하는 경우의 결합도<br>[보기] : 자료 결합도 / 스탬프 결합도 / 제어 결합도 / 공통 결합도 / 내용 결합도 / 외부 결합도<br>내용 → 내부에 있는 변수/기능<br>
공통 → 전역 변수<br>
외부 → 외부, 다른 어쩌구<br>
제어 → 제어 어쩌구<br>
스탬프 → 배열, 구조 어쩌구<br>
자료 → 파라미터 만 의존<br>
A - 내용 결합도<br>
B - 스탬프 결합도<br>
C - 공통 결합도
<br>다음 내용에 해당하는 알맞는 답을 작성하시오.<br>
소프트웨어에서 워터마크 삭제 등과 같이 소프트웨어가 불법으로 변경(unauthorized modifications)되었을 경우, 그 소프트웨어가 정상 수행되지 않게 하는 기법이다. <br>
소프트웨어 변조 공격을 방어하기 위해 프로그램에 변조검증코드(tamper-proofing code)를 삽입하는 것도 한 방법으로, 변조검증코드의 용도는 첫째 프로그램이 변경되었는지를 탐지하는 것이고, 둘째는 변조가 탐지되었다면 프로그램이 실행되지 않게 한다. <br>
소프트웨어의 위변조 방지 역공학 기술의 일종으로 디지털 콘텐츠의 관련 산업이나 전자상거래 또는 보호해야 할 소프트웨어가 있는 다양한 산업 분야에 적용된다. <br>
템퍼 프루핑 (Tamper Proofing)
<br>시스템 분석 및 설계, 또는 문서화에 사용되는 기법으로 시스템 실행 과정인 입력, 처리, 출력의 기능을 표현한 용어를 영문약어로 쓰시오.<br>
HIPO(Hierarchy Input Process Output)
<br>
<br>
BIA(Business Impact Analysis) - 장애나 재해로 인해 운영상의 주요 손실을 볼 것을 가정하여 시간 흐름에 따른 영향도 및 손실평가를 조사하는 BCP를 구축하기 위한 비즈니스 영향 분석 <br>
RTO(Recovery Time Objective) - 업무중단 시점부터 업무가 복구되어 다시 가동될 때까지의 시간 <br>
RPO(Recovery Point Objective) - 업무중단 시점부터 데이터가 복구되어 다시 정상가동될 때 데이터의 손실 허용 시점 <br>
DRP(Disaster Recovery Plan) - 재난으로 장기간에 걸쳐 시설의 운영이 불가능한 경우를 대비한 재난 복구 계획 <br>
DRS(Disaster Recovery System) - 재해복구계획의 원활한 수행을 지원하기 위하여 평상시에 확보하여 두는 인적,물적 자원 및 이들에 대한 지속적인 관리체계가 통합된 재해복구센터 <br>(비즈니스 연속성 계획(BCP)이란 각종 재해나 재난발생에 대비하여 핵심 업무 기능수행의 연속성을 유지하여 고객 서비스의 지속성 보장과 고객에 대한 신뢰도를 높이는 신속한 절차와 체계를 구축해 기업의 가치를 최대화 해주는 방법론)<br>구조적 방법론(Structured Development) - 전체 시스템을 기능에 따라 나누어 개발하고, 이를 통합하는 분할과 정복 접근 방식의 방법론<br>정보공학 방법론(Information Engineering Development) - 정보시스템 개발에 필요한 관리 절차와 작업 기반을 체계화한 방법론<br>개체지향 방법론(Object-Oriented Development) - '객체'라는 기본 단위로 시스템을 분석 및 설계하는 방법론<br>컴포넌트 기반 방법론(CBD : Component Based Development) - 소프트웨어를 구성하는 컴포넌트를 조립해서 하나의 새로운 응용 프로그램을 작성하는 방법론<br>애자일 방법론(Agile Development) - 절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적용하면서 효율적으로 시스템을 개발할 수 있는 신속 적응적 경량 개발방법론<br>제품 계열 방법론(Product Line Development) - 특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론<br>참 오라클 - 모든 입력값에 대하여 기대하는 결과를 생성함으로써 발행된 오류를 모두 검출할 수 있는 오라클<br>샘플링 오라클 - 특정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공해주는 오라클<br>휴리스틱 오라클 - 샘플링 오라클을 개선한 오라클로, 특정 입력값에 대해 올바른 결과를 제공하고, 나머지 값들에 대해서는 휴리스틱(추정)으로 처리하는 오라클<br>일관성 검사 오라클 - 애플리케이션 변경이 있을 때, 수행 전과 후의 결과값이 동일한지 확인하는 오라클<br>(테스트 오라클은 테스트의 결과가 참인지 거짓인지를 판단하기 위해서 사전에 정의된 참값을 입력하여 비교하는 기법입니다.)<br>IP (Internet Protocol) - 송수신 간의 패킷 단위로 데이터를 교환하는 네트워크에서 정보를 주고받는 데 사용하는 통신 프로토콜<br>ARP (Address Resolution Protocol) - IP 네트워크상에서 IP 주소를 MAC 주소(물리 주소)로 변환하는 프로토콜<br>RARP (Reverse Address Resolution Protocol) - IP 호스트가 자신의 물리 네트워크 주소(MAC)는 알지만 IP주소를 모르는 경우, 서버로부터 IP 주소를 요청하기 위해 사용하는 프로토콜<br>ICMP (Internet Control Message Protocol) - IP 패킷을 처리할 때 발생하는 문제를 알려주는 프로토콜 메세지 형식은 8bit 헤더와 가변 길이의 데이터 영역으로 분리<br>IGMP (Internet Group Management Protocol) - 인터넷 그룹 관리 프로토콜은 호스트 컴퓨터와 인접 라우터가 멀캐스트 그룹 멤버십을 구성하는데 사용하는 통신 프로토콜<br>라우팅 프로토콜 (Routing Protocol) - 데이터 전송을 위해 목적지까지 갈 수 있는 여러 경로 중 최적의 경로를 설정해 주는 라우터 간의 상호 통신 프로토콜]]></description><link>https://lts.kr/study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-키워드.html</link><guid isPermaLink="false">study/정보처리기사/정보처리기사 실기/🥇 정보처리 기사 실기 키워드.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Mon, 21 Apr 2025 01:40:00 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-02-10_15_04_45.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-02-10_15_04_45.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🥇 정보처리 기사 실기 SQL 문제]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:정보처리기사" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정보처리기사</a> <a class="tag" href="https://lts.kr/?query=tag:실기" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#실기</a> <a class="tag" href="https://lts.kr/?query=tag:SQL" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SQL</a> <a class="tag" href="https://lts.kr/?query=tag:정리" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정리</a> <br> <a href="https://lts.kr?query=tag:정보처리기사" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정보처리기사">#정보처리기사</a> <a href="https://lts.kr?query=tag:실기" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#실기">#실기</a> <a href="https://lts.kr?query=tag:SQL" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SQL">#SQL</a> <a href="https://lts.kr?query=tag:정리" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정리">#정리</a><br>CREATE TABLE 부서 ( 부서코드 INT PRIMARY KEY, 부서명 VARCHAR(20)
); CREATE TABLE 직원 ( 직원코드 INT PRIMARY KEY, 부서코드 INT, 직원명 VARCHAR(20), FOREIGN KEY(부서코드) REFERENCES 부서(부서코드) ON DELETE CASCADE
); INSERT INTO 부서 VALUES(10, '영업부');
INSERT INTO 부서 VALUES(20, '기획부');
INSERT INTO 부서 VALUES(30, '개발부'); INSERT INTO 직원 VALUES(1001, 10, '이진수');
INSERT INTO 직원 VALUES(1002, 10, '곽명경');
INSERT INTO 직원 VALUES(1003, 20, '김건길');
INSERT INTO 직원 VALUES(1004, 20, '최민수');
INSERT INTO 직원 VALUES(1005, 20, '이용광');
INSERT INTO 직원 VALUES(1006, 30, '한성광');
INSERT INTO 직원 VALUES(1007, 30, '박미경');
<br>SELECT DISTINCT COUNT(부서코드) FROM 직원 WHERE 부서코드 = 20;
<br>결과: 3<br>해설 :<br>DISTINCT(중복 제거)는 부서코드가 아닌 COUNT(부서코드)에 적용되므로, 여전히 부서코드가 20인 컬럼의 수 '3'이 된다.
<br>DELETE FROM 부서 WHERE 부서코드 = 20;
SELECT DISTINCT COUNT(부서코드) FROM 직원;
<br>결과: 4<br>해설 :<br>부서코드가 20인 컬럼을 삭제한 후, 모든 직원테이블의 부서코드 개수를 센다. 이때 DISTINCT(중복 제거)는 COUNT에 적용되므로<br>
여전히 '4'이다.
<br>
<br>DEPT는 '학과'를 뜻한다
<br>가정: 전기과 학생 50명, 전자과 학생 100명, 전산과 학생 50명<br>SELECT DEPT FROM STUDENT;
<br>결과: 200<br>SELECT DISTINCT DEPT FROM STUDENT;
<br>결과: 3<br>해설 :<br>전기/전자/화학 3가지 종류로 이루어진 DEPT 속성의 중복을 제거하면 '3'이 남는다.
<br>SELECT COUNT(DISTINCT DEPT) FROM STUDENT WHERE DEPT = '전산과';
<br>결과: 1<br>해설 :<br>전산과인 학생들의 학과를 뽑는다. 이후 해당 학과의 중복을 제거하면 1개만 남게 된다.
<br>
<br>'H'제조사의 '단가' 보다 높은 '단가'를 가진 제품의 정보를 조회하는 SQL문이다.
<br>SELECT 제품명, 단가, 제조사
FROM 제품
WHERE 단가 &gt; ( ) (SELECT 단가 FROM 제품 WHERE 제조사 = 'H');
<br>답: ALL<br>해설 :<br>해당 쿼리는, where절의 하위 질의에 결과를 반영하여 본 질의의 조건에 추가하는 SQL이다.
<br>만약 서브쿼리에서 'H'제조사의 제품의 단다가 100/200/400 이 나왔다면,
<br>해당 단가들 보다 높은 단가를 찾기 위해서는 100/200/400을 모두 비교하여야 한다.
<br>따라서 ALL키워드가 들어간다면 모든 단가를 비교할 수 있다.
<br>서브쿼리 앞에 아무 키워드도 붙지 않는다면, 서브쿼리가 다중 행일때 오류를 발생시킨다.<br>
이때, ANY나 ALL 연산자를 사용하여 다중행을 비교할 수 있다.<br>ANY -&gt; 서브쿼리 결과 중 하나라도 참이면 해당 행은 참<br>
ALL -&gt; 서브쿼리 결과 중 모든 것에 참이어야 해당 행은 참<br>TABLE<br>SELECT COUNT(COL2)
FROM TABLE
WHERE COL1 IN (2, 3) OR COL2 IN (3, 5);
<br>결과: 3<br>해설 :<br>COL1 컬럼에 2나 3이 포함되었거나, COL2컬럼에 3이나 5가 포함된 컬럼 (4개)를 찾는다,
<br>
<br>여기서 NULL은 COUNT에 집계가 되지 않으므로 답은 '3'이다.
<br><img alt="Pasted image 20250225161448.png" src="https://lts.kr/사진-및-문서/pasted-image-20250225161448.png" target="_self"><br>결과 :<br>① TTL - ② 부장 - ③ 대리 - ④ 과장 - ⑤ 차장
<br>해설 :<br>해당 관계 대수식의 파이는 속성 리스트에 제시된 속성값만을 추출하여 새로운 릴레이션을 만드는 PROJECT연산이다
<br>따라서, TTL속성이 추출되어 속성명인 TTL부터 모든 속성값이 결과로 나타난다.<br>
= SELECT TTL FROM EMPLOYEE
<br>이 연산들은 관계형 데이터베이스의 데이터를 검색하고 변형하는 데 사용됩니다.<br>관계 대수에서 테이블을 하나의 집합(Set)으로 간주하고 수행하는 연산입니다.<br>(단, SQL문은 ISO/IEC 9075 표준을 기반으로 작성하시오.) <br>( 1 ) TABLE 학생 ( 2 ) 주소 VARCHAR(20);
<br>답 :<br>
1 -&gt; ALTER<br>
2 -&gt; ADD<br>해설 :<br>속성을 추가한다 -&gt; 테이블을 수정한다 -&gt; ALTER
<br>ALTER + ADD 속성 추가.
<br>
<br>3, 4학년의 학번, 이름을 조회한다.
<br>IN 예약어를 사용해야 한다.
<br>속성명 아래의 괄호는 속성의 자료형을 의미한다.
<br>정답 :<br>SELECT 학번, 이름 FROM 학생 WHERE 학년 IN (3, 4);
<br>해설 :<br>IN예약어는 WHERE절과 함께 쓰이며, WHERE 속성 IN (조건,조건,...) 방식으로 사용된다.
<br>해당 조건을 포함하고 있는 모든 속성이 선택되게 된다.
<br>student 테이블<br>정답 :<br>CREATE INDEX idx_name ON student(name);
<br>해설 :<br>인덱스 생성 문법 :<br>
CREATE INDEX 인덱스명 ON 테이블명(속성);
<br>(단, 아래의 실행 결과가 되도록 한다.)<br>
<br>
WHERE 조건절은 사용할 수 없다. <br>
GROUP BY는 반드시 포함한다. <br>
집계함수(Aggregation Function)를 적용한다. <br>
학과별튜플수 컬럼명을 출력에 Alias(AS)를 활용한다. <br>
문장 끝의 세미콜론(;)은 생략해도 무방하다. <br>
인용부호 사용이 필요한 경우 단일 따옴표(' ')를 사용한다.
정답 : <br>SELECT 학과, COUNT(*) AS 학과별튜플수
FROM 학생
GROUP BY 학과;
<br>&lt;처리 조건&gt;을 참고하여 적합한 SQL문을 작성하시오.<br>
<br>WHERE문은 사용하지 않는다.
<br>GROUP BY와 HAVING을 이용한다.
<br>집계함수(Aggregation Function)를 사용하여 명령문을 구성한다.
<br>최소점수, 최대점수는 별칭(Alias)을 위한 AS문을 이용한다.
<br>명령문 마지막의 세미콜론(;)은 생략 가능하다.
<br>인용 부호가 필요한 경우 작은따옴표(')를 사용한다.
<br>정답 :<br>SELECT 과목이름, MIN(점수) AS 최소점수, MAX(점수) AS 최대점수 FROM 성적 GROUP BY 과목이름 HAVING AVG(점수) &gt;= 90;
<br>해설 :<br>과목이름별로 여러 점수의 통계를 내는것 이기 때문에, GROUP BY 과목이름을 사용한다.
<br>이때, GROUP BY ~ HAVING 조건 을 사용하여, 해당 그릅화된 데이터 중 다음 조건을 만족하는 그룹만 포함한다.
<br>SELECT COUNT(*) CNT FROM A CROSS JOIN B WHERE A.NAME LIKE B.RULE;
<br>답 : 4<br>해설 :<br>SELECT COUNT(*) CNT 에서 CNT는 as CNT 가 생략된 형태이다.
<br>CROSS JOIN이란 카디션 프로덕트(곱)을 수행하는 조인방식으로써,<br>
A테이블의 모든 행과, B테이블의 모든 행의 모든 가능한 조합을 구한다.
<br>따라서, 저 중 a.name컬럼이 b.rule을 따르는(like 연산을 했을 때, 참인 결과는)<br>총 4개이다.<br>
<br>. 다음 빈칸에 들어갈 UNION 연산의 결과값을 작성하시오.<br>
<img alt="Pasted image 20250415181225.png" src="https://lts.kr/사진-및-문서/pasted-image-20250415181225.png" target="_self">
<br>[쿼리]
SELECT A FROM T1
UNION
SELECT A FROM T2
ORDER BY A DESC;
<br>UNION → 중복 제거
<br>UNION ALL → 중복 허용
<br>
4<br>
3<br>
1
<br>
<br>다음 조건을 참고하여, SQL문에서 괄호안에 알맞는 단어를 작성하시오.
<br>[조건]<br>
학생 테이블을 참조하는 다른 VIEW나 제약 조건까지 모두 삭제되어야 한다.<br>
단, 용어의 대·소문자는 상관하지 않는다.<br>DROP VIEW 학생 ( )<br>
CASCADE
<br>
<br>
다음은, 테이블에서 조건값을 실행한 화면이다. 이에 대한 알맞는 결과값을 작성하시오.<br>
<img alt="Pasted image 20250417121150.png" src="https://lts.kr/사진-및-문서/pasted-image-20250417121150.png" target="_self"> <br>
CROSS JOIN 은 카디션 곱으로, 각 행으로 만들수 있는 모든 경우 즉 6개의 행이 생긴다. <br>
그 중, s로 시작하고 , t를 포함하고 있는 컬럼은 총 4개이다. <br>
4
<br>]]></description><link>https://lts.kr/study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-sql-문제.html</link><guid isPermaLink="false">study/정보처리기사/정보처리기사 실기/🥇 정보처리 기사 실기 SQL 문제.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Fri, 18 Apr 2025 08:20:16 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20250225161448.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20250225161448.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[무제]]></title><description><![CDATA[<br>본문 바로가기<br>
Life-Journey<br>
검색내용을 입력하세요.<br>
검색블로그 이미지<br>
홈<br>
생활정보<br>
국내여행<br>
해외여행<br>
캠핑<br>
시험<br>
맛집<br>
Exam &amp; Study<br>
[2020년~] 정보처리기사 실기 족보 2탄!! (feat. 정리)<br>
by Life-Journey 2021. 7. 4.<br>안녕하세요.<br>정보처리기사 실기를 준비함에 있어 별도로 시험에 잘 나올 수 있는 부분들을 정리 및 요약하여<br>포스팅을 해 보았습니다. 흔히 말해 족보라는 것이 잘 없더라구요..<br>저도 시험 준비를 하고 있는 만큼..<br>그리고 이 글을 보고 계시는 수험생분들에게도 도움이 될 수 있도록 잘 정리해서 모두 합격할 수 있었으면 좋겠습니다.<br>클릭하면 해당 페이지로 이동됩니다.<br>
합격률	정보처리기사 필기/실기 회차별 합격률<br>
시험일정	2025년 정보처리기사 시험 일정 정보<br>
2024년 정보처리기사 시험 일정 정보<br>
2023년 정보처리기사 시험 일정 정보<br>
기출문제	2024년 3회 정보처리기사 실기 기출문제<br>
2024년 2회 정보처리기사 실기 기출문제<br>
2024년 1회 정보처리기사 실기 기출문제<br>
2023년 3회 정보처리기사 실기 기출문제<br>
2023년 2회 정보처리기사 실기 기출문제<br>
2023년 1회 정보처리기사 실기 기출문제<br>
2022년 3회 정보처리기사 실기 기출문제<br>
2022년 2회 정보처리기사 실기 기출문제<br>
2022년 1회 정보처리기사 실기 기출문제<br>
2021년 3회 정보처리기사 실기 기출문제<br>
2021년 2회 정보처리기사 실기 기출문제<br>
2021년 1회 정보처리기사 실기 기출문제<br>
2020년 4회 정보처리기사 실기 기출문제<br>
2020년 3회 정보처리기사 실기 기출문제<br>
2020년 2회 정보처리기사 실기 기출문제<br>
2020년 1회 정보처리기사 실기 기출문제<br>
정리&amp;요약	[2020년 ~] 정보처리기사 실기 족보 1탄 (정리)<br>
[2020년 ~] 정보처리기사 실기 족보 2탄 (정리)<br>
[2020년 ~] 정보처리기사 실기 족보 3탄 (요약)<br>
정보처리기사 실기 공부 방법 (꿀팁)<br>
정보처리기사 실기 쉽게 이해하는 방법 (스토리텔링)<br>
프로그래밍 언어 문제	정보처리기사 실기 Python편<br>
정보처리기사 실기 Java편<br>
정보처리기사 실기 C언어편<br>정보처리기사 족보 2탄<br>리팩토링의 목적 :<br>유지보수성 향상 - 복잡한 코드의 단순화, 소스의 가독성 향상<br>유연한 시스템 - 소프트웨어 요구사항 변경에 유연한 대응<br>생산성 향상 - 정제 및 최적화된 소스의 재사용<br>품질 향상 - 소프트웨어 오류발견이 용이하여 품질향상<br>(리팩토링은 소프트웨어 모듈의 외부적 기능은 수정하지 않고 내부적으로 구조, 관계 등을 단순화하여 소프트웨어의 유지보수성을 향상시키는 기법입니다.)<br>OSPF의 특징 :<br>다익스트라 알고리��� 사용 - 다익스트라 알고리즘을 사용하는 내부 라우팅 프로토콜<br>라우팅 메트릭 지정 - 최조, 지연 , 최대 처리량 등 관리자가 라우팅 메트릭 지정<br>AS분할 사용 - 자치 시스템을 지역으로 나누어 라우팅을 효과적으로 관리<br>홉 카운트 무제한 - 홉 카운트에 제한이 없음<br>(OSPF (Open Shortest Path First)는 대표적인 내부 라우팅 프로토콜로 다익스트라 알고리즘을 이용한 대규모 네트워크에 적합한 링크 상태 라우팅 프로토콜로도 불리는 라우팅 프로토콜 OSPF입니다.)<br>ICMP(Internet Control Message Protocol) :<br>IP 패킷을 처리할 때 발생하는 문제를 알려주는 프로토콜로, 메세지 형식은 8비트의 헤더와 가변 길이의 데이터 영역으로 분리되어 있음<br>식별자 표기법 :<br>가멜 표기법 - 식별자 표기 시에 여러 단어가 이어지면 첫 단어 시작만 소문자로 표시하고, 각 단어의 첫 글자는 대문자로 지정하는 표기법 (ex : goodMan)<br>파스칼 표기법 - 식별자 표기 시에 여러 단어가 이어지면 각 단어의 첫 글자는 대문자로 지정하는 표기법<br>(ex : GoodMan)<br>스네이크 표기법 - 식별자 표기 시에 여러 단어가 이어지면 단어 사이에 언더 바를 넣는 표기법 (ex : good_man)<br>헝가리안 표기법 - 식별자 표기 시, 두어에 자료형을 붙이는 표기법 (ex : goodMan &gt; 정수형)<br>블랙박스 테스트의 유형 :<br>동등분할 테스트 - 입력 데이터의 영역을 유사한 도메인별로 유효 값/ 무효 값을 그룹핑하여 대푯값 테스트 케이스를 도출하여 테스트하는 기법<br>경곗값 분석 테스트 - 등가 분할 후 경곗값 부분에서 오류 발생 확률이 높기 때문에 경곗값을 포함하여 테스트 케이스를 설계하여 테스트하는 기법<br>결정 테이블 테스트 - 요구사항의 논리와 발생 조건을 테이블 형태로 나열하여 조건과 행위를 모두 조합하여 테스트하는 기법<br>상태 전이 테스트 - 테스트 대상, 시스템이나 객체의 상태를 구분하고 이벤트에 의해 어느 한 상태에서 다른 상태로 전이되는 경우의 수를 수행하는 테스트 기법<br>유스케이스 테스트 - 시스템이 실제 사용되는 유스케이스로 모델링 되어있을 때 프로세스 흐름을 기반으로 테스트 케이스를 명세화하여 수행하는 테스트 기법<br>분류 트리 테스트 - SW의 일부 또는 전체를 트리 구조로 분석 및 표현하여 테스트 케이스를 설계하여 테스트하는 기법<br>페어와이즈 테스트 - 테스트 데이터값 간에 최소한 한번씩 조합하는 방식<br>원인-결과 그래프 테스트 - 그래프를 활용하여 입력 데이터 간의 관계 및 출력에 미치는 영향을 분석하여 효용성이 높은 테스트 케이스를 선정하여 테스트하는 기법<br>비교 테스트 - 여러 버전의 프로그램에 같은 입력값을 넣어서 동일한 결과 데이터가 나오는지 비교해 보는 테스트 기법<br>(블랙박스 테스트는 소프트웨어 검사 방법 중 하나로 어떤 소프트���어 를 내부 구조나 작동 원리르 모르는 상태에서 소프트웨어의 동작을 검사하는 방법입니다.)<br>EAI의 구축 유형 :<br>포인트 투 포인트 - 가장 기초적인 애플리케이션 통합방법으로 1:1 단순 통합방법<br>허브 앤 스포크 - 단일한 접점의 허브 시스템을 통하여 데이터를 전송하는 중앙 집중식 방식<br>메시지 버스 - 애플리케이션 사이 미들웨어(버스)를 두어 연계하는 미들웨어 통합 방식<br>하이브리드 - 그룹 내부는 허브 앤 스포크 방식을 사용하고, 그룹 간에는 메세지 버스 방식을 사용하는 통합 방식<br>(EAI(Enterprise Application Integration)란 기업 응용 프로그램의 구조적 통합 방안을 가리킵니다.)<br>IPv4 주소 :<br>
<br>
주소체계는 10진수로 총 12자리이며, 네 부분으로 나뉜다. <br>
각 부분은 0~255까지 3자리의 수로 표현된다. <br>
IPv4 주소는 32bit로 구성되어 있으며, 인터넷 사용자의 증가로 인해 주소 공간의 고갈로 128bit 주소체계를 갖는 IPv6가 <br>등장하고 점점 확산되고 있다.<br>IPv6 주소 :<br>
<br>IPv4의 기존 32bit 주소 공간에서 벗어나, IPv6는 128bit 주소 공간을 제공하고, IPv6는 네트워크의 물리적 위치에 제한받지 않고 같은 주소를 유지한다.
<br>디자인 패턴의 유형 :<br>목적 <br>
<br>
생성 - 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화를 수행하는 패턴 <br>
구조 - 더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴 <br>
행위 - 클래스나 객체들이 상호작용하는 방법과 역할 분담을 다루는 패턴 <br>범위<br>
<br>
클래스 - 클래스 간 관련성 / 컴파일 타임에 정적으로 결정 <br>
객체 - 객체 간 관련성을 다루는 패턴 / 런타임에 동적으로 결정 <br>네트워크 공격 기법 :<br>스니핑 - 공격 대상에게 직접 공격하지 않고 데이터만 몰래 들여다보는 수동적 공격 기법<br>네트워크 스캐너, 스피너 - 네트워크 하드웨어 및 소프트웨어 구성의 취약점 파악을 위해 공격자가 취약점을 탐색하는 공격 도구<br>패스워드 크래킹 - 사전 크래킹 공격, 무차별 크래킹 공격, 패스워드 하이브리드 공격, 레인보우 테이블 공격 활용<br>IP 스푸핑 - 침입자가 인증된 컴퓨팅 시스템인 것처럼 속여서 타깃 시스템의 정보를 빼내기 위해서 본인의 패킷 헤더를 인증된 호스트의 IP 어드레스로 위조하여 타깃에 전송하는 공격기법<br>ARP 스푸핑 - 공격자가 특정 호스트의 MAC 주소를 자신의 MAC 주소로 위조한 ARP Reply를 만들어 희생자에게 지속적으로 전송하여 희생자의 ARP Cache Table에 특정 호스트의 MAC 정보를 공격자의 MAC 정보로 변경, 희생자로부터 특정 호스트로 나가는 패킷을 공격자가 스니핑하는 공격 기법<br>ICMP Redirect 공격 - 3계층에서 스니핑 시스템을 네트워크에 존재하는 또 다른 라우터라고 알림으로써 패킷의 흐름을 바꾸는 공격 기법<br>트로이 목마 - 악성 루틴이 숨어 있는 프로그램으로 겉보기에는 정상적인 프로그램으로 보이지만 실행하면 악성 코드를 실행하는 프로그램<br>NAT 유형 :<br>Static NAT - 사설 IP주소와 공인 IP주소가 1:1로 연결되는 구성<br>Dynamic NAT - 사설 IP와 공인 IP주소가 N:1 또는 N:M으로 연결되는 구성<br>(NAT(Network Address Transformation) 는 보통 사설 네트워크에 속한 여러 개의 호스트가 하나의 공인 IP 주소를 사용하여 인터넷에 접속하기 위하여 사용합니다.)<br>블록체인 합의 알고리즘 :<br>PoW (Proof of Work) - 확률적으로 해답이 어려운 문제를 가장 빨리 해결한 사람에게 블록을 만들 수 있도록 허가<br>PoS (Proof of Stake) - 이더러움이 채택한 알고리즘으로 화폐량을 더 많이 소유하고 있는 승인자가 우선하여 블록을 생성할 수 있는 알고리즘<br>(블록체인은 분산 컴퓨팅 기술 기반의 데이터 위변조 방지 기술로 P2P 방식을 기반으로하여 소규모 데이터들이 연결되어 형성된 '블록'이라는 분산 데이터 저장 환경에 관리 대상 데이터를 저장함으로써 누구도 임의로 수정할 수 없고 누구나 변경의 결과를 열람할 수 없게끔 만드는 기술입니다.)<br>하둡(Hadoop)의 구성 :<br>하둡 분산 파일 시스템 (HDFS) - 대용량 파일을 분산된 서버에 저장하고 그 저장된 데이터를 빠르게 처리할 수 있게 하는 시스템<br>맵리듀스 (Map Reduce) - 대용량 데이터 세트를 분산 병렬 컴퓨팅에서 처리하거나 생성하기 위한 목적으로 만들어진 소프트웨어 프레임워크<br>(하둡은 오픈 소스를 기반으로 한 분산 컴퓨팅 플랫폼으로, 일반 PC급 컴퓨터들로 가상화된 대형 스토리지를 형성하고 그 안에 보관된 거대한 데이터 세트를 병렬로 처리할 수 있도록 개발된 자바 소프트웨어 프레임워크로 구글, 야후 등에 적용한 기술입니다.)<br>데이터베이스 이상 현상 :<br>삽입 이상 - 정보 저장 시 해당 정보의 불필요한 세부정보를 입력해야 하는 경우<br>삭제 이상 - 정보 삭제 시 원치 않는 다른 정보가 같이 삭제되는 경우<br>갱신 이상 - 중복 데이터 중에서 특정 부분만 수정되어 중복된 값이 모순을 일으키는 경우<br>(데이터베이스 이상 현상이란 갱신/삽입/삭제하였을때 그 속성의 다른 속성값들과의 불일치가 발생하는 현상입니다.)<br>프로세스 상태 전이 :<br>생성 상태 - 사용자에 의해 프로세스가 생성된 상태<br>준비 상태 - CPU를 할당받을 수 있는 상태<br>살행 상태 - 프로세스가 CPU를 할당받아 동작 중인 상태<br>대기 상태 - 프로세스 실행 중 입출력 처리 등으로 인해 CPU를 양도하고 입출력 처리가 완료까지 대기 리스트에서 기다리는 상태<br>완료 상태 - 프로세스가 CPU를 할당받아 주어진 시간 내에 완전히 수행을 종료한 상태<br>(프로세스 상태 전이는 다중 프로그래밍 환경을 바탕하기에 상태 전이가 이루어집니다.)<br>테스트 오라클 유형 :<br>참 오라클 - 모든 입력값에 대하여 기대하는 결과를 생성함으로써 발행된 오류를 모두 검출할 수 있는 오라클<br>샘플링 오라클 - 특정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공해주는 오라클<br>휴리스틱 오라클 - 샘플링 오라클을 개선한 오라클로, 특정 입력값에 대해 올바른 결과를 제공하고, 나머지 값들에 대해서는 휴리스틱(추정)으로 처리하는 오라클<br>일관성 검사 오라클 - 애플리케이션 변경이 있을 때, 수행 전과 후의 결과값이 동일한지 확인하는 오라클<br>(테스트 오라클은 테스트의 결과가 참인지 거짓인지를 판단하기 위해서 사전에 정의된 참값을 입력하여 비교하는 기법입니다.)<br>네트워크 계층(3계층) 프로토콜 종류 :<br>IP (Internet Protocol) - 송수신 간의 패킷 단위로 데이터를 교환하는 네트워크에서 정보를 주고받는 데 사용하는 통신 프로토콜<br>ARP (Address Resolution Protocol) - IP 네트워크상에서 IP 주소를 MAC 주소(물리 주소)로 변환하는 프로토콜<br>RARP (Reverse Address Resolution Protocol) - IP 호스트가 자신의 물리 네트워크 주소(MAC)는 알지만 IP주소를 모르는 경우, 서버로부터 IP 주소를 요청하기 위해 사용하는 프로토콜<br>ICMP (Internet Control Message Protocol) - IP 패킷을 처리할 때 발생하는 문제를 알려주는 프로토콜 메세지 형식은 8bit 헤더와 가변 길이의 데이터 영역으로 분리<br>IGMP (Internet Group Management Protocol) - 인터넷 그룹 관리 프로토콜은 호스트 컴퓨터와 인접 라우터가 멀캐스트 그룹 멤버십을 구성하는데 사용하는 통신 프로토콜<br>라우팅 프로토콜 (Routing Protocol) - 데이터 전송을 위해 목적지까지 갈 수 있는 여러 경로 중 최적의 경로를 설정해 주는 라우터 간의 상호 통신 프로토콜<br>DB설계 절차 :<br>요구사항 분석 - 사용자에게서 데이터베이스를 사용하는 용도를 파악<br>개념적 설계 - 요구사항 명세서를 기반으로 개념적 데이터 모델을 표현하며 E-R다이어그램으로 표현할 수 있음<br>논리적 설계 - 목표 DBMS에 맞는 스키마 설계, 트랜잭션 인터페이스를 설계하는 정규화 과정을 수행함<br>물리적 설계 - 특정 DBMS의 특성 및 성능을 고려하여 데이터베이스 저장 구조로 변환하는 과정으로 결과로 나오는 명세서는 테이블 저의서 등이 있음<br>구현 - SQL문을 실행하여 데이터베이스를 실제로 생성함<br>테스트 레벨 종류 :<br>단위 테스트 - 사용자 요구사항에 대한 단위 모듈, 서브루틴 등을 테스트하는 단계 (개발)<br>통합 테스트 - 단위 테스트를 통과한 모듈 사이의 인터페이스, 통합된 컴포넌트 간의 상호작용을 검증하는 테스트 단계 (설계)<br>시스템 테스트 - 통합된 단위 시스템의 기능이 시스템에서 정상적으로 수행되는지를 검증하는 테스트 단계 (기계 명세 분석)<br>인수 테스트 - 계약상의 요구사항이 만족하였는지 확인하기 위한 테스트 단계 (요구사항 분석)<br>알파 테스트 - 선택된 사용자가 개발자 환경에서 통제된 상태로 개발자와 함께 수행하는 인수 테스트<br>베타 테스트 - 실제 환경에서 일정 수의 사용자에게 대상 소프트웨어를 사용하게 하고 피드백을 받는 인수 테스트<br>회귀 테스트 - 회귀 테스트는 오류를 제거하거나 수정한 시스템에서 오류 제거와 수정 때문에 새로이 유입된 오류가 없는<br>지 확인하는 일종의 반복 테스트 기법<br>IPC 기법 :<br>메시지 큐 - 메시지 단위로 동작하여 프로세스 간 통신함<br>공유메모리 - 한 프로세스의 일부분을 다른 프로세스와 공유<br>소켓 - 클라이언트와 서버 프로세스 둘 사이에 통신을 가능하게 함<br>세마포어 - 프로세스 사이의 동기를 맞추는 기능을 제공함<br>(IPC(Inter-Process Communication)는 프로세스 간 통신 기술입니다.)<br>데이터 모델 구성요소 :<br>연산 - 데이터베이스에서 저장된 실제 데이터를 처리하는 작업에 대한 명세<br>구조 - 논리적으로 표현된 개체 타입 간의 관계<br>제약조건 - 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약조건<br>서버 접근통제 유형 :<br>임의적 접근통제(DAC:Discretionary Access Control) - 시스템에 대한 접근을 사용자/그룹의 신분 기반으로 제한하는 방법 <br>강제적 접근통제(MAC:Mandatory Access Control) - 시스템 정보의 허용등급을 기준으로 사용자가 갖는 접근 허가 권한에 근거하여 시스템에 대한 접근을 제한하는 방법<br>역할 기반 접근통제 (RBAC:Role Based Access Control) - 중앙 관리자가 사용자와 시스템의 상호관계를 통제하며 조직 내 맡은 역할에 기초하여 자원에 대한 접근을 제한하는 방법<br>클릭하면 해당 페이지로 이동됩니다.<br>
합격률	정보처리기사 필기/실기 회차별 합격률<br>
시험일정	2025년 정보처리기사 시험 일정 정보<br>
2024년 정보처리기사 시험 일정 정보<br>
2023년 정보처리기사 시험 일정 정보<br>
기출문제	2024년 3회 정보처리기사 실기 기출문제<br>
2024년 2회 정보처리기사 실기 기출문제<br>
2024년 1회 정보처리기사 실기 기출문제<br>
2023년 3회 정보처리기사 실기 기출문제<br>
2023년 2회 정보처리기사 실기 기출문제<br>
2023년 1회 정보처리기사 실기 기출문제<br>
2022년 3회 정보처리기사 실기 기출문제<br>
2022년 2회 정보처리기사 실기 기출문제<br>
2022년 1회 정보처리기사 실기 기출문제<br>
2021년 3회 정보처리기사 실기 기출문제<br>
2021년 2회 정보처리기사 실기 기출문제<br>
2021년 1회 정보처리기사 실기 기출문제<br>
2020년 4회 정보처리기사 실기 기출문제<br>
2020년 3회 정보처리기사 실기 기출문제<br>
2020년 2회 정보처리기사 실기 기출문제<br>
2020년 1회 정보처리기사 실기 기출문제<br>
정리&amp;요약	[2020년 ~] 정보처리기사 실기 족보 1탄 (���리)<br>
[2020년 ~] 정보처리기사 실기 족보 2탄 (정리)<br>
[2020년 ~] 정보처리기사 실기 족보 3탄 (요약)<br>
정보처리기사 실기 공부 방법 (꿀팁)<br>
정보처리기사 실기 쉽게 이해하는 방법 (스토리텔링)<br>
프로그래밍 언어 문제	정보처리기사 실기 Python편<br>
정보처리기사 실기 Java편<br>
정보처리기사 실기 C언어편<br>좋아요27<br>
공유하기게시글 관리<br>
구독하기<br>
저작자표시<br>
응원하기<br>
'Exam &amp; Study' 카테고리의 다른 글<br>
[2021년 2회] 정보처리기사 실기 기출문제!! (15)	2021.09.02<br>
[2020년~] 정보처리기사 실기 족보 3탄!! (feat. 요약) (3)	2021.07.09<br>
[2020년 1회] 정보처리기사 실기 기출문제!! (4)	2021.07.04<br>
[2020년 2회] 정보처리기사 실기 기출문제!! (11)	2021.07.04<br>
[2020년 3회] 정보처리기사 실기 기출문제!! (0)	2021.07.04<br>
태그<br>
내용요약정리, 문제대비, 실기기출문제, 예상문제, 정보처리기사, 족보<br>
관련글<br>[2021년 2회] 정보처리기사 실기 기출문제!!<br>[2020년~] 정보처리기사 실기 족보 3탄!! (feat. 요약)<br>[2020년 1회] 정보처리기사 실기 기출문제!!<br>[2020년 2회] 정보처리기사 실기 기출문제!!<br>
댓글3<br>
Life-Journey님의<br>
글이 좋았다면 응원을 보내주세요!<br>응원하기<br>응원하기<br>
란?<br>
Life-Journey<br>
라이프 분야 크리에이터<br>
We meet many people throughout the journey of life, each leaving a mark.<br>구독하기<br>
Favicon of <a rel="noopener nofollow" class="external-link is-unresolved" href="https://daebakstock.tistory.com" target="_self">https://daebakstock.tistory.com</a> 대박스탁 2021.07.06 19:30 신고더보기<br>
좋은 정보 잘 읽고 갑니다<br>
빗길 조심하시고 행복한 저녁시간 보내세요<br>
답글<br>Favicon of <a rel="noopener nofollow" class="external-link is-unresolved" href="https://pabami.tistory.com" target="_self">https://pabami.tistory.com</a> YohanKim 2021.10.15 00:18 신고더보기<br>
감사합니다! 스스로 정리하려고 했는데, 이렇게 잘 정리해서 올려주셔서 감사합니다.<br>
답글<br>Life-Journey 2021.10.15 07:15 신고더보기<br>
아닙니다 도움이 되셨으면 좋겠습니다 :)<br>이름<br>
비밀번호<br>
비밀글<br>
여러분의 소중한 댓글을 입력해주세요.<br>
등록<br>분류 전체보기 N<br>
Life Writing N<br>
AI<br>
JAVA<br>
Python<br>
Linux<br>
Spring<br>
IT Information<br>
JAVASCRIPT &amp; JQUERY<br>
Error<br>
Database<br>
Domestic Travel N<br>
Overseas Travel<br>
Camping<br>
Website Production<br>
Exam &amp; Study<br>
Algorithm<br>
Must-Eat<br>공지사항<br>최근글인기글<br>벚꽃이 만개한 '동학사 벚꽃축제'의 생생한 현장 ⋯<br>
2025.04.16<br>우엉차, 건강을 담은 구수한 한 잔 (정의와 효능⋯<br>
2025.04.15<br>네이버 안전결제 사기 수법 사례 및 예방법 (+ ⋯<br>
2025.04.09<br>[IntelliJ] 한글 언어 팩 적용 안될 경우⋯<br>
2025.04.05<br>아이크림의 효능과 국내 브랜드 종류<br>
2025.03.29<br>최근댓글<br>
result[i] = (p[i]-'A'+5)% 25 +⋯<br>
페이지 히트하면 애초에 데이터가 안들어옵니다. 다섯 번⋯<br>
실제 실행해 보면 A0 가 나옵니다. 제네릭 타입 소⋯<br>
글 보자마자 취미가 비슷해서 신기하고 기분이 좋았어요!⋯<br>태그<br>
티스토리챌린지 스프링 익산여행지 정보처리기사 홈페이지제작 개정안 HTML 충청도가볼만한곳 MySQL 체크박스 제주도 JavaScript 데이터베이스 jsp 웹홈페이지제작 웹게시판 데이트코스 java 유효성검사 제이쿼리 실기시험 자바스크립트 jQuery 기출문제 게시판 jstl 익산가볼만한곳 오블완 자바 가답안<br>전체 방문자<br>
3,055,638<br>Today : 1,591<br>Yesterday : 14,215<br>TOP<br>
관리메뉴열기Life-Journey구독하기]]></description><link>https://lts.kr/study/정보처리기사/정보처리기사-실기/무제.html</link><guid isPermaLink="false">study/정보처리기사/정보처리기사 실기/무제.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Fri, 18 Apr 2025 02:24:17 GMT</pubDate></item></channel></rss>