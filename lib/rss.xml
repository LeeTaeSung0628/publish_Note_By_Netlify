<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Category]]></title><description><![CDATA[Obsidian digital garden]]></description><link>https://lts.kr/</link><image><url>https://lts.kr/lib/media/favicon.png</url><title>Category</title><link>https://lts.kr/</link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Fri, 23 May 2025 02:22:15 GMT</lastBuildDate><atom:link href="https://lts.kr/lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Fri, 23 May 2025 02:22:13 GMT</pubDate><copyright><![CDATA[taesung's Blog]]></copyright><ttl>60</ttl><dc:creator>taesung's Blog</dc:creator><item><title><![CDATA[🖨 NP_시장조사]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:프로젝트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로젝트</a> <a class="tag" href="https://lts.kr/?query=tag:개발" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#개발</a> <a class="tag" href="https://lts.kr/?query=tag:개요" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#개요</a> <a class="tag" href="https://lts.kr/?query=tag:시장조사" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#시장조사</a> <a class="tag" href="https://lts.kr/?query=tag:아이디어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#아이디어</a> <br> <a href="https://lts.kr?query=tag:프로젝트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로젝트">#프로젝트</a> <a href="https://lts.kr?query=tag:개발" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#개발">#개발</a> <a href="https://lts.kr?query=tag:개요" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#개요">#개요</a> <a href="https://lts.kr?query=tag:시장조사" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#시장조사">#시장조사</a> <a href="https://lts.kr?query=tag:아이디어" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#아이디어">#아이디어</a><br>
<br>신규 웹 프로젝트를 기획을 위한 시장 조사 단계이다.
<br>ChatGPT의 심층 리서치 기능을 참고하였다. → <a data-href="GPT심층 리서치 자료" href="https://lts.kr/GPT심층 리서치 자료" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">GPT심층 리서치 자료</a>
<br>인터넷에서 적은 비용·시간 투자로도 폭발적인 유저 확보가 가능했던 사례들을 살펴보면, 공통적으로 신선한 아이디어와 공유 욕구를 자극하는 요소가 있었습니다. 아래에는 일반 대중을 타겟으로 빠르게 바이럴 되어 브랜드 인지도를 높일 수 있는 웹 페이지 아이디어 5가지를 소개합니다. 각 아이디어마다 핵심 개념, 매력 요인, 성공 가능성, 유사한 성공 사례, 그리고 개발 난이도를 정리했습니다.<br>
<br>핵심 개념: 사용자에게 재미있는 퀴즈나 성격 테스트를 제공하고 결과를 보여주는 웹 페이지입니다. 예를 들어 “나와 어울리는 캐릭터는?”, “페이스북에서 가장 많이 쓴 단어는?” 같은 질문으로 간단한 퀴즈를 만들어 결과를 시각화해줍니다. 사용자는 자신의 데이터나 응답을 통해 개인화된 결과(예: 단어 구름, 점수, 유형)를 얻고 이를 소셜 미디어에 공유할 수 있습니다. <br>유저 유인 요소: 사람들은 자신에 대한 결과를 보는 것에 흥미를 느끼고, 이를 친구들과 공유하는 것을 즐깁니다<a data-tooltip-position="top" aria-label="https://www.shortstack.com/blog/how-to-use-buzzfeed-style-quizzes-for-marketing-2#:~:text=Have%20you%20ever%20taken%20a,social%20media%2C%20according%20to%20Buzzsumo" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.shortstack.com/blog/how-to-use-buzzfeed-style-quizzes-for-marketing-2#:~:text=Have%20you%20ever%20taken%20a,social%20media%2C%20according%20to%20Buzzsumo" target="_self">shortstack.com</a>. 재밌거나 공감가는 결과는 밈(meme)처럼 퍼지며, 친구의 공유를 본 다른 사람들도 호기심에 참여하게 됩니다. 결과 이미지나 설명이 독특하고 공감될수록 바이럴 요소가 커집니다 (예: 웃음을 주거나, 의외의 사실을 알려주는 결과). <br>성공 가능성: 이러한 퀴즈는 빠르게 대규모 사용자를 모을 가능성이 높습니다. 구현이 비교적 간단하면서도 참여 장벽이 낮고 재미있기 때문입니다. 한번 바이럴되면 짧은 기간에 수백만 사용자가 몰릴 수도 있습니다. 실제로 한 페이스북 퀴즈 앱은 출시 5일 만에 1,750만 명이 참여하여 결과를 공유했을 정도로 폭발적 인기를 끌었습니다<a data-tooltip-position="top" aria-label="https://time.com/4126945/facebook-most-used-words-vonvon/#:~:text=Since%20Monday%2C%20other%20users%20began,than%20300%2C000%20have%20tried%20it" rel="noopener nofollow" class="external-link is-unresolved" href="https://time.com/4126945/facebook-most-used-words-vonvon/#:~:text=Since%20Monday%2C%20other%20users%20began,than%20300%2C000%20have%20tried%20it" target="_self">time.com</a>. 공유를 통해 무료로 홍보 효과를 얻을 수 있어 브랜드 노출에도 유리합니다. <br>유사 성공 사례: 대표적으로 2015년 유행한 Vonvon의 “가장 많이 사용한 단어” 페이스북 퀴즈가 있습니다. 사용자의 페이스북 글을 분석해 단어 구름 결과를 보여준 이 퀴즈는 출시 첫 주에 1천7백만 명 이상이 즐겼고<a data-tooltip-position="top" aria-label="https://time.com/4126945/facebook-most-used-words-vonvon/#:~:text=Since%20Monday%2C%20other%20users%20began,than%20300%2C000%20have%20tried%20it" rel="noopener nofollow" class="external-link is-unresolved" href="https://time.com/4126945/facebook-most-used-words-vonvon/#:~:text=Since%20Monday%2C%20other%20users%20began,than%20300%2C000%20have%20tried%20it" target="_self">time.com</a>, 수많은 사람들이 자신의 단어 구름을 페이스북에 올리며 입소문이 났습니다. BuzzFeed의 성격 테스트들도 소셜 미디어에서 자주 공유되며 트래픽 붐을 일으켰고, 심리테스트형 콘텐츠는 한국에서도 종종 큰 유행을 만들곤 했습니다. <br>개발 및 운영 난이도: 개발 난이도는 낮은 편입니다. 간단한 프론트엔드와 약간의 백엔드 로직만으로 구현 가능하며, 오픈 소스 라이브러리나 소셜미디어 API를 활용하면 개발 시간이 단축됩니다. 예를 들어 페이스북 API로 사용자의 게시글을 수집하여 단어 빈도를 계산하고, 자바스크립트로 예쁜 워드 클라우드를 그리는 정도의 작업입니다. 초기 비용도 도메인, 호스팅 등 최소한으로 들고, 개발 기간 역시 몇 주 이내로 짧을 수 있습니다. 다만 트래픽 폭증 시 서버 인프라 비용은 증가할 수 있고, 소셜미디어 플랫폼의 정책 변화에 대비한 유지보수는 고려해야 합니다. <br>
<br>핵심 개념: 사진이나 영상을 활용한 재미있는 합성/분석 웹 페이지입니다. 사용자가 자기 사진을 업로드하거나 간단한 입력을 하면, 이를 바탕으로 흥미로운 결과물을 즉석에서 생성해줍니다. 예를 들어 업로드한 얼굴 사진으로 나이와 성별을 추측해준다든지, 자신의 얼굴을 특정 캐릭터나 배경과 합성해준다든지 하는 기능입니다. 최근에는 AI를 이용해 그림이나 사진을 변환하거나 문장을 이미지로 생성해주는 간단 웹툴도 여기에 속합니다. <br>유저 유인 요소: 사람들은 자신의 얼굴이나 정보가 재미있게 활용된 결과를 보는 것을 좋아합니다. 특히 결과가 의외성이 있거나 웃음을 유발하면 이를 친구들과 공유하게 되죠. “내 사진으로 이런 일이 가능하다니!”라는 신기함과 재미가 입소문 포인트입니다. 결과물을 다운로드하거나 링크로 공유하기 쉽게 하면 바이럴 효과가 커집니다. 또한 최신 AI 기술을 활용했다면 신기함에 더 많은 유저들이 몰립니다. <br>성공 가능성: 적절한 아이디어만 있다면 단기간에 큰 성공을 거둘 확률이 높습니다. 예를 들어 마이크로소프트가 시범으로 선보였던 “How-old.net” 사이트는 사진 속 얼굴의 나이를 자동으로 추정해주는 간단한 서비스였는데, 놀랍게도 공개 몇 시간 만에 3만 명이 찾았고 곧 순식간에 폭발적인 바이럴이 일어났습니다<a data-tooltip-position="top" aria-label="https://time.com/3842400/how-old-microsoft-guess-age/#:~:text=project%20started%20as%20a%20simple,could%20accurately%20read%20their%20face" rel="noopener nofollow" class="external-link is-unresolved" href="https://time.com/3842400/how-old-microsoft-guess-age/#:~:text=project%20started%20as%20a%20simple,could%20accurately%20read%20their%20face" target="_self">time.com</a>. 이 서비스는 처음엔 50명 테스트용으로 시작했지만 일주일도 안 돼 3천3백만 명이 이용하는 초대형 히트를 기록했습니다<a data-tooltip-position="top" aria-label="https://azure.microsoft.com/fr-fr/blog/how-old-net-augmenting-virality-in-real-time-with-batch-analytics-using-data-factory/#:~:text=Microsoft%20launched%20the%20How,time%20with%20historic%20data%20analytics" rel="noopener nofollow" class="external-link is-unresolved" href="https://azure.microsoft.com/fr-fr/blog/how-old-net-augmenting-virality-in-real-time-with-batch-analytics-using-data-factory/#:~:text=Microsoft%20launched%20the%20How,time%20with%20historic%20data%20analytics" target="_self">azure.microsoft.com</a>. 이처럼 신기하고 재미있는 결과만 주어지면 사용자들은 너도나도 몰려들어 짧은 시간에 수백만 뷰를 달성할 수 있습니다. <br>유사 성공 사례: How-old.net 이외에도 2000년대 후반 유행했던 ElfYourself가 좋은 예입니다. 이용자가 자신의 얼굴 사진을 올리면 춤추는 엘프 영상에 얼굴이 합성되어 재미난 e-카드 영상을 만들 수 있었는데, 6주 동안 1억9천만 회 이상의 방문을 끌어모으며 엄청난 바이럴 성공을 거두었습니다<a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=YVtY8m4-_ZA#:~:text=OfficeMax%27s%20holiday%20campaign%2C%20ElfYourself,visits%20during%20six%20weeks" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.youtube.com/watch?v=YVtY8m4-_ZA#:~:text=OfficeMax%27s%20holiday%20campaign%2C%20ElfYourself,visits%20during%20six%20weeks" target="_self">youtube.com</a>. 한국에서도 몇 년 전 유행한 토익 얼굴합성이나 증명사진으로 연예인 닮은꼴 찾기 서비스 등이 SNS 상에서 퍼져 나간 바 있습니다. 이러한 사례들은 기업 브랜드 로고나 이름을 서비스 내에 노출시켜 자연스럽게 브랜드 인지도도 상승시켰습니다. <br>개발 및 운영 난이도: 기술적 난이도는 중간 정도입니다. 단순한 합성이라면 HTML5 캔버스나 오픈소스 스크립트로 구현 가능하고, 얼굴 인식이나 AI 활용은 공개 API(예: 얼굴 인식 API)나 오픈소스 모델을 쓰면 개발 시간을 줄일 수 있습니다. How-old.net의 경우도 기존에 공개된 얼굴인식 API를 조합해 해커톤 수준으로 빠르게 만들었습니다<a data-tooltip-position="top" aria-label="https://time.com/3842400/how-old-microsoft-guess-age/#:~:text=project%20started%20as%20a%20simple,could%20accurately%20read%20their%20face" rel="noopener nofollow" class="external-link is-unresolved" href="https://time.com/3842400/how-old-microsoft-guess-age/#:~:text=project%20started%20as%20a%20simple,could%20accurately%20read%20their%20face" target="_self">time.com</a>. 개발 기간은 아이디어 복잡도에 따라 몇 주에서 1~2달 내외이며, 초기 비용은 클라우드 API 사용료나 서버비 정도로 저렴합니다. 다만 이미지/영상 업로드를 다루므로 트래픽 증가 시 인프라 확장과, 대량 사용에 대비한 API 쿼터 관리 등이 필요합니다. <br>많은 이용자를 모으는 캐주얼 웹 게임은 투자 대비 큰 성과를 낸 사례가 있습니다. 예를 들어 단어 맞추기 퍼즐이나 클릭하는 캐주얼 게임 등을 웹 페이지로 제공하고, 랭킹 공유나 도전 요소를 넣어 사용자 참여를 유도하는 아이디어입니다. 특히 하루에 한 번 문제를 푸는 데일리 챌린지 게임 형태로 만들면 지속 참여와 입소문 전파를 노릴 수 있습니다.<br>핵심 개념: 규칙이 단순하고 금방 플레이할 수 있는 웹 기반 게임입니다. 설치나 회원가입 없이 브라우저에서 바로 즐길 수 있어 진입 장벽이 낮습니다. 예를 들어 하루에 하나의 다섯 글자 단어를 맞히는 퍼즐 게임(※ 대표적으로 Wordle, 한국어의 경우 번역되어 알려진 “워들” 등이 있음), 몇 초 만에 끝나는 미니게임(Flappy Bird와 유사한 웹버전 등) 등이 해당됩니다. 짧은 라운드와 반복 플레이가 가능하도록 설계합니다. <br>유저 유인 요소: 성취감과 경쟁심을 자극하는 요소가 중요합니다. 퍼즐을 풀거나 신기록을 세우면 이를 소셜 미디어에 공유하거나 친구들과 기록을 비교하도록 유도합니다. 예를 들어 Wordle은 성공 시 타일 색 패턴을 공유하는 기능으로 트위터에서 자발적 전파가 되었는데, 이런 “결과 자랑” 요소가 유저들을 끌어모았습니다<a data-tooltip-position="top" aria-label="https://buildd.co/product/wordle-the-viral-sensation#:~:text=users" rel="noopener nofollow" class="external-link is-unresolved" href="https://buildd.co/product/wordle-the-viral-sensation#:~:text=users" target="_self">buildd.co</a><a data-tooltip-position="top" aria-label="https://buildd.co/product/wordle-the-viral-sensation#:~:text=But%20why%20did%20Wordle%20go,can%20share%20your%20results%20publicly" rel="noopener nofollow" class="external-link is-unresolved" href="https://buildd.co/product/wordle-the-viral-sensation#:~:text=But%20why%20did%20Wordle%20go,can%20share%20your%20results%20publicly" target="_self">buildd.co</a>. 또한 하루 한 번 새로운 도전이 열리면 사용자들이 일상 루틴으로 게임을 즐기고 서로 대화를 나누며 바이럴이 지속됩니다. <br>성공 가능성: 게임성이 충분히 재미있고 공유 요소가 잘 설계되면 단기간에 대규모 이용자를 확보할 수 있습니다. Wordle의 경우 출시 한 달 후 일일 이용자가 90명에 불과했지만, 입소문을 타고 불과 3개월 만에 일일 이용자 300만 명 규모의 세계적 히트작이 되었습니다<a data-tooltip-position="top" aria-label="https://buildd.co/product/wordle-the-viral-sensation#:~:text=How%20Wordle%20became%20so%20popular%3A,anatomy%20of%20a%20viral%20product" rel="noopener nofollow" class="external-link is-unresolved" href="https://buildd.co/product/wordle-the-viral-sensation#:~:text=How%20Wordle%20became%20so%20popular%3A,anatomy%20of%20a%20viral%20product" target="_self">buildd.co</a>. 1인 개발 게임임에도 불구하고 이런 폭발적 성장을 이뤄낸 것은 이용자들 사이의 바이럴 전파 덕분이었습니다. 흥미로운 게임은 금세 트위터, 페이스북 등으로 퍼져나가 앱 설치 없이도 순식간에 수백만 유저를 모을 수 있음을 보여줍니다<a data-tooltip-position="top" aria-label="https://buildd.co/product/wordle-the-viral-sensation#:~:text=How%20Wordle%20became%20so%20popular%3A,anatomy%20of%20a%20viral%20product" rel="noopener nofollow" class="external-link is-unresolved" href="https://buildd.co/product/wordle-the-viral-sensation#:~:text=How%20Wordle%20became%20so%20popular%3A,anatomy%20of%20a%20viral%20product" target="_self">buildd.co</a>. <br>유사 성공 사례: Wordle(워들)이 가장 대표적인 사례로, 간단한 단어 추측 게임을 웹으로 제공하여 2021~2022년 전세계적으로 선풍적 인기를 끌었습니다<a data-tooltip-position="top" aria-label="https://buildd.co/product/wordle-the-viral-sensation#:~:text=How%20Wordle%20became%20so%20popular%3A,anatomy%20of%20a%20viral%20product" rel="noopener nofollow" class="external-link is-unresolved" href="https://buildd.co/product/wordle-the-viral-sensation#:~:text=How%20Wordle%20became%20so%20popular%3A,anatomy%20of%20a%20viral%20product" target="_self">buildd.co</a>. 그 외에도 예전에 유행한 2048 퍼즐 게임은 19세 개발자가 주말에 만든 웹게임이었는데 SNS를 통해 퍼지면서 수천만명이 즐겼습니다. 한국에서도 산성비 게임이나 손가락 달리기 등의 간단 웹게임이 커뮤니티를 타고 유행한 바 있고, 이러한 게임들은 기업이 제작해 배포하면 브랜드 홍보 효과까지 얻곤 했습니다. <br>개발 및 운영 난이도: 개발은 비교적 간단합니다. HTML/CSS/JavaScript를 활용하여 2D 그래픽 기반의 게임을 만들 수 있고, 복잡한 서버 연동이 없는 싱글플레이 게임이면 1~2명의 개발자가 짧은 기간 내 제작 가능합니다. Wordle도 한 사람이 취미로 개발했습니다. 개발 기간은 게임 기획 난이도에 따라 몇 주에서 두어 달 정도입니다. 운영 측면에서는 별도의 콘텐츠 업데이트가 많지 않다면 유지보수 부담도 적습니다. 서버 비용도 텍스트나 간단 리소스 위주라 크지 않은데, 다만 트래픽 폭주 시를 대비해 CDN 활용이나 캐싱 등 규모 확장 전략을 준비하면 좋습니다. <br>단순한 기능보다 아이디어 자체의 기발함으로 화제가 되는 웹 페이지입니다. 이는 일종의 이색적인 컨셉의 프로젝트 사이트로, 언뜻 쓸모없어 보이지만 호기심을 자극하는 아이디어를 내세워 사람들을 끌어모읍니다. 이러한 사이트는 언론 보도나 입소문을 통해 폭발적으로 트래픽을 얻으며, 브랜드 인지도를 단기간에 크게 높일 수 있습니다.<br>핵심 개념: 새롭고 특이한 컨셉의 웹사이트를 만드는 것입니다. 예를 들어 한 페이지 전체를 100만 개의 픽셀로 나눠 팔겠다는 발상이나, 웹페이지에 한 번씩만 누를 수 있는 의미없는 버튼을 달아 사람들의 참여를 유도하는 등의 컨셉입니다. 중요한 것은 기존에 없던 형식이거나 한번 들으면 궁금해서 방문하게 되는 주제여야 합니다. 이러한 사이트는 실용성보다는 이슈화 자체가 목표이며, 참여한 사람들에게는 “나도 거기에 참여했다”는 재미있는 경험을 제공합니다. <br>유저 유인 요소: 호기심과 재미가 가장 큰 유인입니다. 사람들은 “이게 뭔지 한번 눌러봐야겠다”는 생각이 들게 하는 신기한 아이디어에 이끌립니다. 또한 언론이나 커뮤니티에서 화제가 되면 너도나도 방문하게 되고, 참여형이면 본인도 한 몫 했다는 만족감을 느낍니다. 이러한 사이트는 한번 화제가 되면 지속적으로 회자되므로 추가 광고 없이도 계속 유저가 유입되는 경향이 있습니다. 퀴즈형이나 게임형과 달리 단발성 방문일지라도 워낙 많은 사람을 끌어모아 브랜드/사이트 이름을 각인시키는 효과가 큽니다. <br>성공 가능성: 아이디어만 참신하다면 대박을 터뜨릴 가능성이 있습니다. 역사적으로 유명한 “백만 달러 홈페이지” 사례를 보면, 단지 50유로 남짓의 도메인 비용으로 시작한 이 기발한 사이트는 사람들의 입소문과 언론 보도로 개설 한 달 만에 25만 달러어치를 팔아치우며 화제가 되었습니다<a data-tooltip-position="top" aria-label="https://www.jdrgroup.co.uk/blog/an-internet-marketing-success-story-the-million-dollar-homepage#:~:text=At%20first%20the%20page%20was,the%20site%20had%20made%20%24250%2C000%E2%80%A6" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.jdrgroup.co.uk/blog/an-internet-marketing-success-story-the-million-dollar-homepage#:~:text=At%20first%20the%20page%20was,the%20site%20had%20made%20%24250%2C000%E2%80%A6" target="_self">jdrgroup.co.uk</a>. 결국 모든 픽셀이 팔려 목표였던 백만 달러를 달성했고 (마지막 1000픽셀은 경매로 판매) 인터넷 역사에 남는 바이럴 마케팅 성공 사례가 되었습니다<a data-tooltip-position="top" aria-label="https://www.jdrgroup.co.uk/blog/an-internet-marketing-success-story-the-million-dollar-homepage#:~:text=Alex%20found%20that%20he%20had,to%20%241%2C037%2C100%20in%20gross%20income" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.jdrgroup.co.uk/blog/an-internet-marketing-success-story-the-million-dollar-homepage#:~:text=Alex%20found%20that%20he%20had,to%20%241%2C037%2C100%20in%20gross%20income" target="_self">jdrgroup.co.uk</a>. 이처럼 퀴크하고 독특한 아이디어는 실패하더라도 손해가 적지만, 성공한다면 엄청난 트래픽과 수익, 그리고 브랜드 홍보 효과를 거둘 수 있습니다. <br>유사 성공 사례: Million Dollar Homepage(백만 달러 홈페이지)가 대표적인 예이며, 2005년에 알렉스 투 라는 대학생의 발상으로 만들어져 전 세계적인 화제를 불러모았습니다<a data-tooltip-position="top" aria-label="https://www.jdrgroup.co.uk/blog/an-internet-marketing-success-story-the-million-dollar-homepage#:~:text=At%20first%20the%20page%20was,the%20site%20had%20made%20%24250%2C000%E2%80%A6" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.jdrgroup.co.uk/blog/an-internet-marketing-success-story-the-million-dollar-homepage#:~:text=At%20first%20the%20page%20was,the%20site%20had%20made%20%24250%2C000%E2%80%A6" target="_self">jdrgroup.co.uk</a>. 그 외에도 Reddit에서 진행된 The Button이나 Place와 같은 소셜 실험 페이지도 큰 참여를 이끌어내며 회자되었습니다. 국내 사례로는 네이버의 그린닷 페이지(만우절 이벤트처럼 특이한 페이지를 공개했던 사례) 등이 사람들의 호기심을 끌었습니다. 이러한 프로젝트들은 언론에서 이야깃거리로 다뤄지고 SNS에서 공유되면서, 만든 사람이나 회사의 이름을 널리 알리는 계기가 되었습니다. <br>개발 및 운영 난이도: 개발 난이도는 케이스마다 다르나 대체로 단순한 편입니다. 핵심은 기술보다 아이디어 구상에 있고, 구현 자체는 복잡하지 않은 경우가 많습니다. 예컨대 백만 달러 홈페이지는 정적인 이미지 맵과 링크로 이뤄진 단일 페이지였고, Reddit의 The Button은 카운트다운 버튼 하나와 간단한 서버 로직으로 구현되었습니다. 소요 시간은 기획 아이디어 확정 후 몇 주 이내로 짧을 수 있습니다. 비용도 디자인/도메인 정도를 제외하면 크지 않으며, 운영 역시 방치형으로 특별한 업데이트 없이 유지됩니다. 다만 폭발적 트래픽에 대비해 초기에 서버를 안정화하고, 보안이나 악용 방지 대책(예: 봇 대응)은 준비해두는 게 좋습니다. <br>
<br>핵심 개념: 낯선 사람들끼리 익명으로 대화하거나 랜덤 매칭되는 웹 서비스입니다. 회원가입 없이 버튼 하나로 전세계 누구와든 연결돼 채팅(텍스트 혹은 영상)을 할 수 있는 페이지가 대표적입니다. 이러한 플랫폼은 사용자 생성 콘텐츠(대화)만으로 돌아가기 때문에, 운영자가 별도 콘텐츠를 제공하지 않아도 됩니다. 호기심에 접속한 유저들이 계속 새로운 사람을 만나보려 재방문하게 만드는 것이 핵심입니다. <br>유저 유인 요소: 사람들은 익명성 뒤에서 평소에 하지 못하던 말을 하거나 전혀 모르는 사람의 생각을 엿보는 것을 신기해합니다. “다음엔 어떤 사람이 나올까?” 하는 랜덤성의 재미가 있어 반복 사용을 이끕니다. 초기에 몇몇 특이한 만남이나 재미있는 사건이 발생하면 스크린샷/후기가 인터넷에 퍼지면서 “나도 한번 해봐야지” 하는 심리가 작동해 유저가 폭발적으로 늘어날 수 있습니다. 또한 친구들에게 재미 삼아 권유하기도 좋고, 유튜브 등 다른 플랫폼에서 이 서비스 체험 영상이 공유되며 바이럴 마케팅 효과를 얻을 수도 있습니다. <br>성공 가능성: 익명 채팅의 콘셉트는 시기만 맞으면 단기간에 대유행할 수 있습니다. 가장 유명한 사례로 2009년 등장한 Chatroulette(챗룰렛)은 개발자가 10대 학생 한 명이었음에도 불구하고, 오직 입소문만으로 출시 3개월 만에 하루 백만 명 이상이 접속하는 기현상을 만들었습니다<a data-tooltip-position="top" aria-label="https://www.thekurzweillibrary.com/has-viral-gone-viral#:~:text=,Source%3A%20New%20York%20Times" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.thekurzweillibrary.com/has-viral-gone-viral#:~:text=,Source%3A%20New%20York%20Times" target="_self">thekurzweillibrary.com</a>. 별다른 광고나 홍보 없이도 전세계 사용자들이 몰려들었고, 언론에서도 “인터넷 신드롬”으로 보도했을 정도입니다. 이처럼 익명/랜덤 채팅 서비스는 초기 임계점을 넘으면 기하급수적으로 성장하며, 성공 시 전세계적인 서비스로 발돋움할 잠재력이 있습니다. <br>유사 성공 사례: Chatroulette이 전세계적으로 유명하지만, 국내에서도 과거 “낯선 사람과의 대화” 류의 서비스(예: 아무나와 1:1 채팅하는 앱이나 웹)들이 인기를 끈 적이 있습니다. 또한 Omegle 같은 텍스트 기반 랜덤 채팅이나, 익명으로 질문을 받는 CC톡/사라허(Sarahah) 등의 서비스도 바이럴 히트를 기록했습니다. 이들 사례는 별도의 컨텐츠 없이 사용자 경험만으로도 폭발적 트래픽을 만들어낼 수 있음을 보여줍니다. 다만 장기적으로는 부적절한 사용이나 관리 이슈가 생길 수 있어 커뮤니티 가이드라인 관리가 중요합니다. <br>개발 및 운영 난이도: 기본 구현은 간단하지만 운영은 조금 신경써야 합니다. 기술적으로는 웹소켓 등을 이용한 실시간 채팅이나 WebRTC 기반 영상 스트리밍 등을 적용해야 하지만, 오픈소스 예제가 많아 참고할 수 있습니다. 1~2명의 개발자가 몇 달 내 프로토타입을 만들 수 있고, 초기 비용도 서버 및 대역폭 비용 정도입니다. 그러나 운영 난이도는 유저 규모가 커질수록 증가할 수 있습니다. 익명 서비스를 악용하는 사례(스팸, 음란 행위 등)를 모니터링 및 제어해야 하며, 쾌적한 서비스 유지를 위한 관리자/모더레이터 역할이 필요할 수 있습니다. 이러한 점만 관리된다면 기술적 투자 대비 큰 유저 풀이 확보될 수 있는 매력적인 아이디어입니다. <br>]]></description><link>https://lts.kr/project/new-project/🖨-np_시장조사.html</link><guid isPermaLink="false">project/New Project/🖨 NP_시장조사.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Fri, 23 May 2025 02:21:48 GMT</pubDate></item><item><title><![CDATA[🎗 @Transactional(readOnly = true) 붙이는 이유]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="https://lts.kr/?query=tag:DB" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#DB</a> <a class="tag" href="https://lts.kr/?query=tag:Transaction" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Transaction</a> <a class="tag" href="https://lts.kr/?query=tag:readOnly" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#readOnly</a> <a class="tag" href="https://lts.kr/?query=tag:JPA" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#JPA</a> <br> <a href="https://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="https://lts.kr?query=tag:DB" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#DB">#DB</a> <a href="https://lts.kr?query=tag:Transaction" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Transaction">#Transaction</a> <a href="https://lts.kr?query=tag:readOnly" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#readOnly">#readOnly</a> <a href="https://lts.kr?query=tag:JPA" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#JPA">#JPA</a><br>오늘은 @Transaction, 특히 readOnly = true 옵션에 대하여 깊이 탐구해 보겠다. <br>
우리는 @Transaction 어노테이션을 통해(Spring AOP로) 트렌젝션 범위를 쉽게 구현할 수 있다.<br>여기서 조회만을 위한 로직에는 @Transactional(readOnly = true)옵션을 추가하여 성능을 높여주는 사실은 모두 알고있을 것이다. 여기서 어떠한 로직을 거처 성능상의 이점을 얻어내는지 탐구해 보겠다.<br>데이터베이스의 상태를 변경하기위해 수행하는 작업의 단위.<br>데이터의 무결성을 보장하는 것.<br>무결성 : 데이터의 정확성, 일관성, 유효성이 유지되는 것. 데이터 값이 정확한 상태. <br>정확성 : 중복이나 누락이 없는 상태.
<br>일관성 : 작업 전/후 데이터 상태가 일관되게 유지되는 상태.
<br>유효성 : 사용자로부터 값을 입력받을 때, 정확한 값만을 입력받도록 하는 것. <br>데이터 무결성과 데이터 정합성의 차이
무결성은 위에서 설명한대로 데이터가 정확하고 유효한 상태고,
정합성은 데이터의 값이 서로 일치하는 상태를 뜻한다.(반정규화를 통해 이상현상이 발생하면 정합성이 깨진다.)
정합성은 지키지만 무결성이 깨진 상태의 예를 들자면,<br>
주문테이블과 고객테이블의 idx값이 모두 -1 이라면 정합성은 지키고 있지만, 반드시 1이상의 값을 가져야한다는 idx값의 규칙에 의해 데이터 무결성이 훼손되게 된다.
<br>
<br>Spring에서 트렌젝션을 선언적으로 관리하기 위해 사용.
<br>메서드 또는 클래스 단위로 트렌젝션 범위 지정.
<br>사용시 다음과 같이 사용된다.<br>@Transactional
public void doBusinessLogic() { ...
}
<br>
<br>@Transactional은 Spring AOP의 인터페이스 기반 (JDK 동적 프록시) 또는 클래스 기반 (CGLIB) 으로 프록시를 생성한다.
<br>따라서 내부 호출(self-invocation) 시 트랜잭션이 적용되지 않는다.
<br>public class A { @Transactional public void methodA() { methodB(); // 트랜잭션 적용 안됨! } @Transactional public void methodB() { ... }
}
<br>
<br>쓰기 작업 금지 : flush발생 X / 변경감지X
<br>성능 최적화 : 특정 DB에서 Lock 생략 ▶ <a data-href="Lock ( 데이터베이스 락 ) 이란" href="https://lts.kr/짧은-키워드/lock-(-데이터베이스-락-)-이란.html" class="internal-link" target="_self" rel="noopener nofollow">Lock ( 데이터베이스 락 ) 이란</a>
<br>@Transactional(readOnly = true)
<br>
단순 조회 전용 메서드에 적용하여 리소스를 절약한다.
<br>
<br>위에서 설명한 바와 같이, 읽기 목적의 로직에 여러 작업을 간소화 하여 성능을 높이는 옵션이다.
<br>이를 더 상세히 설명하겠다.
<br>▶ <a data-href="영속성 컨텍스트" href="https://lts.kr/짧은-키워드/영속성-컨텍스트.html" class="internal-link" target="_self" rel="noopener nofollow">영속성 컨텍스트</a><br>
<br>영속성 컨텍스트는 Entity조회 시 초기 상태에 대한 SnapShot을 저장한다.
<br>트렌젝션이 Commit 될 때, 초기 상태(SnapShot) 와 현재 Entity의 상태를 비교한다.
<br>이때, 비교된 내용에 대해 update query를 자동으로 생성해 쓰기 지연 저장소에 저장한다.
<br>이후 일괄적으로 query를 flush()하여 DB에 반영되게 된다.
<br>이와같이 사용자가 직접 update쿼리 등을 작성하지 않아도, 엔티티의 변경점을 감지하여 자동으로 수정/반영 해주는 것이 영속성 컨텍스트의 변경감지 기법이다.<br>위서 말했듯, readOnly = true 옵션이 켜져있다면, flush발생과 자동감지의 동작을 멈춘다.
즉, JPA세션의 플러시 모드를 MANUAL로 변경하여 강제로 flush를 호출하지 않는 한, 엔티티 수정내역에 DB에 반영되지 않는다.<br>
<br>readOnly = true옵션이 켜져있다면, JPA는 해당 트렌젝션이 내의 조회 쿼리에 대해서, 변경감지를 위한 초기상태(SnapShot)을 저장하지 않아도 되고, 불필요한 Dirty Checking을 건너 뛰게 함으로 매모리와 CPU리소스를 절감할 수 있다.
<br>// 1
@Transactional(readOnly = true)
public Member getMember(int memberId) { .. return member;
} // 2
@Transactional
public Loaner getLoaner(int memberId) { Optional&lt;Loaner&gt; loaner = loanerRepository.findById(loanerId); .. return loaner;
}
<br>위 코드를 보았을 때, 물론 코드를 분석하여 단순 select로직인지, 쓰기 로직인지 판단할 수있겠지만, <br>
누가 봐도 단번에 getMember(int memberId)가 읽기전용 메서드라는것을 파악할 수 있다.
<br>이는 코드의 가독성을 향상시켜 줄 뿐 아니라, 실수로 트리거 할 수 있는 쓰기 작업을 거부할 수 있다.
<br>레플리케이션이란?
’두개 이상의 DBMS를 Master/Slave 라는 수직적 구조를 활용하여 DB의 부하를 분산시키는 기술’
Master DB에는 insert/update/delete 와 같은 작업을 수행하도록 하고, select 작업을 Slave DB에서
작업하도록 구성한다.
<br>
<br>보통의 경우 select작업의 소요시간이 가장 길기 때문이다.
<br>Table Full Scan에 경우 데이터 개수에 따라 소요시간이 아주 길게 사용될 수 있다.
<br>이 시간동안, 다른 작업을 하지 못하게 되니 병목이 발생하는 주요원인이 된다.
<br>
<br>레플리케이션 구조는 복제본 DB(Slave)를 함께 운용함으로, Master DB장애 발생시 SlaveDB를 승격시켜 장애를 빠르게 복구할 수 있다.
<br>조회작업에 대한 트레픽을 분산할 수 있다.
<br><img alt="do-messenger_screenshot_2025-05-23_10_48_34.png" src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-05-23_10_48_34.png" style="width: 725px; max-width: 100%;" target="_self"><br>
<br>@Transactional(readOnly = true) 옵션은 SlaveDB에서 데이터를 가져오도록 동작시키고, <br>(읽기 전용 트렌젝션이 SlaveDB로 자동 라우팅 된다.) <br>이를 통해 레플리케이션의 목적에 맞게 트래픽 분산을 온전하게 적용시킬 수 있다.
<br>만약, readOnly=ture 옵션을 통해, 스냅샷 저장을 막고 조회 속도를 올리는게 목적이라면,<br>@Transactional 어노테이션을 완전히 지우면 되는것 아닌가?<br>// @Transactional(readOnly = true) -&gt; 주석처리
public Member getMember(int idx) { Member member = memberRepository.findByIdx(idx).get(); System.out.println(member.getName()); // Lazy Loading 발생 return member;
}
<br>다음과 같이 코드를 구성했다면?<br>사실 아무일도 일어나지 않는다. (Lazy Loading이 정상적으로 동작한다.)
<br>단, OSIV 옵션이 true인 경우에만 한정이다. ▶ <a data-href="🌋 OSIV란 무엇인가" href="https://lts.kr/study/cs/🌋-osiv란-무엇인가.html" class="internal-link" target="_self" rel="noopener nofollow">🌋 OSIV란 무엇인가</a>
<br>그렇다면 다음과 같이 osiv옵션을 false로 하고 재실행한다면?<br>// application.properties
spring.jpa.open-in-view=false
<br>LazyInitializationException이 발생하게 된다.<br>이는 영속성 컨텍스트가 종료된 이후(준영속 상태)에 해당 엔티티에 접근하려 할 때 발생하는 예외이다.<br>(DTO로 변환하여 직접 엔티티에 접근할 필요가 없도록 관리하는 이유이기도 함)<br>따라서, OSIV옵션이 켜져있지 않다면, @Transactional 어노테이션은 강제되고,<br>조회용 쿼리만을 위한 메서드에는 항상 readOnly=ture 옵션을 붙여주는것이 바람직하다.]]></description><link>https://lts.kr/study/cs/🎗-@transactional(readonly-=-true)-붙이는-이유.html</link><guid isPermaLink="false">study/CS/🎗 @Transactional(readOnly = true) 붙이는 이유.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Fri, 23 May 2025 02:20:32 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-05-23_10_48_34.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-05-23_10_48_34.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[📕 공부]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="https://lts.kr/?query=tag:모음" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#모음</a> <br> <a href="https://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="https://lts.kr?query=tag:모음" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#모음">#모음</a><br>공부
보고 배운 지식 중 공유하고 싶은 정보를 모아둔 카테고리 입니다.
<br>
<br><a data-href="🎗 @Transactional(readOnly = true) 붙이는 이유" href="https://lts.kr/study/cs/🎗-@transactional(readonly-=-true)-붙이는-이유.html" class="internal-link" target="_self" rel="noopener nofollow">🎗 @Transactional(readOnly = true) 붙이는 이유</a>
<br><a data-href="🌩 Cloud-Native Architecture 분석" href="https://lts.kr/study/cs/🌩-cloud-native-architecture-분석.html" class="internal-link" target="_self" rel="noopener nofollow">🌩 Cloud-Native Architecture 분석</a> <br><a data-href="🐹 MSA(Microservices Architecture)" href="https://lts.kr/study/cs/🐹-msa(microservices-architecture).html" class="internal-link" target="_self" rel="noopener nofollow">🐹 MSA(Microservices Architecture)</a>
<br><a data-href="🐋 docker 란" href="https://lts.kr/tools/docker/🐋-docker-란.html" class="internal-link" target="_self" rel="noopener nofollow">🐋 docker 란</a>
<br><a data-href="🚢Kubernetes(k8s)란" href="https://lts.kr/tools/kubernetes/🚢kubernetes(k8s)란.html" class="internal-link" target="_self" rel="noopener nofollow">🚢Kubernetes(k8s)란</a>
<br><a data-href="👔 Jenkins란" href="https://lts.kr/tools/jenkins/👔-jenkins란.html" class="internal-link" target="_self" rel="noopener nofollow">👔 Jenkins란</a> <br><a data-href="🐡 Spring Security와 Filter" href="https://lts.kr/study/cs/🐡-spring-security와-filter.html" class="internal-link" target="_self" rel="noopener nofollow">🐡 Spring Security와 Filter</a>
<br><a data-href="🚨 RSA 암호화 방식의 이해와 적용 (feat.취약성점검)" href="https://lts.kr/issue_troubleshooting/🚨-rsa-암호화-방식의-이해와-적용-(feat.취약성점검).html" class="internal-link" target="_self" rel="noopener nofollow">🚨 RSA 암호화 방식의 이해와 적용 (feat.취약성점검)</a> <br><a data-href="🍎 Redis로 Key관리하기" href="https://lts.kr/study/cs/🍎-redis로-key관리하기.html" class="internal-link" target="_self" rel="noopener nofollow">🍎 Redis로 Key관리하기</a> <br><a data-href="🌋 OSIV란 무엇인가" href="https://lts.kr/study/cs/🌋-osiv란-무엇인가.html" class="internal-link" target="_self" rel="noopener nofollow">🌋 OSIV란 무엇인가</a>
<br><a data-href="🐰 Java의 String과 SpringBuffer" href="https://lts.kr/study/cs/🐰-java의-string과-springbuffer.html" class="internal-link" target="_self" rel="noopener nofollow">🐰 Java의 String과 SpringBuffer</a>
<br><a data-href="🛬 JDK와 JRE, JVM" href="https://lts.kr/study/cs/🛬-jdk와-jre,-jvm.html" class="internal-link" target="_self" rel="noopener nofollow">🛬 JDK와 JRE, JVM</a>
<br><a data-href="🍊 Spring의 의존성 주입(DI)" href="https://lts.kr/study/cs/🍊-spring의-의존성-주입(di).html" class="internal-link" target="_self" rel="noopener nofollow">🍊 Spring의 의존성 주입(DI)</a>
<br><a data-href="🪕 JPA 관련 용어 정리" href="https://lts.kr/study/cs/🪕-jpa-관련-용어-정리.html" class="internal-link" target="_self" rel="noopener nofollow">🪕 JPA 관련 용어 정리</a>
<br>
<br><a data-href="☕ JAVA , OOP" href="https://lts.kr/study/cs/☕-java-,-oop.html" class="internal-link" target="_self" rel="noopener nofollow">☕ JAVA , OOP</a>
<br><a data-href="🍃 Spring" href="https://lts.kr/study/cs/🍃-spring.html" class="internal-link" target="_self" rel="noopener nofollow">🍃 Spring</a>
<br><a data-href="🎩 DevOps" href="https://lts.kr/study/cs/🎩-devops.html" class="internal-link" target="_self" rel="noopener nofollow">🎩 DevOps</a>
<br><a data-href="📔 DataBase" href="https://lts.kr/study/cs/📔-database.html" class="internal-link" target="_self" rel="noopener nofollow">📔 DataBase</a>
<br><a data-href="📭 Server" href="https://lts.kr/study/cs/📭-server.html" class="internal-link" target="_self" rel="noopener nofollow">📭 Server</a>
<br><a data-href="🐞 etc" href="https://lts.kr/study/cs/🐞-etc.html" class="internal-link" target="_self" rel="noopener nofollow">🐞 etc</a>
<br>
<br><a data-href="🤠 Coding Test 풀이 모음" href="https://lts.kr/study/coding-test/🤠-coding-test-풀이-모음.html" class="internal-link" target="_self" rel="noopener nofollow">🤠 Coding Test 풀이 모음</a>
<br><a data-href="👽 Algorithm" href="https://lts.kr/study/coding-test/👽-algorithm.html" class="internal-link" target="_self" rel="noopener nofollow">👽 Algorithm</a>
<br>
<br><a data-href="🔻 Redis 캐쉬 전략 - hello 서비스에 적용하여 성능개선 가능성" href="https://lts.kr/study/dev-seminar/🔻-redis-캐쉬-전략-hello-서비스에-적용하여-성능개선-가능성.html" class="internal-link" target="_self" rel="noopener nofollow">🔻 Redis 캐쉬 전략 - hello 서비스에 적용하여 성능개선 가능성</a>
<br><a data-href="🔐 상품 투자하기 서비스 Lock기법 개선안" href="https://lts.kr/issue_troubleshooting/🔐-상품-투자하기-서비스-lock기법-개선안.html" class="internal-link" target="_self" rel="noopener nofollow">🔐 상품 투자하기 서비스 Lock기법 개선안</a>
<br><a data-href="🔹 TDD에 대하여" href="https://lts.kr/study/dev-seminar/🔹-tdd에-대하여.html" class="internal-link" target="_self" rel="noopener nofollow">🔹 TDD에 대하여</a>
<br><a data-href="🍂 JPA, Mybatis , Dead Lock이슈" href="https://lts.kr/study/dev-seminar/🍂-jpa,-mybatis-,-dead-lock이슈.html" class="internal-link" target="_self" rel="noopener nofollow">🍂 JPA, Mybatis , Dead Lock이슈</a>
<br><a data-href="🥗 Spring Security_토큰-세션-쿠키-JWT 에 대하여" href="https://lts.kr/study/dev-seminar/🥗-spring-security_토큰-세션-쿠키-jwt-에-대하여.html" class="internal-link" target="_self" rel="noopener nofollow">🥗 Spring Security_토큰-세션-쿠키-JWT 에 대하여</a>
<br><a data-href="📔 DB 테이블 설계, 어떻게 하는게 옳은 방법인가" href="https://lts.kr/study/dev-seminar/📔-db-테이블-설계,-어떻게-하는게-옳은-방법인가.html" class="internal-link" target="_self" rel="noopener nofollow">📔 DB 테이블 설계, 어떻게 하는게 옳은 방법인가</a>]]></description><link>https://lts.kr/study/📕-공부.html</link><guid isPermaLink="false">study/📕 공부.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Thu, 22 May 2025 05:57:29 GMT</pubDate></item><item><title><![CDATA[영속성 컨텍스트]]></title><description><![CDATA[<br><br><br><br>- 엔티티를 영구적으로 저장하는 환경
- 앱과 DB사이의 객체를 보관하는 가상의 DB역할
- **엔티티 메니저**를 통해 저장하거나 조회한다.
<br><br><br><br><br>
<br>엔티티 매니저를 생성할 때 하나 만들어진다.
<br>엔티티 매니저를 통해서 영속성 컨텍스트에 접근하고 관리할 수 있다.
<br><br><br>JPA의 save() 함수는?
save()함수는 내부적으로 isNew(Entity)연산을 수행하여,<br>
해당 엔티티가 신규로 등록되는 엔티티이면 persist()를, 기존에 존재하는 엔티티면 merge()를 수행한다.
<br>+JPA의 FlushMode.AUTO(기본)에서는 “현재 컨텍스트에 반영된 변경 사항을쿼리 실행 전에 DB에 동기화(flush) 한다.<br>1 - HfMarketingCode A = new HfMarketingCode(); 2 - A.setHitCode("testCode1"); 3 - A.setCodeName("testName2"); 4 - hfMarketingCodeRepository.save(A); 5 - HfMarketingCode B = hfMarketingCodeRepository.findAllByHitCode("testCode1");
<br>
<br>testCode1을 id로 갖는 testName1의 값을 testName2로 바꿀때, 4번이 아닌, 5번 시점에 update가 발생한다.
<br><br><br><br><br><br>// 객체를 생성한 상태 (비영속)
Member member = new Member();
// 객체의 값 변경해도 영속상태에 영행 X
member.setName("이태성");
<br><br>// 객체를 생성한 상태(비영속)
Member member = new Member();
member.setName("이태성"); EntityManager em = emf.createEntityManager();
em.getTransaction().begin();
//엔티티 매니저를 사용하여 영속상태로 등록
em.persist(member);
<br><br>// 엔티티 매니저를 사용하여 영속상태를 분리 -&gt; 준영속 상태
em.detach(member);
<br>
<br>메모리에 식별자 값을 갖고는 있지만, 영속성 컨텍스트의 어떠한 동작도 하지 않느 상태
<br><br>// 엔티티 매니저를 사용하여 영속상태를 상태 -&gt; 삭제 상태
em.remove(member); // 영속성 컨텍스트를 비워도 관리되던 엔티티는 준영속성 상태가 된다.
em.clear(); // 영속성 컨텍스트를 종료해도 관리되던 엔티티는 준영속 상태가 된다.
em.close();
<br>
<br>영속성 컨텍스트를 비우거나(Clear) 종료해도(Close) 엔티티는 삭제되지 않는다(→ 준영속상태가 된다)
<br>오직 삭제(Remove)를 통해서만 영속상태를 삭제상태로 변경할 수 있다.
<br><br><br><br><br><br>
<br>영속 상태의 엔티티를 1차 캐쉬에 저장하여, 같은 엔티티를 조회할시 DB에서 재조회 하지 않아도 된다.
<br><br>Member a = em.find(Member.class, "A");
Member b = em.find(Member.class, "A"); System.out.println(a==b) // true
<br>
<br>1차 캐시로 격리 수준을 DB가 아닌 애플리케이션 차원에서 제공해 줄 수 있다.
<br><br>EntityManager em = emf.createEntityManager();
EntityTransaction transaction = em.getTransaction(); transaction.begin(); // 트렌젝션 시작 em.persist(memberA);
em.persist(memberB); // 커밋하는 순간 데이터베이스에 INSERT SQL을 보낸다.
transaction.commit(); // 트렌젝션 커밋
<br>영속성 컨텍스트에서 관리하는 객체는 수정되어도 DB에 바로 Insert 쿼리를 날리지 않는다.
SQL 쿼리들을 모아놓았다가 flush(커밋) 될 때 모아둔 쿼리를 모두 날린다.<br><br>EntityManager em = emf.createEntityManager();
EntityTransaction transaction = em.getTransaction();
transaction.begin(); // 영속 엔티티 조회
Member member = em.find(Member.class, "A"); // 영속 엔티티 데이터 수정
member.setName("이태성");
member.setJob("프로그래머"); transaction.commit(); // [트랜잭션] 커밋
<br>
<br>엔티티매니저에서 엔티티를 find()후 해당 객체의 값을 수정 후 커밋하면 어떻게 될까?
<br>따로 save나 update문이 없어 변경이 적용되지 않을것 같지만, 자동으로 변경점을 감지하여 반영된다.
<br>변경감지는 지연쓰기또한 동작한다.
<br><br><br>
<br>flush()는 영속성 컨텍스트의 변경 내용을 DB에 반영하는 행위이다. <br>플러시의 흐름<br>
<br>변경 감지가 동작해서 스냅샷(트렌젝션의 시작 시점)과 비교해서 변경점을 찾는다.
<br>변경된 엔티티에 대해서 수정 쿼리를 만들고 SQL 저장소에 등록한다.
<br>쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 반영한다.
<br>트랜잭션 커밋시 자동 호출
<br>JPQL 쿼리 실행 시 자동 호출
<br>em.flush()
<br><br><a data-href="🎗 @Transactional(readOnly = true) 붙이는 이유" href="https://lts.kr/study/cs/🎗-@transactional(readonly-=-true)-붙이는-이유.html" class="internal-link" target="_self" rel="noopener nofollow">🎗 @Transactional(readOnly = true) 붙이는 이유</a>]]></description><link>https://lts.kr/짧은-키워드/영속성-컨텍스트.html</link><guid isPermaLink="false">짧은 키워드/영속성 컨텍스트.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Thu, 22 May 2025 05:57:08 GMT</pubDate></item><item><title><![CDATA[🍧 JPA의 영속성 상태와 데이터 Log 이슈]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:SQL" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SQL</a> <a class="tag" href="https://lts.kr/?query=tag:JPA" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#JPA</a> <a class="tag" href="https://lts.kr/?query=tag:이슈" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#이슈</a> <a class="tag" href="https://lts.kr/?query=tag:log" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#log</a> <a class="tag" href="https://lts.kr/?query=tag:로그" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#로그</a> <br> <a href="https://lts.kr?query=tag:SQL" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SQL">#SQL</a> <a href="https://lts.kr?query=tag:JPA" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#JPA">#JPA</a> <a href="https://lts.kr?query=tag:이슈" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#이슈">#이슈</a> <a href="https://lts.kr?query=tag:log" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#log">#log</a> <a href="https://lts.kr?query=tag:로그" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#로그">#로그</a><br>업무 중 한 가지 이슈가 있었고, JPA의 영속상태와 동작원리에 대해서 자세히 짚고 넘어가야할 필요가 있다고 느껴
해당 글을 쓰게 되었다.<br>상황은 다음과 같다.<br>신한은행의 계좌잔액(예치금)과 입금내역을 관리하는 DB의 계좌 잔액간의 차액이 발생했다는 알림을 받았다. <br>원인을 찾기위해 신한 전문을 쌓는 log테이블과, 회원 입급내역 log테이블을 비교하였다.
<br>이떄, 신한DB 에는 같은 금액의 중복 log가 없으나, 입금 내역 DB에는 차액만큼의 중복 입금 log를 발견할 수 있었다. <br>차액이 138만원 발생했다고 가정했을 때,<br>입금내역DB에는 10시 / 11시 총 2개의 138만원 입금내역이 LOG로 남아있었다. <br>여기서 해당 입금내역이 차액을 발생시켰을 것으로 예상할 수 있었다. <br>
<br>실제 신한의 전문을 저장하는 DB에는 11시의 입금내역만이 존재하고 있었다.
<br>
<br>신한 측문의 결과 입금에 문제가 생겼을 경우 해당 입금 전문을 동일하게 한 번 더 보낸다는 사실을 알 수 있었다. <br>보통의 상황이라면, 동일한(id값 동일) 전문을 받아 DB에 insert된다면 SQL Exception이 터졌을 것이라 생각하였다.
하지만 상황으로 미루어 볼때, insert가 아닌 update가 동작했을 것으로 예상할 수 있다.<br>해당 Insert쿼리는 Spring DATA JPA의 SAVE메서드로 구현되어있다.
<br>첫번째 save 후 두 번째 save동작 까지, 1시간의 시간 차이가 있다.
<br>트렌젝션이 종료된 이후(commit)임에도 기존의 id를 기억하여 update를 할 수 있었던 이유가 무었일까?<br>영속상태에 관한 관련된 또 다른 이슈.<br>영속성 컨텍스트에 대한 설명.<br><img alt="Pasted image 20250519144842.png" src="https://lts.kr/사진-및-문서/pasted-image-20250519144842.png" style="width: 700px; max-width: 100%;" target="_self"><br>
<br>아래 코드의 실행 결과로 알 수 있듯이, 비영속 상태의 엔티티를 save()하여 persist()를 수행했을 때, DB에 이미 동일한 ID(PK)가 있다면 예외를 발생시킨다.
<br>@Autowired private EntityManager em; @Test @Transactional void MemberPersistenceTest() { // 1) 새 엔티티 인스턴스 생성 → Transient 상태 HfMarketingCode testcode = new HfMarketingCode(); testcode.setHitCode("testCode1"); testcode.setCodeName("testName1"); em.persist(testcode); em.flush(); }
<br><img alt="Pasted image 20250520142253.png" src="https://lts.kr/사진-및-문서/pasted-image-20250520142253.png" target="_self"><br>주의
영속성 컨텍스트에 등록할 객체의 id 설정의 @GeneratedValue(strategy = GenerationType.IDENTITY)<br>
여부에 따라 주의해야 할 사항이 있다. <br>지연 쓰기가 동작하지 않을 수 있다. 기본키 생성에 대한 권한을 DB에 위임하기 때문에, JPA가 곧바로 id값을 알기위해 지연하지 않고, 바로 insert쿼리를 실행시킨다(IDENTITY 방식의 경우). <br>id값을 명시적으로 지정한 후, persist()를 수행하면 예외가 발생한다. 그 이유는, 명시적으로id를 지정하는 순간 non-null의 id값을 갖게되고, isNew()의 첫 호출부터 id가 null이 아니기 때문에, 기존에 존재하는 id값에 대해 persist를 수행하게 되어 예외가 발생하는 것이다. <br>아래는 JPA save()의 isNew() 분기문<br>@Transactional public &lt;S extends T&gt; S save(S entity) { Assert.notNull(entity, "Entity must not be null."); if (this.entityInformation.isNew(entity)) { this.em.persist(entity); return entity; } else { return this.em.merge(entity); } }
<br>질문?
동일한 idx(pk)의 엔티티를 넘겨 save동작을 수행했을 때, persist(insert) 가 아닌 merge(update) 가 되었다면,<br>
해당 엔티티의 영속 상태는 어떻게 되는가?
<br>
엔티티 메니저는 트렌젝션이 종료될때 close되며, 이때 모든 영속석 컨텍스트에 등록된 엔티티를 준영속 상태로 돌린다.
따라서, 준영속 상태로 관리되고 있던 객체에 save() 연산이 수행되면서, update쿼리가 실행된 것.
<br>그렇다면 준영속 상태의 지속 범위는 어떻게 될까?<br>보통 엔티티 객체가 준영속 상태로 진입하게 되면, 엔티티 매니저와 모든 의존성을 끊기 때문에 일반적인 POJO 객체와 같이 GC(가비지 컬렉터) 에 의해 메모리를 해제하게 된다.
<br>그럼에도 1시간의 시간 차가 발생했음에도 GC로 정리가 되지 않은 부분은 조금 의아하다.
<br>해당 부분은 더 깊게 찾아보야 할것으로 보인다.
<br>
<br>
위에서 다음과 같이 표현한 부분이 있다. 이는 불가능하다는 것을 알게 되었다.. “ 비영속 상태의 엔티티를 save()하여 persist()를 수행했을 때,
DB에 이미 동일한 ID(PK)가 있다면 예외를 발생시킨다 ” <br>
물론, 이미 존재하는 id값을 갖는 엔티티를 persist()하면 pk중복 예외가 방생하는 것은 맞다. persist()는 영속성 컨텍스트에 등록여부를 판단 할 뿐, id값의 유뮤를 따지지(select하지) 않기 때문이다. <br>
하지만 이러한 상황이 발생하는 것이 정상적인 상황에서 불가능하다. <br>
그 이유에 대해서 설명하겠다. <br>: Assigned(사용자 id 직접 지정) 전략일 때, id == null or 0 일때만 “새 엔티티로써 판단한다.”<br>public boolean isNew(T entity) { ID id = this.getId(entity); Class&lt;ID&gt; idType = this.getIdType(); if (!idType.isPrimitive()) { return id == null; //null 이거나, } else if (id instanceof Number) { return ((Number)id).longValue() == 0L; //0 일때만 새로운 객체로 판단 } else { throw new IllegalArgumentException(String.format("Unsupported primitive id type %s", idType)); } }
<br>하지만 이때, Assigned으로 직접 id에 값을 어플리케이션에서 직접 지정했다면, (id값을 포함한 엔티티)
persist()가 아닌 merge()로 넘어갈 수밖에없게 된다는 것이다.<br>: JPA의 save()는 단순히 insert와 update의 통합이 아니다. 각 동작의 원리와 특성을 파악하여 예외사항을 정확히 판단하여 결과를 예상 가능하도록 설계해야한다.]]></description><link>https://lts.kr/issue_troubleshooting/🍧-jpa의-영속성-상태와-데이터-log-이슈.html</link><guid isPermaLink="false">Issue_TroubleShooting/🍧 JPA의 영속성 상태와 데이터 Log 이슈.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Thu, 22 May 2025 05:32:08 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20250519144842.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20250519144842.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[✈ MM_클라우드 마이그레이션]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:프로젝트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로젝트</a> <a class="tag" href="https://lts.kr/?query=tag:개발" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#개발</a> <a class="tag" href="https://lts.kr/?query=tag:Cloud" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Cloud</a> <a class="tag" href="https://lts.kr/?query=tag:CloudNative" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#CloudNative</a> <a class="tag" href="https://lts.kr/?query=tag:CI/CD" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#CI/CD</a> <br> <a href="https://lts.kr?query=tag:프로젝트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로젝트">#프로젝트</a> <a href="https://lts.kr?query=tag:개발" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#개발">#개발</a> <a href="https://lts.kr?query=tag:Cloud" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Cloud">#Cloud</a> <a href="https://lts.kr?query=tag:CloudNative" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#CloudNative">#CloudNative</a> <a href="https://lts.kr?query=tag:CI/CD" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#CI/CD">#CI/CD</a><br><img alt="do-messenger_screenshot_2025-05-02_14_28_33.png" src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-05-02_14_28_33.png" target="_self"><br>
<br>해당 프로젝트는 Swift Native iOS 애플리케이션이다.
<br>프로젝트 ‘MeloMeter’의 기능 확장 및 유지보수를 위해 FireBase Cloud에서 다른 Cloud로의 마이그레이션 작업이 필요함을 느꼈다.
<br>FireBase는 백앤드 인프라를 별도로 구축하지 않고도 앱 개발을 시작할 수 있는 Backend-as-a-Service(BaaS) 플랫폼이다. iOS 어플리케이션을 서버 설정, 데이터베이스 구축, 인증 시스템 구현 등 복잡한 작업 없이 빠르게 개발/배포가 가능했다.<br>BaaS란?
서비스형 백엔드(BaaS) 는 개발자가 웹 또는 모바일 애플리케이션의 모든 백그라운드 측면을 아웃소싱하여 프런트엔드만 작성하고 유지 관리하면 되는 클라우드 서비스 모델이다. BaaS 벤더는 사용자 인증, 데이터베이스 관리, 원격 업데이트, 푸시 알림(모바일 앱용), 클라우드 스토리지, 호스팅 등 서버에서 이루어지는 활동을 위해 미리 작성된 소프트웨어를 제공한다.
<br>Firebase의 Realtime Database와 Cloud Firestore는 실시간 데이터 동기화를 지원하며, 짧은 지연시간을 제공하여 MeloMeter의 사용자 간의 위치 데이터 공유나 채팅 기능 등 실시간 기능 구현에 용이하다.<br>Firebase는 인증(Authentication), 클라우드 메시징(Cloud Messaging), 호스팅(Hosting), 스토리지(Storage), 분석(Analytics) 등 다양한 서비스를 통합적으로 제공하여, 별도의 외부 서비스 연동 없이도 앱의 주요 기능을 구현할 수 있다.<br>
ex) 클라우드 메시징을 사용한 유저 통합 알림 / 유저 핸드폰 인증, 로그인 서비스
<br>Firebase는 Google의 서비스로, 특정 기능이나 API에 종속되어있다. Realtime Database와 Cloud Firestore 모두 독자규격을 갖도록하여 프로젝트 규모와 기능이 확장될 수록 다른 벤더로의 이전이 점점 더 어려워진다.<br>Firebase는 공식적으로 RDB를 지원하지 않는다. 또한 Realtime Database는 NoSQL기반 이므로 복잡한 쿼리나, 트렌젝션을 처리하기에 적합하지 않다. 따라서 각 상황에 맞추어 DB를 선택할 수 있는 여타 클라우드 서비스와 다르게 확장에 제한적이다.<br>데이터 구조나 API의 차이로 Firebase에서 다른 데이터베이스로의 마이그레이션은 복잡하고 시간이 많이 걸릴 수 있다. 위엑서 언급한 내용이나, 이또한 프로젝트 규모가 커질수록 단점으로 다가올 수 있다.<br>Firebase는 Google이 개발한 플랫폼으로, Android에 비해 iOS에 대한 지원이 상대적으로 부족하다. 예를 들어, Firebase Test Lab은 Android에 비해 iOS 기기 지원이 제한적이며, 일부 기능은 iOS에서 완벽하게 작동하지 않는다.<br>가장 큰 이유
위의 단점 모두 FireBase에서도 어느정도 해결 할 수 있는 문제이다.<br>
그럼에도 Cloud를 이전하려고 하는 가장큰 이유는 BaaS기반의 클라우드 서비스에서 다양한 캐쉬전략, 트렌젝션 관리 등 좀더 자유롭게 백앤드로 로직을 개발하고, 유연하게 관리하기 위함이 크다
<br>]]></description><link>https://lts.kr/project/melometer-project/✈-mm_클라우드-마이그레이션.html</link><guid isPermaLink="false">project/MeloMeter Project/✈ MM_클라우드 마이그레이션.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 08:55:35 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-05-02_14_28_33.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-05-02_14_28_33.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[💻 프로젝트]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:프로젝트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로젝트</a> <a class="tag" href="https://lts.kr/?query=tag:모음" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#모음</a> <br> <a href="https://lts.kr?query=tag:프로젝트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로젝트">#프로젝트</a> <a href="https://lts.kr?query=tag:모음" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#모음">#모음</a><br>프로젝트
public하게 공개할 수 있는 프로젝트의 제작 과정입니다.
<br>
<br><a data-href="🏹 예치금 차액 비교 Spring Batch 리펙토링" href="https://lts.kr/project/hello-batch/🏹-예치금-차액-비교-spring-batch-리펙토링.html" class="internal-link" target="_self" rel="noopener nofollow">🏹 예치금 차액 비교 Spring Batch 리펙토링</a>⭐
<br><a data-href="🏹 예치금 차액 비교 Spring Batch 리펙토링 부록" href="https://lts.kr/project/hello-batch/🏹-예치금-차액-비교-spring-batch-리펙토링-부록.html" class="internal-link" target="_self" rel="noopener nofollow">🏹 예치금 차액 비교 Spring Batch 리펙토링 부록</a>
<br><a data-href="✏ Chunk_Partitioning Batch 구조 드로잉" href="https://lts.kr/project/hello-batch/✏-chunk_partitioning-batch-구조-드로잉.html" class="internal-link" target="_self" rel="noopener nofollow">✏ Chunk_Partitioning Batch 구조 드로잉</a>
<br>
<br><a data-href="👩‍👧‍👦 marketing Analytics 공통모듈 제작기" href="https://lts.kr/project/hello-marketing/👩‍👧‍👦-marketing-analytics-공통모듈-제작기.html" class="internal-link" target="_self" rel="noopener nofollow">👩‍👧‍👦 marketing Analytics 공통모듈 제작기</a>⭐
<br><a data-href="👩‍👧‍👦 Analytics 공통모듈 ADMIN용 데이터 추출" href="https://lts.kr/project/hello-marketing/👩‍👧‍👦-analytics-공통모듈-admin용-데이터-추출.html" class="internal-link" target="_self" rel="noopener nofollow">👩‍👧‍👦 Analytics 공통모듈 ADMIN용 데이터 추출</a>
<br>
<br><a data-href="🚞 Java 대용량 Excel 리펙토링" href="https://lts.kr/project/🚞-java-대용량-excel-리펙토링.html" class="internal-link" target="_self" rel="noopener nofollow">🚞 Java 대용량 Excel 리펙토링</a>
<br>
<br><a data-href="✈ MM_클라우드 마이그레이션" href="https://lts.kr/project/melometer-project/✈-mm_클라우드-마이그레이션.html" class="internal-link" target="_self" rel="noopener nofollow">✈ MM_클라우드 마이그레이션</a>
<br>
<br><a data-href="🖨 NP_시장조사" href="https://lts.kr/project/new-project/🖨-np_시장조사.html" class="internal-link" target="_self" rel="noopener nofollow">🖨 NP_시장조사</a>
<br>
<br><a data-href="👻 Obsidian 정적호스팅 CICD 과정" href="https://lts.kr/project/note-ci_cd/👻-obsidian-정적호스팅-cicd-과정.html" class="internal-link" target="_self" rel="noopener nofollow">👻 Obsidian 정적호스팅 CICD 과정</a>
<br>
<br><a data-href="📘 SpringBoot &amp; Docker + Reids 연동" href="https://lts.kr/tools/docker/📘-springboot-&amp;-docker-+-reids-연동.html" class="internal-link" target="_self" rel="noopener nofollow">📘 SpringBoot &amp; Docker + Reids 연동</a>
<br><a data-href="🌥 aws(EC2)셋팅부터 배포까지" href="https://lts.kr/tools/aws/🌥-aws(ec2)셋팅부터-배포까지.html" class="internal-link" target="_self" rel="noopener nofollow">🌥 aws(EC2)셋팅부터 배포까지</a>]]></description><link>https://lts.kr/project/💻-프로젝트.html</link><guid isPermaLink="false">project/💻 프로젝트.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 08:55:34 GMT</pubDate></item></channel></rss>