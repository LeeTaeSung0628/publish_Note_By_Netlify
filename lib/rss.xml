<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><parsererror xmlns="http://www.w3.org/1999/xhtml" style="display: block; white-space: pre; border: 2px solid #c77; padding: 0 1em 0 1em; margin: 1em; background-color: #fdd; color: black"><h3>This page contains the following errors:</h3><div style="font-family:monospace;font-size:12px">error on line 3141 at column 410: Input is not proper UTF-8, indicate encoding !
Bytes: 0x1D 0xEC 0xA3 0xBC
</div><h3>Below is a rendering of the page up to the first error.</h3></parsererror><channel><title><![CDATA[Category]]></title><description><![CDATA[Obsidian digital garden]]></description><link>https://lts.kr/</link><image><url>https://lts.kr/lib/media/favicon.png</url><title>Category</title><link>https://lts.kr/</link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Wed, 21 May 2025 07:22:21 GMT</lastBuildDate><atom:link href="https://lts.kr/lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Wed, 21 May 2025 07:21:22 GMT</pubDate><copyright><![CDATA[taesung's Blog]]></copyright><ttl>60</ttl><dc:creator>taesung's Blog</dc:creator><item><title><![CDATA[🏫 강의 &amp; 자격증]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:강의" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#강의</a> <a class="tag" href="https://lts.kr/?query=tag:모음" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#모음</a> <a class="tag" href="https://lts.kr/?query=tag:lectur" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#lectur</a> <br> <a href="https://lts.kr?query=tag:강의" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#강의">#강의</a> <a href="https://lts.kr?query=tag:모음" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#모음">#모음</a> <a href="https://lts.kr?query=tag:lectur" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#lectur">#lectur</a><br>강의
강의를 수강하며, 정리한 내용 모음집 입니다.
<br>정보
inflearn - SpringCoreBasic.김영한 님의 강의 입니다.
<br> <br> <br> <br> <br>
<br><a data-href="🥈 필기 1과목 - 소프트웨어 설계" href="https://lts.kr/study/정보처리기사/정보처리기사-필기/🥈-필기-1과목-소프트웨어-설계.html" class="internal-link" target="_self" rel="noopener nofollow">🥈 필기 1과목 - 소프트웨어 설계</a>
<br><a data-href="🥈 필기 2과목 - 소프트웨어 개발" href="https://lts.kr/study/정보처리기사/정보처리기사-필기/🥈-필기-2과목-소프트웨어-개발.html" class="internal-link" target="_self" rel="noopener nofollow">🥈 필기 2과목 - 소프트웨어 개발</a>
<br><a data-href="🥈 필기 3과목 - 데이터베이스 구축" href="https://lts.kr/study/정보처리기사/정보처리기사-필기/🥈-필기-3과목-데이터베이스-구축.html" class="internal-link" target="_self" rel="noopener nofollow">🥈 필기 3과목 - 데이터베이스 구축</a>
<br><a data-href="🥈 필기 4과목 - 프로그래밍 언어 활용" href="https://lts.kr/study/정보처리기사/정보처리기사-필기/🥈-필기-4과목-프로그래밍-언어-활용.html" class="internal-link" target="_self" rel="noopener nofollow">🥈 필기 4과목 - 프로그래밍 언어 활용</a>
<br><a data-href="🥈 필기 5과목 - 정보시스템 구축관리" href="https://lts.kr/study/정보처리기사/정보처리기사-필기/🥈-필기-5과목-정보시스템-구축관리.html" class="internal-link" target="_self" rel="noopener nofollow">🥈 필기 5과목 - 정보시스템 구축관리</a>
<br>
<br><a data-href="🥇 정보처리 기사 실기 키워드" href="https://lts.kr/study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-키워드.html" class="internal-link" target="_self" rel="noopener nofollow">🥇 정보처리 기사 실기 키워드</a>
<br><a data-href="🥇 정보처리 기사 실기 SQL 문제" href="https://lts.kr/study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-sql-문제.html" class="internal-link" target="_self" rel="noopener nofollow">🥇 정보처리 기사 실기 SQL 문제</a>
<br><a data-href="🥇 정보처리 기사 실기 프로그래밍-제어문" href="https://lts.kr/study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-프로그래밍-제어문.html" class="internal-link" target="_self" rel="noopener nofollow">🥇 정보처리 기사 실기 프로그래밍-제어문</a>
<br><a data-href="🥇 정보처리 기사 실기 프로그래밍-포인터" href="https://lts.kr/study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-프로그래밍-포인터.html" class="internal-link" target="_self" rel="noopener nofollow">🥇 정보처리 기사 실기 프로그래밍-포인터</a>
<br><a data-href="🥇 정보처리 기사 실기 프로그래밍-사용자 정의 함수" href="https://lts.kr/study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-프로그래밍-사용자-정의-함수.html" class="internal-link" target="_self" rel="noopener nofollow">🥇 정보처리 기사 실기 프로그래밍-사용자 정의 함수</a>
<br><a data-href="🥇 정보처리 기사 실기 프로그래밍-구조체(structuer)" href="https://lts.kr/study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-프로그래밍-구조체(structuer).html" class="internal-link" target="_self" rel="noopener nofollow">🥇 정보처리 기사 실기 프로그래밍-구조체(structuer)</a>
<br><a data-href="🥇 정보처리 기사 실기 기타문제" href="https://lts.kr/study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-기타문제.html" class="internal-link" target="_self" rel="noopener nofollow">🥇 정보처리 기사 실기 기타문제</a>]]></description><link>https://lts.kr/lectur/🏫-강의-&amp;-자격증.html</link><guid isPermaLink="false">lectur/🏫 강의 &amp; 자격증.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 07:13:28 GMT</pubDate></item><item><title><![CDATA[📕 공부]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="https://lts.kr/?query=tag:모음" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#모음</a> <br> <a href="https://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="https://lts.kr?query=tag:모음" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#모음">#모음</a><br>공부
보고 배운 지식 중 공유하고 싶은 정보를 모아둔 카테고리 입니다.
<br>
<br><a data-href="🌩 Cloud-Native Architecture 분석" href="https://lts.kr/study/cs/🌩-cloud-native-architecture-분석.html" class="internal-link" target="_self" rel="noopener nofollow">🌩 Cloud-Native Architecture 분석</a> <br><a data-href="🐹 MSA(Microservices Architecture)" href="https://lts.kr/study/cs/🐹-msa(microservices-architecture).html" class="internal-link" target="_self" rel="noopener nofollow">🐹 MSA(Microservices Architecture)</a>
<br><a data-href="🐋 docker 란" href="https://lts.kr/tools/docker/🐋-docker-란.html" class="internal-link" target="_self" rel="noopener nofollow">🐋 docker 란</a>
<br><a data-href="🚢Kubernetes(k8s)란" href="https://lts.kr/tools/kubernetes/🚢kubernetes(k8s)란.html" class="internal-link" target="_self" rel="noopener nofollow">🚢Kubernetes(k8s)란</a>
<br><a data-href="👔 Jenkins란" href="https://lts.kr/tools/jenkins/👔-jenkins란.html" class="internal-link" target="_self" rel="noopener nofollow">👔 Jenkins란</a> <br><a data-href="🐡 Spring Security와 Filter" href="https://lts.kr/study/cs/🐡-spring-security와-filter.html" class="internal-link" target="_self" rel="noopener nofollow">🐡 Spring Security와 Filter</a>
<br><a data-href="🚨 RSA 암호화 방식의 이해와 적용 (feat.취약성점검)" href="https://lts.kr/issue_troubleshooting/🚨-rsa-암호화-방식의-이해와-적용-(feat.취약성점검).html" class="internal-link" target="_self" rel="noopener nofollow">🚨 RSA 암호화 방식의 이해와 적용 (feat.취약성점검)</a> <br><a data-href="🍎 Redis로 Key관리하기" href="https://lts.kr/study/cs/🍎-redis로-key관리하기.html" class="internal-link" target="_self" rel="noopener nofollow">🍎 Redis로 Key관리하기</a> <br><a data-href="🌋 OSIV란 무엇인가" href="https://lts.kr/study/cs/🌋-osiv란-무엇인가.html" class="internal-link" target="_self" rel="noopener nofollow">🌋 OSIV란 무엇인가</a>
<br><a data-href="🐰 Java의 String과 SpringBuffer" href="https://lts.kr/study/cs/🐰-java의-string과-springbuffer.html" class="internal-link" target="_self" rel="noopener nofollow">🐰 Java의 String과 SpringBuffer</a>
<br><a data-href="🛬 JDK와 JRE, JVM" href="https://lts.kr/study/cs/🛬-jdk와-jre,-jvm.html" class="internal-link" target="_self" rel="noopener nofollow">🛬 JDK와 JRE, JVM</a>
<br><a data-href="🍊 Spring의 의존성 주입(DI)" href="https://lts.kr/study/cs/🍊-spring의-의존성-주입(di).html" class="internal-link" target="_self" rel="noopener nofollow">🍊 Spring의 의존성 주입(DI)</a>
<br><a data-href="🪕 JPA 관련 용어 정리" href="https://lts.kr/study/cs/🪕-jpa-관련-용어-정리.html" class="internal-link" target="_self" rel="noopener nofollow">🪕 JPA 관련 용어 정리</a>
<br>
<br><a data-href="☕ JAVA , OOP" href="https://lts.kr/study/cs/☕-java-,-oop.html" class="internal-link" target="_self" rel="noopener nofollow">☕ JAVA , OOP</a>
<br><a data-href="🍃 Spring" href="https://lts.kr/study/cs/🍃-spring.html" class="internal-link" target="_self" rel="noopener nofollow">🍃 Spring</a>
<br><a data-href="🎩 DevOps" href="https://lts.kr/study/cs/🎩-devops.html" class="internal-link" target="_self" rel="noopener nofollow">🎩 DevOps</a>
<br><a data-href="📔 DataBase" href="https://lts.kr/study/cs/📔-database.html" class="internal-link" target="_self" rel="noopener nofollow">📔 DataBase</a>
<br><a data-href="📭 Server" href="https://lts.kr/study/cs/📭-server.html" class="internal-link" target="_self" rel="noopener nofollow">📭 Server</a>
<br><a data-href="🐞 etc" href="https://lts.kr/study/cs/🐞-etc.html" class="internal-link" target="_self" rel="noopener nofollow">🐞 etc</a>
<br>
<br><a data-href="🤠 Coding Test 풀이 모음" href="https://lts.kr/study/coding-test/🤠-coding-test-풀이-모음.html" class="internal-link" target="_self" rel="noopener nofollow">🤠 Coding Test 풀이 모음</a>
<br><a data-href="👽 Algorithm" href="https://lts.kr/study/coding-test/👽-algorithm.html" class="internal-link" target="_self" rel="noopener nofollow">👽 Algorithm</a>
<br>
<br><a data-href="🔻 Redis 캐쉬 전략 - hello 서비스에 적용하여 성능개선 가능성" href="https://lts.kr/study/dev-seminar/🔻-redis-캐쉬-전략-hello-서비스에-적용하여-성능개선-가능성.html" class="internal-link" target="_self" rel="noopener nofollow">🔻 Redis 캐쉬 전략 - hello 서비스에 적용하여 성능개선 가능성</a>
<br><a data-href="🔐 상품 투자하기 서비스 Lock기법 개선안" href="https://lts.kr/issue_troubleshooting/🔐-상품-투자하기-서비스-lock기법-개선안.html" class="internal-link" target="_self" rel="noopener nofollow">🔐 상품 투자하기 서비스 Lock기법 개선안</a>
<br><a data-href="🔹 TDD에 대하여" href="https://lts.kr/study/dev-seminar/🔹-tdd에-대하여.html" class="internal-link" target="_self" rel="noopener nofollow">🔹 TDD에 대하여</a>
<br><a data-href="🍂 JPA, Mybatis , Dead Lock이슈" href="https://lts.kr/study/dev-seminar/🍂-jpa,-mybatis-,-dead-lock이슈.html" class="internal-link" target="_self" rel="noopener nofollow">🍂 JPA, Mybatis , Dead Lock이슈</a>
<br><a data-href="🥗 Spring Security_토큰-세션-쿠키-JWT 에 대하여" href="https://lts.kr/study/dev-seminar/🥗-spring-security_토큰-세션-쿠키-jwt-에-대하여.html" class="internal-link" target="_self" rel="noopener nofollow">🥗 Spring Security_토큰-세션-쿠키-JWT 에 대하여</a>
<br><a data-href="📔 DB 테이블 설계, 어떻게 하는게 옳은 방법인가" href="https://lts.kr/study/dev-seminar/📔-db-테이블-설계,-어떻게-하는게-옳은-방법인가.html" class="internal-link" target="_self" rel="noopener nofollow">📔 DB 테이블 설계, 어떻게 하는게 옳은 방법인가</a>]]></description><link>https://lts.kr/study/📕-공부.html</link><guid isPermaLink="false">study/📕 공부.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 07:08:53 GMT</pubDate></item><item><title><![CDATA[🔫 이슈 분석 &amp; 트러블슈팅]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:이슈" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#이슈</a> <a class="tag" href="https://lts.kr/?query=tag:트러블슈팅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#트러블슈팅</a> <a class="tag" href="https://lts.kr/?query=tag:모음" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#모음</a> <br> <a href="https://lts.kr?query=tag:이슈" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#이슈">#이슈</a> <a href="https://lts.kr?query=tag:트러블슈팅" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#트러블슈팅">#트러블슈팅</a> <a href="https://lts.kr?query=tag:모음" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#모음">#모음</a><br>이슈 / 트러블 슈팅
크고 작은 이슈와, 그 해결 과정을 쓴 글 모음입니다.
<br>
<br><a data-href="🍧 JPA의 영속성 상태와 데이터 Log 이슈" href="https://lts.kr/issue_troubleshooting/🍧-jpa의-영속성-상태와-데이터-log-이슈.html" class="internal-link" target="_self" rel="noopener nofollow">🍧 JPA의 영속성 상태와 데이터 Log 이슈</a>
<br><a data-href="🍂 JPA, Mybatis , Dead Lock이슈" href="https://lts.kr/study/dev-seminar/🍂-jpa,-mybatis-,-dead-lock이슈.html" class="internal-link" target="_self" rel="noopener nofollow">🍂 JPA, Mybatis , Dead Lock이슈</a> <br><a data-href="🌋 OSIV란 무엇인가" href="https://lts.kr/study/cs/🌋-osiv란-무엇인가.html" class="internal-link" target="_self" rel="noopener nofollow">🌋 OSIV란 무엇인가</a>
<br><a data-href="🪕 JPA 관련 용어 정리" href="https://lts.kr/study/cs/🪕-jpa-관련-용어-정리.html" class="internal-link" target="_self" rel="noopener nofollow">🪕 JPA 관련 용어 정리</a> <br><a data-href="🔐 상품 투자하기 서비스 Lock기법 개선안" href="https://lts.kr/issue_troubleshooting/🔐-상품-투자하기-서비스-lock기법-개선안.html" class="internal-link" target="_self" rel="noopener nofollow">🔐 상품 투자하기 서비스 Lock기법 개선안</a>
<br><a data-href="⚔ StckOverflow 이슈와 QueryDSL" href="https://lts.kr/issue_troubleshooting/⚔-stckoverflow-이슈와-querydsl.html" class="internal-link" target="_self" rel="noopener nofollow">⚔ StckOverflow 이슈와 QueryDSL</a>
<br>
<br><a data-href="🚨 RSA 암호화 방식의 이해와 적용 (feat.취약성점검)" href="https://lts.kr/issue_troubleshooting/🚨-rsa-암호화-방식의-이해와-적용-(feat.취약성점검).html" class="internal-link" target="_self" rel="noopener nofollow">🚨 RSA 암호화 방식의 이해와 적용 (feat.취약성점검)</a> <br><a data-href="🤲분산 환경에서의 Cache 선택하기" href="https://lts.kr/study/cs/🤲분산-환경에서의-cache-선택하기.html" class="internal-link" target="_self" rel="noopener nofollow">🤲분산 환경에서의 Cache 선택하기</a>
<br><a data-href="🍎 Redis로 Key관리하기" href="https://lts.kr/study/cs/🍎-redis로-key관리하기.html" class="internal-link" target="_self" rel="noopener nofollow">🍎 Redis로 Key관리하기</a> <br><a data-href="🚦 Spring Batch 트러블슈팅" href="https://lts.kr/issue_troubleshooting/🚦-spring-batch-트러블슈팅.html" class="internal-link" target="_self" rel="noopener nofollow">🚦 Spring Batch 트러블슈팅</a>
<br><a data-href="⏰ Script 로딩 지연 문제 해결 .js" href="https://lts.kr/issue_troubleshooting/⏰-script-로딩-지연-문제-해결-.js.html" class="internal-link" target="_self" rel="noopener nofollow">⏰ Script 로딩 지연 문제 해결 .js</a>]]></description><link>https://lts.kr/project/🔫-이슈-분석-&amp;-트러블슈팅.html</link><guid isPermaLink="false">project/🔫 이슈 분석 &amp; 트러블슈팅.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 07:08:40 GMT</pubDate></item><item><title><![CDATA[🐞 etc]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="https://lts.kr/?query=tag:기타" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#기타</a> <br> <a href="https://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="https://lts.kr?query=tag:기타" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#기타">#기타</a><br><a data-href="Service의 순환참조를 막는 방법" href="https://lts.kr/짧은-키워드/service의-순환참조를-막는-방법.html" class="internal-link" target="_self" rel="noopener nofollow">Service의 순환참조를 막는 방법</a><br><a data-href="Maven VS Gradle" href="https://lts.kr/짧은-키워드/maven-vs-gradle.html" class="internal-link" target="_self" rel="noopener nofollow">Maven VS Gradle</a><br><a data-href="Multi Thread환경에서의 Singleton" href="https://lts.kr/짧은-키워드/multi-thread환경에서의-singleton.html" class="internal-link" target="_self" rel="noopener nofollow">Multi Thread환경에서의 Singleton</a>]]></description><link>https://lts.kr/study/cs/🐞-etc.html</link><guid isPermaLink="false">study/CS/🐞 etc.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 07:03:52 GMT</pubDate></item><item><title><![CDATA[Multi Thread환경에서의 Singleton]]></title><description><![CDATA[<br><br>
<br>
일반적으로 하나의 인스턴스만 존재해야 할 경우 Singleton패턴을 사용하게 된다.
single thread환경에서 사용되는 경우에는 아무런 문제가 없지만, Multi thread환경에서
singleton객체에 접근 시 초기화 관련하여 문제가 있다. <br>
보통 Singleton객체를 얻는 Static메서드는 getInstance( )로 작명하는게 일반적이다. <br><br>
<br>단순하게 문제를 해결하고자 한다면, 메서드에 synchronized 키워드만 추가해도 무방하다.
하지만, 이는 하는 역할에 비해서 동기화 오버헤드가 심하다는 단점이 있다.
<br><br>
<br>간단하게 설명하면, 객체가 필요할 때로 초기화를 미루는 것이다.
<br>public class Singleton { private Singleton() {} public static Singleton getInstance() { return LazyHolder.INSTANCE; } private static class LazyHolder { private static final Singleton INSTANCE = new Singleton(); }
}
<br>처음 singleton로딩 시에는 LazyHolder클래스의 변수가 없기 때문에 초기화 하지 않는다.
LazyHolder클래스는 singleton클래스의 getInstance( ) 메서드가 참조되는 순간 class가 로딩되며 초기화 된다.<br>Class를 로딩하고 초기화하는 시점은 thread-safe가 보장되기 때문에, 성능과 안정성을 모두 보장하는 훌륭한 방법이다.]]></description><link>https://lts.kr/짧은-키워드/multi-thread환경에서의-singleton.html</link><guid isPermaLink="false">짧은 키워드/Multi Thread환경에서의 Singleton.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 07:03:47 GMT</pubDate></item><item><title><![CDATA[Maven VS Gradle]]></title><description><![CDATA[<br><br><br>
<br>Apach에서 2004년 출시한 빌드 툴이다.
<br>Ant를 사용하던 개발자들의 불편함을 해소 + 부가기능을 추가 하기위해 만들어졌다.
<br><br>
<br>Ant와 Maven의 장점을 모아 2012년 출시한 빌드 툴이다.
<br>Gradel이 시기 상 늦게 출시된 만큼 사용성/성능 등 비교적 뛰어난 스펙을 갖고 있다.
<br><br>
<br>
Gradle의 Groovy를 이용해서 기존 XML로 작성되있던 요소들의 단점을 해소하고 있다. <br>XML의 경우 코드가 길어지면 가독성이 떨어진다.
<br>의존관계가 복잡한 프로젝트 설정에 어려움이 있다. <br>
특정 상황에서 Gradle의 속도는 Maven보다 훨씬 빠르다. <br>Gradle은 캐시를 사용하기 때문에 반복될 수록 속도 차이는 더욱 커진다. <br>]]></description><link>https://lts.kr/짧은-키워드/maven-vs-gradle.html</link><guid isPermaLink="false">짧은 키워드/Maven VS Gradle.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 07:03:40 GMT</pubDate></item><item><title><![CDATA[☕ JAVA , OOP]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="https://lts.kr/?query=tag:Java" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Java</a> <a class="tag" href="https://lts.kr/?query=tag:OOP" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#OOP</a> <br> <a href="https://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="https://lts.kr?query=tag:Java" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Java">#Java</a> <a href="https://lts.kr?query=tag:OOP" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#OOP">#OOP</a><br><a data-href="오버로딩 &amp; 오버라이딩" href="https://lts.kr/짧은-키워드/오버로딩-&amp;-오버라이딩.html" class="internal-link" target="_self" rel="noopener nofollow">오버로딩 &amp; 오버라이딩</a><br><a data-href="상속과 합성" href="https://lts.kr/짧은-키워드/상속과-합성.html" class="internal-link" target="_self" rel="noopener nofollow">상속과 합성</a><br><a data-href="객체지향설계 5원칙 S.O.L.I.D" href="https://lts.kr/짧은-키워드/객체지향설계-5원칙-s.o.l.i.d.html" class="internal-link" target="_self" rel="noopener nofollow">객체지향설계 5원칙 S.O.L.I.D</a><br><a data-href="🛬 JDK와 JRE, JVM" href="https://lts.kr/study/cs/🛬-jdk와-jre,-jvm.html" class="internal-link" target="_self" rel="noopener nofollow">🛬 JDK와 JRE, JVM</a><br><a data-href="🐰 Java의 String과 SpringBuffer" href="https://lts.kr/study/cs/🐰-java의-string과-springbuffer.html" class="internal-link" target="_self" rel="noopener nofollow">🐰 Java의 String과 SpringBuffer</a><br><a data-href="데코레이션 패턴 vs 프록시 패턴" href="https://lts.kr/짧은-키워드/데코레이션-패턴-vs-프록시-패턴.html" class="internal-link" target="_self" rel="noopener nofollow">데코레이션 패턴 vs 프록시 패턴</a><br><a data-href="JPA의 지연로딩" href="https://lts.kr/짧은-키워드/jpa의-지연로딩.html" class="internal-link" target="_self" rel="noopener nofollow">JPA의 지연로딩</a><br><a data-href="Java의 리플렉션이란" href="https://lts.kr/짧은-키워드/java의-리플렉션이란.html" class="internal-link" target="_self" rel="noopener nofollow">Java의 리플렉션이란</a><br><a data-href="Java의 람다란" href="https://lts.kr/짧은-키워드/java의-람다란.html" class="internal-link" target="_self" rel="noopener nofollow">Java의 람다란</a><br><a data-href="Static 키워드에 대하여" href="https://lts.kr/짧은-키워드/static-키워드에-대하여.html" class="internal-link" target="_self" rel="noopener nofollow">Static 키워드에 대하여</a><br><a data-href="JVM의 Stack과 Heap" href="https://lts.kr/짧은-키워드/jvm의-stack과-heap.html" class="internal-link" target="_self" rel="noopener nofollow">JVM의 Stack과 Heap</a><br><a data-href="JPQL과 QueryDSL 비교" href="https://lts.kr/짧은-키워드/jpql과-querydsl-비교.html" class="internal-link" target="_self" rel="noopener nofollow">JPQL과 QueryDSL 비교</a><br><a data-href="JPA에서 BooleanBuilder 와 BooleanExpression 이란" href="https://lts.kr/짧은-키워드/jpa에서-booleanbuilder-와-booleanexpression-이란.html" class="internal-link" target="_self" rel="noopener nofollow">JPA에서 BooleanBuilder 와 BooleanExpression 이란</a><br><a data-href="JPAQueryFactory란" href="https://lts.kr/짧은-키워드/jpaqueryfactory란.html" class="internal-link" target="_self" rel="noopener nofollow">JPAQueryFactory란</a><br><a data-href="예외처리(Exception)" href="https://lts.kr/짧은-키워드/예외처리(exception).html" class="internal-link" target="_self" rel="noopener nofollow">예외처리(Exception)</a><br><a data-href="Equals() 와 HashCode() 재정의" href="https://lts.kr/짧은-키워드/equals()-와-hashcode()-재정의.html" class="internal-link" target="_self" rel="noopener nofollow">Equals() 와 HashCode() 재정의</a><br><a data-href="Java에서 String을 선언하는 두 가지 방법" href="https://lts.kr/짧은-키워드/java에서-string을-선언하는-두-가지-방법.html" class="internal-link" target="_self" rel="noopener nofollow">Java에서 String을 선언하는 두 가지 방법</a>]]></description><link>https://lts.kr/study/cs/☕-java-,-oop.html</link><guid isPermaLink="false">study/CS/☕ JAVA , OOP.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 07:03:36 GMT</pubDate></item><item><title><![CDATA[Java에서 String을 선언하는 두 가지 방법]]></title><description><![CDATA[<br><br>	1. String x = "abc"; 2. String y = new String("abc");
<br>1번의 경우로 생성했을 때는 abc라는 문자열을 String 상수 pool에 저장하고,
다음번에 동일 문자열이 선언될 때 이풀에서 꺼내의 재사용하게 된다.<br>2번의 경우엔 String을 인스턴스와 하여 새로운 객체를 생성하게 된다.
String Class는 자신을 수정하는 기능을 제공하지 않기때문에,
1번의 경우로 선언했을경우 한가지가 바뀌게 되면 나머지가 모두 바뀌게 된다.
이러한 일을 방지하기 위해서는 생성자를 이용한 선언(2번)을 사용해야한다.<br>]]></description><link>https://lts.kr/짧은-키워드/java에서-string을-선언하는-두-가지-방법.html</link><guid isPermaLink="false">짧은 키워드/Java에서 String을 선언하는 두 가지 방법.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 07:03:17 GMT</pubDate></item><item><title><![CDATA[Service의 순환참조를 막는 방법?]]></title><description><![CDATA[<br><br><br>순서를 맞추어 호출하는 로직과 예외처리를하는 로직이 컨트롤러에 집중되어 있다면 가독성이 떨어지게된다 이를 해결하기위해, 서비스에서 로직을 구현하게 된다면 서비스에서 서비스를 호출하는 순환참조를 야기할 수 있게된다. 이를위한 해결법으로 서비스를 주입받는 메인 서비스를 만들어 여러서비스를 주입받고 한개의 서비스에서 이를 동작시킬 수 있다.
<br>]]></description><link>https://lts.kr/짧은-키워드/service의-순환참조를-막는-방법.html</link><guid isPermaLink="false">짧은 키워드/Service의 순환참조를 막는 방법.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 07:02:55 GMT</pubDate></item><item><title><![CDATA[📭 Server]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="https://lts.kr/?query=tag:Server" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Server</a> <br> <a href="https://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="https://lts.kr?query=tag:Server" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Server">#Server</a><br><a data-href="Load Balancer란" href="https://lts.kr/짧은-키워드/load-balancer란.html" class="internal-link" target="_self" rel="noopener nofollow">Load Balancer란</a><br><a data-href="CND(Content Delivery Network)란" href="https://lts.kr/짧은-키워드/cnd(content-delivery-network)란.html" class="internal-link" target="_self" rel="noopener nofollow">CND(Content Delivery Network)란</a><br><a data-href="REST 기반의 트랜잭션" href="https://lts.kr/짧은-키워드/rest-기반의-트랜잭션.html" class="internal-link" target="_self" rel="noopener nofollow">REST 기반의 트랜잭션</a>]]></description><link>https://lts.kr/study/cs/📭-server.html</link><guid isPermaLink="false">study/CS/📭 Server.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 07:02:46 GMT</pubDate></item><item><title><![CDATA[REST 기반의 트랜잭션]]></title><description><![CDATA[<br><br><br><img alt="Pasted image 20240603173517.png" src="https://lts.kr/사진-및-문서/pasted-image-20240603173517.png" target="_self"><br>하지만, MSA의 경우 각 서비스마다 다른 데이터베이스를 사용하는 것이 일반적이고, 이를 하나의 데이터베이스 트렌젝션으로 처리하는 것은 기술적으로 어렵고, 처리한다 해도 긴 트렌젝션이 발생하기 때문에 효용도 적다.
<img alt="Pasted image 20240603180042.png" src="https://lts.kr/사진-및-문서/pasted-image-20240603180042.png" target="_self"><br><br>
<br>tcc는 분산된 REST 시스템들 간의 트랜젝션을 HTTP와 REST원칙으로 접근하여 해결하는 방법이다.
<br>REST API 호출은 한 번에 끝내는 것이 아니라, 2번의 걸쳐서(Try / Confirm) 진행하게 된다.
트렌젝션의 All-or-Nothing을 TCC의 REST API를 호출을 시도(Try)하고 전부 확정(Confirm)하거나 전부 취소(Cancel)하는 것으로 구현된다.<br>
<br>Spring RestTemplate을 사용하여 HTTP 요청(POST)을 보냈을 때, try 요청의 경우 정상적인 HTTP응답(HttpStatus.CREATED)를 받으면 HTTP BODY에는 JSON형태로 Confirm하게 하거나 Cancel 할 수 있는 URL이 담겨 있다.
<br><br>
<br>여기서 Service에서 반환받은 값을 기준으로 Confirm 할지 Cancel할지 선택하게 된다.
<br>중요한 것은 여기서 실제로 데이터베이스 테이블에 변경이 있는것 이 아닌, Confirm되었을때 그때 처리가 된다.
<br><br>
<br>여기서 받은 반환값을 토대로 Service에서는 resource 필드(JSON)을 역질렬화 하고 이를 사용하여 그때 실제로 데이터베이스에 있는 테이블을 변경하게 된다.
<br><br>
<br>
Try는 리소스를 사용하기 전에 예약하는 것이다. 만약 4.구매 주문 생성에서 Try만 하고, 실패했다면 REST로 통신은 기다리고 있던(Try만 한 상태) 두 API에는 Confirm이 전달되지 않아 예약만 된 상태로 남아있게 된다. <br>
예약된 상태는 특정 리소스를 점유하고 있다는 의미이며, 리소스를 점유하고 있는 동안에는 다른 API에서 해당 리소스를 사용하는 것은 제한된다. <br>
따라서, 4. 행위에서 Try만 하고 실패했다면, 예약한 리소스까지 해제해주어야 한다. <br>
분산된 환경에서 리소스를 해제하는 것은 쉬운 문제가 아닌데, TCC매커니즘에서는 Cancel과 Timeout 두가지 방법으로 예약된 리소스를 해제한다.
<img alt="Pasted image 20240604102140.png" src="https://lts.kr/사진-및-문서/pasted-image-20240604102140.png" target="_self"> <br>REST커뮤니케이션 관전에서 자세하게 설명하면,<br>
<br>TCC REST API Consumer(여기선 OrderService)가 Try요청
<br>TCC REST API Provider (여기선 StockService/PaymentService)는 응답으로 Confirm하거나 Cancel할 수 있는 URI를 반환
<br>이를 사용하여 API Consumer는 DELETE HTTP Method로 예약한 리소스에 대한 해제를 요청한다.
<br><br><img alt="Pasted image 20240604144026.png" src="https://lts.kr/사진-및-문서/pasted-image-20240604144026.png" target="_self"><br>
<br>클라이언트가 주문을하고, OrderService는 StockService와 PaymentService로 Try한다.
그리고 구매 주문을 생성 후 Confirm하였다. StockService는 재고 처리에 성공을 한 반면, PaymentService는 결제에 실패한다.
이경우에는 어떻게 일관성을 유지할 수 있을까?
<br><br>
<br>관계형 데이터베이스에서 트랜젝션을 처리할 때에는 데이터 적합성을 보장해야 하기 때문에 엄격한 일관성 모델을 사용한다.
<br>하지만 결제시스템 하나의 문제로 모든 비즈니스가 멈추게 되는 문제가 발생한다.(보통은 멈추는게 맞다)
<br><br>
<br>
StockService와 PaymentService는 OrderService로부터 받은 Confirm요청을 Queue나 Log파일에 큐잉 하고, 이를 비동기적으로 처리한다. Confirm처리 과정에서 오류가 나는 경우 계속해서 재시도하여 결국(언젠가) 처리하게 한다. <br>
이렇게 단기적으로 일관성을 잃더라도(클라이언트 입장에서는 성공했다고 느끼지만, 실제 결제처리가 되지 않았을 수도 있다.) 결국에서는 일관성을 유지하는 모델을 결과적 일관성 이라고 한다. <br>
단, 결과적 일관성 모델은 단기적으로 일관성을 잃어버렸을 때를 대비한 화면 처리 등이 필요하다. <br>
ex) 아마존에서 전자책을 구입한 후, 결제 과정이 진행되었고 이후 카드가 정상처리되지 않는 메일을 받아, 2일후에 제대로 결제처리를 하였다. ]]></description><link>https://lts.kr/짧은-키워드/rest-기반의-트랜잭션.html</link><guid isPermaLink="false">짧은 키워드/REST 기반의 트랜잭션.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 07:02:39 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20240603173517.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20240603173517.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[CND(Content Delivery Network)란??]]></title><description><![CDATA[<br><br>
<br>
웹서버가 클라이언트의 요청에 의해 웹페이지에 대한 응답 결과를 돌려줬을때,
클라이언트의 화면에는 랜더링해야하는 수많은 이미지가 필요하다.
이 이미지를 웹서버가 전부 주려면 데이터의 용량이 무거워서 서버에 부하가 걸리게 되는데,,
따라서 웹서버는 이미지를 대신 건내주는 CDN에게 요청한다는 개념이다. <br>
CDN은 일반적으로 용량이 큰 컨텐츠 데이터를 빠른속도로 제공하기 위해 사용자와 가까운곳에 분산되어 있는 데이터 저장 서버이다. <br><br>
<br>push CDN : 서버에서 컨텐츠가 업로드 되거나, 변경되었을 때 모두 반영하는 방식
<br>pull CDN : 클라이언트가 요청할 때마다 컨텐츠가 CDN에 새로 저장되는 방식
<br>두 방식 모두 장단점이 있다.
Push방식은 모든 컨텐츠를 갖고 있기 때문에 웹서버에 요청할 일이 없지만 유지하는데 필요한 용량과 비용이 크고,
Pull방식은 요청이 들어왔을 때 컨텐츠가 있다면 즉각 응답하지만, 그렇지 않을때 웹서버에 요청해야하는 부담이 있다.<br>]]></description><link>https://lts.kr/짧은-키워드/cnd(content-delivery-network)란.html</link><guid isPermaLink="false">짧은 키워드/CND(Content Delivery Network)란.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 07:02:36 GMT</pubDate></item><item><title><![CDATA[Load Balancer란??]]></title><description><![CDATA[<br><br>
<br>서버에 일을 분산시켜주는 역할을 한다.
<br> <br>Random 랜덤분배 <br> <br>Least loaded 가장 적은양의 작업을 처리하고 있는 서버에게 요청 할당 <br> <br>Round Robin 순서를 정하여 돌아가며 작업 분배 <br><br>
<br>layer4 : 데이터의 내용을 보지 않고 IP주소 및 TCP/UDP정보에 따라 단순히 분배를 해준다
<br>layer7 : 서버가 하는 역할이 분리되어 있는 환경에서 데이터의 내용을 보고 각기 맞는 역할을 하는 서버에게 분배
<br>로드밸런서는 클라이언트가 요청을 보내야 할 서버를 골라야하는 부담을 덜어주며, 로드 밸런서에게 할당된 vIP(가상IP)로 요청을 보내기만 하면 로드 밸런서에서 알아서 작업을 나눠준다.
서버에서는 적절한 로드 밸런서를 사용하면 들어오는 요청이 여러 장비에 분산되어 처리량이 늘어나고 응답 시간이 줄어드는 효과를 기대할 수 있다.<br>]]></description><link>https://lts.kr/짧은-키워드/load-balancer란.html</link><guid isPermaLink="false">짧은 키워드/Load Balancer란.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 07:02:30 GMT</pubDate></item><item><title><![CDATA[📔 DataBase]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="https://lts.kr/?query=tag:DB" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#DB</a> <a class="tag" href="https://lts.kr/?query=tag:DataBase" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#DataBase</a> <br> <a href="https://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="https://lts.kr?query=tag:DB" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#DB">#DB</a> <a href="https://lts.kr?query=tag:DataBase" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#DataBase">#DataBase</a><br><a data-href="DB의 저장 프로시저 (SP - Stored Procedure)란" href="https://lts.kr/짧은-키워드/db의-저장-프로시저-(sp-stored-procedure)란.html" class="internal-link" target="_self" rel="noopener nofollow">DB의 저장 프로시저 (SP - Stored Procedure)란</a><br><a data-href="DB Connection이란 무엇일까" href="https://lts.kr/짧은-키워드/db-connection이란-무엇일까.html" class="internal-link" target="_self" rel="noopener nofollow">DB Connection이란 무엇일까</a><br><a data-href="DataBase 정규화 과정" href="https://lts.kr/짧은-키워드/database-정규화-과정.html" class="internal-link" target="_self" rel="noopener nofollow">DataBase 정규화 과정</a><br><a data-href="Dual 테이블이란" href="https://lts.kr/짧은-키워드/dual-테이블이란.html" class="internal-link" target="_self" rel="noopener nofollow">Dual 테이블이란</a><br><a data-href="엘라스틱서치 인덱스와 샤드 분할" href="https://lts.kr/짧은-키워드/엘라스틱서치-인덱스와-샤드-분할.html" class="internal-link" target="_self" rel="noopener nofollow">엘라스틱서치 인덱스와 샤드 분할</a><br><a data-href="많이쓰이는 DB용어" href="https://lts.kr/짧은-키워드/많이쓰이는-db용어.html" class="internal-link" target="_self" rel="noopener nofollow">많이쓰이는 DB용어</a><br><a data-href="Lock ( 데이터베이스 락 ) 이란" href="https://lts.kr/짧은-키워드/lock-(-데이터베이스-락-)-이란.html" class="internal-link" target="_self" rel="noopener nofollow">Lock ( 데이터베이스 락 ) 이란</a>]]></description><link>https://lts.kr/study/cs/📔-database.html</link><guid isPermaLink="false">study/CS/📔 DataBase.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 07:02:23 GMT</pubDate></item><item><title><![CDATA[Lock ( 데이터베이스 락 ) 이란?]]></title><description><![CDATA[<br><br>세션1이 트렌젝션을 시작하고 데이터를 수정하는 동안 아직 커밋을 수행하지 않았는데,
세션2에서 동시에 같은 데이터를 수정하게 되면 여러가지 문제가 발생한다.<br>이런문제를 방지하기 위해, 세션이 트렌젝션을 시작하고 데이터를 수정하는 동안에 커밋이나 롤백 전까지
다른세션에서 해당 데이터를 수정할 수 없게 막아야 한다. 이런 문제를 해결하기 위해 DB에서는
LOCK 락 이라는 개념을 제공한다.<br>
<br>락은 언제 사용하는가? : 트렌젝션 종료 시점까지 해당 데이터를 다른 곳에서 변경하지 못하도록 강제로 막아야 할 때 사용한다.
<br>일반적인 조회는 락을 사용하지 않는다.
<br>락 타임아웃(다른 세션이 데이터를 점유하고 있을때 대기시간이 초과된 경우)에는 익셉션이 발생하게 된다.
<br><br>동시성 제어(Concurrency Control)란,&nbsp;여러 사용자나 프로세스가 데이터를 공유할 때 발생할 수 있는 문제를 해결하기 위해, 데이터베이스 시스템이 트랜잭션을 순서대로 실행하는 것이 아니라, 트랜잭션이 동시에 실행될 수 있도록 허용하면서도 데이터의 일관성과 무결성을 유지할 수 있도록 하는 기술이며, 데이터베이스 시스템에서 매우 중요한 개념 중 하나이다.<br><br>
<br>여러 사용자가 DB에 접근하더라도&nbsp;데이터의 일관성을 보장하고 데이터의 무결성을 유지
<br>위를 만족하며 데이터베이스 시스템의 성능과 효율성을 유지하는 것
<br>
<br>분실된 갱신(Lost Update) <br>두개의 트랜잭션이 같은 데이터를 갱신하는 작업을 진행하게 되면서 하나의 작업이 진행되지 않는 경우 <br>모순성(Inconsistency) <br>두개의 트랜잭션이 같은 데이터를 동시에 갱신하게되어 사용자가 원하는 결과와 일치하지 않은 상태가 되는 경우 <br>연쇄복귀(Cascading Rollback) <br>두개의 트랜잭션이 같은 데이터를 갱신하는 작업을 진행하는 과정에서 하나의 트랜잭션이 실패하면 원자성에 의해 두 트랜잭션 모두 복귀하는 경우 <br>비완료 의존성(Uncommitted Dependency) <br>한개의 트랜잭션이 실패하였을때, 이 트랜재션이 회복하기전에 다른 트랜잭션이 실패한 수행 결과를 참조하는 경우 <br><br><br>
<br>Locking은 공유 자원에 대한 동시 액세스를 제어하는 전통적인 방법이다.
<br>단일 스레드 또는 단일 프로세스에서만 동작하며, 한 번에 하나의 스레드만 공유 자원에 액세스할 수 있다.
<br>신뢰성과 안전성이 높으며, 어떤 수준의 locking을 적용하느냐에 따라 교착 상태나 경쟁 조건과 같은 문제를 방지할 수 있다.
<br>하지만 동시성 처리 속도가 저하될 수 있고, 대기 시간이 발생할 수 있다.
<br>기본적으로 lock 연산과 unlock 연산을 사용한다.
<br><br>
<br>
공유 잠금 (shared lock/s-lock): 데이터를 읽을 때 사용하는 락 <br>공유잠금을 설정한 트랜잭션은 데이터 항목에 대해&nbsp;읽기 연산(read)만 가능하다. <br>T1에서 x에 대해 S-lock을 설정했다면, T1은 read(x) 연산만 가능하다. <br>하나의 데이터 항목에 대해&nbsp;여러 개의 공유잠금이(S-lock) 가능하다. <br>T1에서 x에 대해 S-lock을 설정한 경우, 동시에 T2에서도 x에 대해 S-lock을 설정할 수 있다. <br>다른 트랜잭션도 읽기 연산(read) 만을 실행할 수 있다. <br>T1에서 x에 대해 S-lock을 설정했다면, T2에서도 T1이 S-lock(x)을 실행하는 동안 read(x) 연산만 가능하다. <br>
배타 잠금 (exclusive lock/x-lock): 데이터를 변경할 때 사용하는 락 <br>배타잠금을 설정한 트랜잭션은 데이터 항목에 대해서&nbsp;읽기 연산(read)과 쓰기 연산(write) 모두 가능하다. <br>T1에서 x에 대해 S-lock을 설정했다면, T1은 read(x) 연산과 write(x) 연산 모두 가능하다. <br>하나의 데이터 항목에 대해서는&nbsp;하나의 배타잠금(X-lock)만 가능하다.
<br>동시에 여러 개의 배타잠금은 불가능하다. <br>T1에서 x에 대해 X-lock을 설정했다면, T1에서 unlock(x)를 하기 전까지 T2에서 x에 대해 X-lock을 설정할 수 없다. <br>다른 트랜잭션은 읽기 연산(read)와 쓰기 연산(write) 모두 불가능하다. <br>T1에서 x에 대해 X-lock을 설정했다면, T2에서는 T1에서 unlock(x)를 하기 전까지 read(x), write(x) 연산이 모두 불가능하다. <br>
추가) 교착상태 (deadlock) <br>모든 transaction이 대기 상태에 들어가 아무런 진행이 일어나지 않는 상태를 교착상태라고 한다. 교착상태에 빠지면 외부에서 강제로 트랜잭션을 중단하거나 잠금을 해제하지 않는 이상 무한정 대기 상태로 남게 된다. <br><br><br>
<br>
낙관적 락 (optimistic lock) <br>충돌이 발생할 가능성이 낮은 경우 사용되는 동시성 제어 기법이다.
<br>충돌이 발생하면 재시도 또는 병합을 통해 충돌을 해결한다.
<br>실제로 lock을 사용하지 않고&nbsp;version을 이용함으로서 정합성을 맞추는 방법이다. 데이터를 읽을 때 lock을 사용하지 않고, 업데이트 시&nbsp;내가 읽은 version이 맞는지 충돌 여부를 확인하여 처리한다.
<br>즉, 자원에 lock을 직접 걸어서 선점하지 않고, 동시성 문제가 실제로 발생하면 그때가서 처리하는 방식이다. <br>
비관적 락 (pessimistic lock) <br>충돌이 발생할 가능성이 높은 경우 사용되는 동시성 제어 기법이다.
<br>데이터를 읽거나 수정하기 전에 lock을 획득하여 다른 사용자의 액세스를 차단하고, lock을 가진 스레드만 접근하도록 제어한다.
<br>데이터에 대한 배타적인 액세스 권한을 보장하여 충돌을 방지한다.
<br>실제로 데이터에 lock을 걸어서 정합성을 맞추는 방법으로, 자원 요청에 따른 동시성 문제가 발생할 것이라고 예상하고 lock을 걸어버리는 방법이다.
<br>즉, 트랜젝션이 시작할 때 s-lock이나 x-lock을 실제로 걸고 시작한다. <br>
낙관적 락 vs. 비관적 락
<img alt="Pasted image 20250228150552.png" src="https://lts.kr/사진-및-문서/pasted-image-20250228150552.png" target="_self"> <br>
분산락 (distributed lock) <br>여러 컴퓨터 또는 프로세스 간에 공유된 자원에 대한 동시 액세스를 제어하기 위해 사용된다.
<br>분산 시스템에서 동시성 문제를 해결하기 위해 사용되며,&nbsp;분산된 서버 또는 클러스터 간의 상호작용이 필요하다.
<br>주로&nbsp;데이터베이스나 메시지 큐 등의 분산 시스템에서 사용된다.
<br>대표적인 분산락 기법으로는 ZooKeeper, Redis 등이 있다.
<br>Redis는 RedLock이라는 알고리즘을 제안하며 3가지 특성을 보장해야한다고 한다. <br>오직 한 순간에 하나의 작업자만이 락(lock) 을 걸 수 있다.
<br>락 이후, 어떠한 문제로 인해 락을 풀지 못하고, 종료된 경우라도 다른 작업자가 락을 획득할 수 있어야합니다.
<br>Redis 노드가 작동하는한, 모든 작업자는 락을 걸고 해체할 수 있어야합니다. <br>분산 락을 구현하기 위해 lock에 대한 정보를 Redis에 저장하고 있어야한다. 그리고 분산환경에서 여러대의 서버들은 공통된 Redis를 바라보며, 자신이 공유 자원에 접근할 수 있는지 확인한다. <br>
스핀락 (spin lock) <br>자원에 대한 접근이 필요할 때 무한루프를 돌면서 반복적으로 확인하며, 다른 스레드가 lock을 해제할 때까지 대기한다.
<br>경쟁 상태 (2개 이상의 프로세스가 공유 자원을 동시에 읽거나 쓰는 상황)가 짧고 자원 점유 시간이 길지 않은 경우에 효과적이다.
<br>주로 멀티코어 시스템에서 사용되며, 락 획득을 위해 CPU를 계속 사용하므로 서버에 많은 부하를 주어 주의해야 한다.
<br> <br>]]></description><link>https://lts.kr/짧은-키워드/lock-(-데이터베이스-락-)-이란.html</link><guid isPermaLink="false">짧은 키워드/Lock ( 데이터베이스 락 ) 이란.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 07:02:17 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20250228150552.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20250228150552.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[많이쓰이는 DB용어]]></title><description><![CDATA[<br><br><br>트렌젝션
- 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위<br>트렌젝션매니저
- Spring에서 제공하는 트렌젝션 관리 기능과 JPA를 연결하는 역할을 수행.<br>@Transactional
- 클래스나 메서드에 삽입하면, AOP레벨(프록시를 사용하여)에서 트렌젝션매니저를 이용한 동작을 공통으로 적용.<br>앤티티매니저
- 영속성 컨텍스트를 관리하는 인터페이스
- 엔티티의 저장/수정/삭제/조회 작업을 수행
- 스레드 세이프하지 않으므로 한트레젝션 내에서만 사용
- 앤티티매니저펙토리는 스레드세이프하므로 공유 가능<br>영속성컨텍스트
- JPA의 엔티티를 관리하는 1차 캐시 역할을 하는 메모리 공간
- 엔티티와 DB데이터간의 상태 동기화를 책임
- 1차캐싱 / 변경 감지 / 지연 로딩 의 특징을 갖는다
- 지연로딩 : 관계된 엔티티를 실제로 필요할때만 가져오며, 변경점을 한번만 commit한다<br>스냅샷
- DB스냅샷 :
- 트렌젝션이 시작될때 생성된다.
- 독립적인 데이터베이스 복사본으로, 원본데이터 변경과 무관하다.
- 고급 격리 수준(REPEATABLE READ, SERIALIZABLE)에서 MVCC(Multi-Version Concurrency Control)를 구현할 때 사용한다.
- 물리적인 복사본이 아닌, 논리적으로 매 쿼리마다 동적으로 가공이 되는 방식이다.
- 앤티티매니저_스냅샷 :
- 엔티티가 영속성 컨텍스트에 로드될 때 생성된다.
- 엔티티의 초기 상태를 저장하여 변경 감지에 사용된다.<br>]]></description><link>https://lts.kr/짧은-키워드/많이쓰이는-db용어.html</link><guid isPermaLink="false">짧은 키워드/많이쓰이는 DB용어.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 07:02:11 GMT</pubDate></item><item><title><![CDATA[엘라스틱서치 인덱스와 샤드 분할]]></title><description><![CDATA[<br><br>인덱스 : 단일데이터 단위인 도큐먼트(document)를 모아놓은 집합을 인덱스(index)라고 한다.
색인 : 데이터를 Elasticsearch에 저장하는 행위
샤드 : 인덱스는 기본적으로 샤드(shard)라는 단위로 분리되고, 각 노드에 분산되어 저장된다 (검색의 기본단위는 샤드이다.)
<img alt="Pasted image 20240828104032.png" src="https://lts.kr/사진-및-문서/pasted-image-20240828104032.png" target="_self"><br>
<br>데이터를 범위나 카테고리로 나누어 관리하는 기법을 파티셔닝 이라고 한다.
<br><br>
<br>
인덱스를 생성할 때, 처음 생성된 샤드를 프라이머리 샤드, 복제본은 리플리카 라고 부른다. <br>
예를 들어 한 인덱스가 5개의 샤드로 구성되어있고, 클러스터가 4개의 노드로 구성되어있다고 가정하면,
각각 5개의 프라이머리 샤드와 복제본, 총 10개의 샤드들이 전체 노드에 골고루 분산되어 저장된다.
<img alt="Pasted image 20240828104728.png" src="https://lts.kr/사진-및-문서/pasted-image-20240828104728.png" target="_self">
노드가 1개만 존재한다면 복제본은 생성되지 않는다. Elasticsearch는 아무리 작은 클러스터라도 최소 3개의 노드로 구성할 것을 권장하고 있다. <br>
이렇게 프라이머리 샤드와 리플리카를 통해 Elasticsearch는 운영 중에 노드가 유실되어도 데이터를 잃어버리지 않고, 데이터 가용성과 무결성을 보장하게 된다. <br><br>샤드는 여러 서버에 분산되어 병렬 및 병행으로 검색되므로, 인덱스가 같던 다르던 상관이 없다.
검색의 기본 단위는 샤드이기 때문이다. 따라서 인덱스를 나누는 것은 운영의 편의성을 고려할 때 선택하는 방법이다.
<br><br>전체색인을 할 경우 인덱스 1개가 7억건 이라면 색인이 모두 끝날때 까지 몇시간이 걸리게 된다.
그 와중에 데이터에 변경이 있게 된다면 전체 색인 후 일괄적용이 들어가게 될텐데, 대기시간이 길어질 수록 일괄적용 시간도 함께 늘어나게 된다.
결국 더 빠른 색인을 위해서는 하나의 인덱스를 여러개로 나누너 병행처리를 시키도록 해야한다. 다나와 에서는 상품DB특성상 카테고리군 별로 인덱스를 나누고 있다. 이때의 장점은 특정 카테고리만 검색할때 해당 인덱스만 검색하면 되므로, 검색 속도가 현저히 감소하게 된다.
<br><br>
<br>일반적인 시스템 로그와 같은 로그성 문서는 색인을 하고 나면 수정이 필요없는 정적 컨텐츠인 반면
상품문서같은 경우 색인이 끝나도 계속 갱신되어야 하는 살아있는 동적 컨텐츠이다. 따라서 동적색인에 원할하고, 검색성능도 높은 설계를 요구한다.
<br>]]></description><link>https://lts.kr/짧은-키워드/엘라스틱서치-인덱스와-샤드-분할.html</link><guid isPermaLink="false">짧은 키워드/엘라스틱서치 인덱스와 샤드 분할.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 07:01:40 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20240828104032.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20240828104032.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Dual 테이블이란??]]></title><description><![CDATA[<br><br><br><br><br>]]></description><link>https://lts.kr/짧은-키워드/dual-테이블이란.html</link><guid isPermaLink="false">짧은 키워드/Dual 테이블이란.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 07:01:36 GMT</pubDate></item><item><title><![CDATA[DataBase 정규화  과정]]></title><description><![CDATA[<br><br><br>
<br>테이블 간에 중복된 데이터를 허용하지 않는다는 기본 목표를 갖는다. <br>중복된 데이터를 허용하지 않음으로 써 무결성 을 유지할 수 있다.
<br><br>
<br>DB의 저장 용량 또한 줄일 수 있다.
<br>데이터 테이블을 분해하여 이상현상이 발생할 가능성을 줄이고, 확장/수정시 구조 변경을
최소화 할 수 있다.
<br><br>
<br>
릴레이션의 분해로 인해 Join연산이 늘어날 수 있다. <br>
쿼리시 응답시간이 느려질 수 있다. 데이터의 중복속성을 최대한 제거하는 것 이기때문에, 속성이 하나의 테이블에 집약되므로
데이터 용량이 최소화 되어 상황에따라 처리속도가 빨라질 수도 있고, 느려질 수도 있다.
만약 조인이 만연하여 속도저하가 발생하게 된다면 반정규화를 통해 속도를 개선할 수 있다. <br><br>
<br>테이블의 컬럼이 원자값(하나의 값)을 갖도록 테이블을 분해하는 것이다.
<br>각 컬럼의 순서가 상관이 없어야한다.
<br>하나의 컬럼은 같은 종류의 타입을 가져야 한다.
<img alt="Pasted image 20240531103441.png" src="https://lts.kr/사진-및-문서/pasted-image-20240531103441.png" target="_self">
원자값을 갖도록 컬럼을 나눈다.
<img alt="Pasted image 20240531103549.png" src="https://lts.kr/사진-및-문서/pasted-image-20240531103549.png" target="_self">
<br><br>
<br>제 1 정규화를 진행한 테이블에 대해 "완전 함수 종속"을 만족하도록 테이블을 분해하는 것이다.
<br>여기서 완전 함수 종속이란, 기본키의 부분집합이 결정자가 되어선 안된다는 것을 의미한다.
즉, 부분적 종속을 없애는 것이다.
<br><img alt="Pasted image 20240531105228.png" src="https://lts.kr/사진-및-문서/pasted-image-20240531105228.png" target="_self">
해당 테이블의 기본키는 (학생번호, 강좌이름)으로 복합키 이다.
성적은 (학생번호, 강좌이름)인 기본키가 결정하지만,
강의실은 기본키의 부분집합인 강좌이름이 결정하게 된다.<br>즉, 부분집합이 결정자가 되지 않도록 테이블을 분리시키는 것으로 완전 함수 종속을 만족시킬 수 있다.
<img alt="Pasted image 20240531105241.png" src="https://lts.kr/사진-및-문서/pasted-image-20240531105241.png" target="_self"><br><br>
<br>제2 정규화를 진행한 테이블에 대해 "이행적 종속"을 없애도록 테이블을 분해하는 것이다.
<br>여기서 이행적 종속이란 A -&gt; B , B -&gt; C 가 성립할때, A -&gt; C 가 성립되는 것을 의미한다.
<img alt="Pasted image 20240531104351.png" src="https://lts.kr/사진-및-문서/pasted-image-20240531104351.png" target="_self">
다음의 경유 이행적 종속상태 로 말할 수 있다.
<br>그 경우 테이블을 분리하여 데이터 변경시에 다른 데이터까지 변경되는 상황을 막을 수 있다.
<img alt="Pasted image 20240531104418.png" src="https://lts.kr/사진-및-문서/pasted-image-20240531104418.png" target="_self"><br><br>
<br>제3 정규화를 좀 더 강화한 것이라 생각하면 된다.
<br>BCNF정규화란 제3 정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록
테이블을 분해하는 것을 말한다.
<br><img alt="Pasted image 20240531104751.png" src="https://lts.kr/사진-및-문서/pasted-image-20240531104751.png" target="_self">
특수 수강 테이블에서 기본키는 (학생번호, 특강이름)이다. 그리고 기본키는 교수를 결정하고 있다.
또한, 여기서 교수는 특강이름을 결정하고있다.<br>문제는 교수가 특강이름을 결정하는 결정자 이지만, 후보키가 아니다.
그렇기 때문에 BCNF 정규화를 만족시키기 위해서는 테이블을 분해하여 아래와 같이 분리할 수 있다.<br><img alt="Pasted image 20240531104803.png" src="https://lts.kr/사진-및-문서/pasted-image-20240531104803.png" target="_self"><br><br>
<br>컬럼값의 중복을 제거하는것이다.
<br><br>
<br>중복을 제거하기 위해 분해할 수 있을만큼 최대한 분해하는 것이다.
<br><br> 그 이상 정규화를 진행하면 오히려 정규화의 단점이 더 커지기 때문이다.
<br>]]></description><link>https://lts.kr/짧은-키워드/database-정규화-과정.html</link><guid isPermaLink="false">짧은 키워드/DataBase 정규화  과정.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 07:01:24 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20240531103441.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20240531103441.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[DB Connection이란 무엇일까?]]></title><description><![CDATA[<br><br>- 커넥션이란 어플리케이션과 데이터베이스 서버간의 통신 링크를 뜻한다. 애플리케이션이 쿼리를 실행하고, 데이터를 검색하고, 데이터베이스에서 트랜젝션을 수행 할 수 있는 세션을
설정하는데 사용된다.
말그대로 애플리케이션과 DB를 연결하는 통신링크이며, 이가 모여있는것을 커넥션 풀 이라고 한다.
매번 연결하고 끊고 하는것 보다 커넥션풀에 등록하는 것이 성능적인 향상을 기대할 수 있기 때문이다.
<br>]]></description><link>https://lts.kr/짧은-키워드/db-connection이란-무엇일까.html</link><guid isPermaLink="false">짧은 키워드/DB Connection이란 무엇일까.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 07:01:20 GMT</pubDate></item><item><title><![CDATA[DB의 저장 프로시저 (SP - Stored Procedure)란]]></title><description><![CDATA[<br><br>- 저장 프로시저는 각 DBMS에서 제공하는 기능으로, SQL문을 저장해놓고, 필요할 때마다 호출해서 사용하는 프로그래밍 기능이다.
<br><br>
<br>
SQL의성능을 향상시킬수 있다. <br>SP를 실행하게 되면 최적화, 컴파일 단계를 거쳐, 결과가 캐시에 저장되게 되는데,
이 후 해당 SP를 실행하게 되면 캐시에 있는것을 가져와 사용하므로 실행속도가 빠르다. <br>
유지보수 및 재활용 측면에서 유리하다. <br>응용프로그램 내에서 직접 SQL문을 호출하지않고 SP이름을 호출하도록 설정하면
SP파일만 수정하면 되기때문에 유지보수와 재활용 측면에서 유리하다 <br>
보안이 강화될 수 있다. <br>사용자별로 테이블 권한을 부여하는것이 아닌, SP에만 접근 권한을 주는 방식으로 보안을 강화할 수 있다.
실제 테이블에 접근하여 조작하는것이 위험하기 때문에 개발자에게는 SP권한만 주는 방식을 많이 사용한다. <br>또한, 일반적인 쿼리들은 Where의 조건이 조금만 달라져도, 최적화 컴파일을 다시 수행하여야 하지만,
함수 형태의 SP로 생성하게 되면 매개변수만 변경하여 성능적인 측면을 크게 높일 수 있다.<br><br><br>1. DB에서 SP를 생성한다( 미리 작성되어있는 쿼리 모음 )
2. SP의 리턴값을 저장하는 Entity클래스(@NamedStoredProcedureQuery어노테이션)으로 연결함.
3. Repository에서 프로시저 객체를 생성한다. 이때, 2.에서 생성한 프로시저JPA의 파라미터를 설정한 후 execute한다.
<br>궁금한점 : 저장 프로시저를 사용할경우 Entity는 테이블명으로 class와 연결하지 않아도 괜찮은것인가?<br>
<br>@NamedStoredProcedureQuery어노테이션을 Entity에 적용하면 DBMS에 정의 되어있는 SP(저장 프로시저)
와 연동하여 사용할 수 있다.
<br><br><br>
<br>간단히 설명하면 "여러 쿼리를 한번에 실행하는 것" 이다.
<br>SQL의 Function과 비슷해 보이지만 차이가 있다.
function : 클라이언트에서 처리, 리턴값 필수, 리턴값은 한개만 반환 가능
프로시저 : 서버로 보내서 처리, 리턴값 선택, 리컨값 여러개 가능
<br>속도면에서는 함수에 비해 프로시저가 더 빠르다.
그렇기 때문에 프로시저같은 경우는 실행,처리를 할때 주로 사용하고, 함수는 간단한 계산이나 수치 결과를 나타낼 때 사용한다.<br><br>
<br>하나의 요청으로 여러 SQL문을 실행 할 수 있음
<br>네트워크 소요 시간을 줄일 수 있음(여러개의 쿼리를 처리하는 시점에서 네트워크 부하를 줄임)
<br>보수성이 뛰어나다
<br>개발 업무를 구분하여 개발할 수 있다.(DB관련 처리를 API처럼 만들어 사용가능)
<br><br>
<br>재사용성이 낮다(DB버전 별 구문/규칙과 호환성이 다르기 때문)
<br>처리 성능이 좋지 않다(MySQL스토어드 프로그램 처리 성능이 낮다)
<br><img alt="Pasted image 20240610171904.png" src="https://lts.kr/사진-및-문서/pasted-image-20240610171904.png" target="_self"><br>
<br>파라미터 선언은 프로시저명() 안에서 선언하고, SQL문과 변수는 BEGIN - END 안에서 작성한다.
<br>SELECT사용시 반드시, 조회한 컬럼의 값을 INTO로 변수 안에 넣어주어야 한다.
<br>프로시저안에서 사용하는 SQL문은 세미콜론(;)으로 문장 끝을 맺어주어야 한다.
<br>if, case, loop 문을 사용할 수 있다.
<br>프로시저내에서 다른 프로시저를 호출 할 수 있다.
<br>]]></description><link>https://lts.kr/짧은-키워드/db의-저장-프로시저-(sp-stored-procedure)란.html</link><guid isPermaLink="false">짧은 키워드/DB의 저장 프로시저 (SP - Stored Procedure)란.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 07:00:43 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20240610171904.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20240610171904.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🎩 DevOps]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="https://lts.kr/?query=tag:DevOps" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#DevOps</a> <a class="tag" href="https://lts.kr/?query=tag:CI/CD" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#CI/CD</a> <br> <a href="https://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="https://lts.kr?query=tag:DevOps" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#DevOps">#DevOps</a> <a href="https://lts.kr?query=tag:CI/CD" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#CI/CD">#CI/CD</a><br><a data-href="컨테이너란 무엇일까" href="https://lts.kr/짧은-키워드/컨테이너란-무엇일까.html" class="internal-link" target="_self" rel="noopener nofollow">컨테이너란 무엇일까</a><br><a data-href="젠킨스의 간단한 설명" href="https://lts.kr/짧은-키워드/젠킨스의-간단한-설명.html" class="internal-link" target="_self" rel="noopener nofollow">젠킨스의 간단한 설명</a><br><a data-href="Docker에 대한 간단한 설명" href="https://lts.kr/짧은-키워드/docker에-대한-간단한-설명.html" class="internal-link" target="_self" rel="noopener nofollow">Docker에 대한 간단한 설명</a><br><a data-href="k8s(쿠버네티스)에 대한 간단한 설명" href="https://lts.kr/짧은-키워드/k8s(쿠버네티스)에-대한-간단한-설명.html" class="internal-link" target="_self" rel="noopener nofollow">k8s(쿠버네티스)에 대한 간단한 설명</a><br><a data-href="GitOps란" href="https://lts.kr/짧은-키워드/gitops란.html" class="internal-link" target="_self" rel="noopener nofollow">GitOps란</a><br><a data-href="Argo CD란" href="https://lts.kr/짧은-키워드/argo-cd란.html" class="internal-link" target="_self" rel="noopener nofollow">Argo CD란</a><br><a data-href="쿠버네티스의 매니페스트 파일이란" href="https://lts.kr/짧은-키워드/쿠버네티스의-매니페스트-파일이란.html" class="internal-link" target="_self" rel="noopener nofollow">쿠버네티스의 매니페스트 파일이란</a><br><a data-href="현재 HF서비스의 CICD과정" href="https://lts.kr/짧은-키워드/현재-hf서비스의-cicd과정.html" class="internal-link" target="_self" rel="noopener nofollow">현재 HF서비스의 CICD과정</a><br><a data-href="Git Lab(깃랩) Git Hub(깃허브) 차이" href="https://lts.kr/짧은-키워드/git-lab(깃랩)-git-hub(깃허브)-차이.html" class="internal-link" target="_self" rel="noopener nofollow">Git Lab(깃랩) Git Hub(깃허브) 차이</a><br><a data-href="Grafana Loki 란" href="https://lts.kr/짧은-키워드/grafana-loki-란.html" class="internal-link" target="_self" rel="noopener nofollow">Grafana Loki 란</a>]]></description><link>https://lts.kr/study/cs/🎩-devops.html</link><guid isPermaLink="false">study/CS/🎩 DevOps.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 07:00:32 GMT</pubDate></item><item><title><![CDATA[Grafana Loki 란?]]></title><description><![CDATA[<br><br><br>
<br>ELK란 elastic / logstash / kibana 의 앞글자를 딴 시슷템으로
데이터를 수집, 처리, 조회 하는데 특화되어있는 시스템이다.
<br><br><br>
<br>인덱스란 ? - 단일 데이터 단위를 도큐먼트라고 하며, 이 도큐먼트를 모아놓은 집합을 인덱스라고 한다.
<br><br>
<br>인덱스 용량이 증가함에 따라 운영부담과 비용이 크게 증가한다.
<br>튜닝을 통한 안정화에 한계가 있다.
<br><br>
<br>
수평 확장이 가능하다 <br>
가용성 높은 다중 테넌트 로그 집계가 가능하다 <br>
로그에 대한 메타데이터만 인덱싱한다. 즉 레이블을 기반으로 구축되어있다. <br>
로그 내용을 색인화 하는것이 아닌, 레이블 세트를 색인화 하기 때문에 데이터 량을 감소시킬 수 있다. <br>
검색시 레이블 기반으로만 조회하고, 레이블과 매칭된 압축된 로그 데이터를 가져와 사용한다. <br><br>
<br>풀텍스트 검색시 기존 ELK대비 느리다.
<br>쿼리언어를 새로이 학습해야한다.
<br>레퍼런스가 부족하다.
<br><br>]]></description><link>https://lts.kr/짧은-키워드/grafana-loki-란.html</link><guid isPermaLink="false">짧은 키워드/Grafana Loki 란.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 07:00:30 GMT</pubDate></item><item><title><![CDATA[현재 HF서비스의 CI/CD과정]]></title><description><![CDATA[<br><br><br> local브랜치에서 작업 후 각(dev/stg/prod)프로젝트로 소스를 통합(merge)한다.
<br><br>jar, 메니페스트 file 등 소스,배포에 필요한 파일들 이미지 화
<br><br> Jenkin에서 이미지화된 배포에 필요한 파일,소스들을 ArgoCD로 Pull한다.
<br><br> Jenkins에서 받은 이미지파일과 매니패스트파일을 기반으로 실제 서버에 배포한다.
<br><br><br><br><img alt="Pasted image 20240531162124.png" src="https://lts.kr/사진-및-문서/pasted-image-20240531162124.png" target="_self"><br><br><br><br><br> local브랜치에서 작업 후 각(dev/stg/prod)프로젝트로 소스를 통합(merge)한다.
<br><br>jar, 메니페스트 file 등 소스,배포에 필요한 파일들 이미지 화
<br><br> Jenkin에서 이미지화된 배포에 필요한 파일,소스들을 ArgoCD로 Pull한다.
<br><br> Jenkins에서 받은 이미지파일과 매니패스트파일을 기반으로 실제 서버에 배포한다.
<br><br><br><br><img alt="Pasted image 20240531162124.png" src="https://lts.kr/사진-및-문서/pasted-image-20240531162124.png" target="_self"><br><br><br><br><img alt="Pasted image 20240722180706.png" src="https://lts.kr/사진-및-문서/pasted-image-20240722180706.png" target="_self"><br>]]></description><link>https://lts.kr/짧은-키워드/현재-hf서비스의-cicd과정.html</link><guid isPermaLink="false">짧은 키워드/현재 HF서비스의 CICD과정.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 07:00:25 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20240531162124.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20240531162124.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Git Lab(깃랩) / Git Hub(깃허브) 차이]]></title><description><![CDATA[<br><br>
<br>두가지 모두 소스코드 저장소 호스팅 플랫폼이며, 기술적 기반을 깃(Git)으로 삼는다는 점에서 비슷하다.
<br>기본 기능은 같지만, 서비스의 초점이 조금 다른곳에 맞추어져 있다.
<br><br>
<br>깃허브와 깃랩의 가장 큰 차이점은 데브옵스 요소에 있다.
<br><br><br>
<br>즉 깃랩은 젠킨스와 아르고와 같은 CI/CD 도구들을 사용하지 않아도 자체적으로 파이프라인을 구성하여 간단하고 빠른 배포가 가능하다. 하지만 우리는 깃랩은 사용하지만, 깃랩CI/CD는 사용하고 있지 않은 상태이다.
<br><br><br>
<br>그덕에 신속한 배포가 가능하고, 문제 발생시 이전 버전으로 신속하게 복원할 수 있다.
<br><br>
<br>프로덕션과 스테이징의 분기가 최소한으로 있으며, 이러한 여러 다중 분기 접근방식은 여러단계의 테스트로 안정적인 유지가 가능하게 한다. 한편 이러한 이유로 병합및 수정시 코드 검토가 까다로워진다.
<br>]]></description><link>https://lts.kr/짧은-키워드/git-lab(깃랩)-git-hub(깃허브)-차이.html</link><guid isPermaLink="false">짧은 키워드/Git Lab(깃랩) Git Hub(깃허브) 차이.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 07:00:08 GMT</pubDate></item><item><title><![CDATA[쿠버네티스의 매니페스트 파일이란?]]></title><description><![CDATA[<br><br>
<br>쿠버네티스는 클러스터 안에서 컨테이너 애플리케이션이나 네트워크 설정, 배치 실행을 하는 Job등
리소스를 작성한다. 이와 같은 구체적인 설정 정보를 파일로 관리하는데,
이것이 매니페스트파일(manifest file)이라고 한다.
<br>JSON이나 YALM 파일로 작성되며, 오브젝트를 생성하기 위해 필요한 파일이기도 하다.
<br>]]></description><link>https://lts.kr/짧은-키워드/쿠버네티스의-매니페스트-파일이란.html</link><guid isPermaLink="false">짧은 키워드/쿠버네티스의 매니페스트 파일이란.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:59:06 GMT</pubDate></item><item><title><![CDATA[Argo CD란?]]></title><description><![CDATA[<br><br>- GitOps를 구현하기 위한 도구 중 하나로, k8s애플리케이션의 자동배포(CD)를 위한 오픈소스 도구 이다.
k8s클러스터에 배포된 애플리케이션의 CD를 담당한다.
- Git저장소에서 변경사항을 감지하여 자동으로 k8s클러스터에 애플리케이션을 배포한다.
<br>]]></description><link>https://lts.kr/짧은-키워드/argo-cd란.html</link><guid isPermaLink="false">짧은 키워드/Argo CD란.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:59:00 GMT</pubDate></item><item><title><![CDATA[GitOps란?]]></title><description><![CDATA[<br><br>- DevOps(개발과 운영을 통합하여 효율성,협력,안정성을 개선하는 개발/운영 방법론)의 실천 방법중 하나로, 애플리케이션 배포와 운영에 관련된 모든요소를 Git에서 관리(Opertation)한다는 뜻이다.
- Git의 버전관리 시스템과 운영환경간의 일관성을 유지하여 소프트웨어간의 불일치 문제를
해결할 수 있다.
<br>]]></description><link>https://lts.kr/짧은-키워드/gitops란.html</link><guid isPermaLink="false">짧은 키워드/GitOps란.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:58:56 GMT</pubDate></item><item><title><![CDATA[k8s(쿠버네티스)에 대한 간단한 설명]]></title><description><![CDATA[<br><br>
<br>쿠버네티스는 "컨테이너화된 애플리케이션"을 배포, 관리, 확장 할때 수반되는 다수의 "수동 프로세스를 자동화"하는 오픈소스 "컨테이너 오케스트레이션 플랫폼"이다.
<br><br>1. 프로비저닝 및 배포
2. 구성 및 일정 조정
3. 리소스 할당
4. 컨테이너 가용성 체크
5. 로드밸런싱 기반 컨테이너 스케일링
6. 트래픽 라우팅
7. 컨테이너 상세 모니터링
8. 컨테이너 간 상호작용 및 보안
<br><br>
<br>클러스터 <br>컨트롤 플레인 및 하나 이상의 컴퓨팅 머신 또는 노드를 뜻한다. <br>컨트롤 플레인 <br>쿠버네티스 노드를 제어하는 프로세스의 컬렉션. 여기에 모든 태스크 할당이 시작된다. <br>kubelet <br>노드에서 실행되며, 컨테이너 매니패스트를 읽고, 정의된 컨테이너가 실행중인지 확인한다. <br>포드(Pod) <br>단일 노드에 배포된 하나 이상의 컨테이너 그룹. 포드에 있는 모든 컨테이너는 IP주소.호스트 이름, 기타 리소스 등을 공유한다. <br><br> 작동 중인 쿠버네티스 배포를 클러스터라고 한다. 클러스터는 컨테이너를 실행하는 호스트 그룹으로, 컨트롤 플레인과 컴퓨팅머신의 2개 부분으로 시각화 할 수 있다.
<br><br> Docker는 쿠버네티스가 오케스트레이션하는 컨테이너의 런타임으로 사용할 수 있다. 쿠버네티스가 노드에 대해 pod을 예약하면 해당 노드의 kubelet(각 컨테이너의 실행을 보장하는 서비스)가 지정된 컨테이너를 실행하도록 Docker에 명령한다. 이후, kubelet은 Docker로 부터, 지속적으로 상태를 수집하고 컨트롤 플레인에서 해당 정보를 집계한다.
<br>** 한줄 요약 : docker는 k8s가 시키는데로(이미짜여진대로, 자동으로) 컨테이너를 실행한다.<br>]]></description><link>https://lts.kr/짧은-키워드/k8s(쿠버네티스)에-대한-간단한-설명.html</link><guid isPermaLink="false">짧은 키워드/k8s(쿠버네티스)에 대한 간단한 설명.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:58:48 GMT</pubDate></item><item><title><![CDATA[Docker에 대한 간단한 설명]]></title><description><![CDATA[<br><br> Linux 컨테이너를 만들고 사용할 수 있도록 하는 컨테이너화 기술이다. 컨테이너를 매우 가벼운 모듈식 가상 머신처럼 다룰 수 있으며, 컨테이너를 구축, 배포, 복사, 이동 등 유연하게 사용할 수 있도록 도와준다. 애플리케이션을 클라우드에 최적화 하도록 지원한다.
<br><br>
<br>커널과 네임스페이스 등 Linux의 기능을 사용하여 프로세스를 분리함으로 써, 독립적으로 실행할 수 있도록 한다.
<br>개별적으로 실행하여 인프라를 더 효과적으로 활용하고 개별시스템을 사용할 때와 동일한 보안을 유지할 수 있도록 한다.
<br>이미지 기반 배포 모델을 제공하여, 여러 환경에서 종속 항목과 손쉽게 공유 할 수 있다.
<br><br>
<br>모듈성 <br>컨테이너화에 대한 docker의 접근방식은 전체 애플리케이션을 분해하지 않고도 업데이트 또는 복구를 가능하게 한다 <br>계층 및 이미지 버전제어 <br>docker의 이미지파일은 일련의 계층으로 구성되며 이러한 계층들은 단일 이미지로 결합된다.
이러한 이미지 계층을 재사용하여 구축 속도가 빠르며, 각 계층화에는 버전 제어가 가능하다. <br>롤백 <br>롤백 기능을 제공하여 이전 이미지 버전으로 롤백이 가능하다. <br>신속한 배포 <br>이전에는 하드웨어 확보, 실행, 프로비저닝, 테스트 하는데에 몇일이 걸렸으나, docker기반의 컨테이너는 배포 시간을 몇 초로 줄일 수 있다. <br><br>
<br>
도커는 애플리케이션 뿐만 아니라, 실행에 필요한 시스템 환경을 모아서 컨테이너로 관리한다. 이것을 Docker Image라고 한다. <br>
이 이미지로 만든 컨테이너는 도커가 설치된 곳이라면 어디든 똑같이 작동함을 보장한다. <br>
개발자가 커밋할때마다, Jenkins와 같은 CI( 지속적 통합 )툴이 해당 소스를 도커 이미지로 빌드하고, 이미지 레파지토리에서 이미지를 버전별로 관리한다. <br>
해당 이미지를 배포 하면, 독립적으로 동작하기 때문에 CD( 지속적인 배포 )또한 가능하게 된다. <br>
이러한 특징은 MSA와도 잘 맞는데, 각각의 서비스를 컨테이너로 배포하는 것이다. <br>]]></description><link>https://lts.kr/짧은-키워드/docker에-대한-간단한-설명.html</link><guid isPermaLink="false">짧은 키워드/Docker에 대한 간단한 설명.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:58:36 GMT</pubDate></item><item><title><![CDATA[젠킨스의 간단한 설명]]></title><description><![CDATA[<br><br><br>- 젠킨스는 지속적 통합(CI)및 지속적 배포(CD)도구로, 개발 프로세스의 빌드, 테스트, 배포 등을 자동화하고 관리해주는 도구이다.
<br><br>
<br>개발자들이 작성한 코드를 중앙 저장소에 자주 통합하고, 자동화된 빌드와
테스트를 통해 문제를 빠르게 발견하고 해결할 수 있게 해주는것.
<br><br>
<br>모든 변경사항을 자동화된 테스트와 빌드를 거친 후 실제 서버에 자동으로
배포하는 기술. ( 현제 HF서비스에서는 ArgoCD를 사용하여 진행한다. )
<br><br><br><br>
<br>이러한 구조를 통해 다양한 환경에서 동시에 빌드와 테스트를 수행할 수 있으며,
부하 분삭 및 확장성을 제공한다.
<br><br>
<br>젠킨스는 소스코드관리(SCM)시스템과 통합하여 변경사항이 발견될때
자동으로 빌드 및 테스트를 실행할 수 있다.
웹훅이나 폴링 방식을 사용하여 scm시스템에서 변경사항을 감지하고
해당작업을 트리거한다.
<br><br>
<br>젠킨스는 빌드 및 테스트작업이 완료되면 해당결과와 로그를 저장한다.
이를 통해 빌드 실패의 원인을 찾거나 테스트 결과를 검토할수 있다.
<br><br>
<br>젠킨스는 빌드, 테스트 및 배포 과정에서 발생하는 로그와 메트릭을 수집하고
분석하여 성능문제, 장애, 최적화 포인트 등을 식별할 수 있다.
<br><br><br>
<br>
개발자가 소스코드 변경사항을 SCM 시스템에 푸시한다. <br>
젠킨스는 웹훅이나 폴링 방식을 통해 변경사항을 감지하고 Jenkinsfile에 정의된 파이프라인을 실행한다. <br>
젠킨스는 마스터노드에서 슬레이브 노드로 작업을 할당하고 슬레이브 노드에서 빌드, 테스트 , 배포 작업을 수행한다. <br>
각 단계에서 필요의 경우, 플러그인을 사용하여 다양한 도구와 통합하여작업을 수행할 수 있다. <br>
작업이 완료되면 젠킨스는 결과와 로그를 저장하고 개발자에게 알림을 전송한다. <br>]]></description><link>https://lts.kr/짧은-키워드/젠킨스의-간단한-설명.html</link><guid isPermaLink="false">짧은 키워드/젠킨스의 간단한 설명.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:58:21 GMT</pubDate></item><item><title><![CDATA[컨테이너란 무엇일까?]]></title><description><![CDATA[<br><br>
<br>애플리케이션을 실행하는데 필요한 모든 구성 요소와 기능을 갖춘 소프트웨어이다.
<br>전체 실행(runtime)환경에서 애플리케이션을 패키징하고 격리할 수 있는 기술이다.
<br>
<br>
컨테이너화 된 애플리케이션은 환경(개발/테스트/프로덕션)에 쉽게 이동할 수 있다. <br>
컨테이너 파이프라인에 보안을 구축하고 인프라를 보호하여 컨테이너의 안정성, 확장성, 신뢰성을 보장할 수 있다. <br>
일관된 행동과 기능으로, 퍼블릭/프라이빗/클라우드 간에 쉽게 이동이 가능하다. <br><br>
<br>담당 영역을 분리하여 개발 팀과 운영 팀간의 충돌을 줄일 수 있다.
<br>오픈기술을 기반으로 하기 때문에, 최신 기술을 활용하여 다양하고 강력한 기술의 제품을 채택할 수 있다.
ex) docker / k8s 등등
<br>클라우드 네이티브 개발 방식에 필요한 기반 기술을 제공한다.
<br><br>
<br>전사적으로 배포를 관리할 수 있는 방법이다.
<br>k8s(쿠버네티스)는 컨테이너 작업을 자동화하는 오픈소스 플랫폼이다.
<br>컨테이너화 된 애플리케이션을 배포하고 확장하는데 수동 프로세스를 필요로 하지 않는다.
<br><br>docker는 전통적인 LXC와 다르다. docker도 처음에는 LXC기반으로 개발되었지만 이후, 이러한 종속관계에서 벗어났다.
LXC는 경량/가상화 기술은 뛰어났지만 사용자환경은 그에 미치지 못햇다.
하지만 docker는 컨테이너를 실행하는 것 이상의 다양한 생성/구축/이미지전송 등의 프로세스 관리를 용이하게 해준다.
<br>]]></description><link>https://lts.kr/짧은-키워드/컨테이너란-무엇일까.html</link><guid isPermaLink="false">짧은 키워드/컨테이너란 무엇일까.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:57:39 GMT</pubDate></item><item><title><![CDATA[🍃 Spring]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="https://lts.kr/?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <a class="tag" href="https://lts.kr/?query=tag:FRAMWORK" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#FRAMWORK</a> <br> <a href="https://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="https://lts.kr?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a> <a href="https://lts.kr?query=tag:FRAMWORK" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#FRAMWORK">#FRAMWORK</a><br><a data-href="Bean이란 무엇인가" href="https://lts.kr/짧은-키워드/bean이란-무엇인가.html" class="internal-link" target="_self" rel="noopener nofollow">Bean이란 무엇인가</a><br><a data-href="@ 어노테이션이란 무엇인인가" href="https://lts.kr/짧은-키워드/@-어노테이션이란-무엇인인가.html" class="internal-link" target="_self" rel="noopener nofollow">@ 어노테이션이란 무엇인인가</a><br><a data-href="@Component" href="https://lts.kr/짧은-키워드/@component.html" class="internal-link" target="_self" rel="noopener nofollow">@Component</a><br><a data-href="Spring 어노테이션@ 간단설명모음" href="https://lts.kr/짧은-키워드/spring-어노테이션@-간단설명모음.html" class="internal-link" target="_self" rel="noopener nofollow">Spring 어노테이션@ 간단설명모음</a><br><a data-href="빌더패턴을 왜쓰는가" href="https://lts.kr/짧은-키워드/빌더패턴을-왜쓰는가.html" class="internal-link" target="_self" rel="noopener nofollow">빌더패턴을 왜쓰는가</a><br><a data-href="Lombok 사용시 주의사항" href="https://lts.kr/짧은-키워드/lombok-사용시-주의사항.html" class="internal-link" target="_self" rel="noopener nofollow">Lombok 사용시 주의사항</a><br><a data-href="Spring에서의 의존성 주입 방법" href="https://lts.kr/짧은-키워드/spring에서의-의존성-주입-방법.html" class="internal-link" target="_self" rel="noopener nofollow">Spring에서의 의존성 주입 방법</a><br><a data-href="데이터 검증 (Validation)" href="https://lts.kr/짧은-키워드/데이터-검증-(validation).html" class="internal-link" target="_self" rel="noopener nofollow">데이터 검증 (Validation)</a><br><a data-href="Entity와 DTO를 분리해야하는 이유" href="https://lts.kr/짧은-키워드/entity와-dto를-분리해야하는-이유.html" class="internal-link" target="_self" rel="noopener nofollow">Entity와 DTO를 분리해야하는 이유</a><br><a data-href="Spring의 EntityManager는 무엇일까" href="https://lts.kr/짧은-키워드/spring의-entitymanager는-무엇일까.html" class="internal-link" target="_self" rel="noopener nofollow">Spring의 EntityManager는 무엇일까</a><br><a data-href="DB의 저장 프로시저 (SP - Stored Procedure)란" href="https://lts.kr/짧은-키워드/db의-저장-프로시저-(sp-stored-procedure)란.html" class="internal-link" target="_self" rel="noopener nofollow">DB의 저장 프로시저 (SP - Stored Procedure)란</a><br><a data-href="Spring AOP" href="https://lts.kr/짧은-키워드/spring-aop.html" class="internal-link" target="_self" rel="noopener nofollow">Spring AOP</a><br><a data-href="Spring Batch란" href="https://lts.kr/짧은-키워드/spring-batch란.html" class="internal-link" target="_self" rel="noopener nofollow">Spring Batch란</a><br><a data-href="Batch 용어 설명" href="https://lts.kr/짧은-키워드/batch-용어-설명.html" class="internal-link" target="_self" rel="noopener nofollow">Batch 용어 설명</a><br><a data-href="Spring Batch에서의 파티셔닝(Partitioning)" href="https://lts.kr/짧은-키워드/spring-batch에서의-파티셔닝(partitioning).html" class="internal-link" target="_self" rel="noopener nofollow">Spring Batch에서의 파티셔닝(Partitioning)</a><br><a data-href="APP - SERVICE - API 통신 플로우" href="https://lts.kr/짧은-키워드/app-service-api-통신-플로우.html" class="internal-link" target="_self" rel="noopener nofollow">APP - SERVICE - API 통신 플로우</a><br><a data-href="Spring WebFlux란" href="https://lts.kr/짧은-키워드/spring-webflux란.html" class="internal-link" target="_self" rel="noopener nofollow">Spring WebFlux란</a><br><a data-href="DispatcherServlet의 역할" href="https://lts.kr/짧은-키워드/dispatcherservlet의-역할.html" class="internal-link" target="_self" rel="noopener nofollow">DispatcherServlet의 역할</a><br><a data-href="HTTP Method - Mapping" href="https://lts.kr/짧은-키워드/http-method-mapping.html" class="internal-link" target="_self" rel="noopener nofollow">HTTP Method - Mapping</a><br><a data-href="Spring Integration이란" href="https://lts.kr/짧은-키워드/spring-integration이란.html" class="internal-link" target="_self" rel="noopener nofollow">Spring Integration이란</a><br><a data-href="Spring MVC의 Service와 ServiceImpl 구조" href="https://lts.kr/짧은-키워드/spring-mvc의-service와-serviceimpl-구조.html" class="internal-link" target="_self" rel="noopener nofollow">Spring MVC의 Service와 ServiceImpl 구조</a><br><a data-href="Netty란" href="https://lts.kr/짧은-키워드/netty란.html" class="internal-link" target="_self" rel="noopener nofollow">Netty란</a>]]></description><link>https://lts.kr/study/cs/🍃-spring.html</link><guid isPermaLink="false">study/CS/🍃 Spring.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:57:17 GMT</pubDate></item><item><title><![CDATA[Equals() 와 HashCode() 재정의]]></title><description><![CDATA[<br><br>@Test
@DisplayName("같은 객체를 equals 비교")
void equals() { //given Menu friedChicken = new Menu("후라이드치킨", 16_000); Menu friedChicken2 = new Menu("후라이드치킨", 16_000); //when &amp; then assertThat(friedChicken).isEqualTo(friedChicken2);
}
<br>헤당 코드와 같이 구현한다면, false를 출력한다.
이유는 객체의 equals메서드는 주소값이 서로 다른 객체는 다른객체로 판단하기 때문이다.<br><br><br>이때, 왜 HashCode도 재정의 해야하나?<br><br><br>해당 규약으로 인하여, 서로다른 객체의 해쉬값을 통일시켜주어야 한다.]]></description><link>https://lts.kr/짧은-키워드/equals()-와-hashcode()-재정의.html</link><guid isPermaLink="false">짧은 키워드/Equals() 와 HashCode() 재정의.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:54:39 GMT</pubDate></item><item><title><![CDATA[Netty란??]]></title><description><![CDATA[<br><br><br><br><br>
<br>비동기 적으로 입출력처리를 관리하기 때문에 전송 작업이 성공했는지 실패했는지 알수 있다.
<br>비동기식 작업에서 높은 성능을 유지할수 있다.
<br>]]></description><link>https://lts.kr/짧은-키워드/netty란.html</link><guid isPermaLink="false">짧은 키워드/Netty란.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:54:34 GMT</pubDate></item><item><title><![CDATA[Spring MVC의 Service와 ServiceImpl 구조]]></title><description><![CDATA[<br><br>
<br>
해당 구조가 갖는 장점이 무엇인가?
먼저 Serviced에 인터페이스를 구현하여 세부 구현체를 숨기고 인터페이스를 바라보게 함으로써 클래스간의 의존관계를 줄이는것 이다.
좀 더 쉽게 정리하면,
하나의 인터페이스를 구현하는 여러개의 구현체가 있고, 기능에 따라 적절한 구현체가 드어감으로써 다형성을 주기위함이다. <br>
하지만, 인터페이스 하나에 구현체 한개만 사용하는경우는 어떠한가?
이렇게 된다면, 의존관계를 줄여주는 효과도, 다형성을 주는 효과도 없게된다.
하지만 보통의 경우 한개의 기능을하는 인터페이스를 여러기능의 구현체로 나누는 일은 쉽게 일어나지 않는다. <br>public interface CardPaymentService { void pay();
} public class ShinhanCardPaymentService implements CardPaymentService{ private ShinhanCard shinhanCard; @Override public void pay() { shinhanCard.pay(); //신한 카드 결제 API 호출 // 결제를 위한 비즈니스 로직 실행.... }
}
<br><br>
<br>위와 같은 경우, 하나의 인터페이스에 하나의 구현체를 갖지만, 향후 추가적으로 구현체가 더 생길여지가 있으니, 인터페이스를 두는것이 바람직 하다고 할 수 있다.
<br>그렇다면 향후 구현체가 추가될 계획이 없는 기능들 까지 인터페이스를 만들어주어야 하는가?<br>
<br>그렇지 않다, 예를들어 간단하게 아이디를 기반으로한 조회기능 등은 인터페이스를 구현하지 않고 바로 서비스 객체를 생성하는것이 옳다.
<br>public interface ChangePasswordService { public void change(MemberId id, PasswordDto.ChangeRequest dto);
} public class ByAuthChangePasswordService implements ChangePasswordService { private MemberFindService memberFindService; @Override public void change(MemberId id, PasswordDto.ChangeRequest dto) { if (dto.getAuthCode().equals("인증 코드가 적합한지 로직 추가...")) { final Member member = memberFindService.findById(id); final String newPassword = dto.getNewPassword().getValue(); member.changePassword(newPassword); // 필요로직... } }
} public class ByPasswordChangePasswordService implements ChangePasswordService { private MemberFindService memberFindService; @Override public void change(MemberId id, PasswordDto.ChangeRequest dto) { if (dto.getPassword().equals("비밀번호가 일치하는지 판단 로직...")) { final Member member = memberFindService.findById(id); final String newPassword = dto.getNewPassword().getValue(); member.changePassword(newPassword); } }
}
<br>이렇게 비밀번호를 변경하는 기능같은 경우에는 2가지 이상의 경우가 있기때문에 인터페이스로 구현하는것이 옳아보인다.<br><br>]]></description><link>https://lts.kr/짧은-키워드/spring-mvc의-service와-serviceimpl-구조.html</link><guid isPermaLink="false">짧은 키워드/Spring MVC의 Service와 ServiceImpl 구조.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:53:48 GMT</pubDate></item><item><title><![CDATA[예외처리(Exception)]]></title><description><![CDATA[<br><br><br>1. e.getMessage() : 에러 메시지의 정보를 받음
2. e.getExceptionCode() : 에러 메시지 발생 코드를 받음
3. e.getStatus() : 에러 메시지의 발생 상태를 받음
4. HttpStatus(enum 클래스)를 받아 해당 value(Code) 와 getReasonPhrase(message)를 얻을 수 있음
<br><br>1. 체크 예외 발생한 예외를 잡아서(catch) 체크 후 예외를 복구 or 회피 하도록 만드는 구체적인 처리를 필요로 하는 예외이다. try catch가 강제된다. 컴파일 시점에서 에러의 확인이 가능하다. try catch를 할 수 없다면 예외를 밖으로 던지는 Throw 예외를 필수로 선언해 주어야 한다.
2. 언체크 예외 예외를 잡아서 해당 예외에 대한 처리가 필요 없는 예외. RuntimeException을 상속 받은 예외들이 이에 포함된다.
<br><br><br><br><br>UncheckedException으로 처리
<br><br>try { 예외가 생길 가능성이 있는 코드
} catch (예외종류){ 예외처리 코드
} finaly { 예외와 상관없이 항상 실행시킬 코드(선택사항)
}
<br>자바에서는 Exception클래스에서 상속받은 다양한 Exception클래스를 갖고 있기 때문에, 여러가지 에러 발생 가능성에 대해서 예외 구문을 처리해 줄 수 있다.<br><br>자신을 호출하는 메서드에 예외처리의 책임을 떠넘기는 것이다.
단, throws를 사용하려면 반드시 호출한 메서드에 try-catch 구문을 사용하여 예외를 처리해 주어야 한다.<br>public class ThrowTest { public static void main(String[] args) { int n1, n2; n1=12; n2=0; try { throwTest(n1, n2); } catch (ArithmeticException e) { // n1/n2 라면 발생했을 것 System.out.println("ArithmeticException: " + e.getMessage()); } } public static void throwTest(int a, int b) throws ArithmeticException{ System.out.println("throw a/b: "+ a/b); }
}
<br><br>throw와 throws는 큰 차이가 있다.
throw는 개발자가 직접 예외를 발생시키고싶을 떄 사용하는 것이다.
주로 RuntimeException처리를 위해 사용한다.<br>**checkedException에서도 사용이 가능하다.<br>throw new IOException("IO Exception occurred");
<br>사용예제<br>public class ThrowTest { public static void main(String[] args) { int n1, n2; n1=12; n2=0; try { throwTest(n1, n2); } catch (ArithmeticException e) { // n1/n2 라면 발생했을 것 System.out.println("ArithmeticException: " + e.getMessage()); } } public static void throwTest(int a, int b) throws ArithmeticException{ throw new ArithmeticException(); }
}
<br>해당 코드의 익셉션 메세지는 null 로 뜨게 된다.
throw는 Exception을 던질 때, 예외 내용을 함께 던져 주지 않기 때문이다.
그래서 개발자가 Exception을 따로 커스터마이징해서 만들고, 그 안에 메세지를 넣어서 던져주는 방식이다.<br><br>
<br>
CheckedException =&gt; try ~ catch 문, throws(의존관계) 로 처리! <br>
UnCheckedException(RuntimeException) =&gt; 기본적으로 복구 불가능한 예외(발생시 런타임 중지)로, CheckedExceptoin이어도 더 구체적인 UnCheckedException으로 발생시켜! throw로 exception을 던지고, ExceptionHandler로 처리! <br>
언체크드익셉션(런타입익셉션) -&gt; 기본적으로 복구 불가능한 예외(발생시 런타임 중지)로, 체크드익셉션이어도 더 구체적인 언체크드익셉션으로 발생시켜 쓰로우로 익셉션을 던지고, 익셉션핸들러로 처리 <br>]]></description><link>https://lts.kr/짧은-키워드/예외처리(exception).html</link><guid isPermaLink="false">짧은 키워드/예외처리(Exception).md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:53:36 GMT</pubDate></item><item><title><![CDATA[Spring Integration이란?]]></title><description><![CDATA[<br><br>
<br>
애플리케이션 내부-외부 사이의 메시징을 가능하게 하는 프레임워크이다. <br>
Spring Framwork에서 매세징이란 메타데이터와 함께 결합되어있는 이련의 자바 오브젝트를 위한 포괄적인 Wrapper를 말한다. 메시지는 여러개의 헤더로 구성된다. <br>
Enterprise Integration Patterns은 엔터프라이즈 환경에서 사용하고 있는 다양한 분야(ex. 결제,메일, 각 부서별 서비스) 의 애플리케이션을 통합, 즉 유기적으로 연결해서 효율적으로 적절하게 통합하는 방법을 여러 패턴을 통해 제시했다. <br>
하나의 동작을 하는 서비스의 각각의 기능들(프로젝트)이 내/외부 모듈과 접촉하는 부분을 쉽게 구성할 수 있도록 하는 기능들을 제공한다. <br><br>
<br>채널: 한 요소로부터 다른 요소로 메시지를 전달
<br>필터: 조건에 맞는 메시지가 플로우를 통과하게 해줌
<br>변환기: 메시지 값을 변경하거나 메시지 페이로드의 타입을 다른 타입으로 변환
<br>라우터: 여러 채널 중 하나로 메시지를 전달하며 대개 메시지 헤더를 기반으로 함
<br>분배기: 들어오는 메시지를 두 개 이상의 메시지로 분할하며, 분할된 각 메시지는 다른 채널로 전송
<br>집적기: 분배기와 상반된 것으로 별개의 채널로부터 전달되는 다수의 메시지를 하나의메시지로 결합함
<br>서비스 액티베이터: 메시지를 처리하도록 자바 메서드에 메시지를 넘겨준 후 메서드의 반환값을 출력 채널로 전송
<br>채널 어댑터: 외부 시스템에 채널을 연결함. 외부 시스템으로부터 입력을 받거나 쓸 수 있음
<br>게이트웨이: 인터페이스를 통해 통합플로우로 데이터를 전달
<br><br>
<br>Spring Integration은 'pipe and filters' 모델을 구현하기 위해 3가지 핵심 개념으로 구성되어 있다.
<br><br>header, payload로 구성되어 있는 내용을 포함하고 있는 generic wrapper. 컴포넌트 간에 이동되는 실제 데이터이다.
<br><img alt="Pasted image 20240605160336.png" src="https://lts.kr/사진-및-문서/pasted-image-20240605160336.png" target="_self"><br><br>pipes-and-filters 모델의 pipe에 해당.
컴포넌트간의 메세지 중간 통로 역할을 함으로써 컴포넌트간 디컬플링을 유지 할 수 있도록 하며 interception, monitering 포인트가 될 수 있다. 다른 주요 기능 중 하나는, 메세지 버퍼 역할을 할 수 있는 Queue로써 동작할 수 있다.
FIFO방식으로 컨슈머가 가져갈 때 까지 큐에 저장된다.
<br>ex)
@Bean
public MessageChannel sampleChannel() {
return new DirectChannel();
}
-&gt; DirectChannel은 Point to Point로, 하나의 MessageHeader에게 Message를 전달한다.
이외에도 다양한 체널종류가 있다.<br><br>pipes-and-filters 모델의 filters에 해당.
Spring integration상에서 채널을 통해서 메세지를 받고, 소비하는 주체이며 하나의 클래스이다.
여기서 말하는 EndPoint란 Spring integration이 구성할 파이프라인의 끝단이 아닌, 파이프라인 중간에서 메세지를 변경하거나 필터링 하거나, 다른 채널로 라우팅하는 요소이다.
<br>ex)
@MessageEndpoint
public class serverEndpoint { ...
}
<br>
<br>
Spring integration에서 일련의 작업들을 정의한 플로우를 integration flow 라고 하는데, 이 플로우가 Message Endpoint로 구성되어있다. <br>
엔드포인트는 작업 타입에 따라 크게 그 종류를 나눌 수 있는데 Transformer(변형), Filter(필터링), Router(메세지를 특정 채널로 전송), Splitter(메세지를 분리하여 여러 채널로 전송), Aggregator(splitter의 반대), Service Activator(메세지로 특정 작업을 수행할 수 있는 핸들러를 붙일 수 있는 엔드포인트), Channel Adapter(외부 시스템과 입출력이 가능)가 있다. <br><br>
<br>통합 파이프라인 중간에 위치하며, 조건을 기반으로 플로우의 전 단계로부터 다음단계로의 메세지 전달에 조건을 달 수 있다.
ex)
<br>@Filter( inputChannel="numberChannel", outputchannel="evenNumberChannel" )
public boolean evenNumberFilter( Integer number ) { return number % 2 == 0; //숫자를 받아 짝수만 전달
}
<br><br>
<br>입력체널로 부터 메세지를 수신하고, 이 메세지를 MessageHandler 인터페이스를 통해 구현한 클래스에 전달(서비스호출)한다.
<br>서비스를 메시징 시스템에 연결하기 위한 앤드포인트이다.
<br>입력 채널이 설정되어 있어야 하고, 서비스가 값을 리턴하도록 구현했다면 출력 채널도 설정해야한다.
<br>**만약 출력체널을 설정하지 않았을 때 메세지에 "return address"가 있다면 이 헤더에 지정한 체널로 응답을 전송한다.
<br>MessageChennel메서드를 입력해서 파이프라인을 구축한다,
<br>ex)
@ServiceActivator(inputChannel = "sampleChannel") { }
<br>]]></description><link>https://lts.kr/짧은-키워드/spring-integration이란.html</link><guid isPermaLink="false">짧은 키워드/Spring Integration이란.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:53:15 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20240605160336.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20240605160336.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[HTTP Method - Mapping]]></title><description><![CDATA[<br><br><br>#### PathVariable 방법 @RestController public class SecondController { @GetMapping("/second/{id}") //PK(id)가 (변수)인 페이지를 찾고 싶다 public String getData(@PathVariable Integer id) { return "id : "+id; }
#### QueryString 방법 @GetMapping("/second") public String getData2(String title, String content) { return "title:"+title+", content :"+content; }
<br><br>@PostMapping("/second") public String postData(String title, String content) { return "title:"+title+", content :"+content; }
<br><br><br><br>	@PutMapping("/second") public String putData(String title, String content) { return "title:"+title+", content :"+content; }
<br>
<br>PostMapping과 같은원리로 작동한다
<br><br>	@DeleteMapping("/second/{id}") //쿼리스트링 해도 됨 public String deleteData(@PathVariable Integer id) { return id+"delete ok"; }
<br><br><br>
<br>데이터 전달이 필요한 경우 @RequestParam을 사용하거나
@DeleteMapping 대신에 @PutMapping을 사용하도록 하자
<br><br> 내생각에는 메서드를 명시적으로 작성 할 수 있기 때문에 더욱 가독성이 높아지는 장점이 있지 않을까 싶다.
<br>]]></description><link>https://lts.kr/짧은-키워드/http-method-mapping.html</link><guid isPermaLink="false">짧은 키워드/HTTP Method - Mapping.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:53:07 GMT</pubDate></item><item><title><![CDATA[DispatcherServlet의 역할]]></title><description><![CDATA[<br><br>- 웹 애플리케이션 최전방에서 사용자의 요청을 접수하여 URL기주능로 요청을 처리할 controller를 찾고, 그 controller에 처리를 위임한 후, 결과를 받아서 사용자에게 처리 결과가 담긴 화면을 제공해준다.
<br>
<br>설정은 web.xml의 정보를 활용한다. 사용자 요청을 처리할 Controller목록과 사용자 에게 보여줄 화면을 찾는 ViewResolver가 있다.
<br>]]></description><link>https://lts.kr/짧은-키워드/dispatcherservlet의-역할.html</link><guid isPermaLink="false">짧은 키워드/DispatcherServlet의 역할.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:53:04 GMT</pubDate></item><item><title><![CDATA[Spring WebFlux란?]]></title><description><![CDATA[<br><br>
<br>스프링5에서 소개된 리엑티브 프로그래밍, 반응형 및 비동기적인 웹 어플리케이션 개발을 지원하는 모듈이다.
<img alt="Pasted image 20240611144129.png" src="https://lts.kr/사진-및-문서/pasted-image-20240611144129.png" target="_self">
<br>*리엑티브 프로그래밍이란 ?
- 비동기 및 이벤트 기반 애플리케이션을 개발하기 위한 패러다임으로, 주로 높은 확장성과 성능을 제공하는것<br>내부통신을 이용하여 API프로젝트와 통신할때 주소 맵핑이 어떻게 이루어지는지??
- Spring WebClient를 이용하여 내부 통신을 한다.<br><br>
<br>
SpringWebFlux의 일부로써, 비동기적인 방식으로 HTTP 요청을 보내고 응답을 받을 수 있는 라이브러리이다. <br>
웹으로 API를 호출하기 위해 사용되는 HTTP Client모듈 중 하나이다. <br>
RestTemplate과 같은 기능을 하지만, RestTemplate는 Blocking 방식이고, WebClient는 Non-Blocking방식이다.
Blocking 동기 - Non-Blocking 비동기 ( 정확히 같은것은 아니지만 비슷하다 ? ) <br>
요청자(APP)에서 WebClient라이브러리를 사용한 senderUtils를 사용하여
프로퍼티 소스와, 송신방식(GET/POST), 넘길 값(DTO), request를 수신할 값(ApiResponseModel)을 설정한다. <br><br>-SpringMVC에서는 WebFlux와 달리, 블로킹I/O를 사용하기 때문에, 동기적인 작업을 수행할 떄에는 WebClient보다 RestTemplat이 효과적이지만, 비동기 작업을 할 때에는 WebClient를 사용하는것이 효과적이다.<br><br><br><br>
<br>Thread Pool을 애플리케이션 구동시 미리 만들어 두고,
요청시 가용한 Thread가 있다면 1요청당 1Thread가 할당된다.
<br>만약 가용한 스레드가 부족하다면 Queue는 대기하게 되며,
전체 서비스의 속도가 현저히 느려지게 된다.
<br><br>
<br>Core당 1개의 Thread를 사용한다.
<br>요청은 Event Loop내의 job으로 등록되고, 각 job을 제공자에게 요청한 후,
기다리지 않고 다른 job을 처리한다.
<br>Event Loop는 제공자로부터 callback으로 응답이 오면, 그 결과를 요청자에게 제공하낟.
<br>따라서 반응성/탄력성/가용성/비동기성 을 보장하기 때문에 동시사용자가 크게 몰렸을때
RestTemplate에 비해 성능이 저하되지 않는다.
<br>]]></description><link>https://lts.kr/짧은-키워드/spring-webflux란.html</link><guid isPermaLink="false">짧은 키워드/Spring WebFlux란.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:52:55 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20240611144129.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20240611144129.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[APP - SERVICE - API 통신 플로우]]></title><description><![CDATA[<br><br>투자신청기록쪽 api -&gt; API레스폰스모델
웹플럭스(비동기 기반)을 사용해서 service프로젝트와 (내부)통신한다.<br>내부통신을 위해 필요한 헤더, url등을 생성해야하기 때문에 senderutils 클래스를 공통(빈)을 정의해서 만들어 통신.<br>retrieve ** 중요
웹클라이언트 클래스 객체를 사용해서 uri 콘텐츠 등등 헤더와 바디(데이타)를 정의한다<br>]]></description><link>https://lts.kr/짧은-키워드/app-service-api-통신-플로우.html</link><guid isPermaLink="false">짧은 키워드/APP - SERVICE - API 통신 플로우.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:52:15 GMT</pubDate></item><item><title><![CDATA[Spring Batch에서의 파티셔닝(Partitioning)]]></title><description><![CDATA[<br><br>
<br>Tasklet 방식과 Chunk 방식 모두 사용 가능하지만, 보통 Chunk방식에서 사용한다.
<br><br>
<br>대량 데이터를 효율적으로 처리하기 위해 데이터를 여러 개의 작은 조각(Partition)으로 나눠 병렬적으로 처리하는 기술입니다. Spring Batch에서 파티셔닝은 마스터-슬레이브 패턴을 사용하며, 마스터는 작업을 분할하고 슬레이브는 각각의 분할된 작업을 수행합니다.
<br><br>import org.springframework.batch.core.partition.support.Partitioner;
import org.springframework.batch.item.ExecutionContext;
import java.util.HashMap;
import java.util.Map; public class RangePartitioner implements Partitioner { @Override public Map&lt;String, ExecutionContext&gt; partition(int gridSize) { Map&lt;String, ExecutionContext&gt; partitions = new HashMap&lt;&gt;(); int min = 1; // 데이터베이스 ID의 최소값 int max = 5; // 데이터베이스 ID의 최대값 int targetSize = (max - min) / gridSize + 1; // 각 Partition의 범위 크기 int start = min; int end = start + targetSize - 1; for (int i = 0; i &lt; gridSize; i++) { ExecutionContext context = new ExecutionContext(); context.putInt("minId", start); // 시작 ID context.putInt("maxId", end); // 종료 ID partitions.put("partition" + i, context); start += targetSize; end += targetSize; } return partitions; }
}
<br><br><br>
<br>데이터베이스에 100개의 레코드가 있음.
<br>gridSize = 4: 데이터를 4개의 Partition으로 나눔.
<br>chunkSize = 10: 각 Partition에서 데이터를 10개씩 읽어 처리.
<br>스레드 풀 크기 = 4: 4개의 Partition이 동시에 실행 가능.
<br><br>코드가 여러줄 나올거같진 않아서 방식은
페어 프로그래밍 방식으로 진행하도록 하죠<br>개발 절차는 이렇게 갈 예정이에요<br>
<br>Chunk, Partioning방식을 Job을 추가 개발 (기존 balanceJob 유지)
<br>당분간 두 Job을 병행하면서 비교
<br>추가한 Job 기능에 문제없다면 기존 balanceJob 삭제
<br><br>
<br>
Partition 생성: <br>Partition 1: ID 1 ~ 25
<br>Partition 2: ID 26 ~ 50
<br>Partition 3: ID 51 ~ 75
<br>Partition 4: ID 76 ~ 100 <br>
각 Partition에서 Chunk 처리: <br>Partition 1: <br>Chunk 1: ID 1 ~ 10 → 커밋
<br>Chunk 2: ID 11 ~ 20 → 커밋
<br>Chunk 3: ID 21 ~ 25 → 커밋 <br>Partition 2: <br>Chunk 1: ID 26 ~ 35 → 커밋
<br>Chunk 2: ID 36 ~ 45 → 커밋
<br>Chunk 3: ID 46 ~ 50 → 커밋 <br>나머지 Partition도 동일 방식으로 처리. <br>
병렬 실행: <br>스레드 풀 크기 = 4이므로 4개의 Partition이 동시에 실행됩니다.
<br>Partition 처리 순서는 스레드 풀에서 처리되는 순서에 따라 다를 수 있음. <br>
트랜잭션 관리: <br>각 Partition은 독립적인 트랜잭션을 가짐.
<br>각 Chunk가 커밋될 때마다 트랜잭션이 종료됨. <br><br><br><br>]]></description><link>https://lts.kr/짧은-키워드/spring-batch에서의-파티셔닝(partitioning).html</link><guid isPermaLink="false">짧은 키워드/Spring Batch에서의 파티셔닝(Partitioning).md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:52:07 GMT</pubDate></item><item><title><![CDATA[Batch 용어 설명]]></title><description><![CDATA[<br><br><br>
<br>독립적으로 실행할 수 있는 고유하며 순서가 지정된 스텝의 목록
<br>애플리케이션 실행시 Job으로 인식되는 bean들이 자동으로 실행된다.
<br>1개 이상의 Step을 포함하여 원하는 동작을 실행시킬 수 있다
<br>배치 처리 과정 중 전체 계층의 최상단에 위치도
<br><br>
<br>job의 구성요소로 자체적인 입력/출력/처리를 가질 수 있다.
<br>tasklet 또는 Chunk기반 처리를 포함하여 step안에서 수행될 기능들을 명시할 수 있다.
<br>트렌젝션은 step내에서 이루어진다. 때문에, 독립되도록 의도적으로 설계된 것이다.
<br><br>
<br>Step의 작업 단위를 Tasklet으로 정의
<br>주로 간단한 작업(단일 데이터 처리, 파일 삭제 등)에 적합하다.
<br>@Component
public class SimpleTasklet implements Tasklet { @Override public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception { System.out.println("Tasklet 방식으로 작업 수행"); return RepeatStatus.FINISHED; }
} @Bean
public Step step1(StepBuilderFactory stepBuilderFactory) { return stepBuilderFactory.get("step1") .tasklet(new SimpleTasklet()) .build();
} @Bean
public Job job(JobBuilderFactory jobBuilderFactory, Step step1) { return jobBuilderFactory.get("job") .start(step1) .build();
} <br><br>
<br>대량 데이터를 일정 크기(chunk)로 나누어 처리한다.
<br>Reader / Processor / Writer로 구성된다.
<br>@Bean
public FlatFileItemReader&lt;String&gt; reader() { return new FlatFileItemReaderBuilder&lt;String&gt;() .name("fileReader") .resource(new ClassPathResource("input.txt")) .lineMapper(new DefaultLineMapper&lt;String&gt;() { { setLineTokenizer(new DelimitedLineTokenizer()); setFieldSetMapper(new PassThroughFieldSetMapper()); } }) .build();
} @Bean
public ItemProcessor&lt;String, String&gt; processor() { return item -&gt; "Processed " + item;
} @Bean
public FlatFileItemWriter&lt;String&gt; writer() { return new FlatFileItemWriterBuilder&lt;String&gt;() .name("fileWriter") .resource(new FileSystemResource("output.txt")) .lineAggregator(new PassThroughLineAggregator&lt;&gt;()) .build();
} @Bean
public Step step(StepBuilderFactory stepBuilderFactory) { return stepBuilderFactory.get("step") .&lt;String, String&gt;chunk(10) .reader(reader()) .processor(processor()) .writer(writer()) .build();
} @Bean
public Job job(JobBuilderFactory jobBuilderFactory, Step step) { return jobBuilderFactory.get("job") .start(step) .build();
} <br><br>
<br>잡 리스너를 이용해서 스프링batch 생명주기의 여러로직을 추가할 수 있다.
ex) beforeJob , afterJob 등등
<br><br>=&gt; 스케줄러는 Jenkins에서 SSH스크립트를 통해 주기적으로 실행한다. Controller에 POST주소가 맵핑되어있는 이유는 테스트로 직접 실행하기 위함이다.<br>]]></description><link>https://lts.kr/짧은-키워드/batch-용어-설명.html</link><guid isPermaLink="false">짧은 키워드/Batch 용어 설명.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:52:00 GMT</pubDate></item><item><title><![CDATA[Spring Batch란?]]></title><description><![CDATA[<br><br>- 스프링배치는 엔터프라이즈 시스템의 강력한 배치 어플리케이션을 개발할 수 있도록 설계된 배치프레임워크이다.
- 일괄처리(Batch Processing), 분산처리 작업을 효율적으로 처리할 수있는 기능 제공.
- 로깅/추적, 트렌잭션관리, 작업 처리통계, 작업재시작, 리소스관리 등 대용량 레코드 처리에 필수적인 기능을 제공
- SpringBatch는 JobRepository로 동작하는데, 여기에 Job / JobLauncher / Step이 포함되어있다.
<br>
<br>SpringBatch는 대량의 데이터를 일괄적으로 처리할 뿐
특정 주기마다 자동으로 돌아가는 스케줄링 기능은 없다.
단지, 스케줄러와 함계 사용할 수 있도록 설계되어있을 뿐이다.
<br>그렇기 때문에 스케줄링 라이브러리인 Quartz라이브러리를 추가하여 같이 사용한다.<br>]]></description><link>https://lts.kr/짧은-키워드/spring-batch란.html</link><guid isPermaLink="false">짧은 키워드/Spring Batch란.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:51:30 GMT</pubDate></item><item><title><![CDATA[JPAQueryFactory란?]]></title><description><![CDATA[<br><br>- SQL문법과 유사하게 복잡한 쿼리를 제작할 수 있게 도와주는 SPRING의 JPA지원 클래스이다.
<br>ex)<br> private RemainDto firstList(DashBoardModel model) { return factory .select( Projections.fields( RemainDto.class, cfProductInvest.amount.sum().coalesce(0L).as("total"), new CaseBuilder() .when(cfProduct.category.eq("2")) .then(cfProductInvest.amount) .otherwise(0L).sum().coalesce(0L).as("estate"), new CaseBuilder() .when(cfProduct.category.ne("2")) .then(cfProductInvest.amount) .otherwise(0L).sum().coalesce(0L).as("noneEstate") ) ) .from(cfProductInvest) .leftJoin(cfProduct) .on(cfProductInvest.productIdx.eq(cfProduct.idx)) .leftJoin(g5Member) .on(cfProductInvest.memberIdx.eq(g5Member.mbNo)) .where( g5Member.mbId.eq(model.getMbId()), cfProductInvest.investState.eq("Y") ) .fetchOne(); }
<br>]]></description><link>https://lts.kr/짧은-키워드/jpaqueryfactory란.html</link><guid isPermaLink="false">짧은 키워드/JPAQueryFactory란.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:51:26 GMT</pubDate></item><item><title><![CDATA[JPA에서 BooleanBuilder 와 BooleanExpression 이란?]]></title><description><![CDATA[<br><br>- 두 클래스 모두 JPA에서 동적쿼리를 제작할 때 사용한다.
BooleanBuilder는 if문을 각 데이터 조건에 맞게 코드로 작성할 수 있도록 도와주는 역할을 한다.
<br>BooleanExpression 는 메서드를 생성하여 where절 안에서 호출하여 구현할 수 있다.
메서드 안에서 where절로 null이 반환되면 해당 조건이 무시되기 때문에 동적쿼리가 가능하다.
(모든 조건이 NULL을 반환하면 전체 엔티티를 불러오는 점을 주의하자)
메서드는 재사용이 가능하고, 메서드들 끼리 재조합도 가능하기 때문에 유지보수나, 재활용에 유리하다.<br>*동적쿼리 - 실행시점에서, 사용자나 프로그램의 사정에따라 쿼리의 조건이나 구조를 동적으로 결정할때 사용.<br>]]></description><link>https://lts.kr/짧은-키워드/jpa에서-booleanbuilder-와-booleanexpression-이란.html</link><guid isPermaLink="false">짧은 키워드/JPA에서 BooleanBuilder 와 BooleanExpression 이란.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:50:17 GMT</pubDate></item><item><title><![CDATA[JPQL과 QueryDSL 비교]]></title><description><![CDATA[<br><br><br>	String username = "java"; String jpql = "select m from Member m where m.username = :username"; List&lt;Member&gt; result = em.createQuery(query, Member.class).getResultList()
<br>jpql이란 JPA의 일부로, 쿼리를 Table이 아닌 객체 기준으로 작성하는 객체지향 쿼리 언어 이다.<br>문제점 : String형태 이기 때문에 개발자 의존적인 형태를 띈다.
컴파일 단계에서 Type-Check가 불가능하다.
런타임 단계에서 오류가 발생한다.(장애 리스크가 증가한다)<br><br><br>	String username = "java"; List&lt;Member&gt; result = queryFactory .select(member) .from(member) .where(usernameEq(username)) .fetch();
<br>QueryDSL은 해당 문제를 해결하기 위해서 나온 기능이다.<br>장점 : 문자가 아닌 코드로 쿼리를 작성할 수 있어 컴파일 시점에 문법오류 확인 가능.
IDE의 자동완성 기능의 도움을 받을 수 있다.
복잡한 쿼리나 동적 쿼리 작성이 편하다.
쿼리 작성시 제약조건 등 메서드를 추출해서 재사용할 수 있다.<br>]]></description><link>https://lts.kr/짧은-키워드/jpql과-querydsl-비교.html</link><guid isPermaLink="false">짧은 키워드/JPQL과 QueryDSL 비교.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:50:10 GMT</pubDate></item><item><title><![CDATA[Spring의 EntityManager는 무엇일까?]]></title><description><![CDATA[<br><br>- 엔티티 매니저는 DB커넥션처럼 사용된다. 즉, 엔티티매니저를 절대 공유해서는 안된다.
하나의 스레드에서만 사용해야하며, 사용이 끝나면 반납해야한다.
그 이유는 트렌젝션 단위로 엔티티매니저를 사용하기 때문이다.
여러 쓰레드가 동시에 사용하게 된다면 영속성 과 DB간의 데이터동기화가 깨지게 되기 때문이다.
<br>]]></description><link>https://lts.kr/짧은-키워드/spring의-entitymanager는-무엇일까.html</link><guid isPermaLink="false">짧은 키워드/Spring의 EntityManager는 무엇일까.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:49:08 GMT</pubDate></item><item><title><![CDATA[Entity와 DTO를 분리해야하는 이유]]></title><description><![CDATA[<br><br>- Entity와 관련된 코드들은 많은데 비해 Dto의 경우는 상대적으로 적다.
그런 상황에서 Entity의 변경가능성은 Dto의 비해서 또 적다.
만약 Entity를 Request나 Respons에 사용하게 된다면 변경 가능성이 높아지고,
동시에 같이 변경되는 코드들이 늘어나기 때문에 코드 유지보수를 생각했을때 분리하는것이 옳다.
<br>]]></description><link>https://lts.kr/짧은-키워드/entity와-dto를-분리해야하는-이유.html</link><guid isPermaLink="false">짧은 키워드/Entity와 DTO를 분리해야하는 이유.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:48:59 GMT</pubDate></item><item><title><![CDATA[Spring에서의 의존성 주입 방법]]></title><description><![CDATA[<br><br><br>	@Component public class Controller{ @Autowired private Service servic ... }
<br><br>- 단일책임의 원칙 위반
- 의존성을 주입하기 쉽기 때문에, @Autoqwired아래에 개수 제한없이 추가할 수 있다.
- 이때, 하나의 class가 많은 책임을 갖고, 순환참조가 이뤄질 수도 있기 때문에
의존성이 높아져, 사용을 피하는것이 좋다.
<br><br><br>	@Component public class Controller{ private Service servic @Autowired private void setService(Service servic){ this.service = service; } }
<br>선택적인 의존성을 사용할때 유용하다.
스프링 3.x 에서는 수정자 주입을 권장하고있다.<br><br>- 수정자 주입을 사용하게 되면, service구현제를 주입하지 않아도 controller객체는 생서이 가능하기때문에 널포인터익셉션이 발생할 가능성이 있다.
주입이 필요한 객체가 주입되지 않아도 얼마든지 객체를 생성할 수 있다는것이 문제다.
<br><br><br>	@Component public class Service{ private DAO dao; //생성자 @Autowired private Service(DAO dao){ this.dao = dao; } } @Component public class Controller{ private final Service servic = new Service( new DAO( ) ); }
<br><br>- Spring Framework 에서 권장하는 방법으로, 필수적으로 사용해야하는 의존성 없이는 객체를 만들지 못하도록 강제할 수 있기
때문에 사용을 권장하고 있다.
- Spring 4.3 버전 이후부터는 Class를 완벽하게 DI Framework로 부터
분리할 수 있다.
- 단일 생성자에 한해서 @Autowired를 붙이지 않아도 된다.
- 필드 주입과 수정자 주입은 final로 선언할 수 없지만, 생성자 주입은 final로 필드 객체를 선언하여 런타임에 불변성을 보장한다.
- 앞서 설명한 필드 주입의 모든 단점을 보완할 수 있다.
<br><br>하지만 실무에서는 필드 주입을 주로 사용한다.
이유 : 가장 구현하기 쉽고, 읽기 편하기 때문이다.<br>]]></description><link>https://lts.kr/짧은-키워드/spring에서의-의존성-주입-방법.html</link><guid isPermaLink="false">짧은 키워드/Spring에서의 의존성 주입 방법.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:48:19 GMT</pubDate></item><item><title><![CDATA[데이터 검증 (Validation)]]></title><description><![CDATA[<br><br>Spring에서의 데이터 검증(Validation)은 여러 계층에 거쳐서 발생한다.
여기서, 가장 기본적인 검증 방법은 Bean Validation이다.<br>
<br>'필드'에 특정 어노테이션을 적용하여 필드가 갖는 제약 조건을 정의하는 구조로 이루어진 검사다.
validator가 그 클래스로 생성된 객체의 유효성 여부를 확인한다.
이때, 어떠한 비즈니스로직에 대한 검증이 아닌, 객체 자체 필드에 대한 검증을 한다.
<br>	@RestController @AllArgsConstructor public class BookController { private BookService bookService; @PostMapping("/books") public void save(@RequestBody @Valid AddBookRequestDto addBookRequestDto, BindingResult bindingResult) { if(bindingResult.hasErrors()) { bindingResult.getAllErrors() .forEach(objectError-&gt;{ System.err.println("code : " + objectError.getCode()); System.err.println("defaultMessage : " + objectError.getDefaultMessage()); System.err.println("objectName : " + objectError.getObjectName()); }); return; } bookService.save(addBookRequestDto.toEntity()); }
<br>-&gt; 여기서@Valid 어노테이션이 Request에 있는 방인된 객체(dto)의 유효성을 확인하고
유효하지 않은객체라면 BindingResult 파라미터에 들어가게 된다.<br>그렇다면, @PathVariable과 @RequestParam은 어떻게 유효성 검사를 진행할까?<br>
<br>
클래스에 @Validated 어노테이션을 등록해 주면 된다.
@RestController
@Validated
public class UserController {
} <br>]]></description><link>https://lts.kr/짧은-키워드/데이터-검증-(validation).html</link><guid isPermaLink="false">짧은 키워드/데이터 검증 (Validation).md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:47:24 GMT</pubDate></item><item><title><![CDATA[Lombok 사용시 주의사항]]></title><description><![CDATA[<br><br><br>- 위 두개의 어노테이션을 편리하게 생성자를 자동으로 생성해 주지만, 주의를 요할 필요가 있다.
<br>
<br>어떠한 클래스에서 순서대로 인자를 받는 생성자가 있다고 했을 때, 개발자가 임의로 순서를 변경할 경우, 리펙토링은 전혀 작동하지 않고, lombok이 개발자가 인지하지 못하는 사이에 순서에 맞춰 두 필드를 변경해 버린다.
<br>그렇기 때문에 순서의 구애받지 않는 @Builder 어노테이션을 사용한는 것을 권장하고 있다.
<br><br> Mutable(변경가능한)객체에 아무런 파라미터 없이 그냥 사용하는 경우에 문제가 발생할 수 있다.
<br>
<br>동일한 객체임에도 불구하고 Set으로 필드값을 변경하게 되면, hashCode가 변경되면서 찾을 수 없게되는 부분이 있다. <br><br>- 위에서 설명한 @RequiredArgsConstructor 및 @EqualsAndHashCode를 포함하고 있기 때문에 사용을 피하는 것이 좋다.
<br><br>- 불변 클래스를 생성해주는 @Value또한, @EqualsAndHashCode와 @AllArgsConstructor를 포함하고 있기 때문에 사용을 피하는것이 좋다. - 불변클래스 이기 때문에 @EqualsAndHashCode는 문제가 되지 않지만, AllArgsConstructor가 문제를 일으킬 가능성이 있다.
<br>]]></description><link>https://lts.kr/짧은-키워드/lombok-사용시-주의사항.html</link><guid isPermaLink="false">짧은 키워드/Lombok 사용시 주의사항.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:45:47 GMT</pubDate></item><item><title><![CDATA[빌더패턴을 왜쓰는가?]]></title><description><![CDATA[<br><br><br>
<br>생성자의 파라미터가 많은 경우 가독성이 떨어진다. <br>빌더패턴으로 생성하는 경우 각 값들이 함수로 셋팅이되고, 각각 무슨값들이 어떠한 것을을 의미하는지 파악하기가 수월하다.
ex)
Bag bag = new Bag("name", 1000, "memo", "20", "30");
vs
Bag bag = Bag.builder()
,name("name")
,money(1000)
,memo("memo")
,won(20)
,dolor(30)
,build(); <br>어떠한 값을 먼저 넣더라도 상관없다(순서x) <br>생성자의 경우 정해진 파라미터대로 값을 입력해야 정해진 값에 매핑이 되지만, 빌더패던의 경우 필드 이름을 기준으로 값을 삽입하게 때문에 순서를 생각하지 않아도 된다. <br><br>
<br>@NoArgsConstructor로 기본 생성자의 생성을 방지하고, @Builder를 이용하여 객체의 생성에 유연성을 준다.
이때, 이 2개의 어노테이션을 함께 사용하기 위해서는 @AllArgsConstructor 어노테이션이 필요하다.
<br>이유 : @Build는 위에서 설명한 바와 같이 생성자가 없다면 모든 파라미터를 갖는 생성자를 생성하지만, @NoArgsConstructor로 인해 아무런 생성자를 생성하지 않는다. 이때 build메서드를 사용하여 모든파라미터를 받는 메서드(생성자)를 동작시키면 매칭되는 생성자가 없기때문에 오류를 야기한다.
따라서 @AllArgsConstructor 어노테이션을 추가로 작성하여 해결할 수 있다.<br>더 깔끔한 방법으로는 직접 생성자를 생성해주고, 빌더 패턴에서 해당 생성자를 사용하도록 하는 방법도 있다.<br>]]></description><link>https://lts.kr/짧은-키워드/빌더패턴을-왜쓰는가.html</link><guid isPermaLink="false">짧은 키워드/빌더패턴을 왜쓰는가.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:45:10 GMT</pubDate></item><item><title><![CDATA[Spring 어노테이션@ 간단설명모음]]></title><description><![CDATA[<br><br><br>JAVA오브젝트로 자동 변환해준다. (Controller기준 받는 입장)
<br>
<br>프론트앤드에서 Ajax요청시 JSON형식으로 값이 넘어오는데,
이 JSON형식을 받을때 사용하는 어노테이션이다. <br>자동으로 자바객체로 바꿔준다.
<br><br>- 외부API에서 name으로 넘긴 값을 String name에 저장함.
<br><br>- Autowired/생성자/setter 이렇게 총 3가지 방법으로 의존성을 주입받을 수 있다.
<br><br><br>- 경로변수는 {id}로 둘러싸인 값을 의미한다.
- 주로 상세조회, 수정, 삭제 등의 작업에서 리소스 식별자로 사용된다.
<br><br>하이버네이트가 오브젝트를 대신 갱신한다.
<br><br>*빌더 패턴이란? : 생성자에 파라미터를 주입하여 생성하는것이 아닌, 별도의 Builder를 두어서 객체를 생성하는것을 말한다.
생성자가 없는경우 : 모든 맴버 변수를 파라미터로 받는 기본 생성자 생성
생성자가 있는 경우 : 따로 생성자를 생성하지 않음
<br><br>@Getter/@Setter/@ToString/@EqualsAndHashCode/@RequiredArgsConstructor를 자동으로 적용시켜준다.
<br><br>@NonNull이나 final이 붙은 필드값 들에 대해 생성자를 자동으로 생성해준다. ( @Autowired를 사용하지 않고 의존성주입이 가능하다)
해당 어노테이션을 사용하면 클래스가 의존하고 있는 필드를 간단하게 초기화할 수 있다.
<br><br>해당 어노테이션을 사용하면 클래스의 모든 필드값을 한 번에 초기화할 수 있다.
<br><br>해당 어노테이션을 사용하면 클래스에 명시적으로 선언된 생성자가 없더라도 인스턴스를 생성할 수 있다. 개발자가 실수로 클래스의 필드 중 하나의 필드에 대한값 설정을 누락 시킬수도 있어, 객체는 불완전한 상태가 되어버린다.
이를 방지하고자 모든 필드값을 가지도록 강제하고 싶다면, AccessLevel.PROTECTED 속성을 부여해줘 해결할 수 있다.
다음과 같은 속성을 부여해주면, 기본 생성자의 접근 제어가되어 IDE단계에서 누락을 방지할 수 있다.
<br><br>- equals는 두 객체의 내용이 같은지, 동등성을 비교하는 연산자이다.
- hashcode는 두 객체가 같은 객체인지, 동일성을 비교하는 연산자 이다.
]]></description><link>https://lts.kr/짧은-키워드/spring-어노테이션@-간단설명모음.html</link><guid isPermaLink="false">짧은 키워드/Spring 어노테이션@ 간단설명모음.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:44:37 GMT</pubDate></item><item><title><![CDATA[@Component는 내가 만든 클래스에 Bean을 주입하는역할을 한다.]]></title><description><![CDATA[<br><br>이때 객체가 생성된다면 싱글톤 패턴으로 생성이 된다. ** Spring Framework의 도움을 받으면 단점을 줄이고 장점을 사용할 수 있다.
<br>*@Controller / @Service / @Repository 등의 어노테이션을 포함한다.
싱글톤패턴?<br>
<br>인스턴스(객체)가 오직 한개만 생성된다
<br>장점 : 메모리낭비를 방지한다.
이미 생성된 객체를 재사용하기 때문에 속도가 빠르며
전역으로 사용되는 인스턴스이기 때문에 데이터공유가 쉽다.
<br>단점 : 테스트에 어려움이있다.
자식클래스를 만들수없다.
내부의 상태를 변경하기 어렵다.
<br><br> - 컴포넌트와 컨트롤러 모두 Bean객체를 등록하지만
컨트롤러는 url과 클래스를 이어주는 역할을 할 수 있다.
<br>]]></description><link>https://lts.kr/짧은-키워드/@component.html</link><guid isPermaLink="false">짧은 키워드/@Component.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:44:12 GMT</pubDate></item><item><title><![CDATA[Bean이란 무엇인가?]]></title><description><![CDATA[<br><br>- Spring컨테이너에 의해 관리되는 재사용 가능한 컴포넌트이다.
즉 스프링이 관리하는 자바 객체 이다.
- getter/setter를 포함한다.
<br>]]></description><link>https://lts.kr/짧은-키워드/bean이란-무엇인가.html</link><guid isPermaLink="false">짧은 키워드/Bean이란 무엇인가.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:43:59 GMT</pubDate></item><item><title><![CDATA[@ 어노테이션이란 무엇인인가?]]></title><description><![CDATA[<br><br>1. 컴파일러에게 코드작성 문법에러를 체크하도록 정보 제공
2. 빌드나 배치시 코드를 자동으로 생성할수 있도록 정보 제공
3. 실행시 특정 기능을 수행하도록 정보 제공
<br>]]></description><link>https://lts.kr/짧은-키워드/@-어노테이션이란-무엇인인가.html</link><guid isPermaLink="false">짧은 키워드/@ 어노테이션이란 무엇인인가.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:43:52 GMT</pubDate></item><item><title><![CDATA[JVM의 Stack과 Heap]]></title><description><![CDATA[<br><br><img alt="Pasted image 20250122111223.png" src="https://lts.kr/사진-및-문서/pasted-image-20250122111223.png" target="_self"><br><br>
<br>int, long, booolean 등 기본 자료형을 생성할 때 저장하는 공간
<br>임시적으로 사용되는 변수나 정보들이 저장되는 영역
<br>메서드 호출 시 마다 스텍 프레임(그 메서드만을 위한 공간이 생성되고, 그 메서드 안에서
사용되는 값들을 저장하고, 호출된 메서드의 매개변수, 지역변수, 리턴 값 등을 임시로 저장한다.<br>그리고 메서드의 수행이 끝나면 프레임별로 삭제된다.<br>단, 데이터 타입에 따라 스텍과 힙에 저장되는 방식이 다르다는 점을 유의해야한다.<br><br><br>위사진 참고<br><br><br>- 이를 넘어서면 StackOverFlowError를 발생한다.
<br><br>
<br>메서드 영역과 함께 모든 스레드가 공유한다.
<br>JVM이 관리하는 프로그램 상에서 데이터를 저장하기 위해 런타임 시 동적으로 할당되어 사용되는 영역이다.
<br>new연산자로 생성되는 클래스와 인스턴스 변수, 배열 타입 등 Reference Type이 저장된다.
<br>메서드 영역에 저장된 클래스만이 힙영역에 생성이 되어 적재된다.
힙영역에 더이상 아무도 참조하지않는 객체가 있다면, GC에 의해 제거된다.
<br>]]></description><link>https://lts.kr/짧은-키워드/jvm의-stack과-heap.html</link><guid isPermaLink="false">짧은 키워드/JVM의 Stack과 Heap.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:39:42 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20250122111223.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20250122111223.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Java의 람다란?]]></title><description><![CDATA[<br><br>
<br>
람다 표현식(Lambda Expression)이란?
함수형 프로그래밍을 구성하기 위한 함수식이며, 간단히 말해 자바의 메소드를 간결한 함수 식으로 표현한 것. <br>
이름없는 함수, 익명 함수(anonymous function) 이라고도 한다. <br>int add(int x, int y) { return x + y;
}
<br>// 위의 메서드를 람다 표현식을 이용해 아래와 같이 단축 시킬수 있다. (메서드 반환 타입, 메서드 이름 생략)
(int x, int y) -&gt; { return x + y;
};
<br>// 매개변수 타입도 생략 할 수 있다.
(x, y) -&gt; { return x + y;
};
<br>// 함수에 리턴문 한줄만 있을 경우 더욱 더 단축 시킬 수 있다. (중괄호, return 생략)
(x, y) -&gt; x + y;
<br><br><br>
<br>람다의 바디에서는 파라미터가 아닌 바디 외부에 있는 변수를 참조할 수 있다.
<br>유사하게 로컬 클래스, 익명 클래스에서도 참조가 가능하다.
<br>public class VariableCapture { private void run() { // 로컬 클래스, 익명 클래스, 람다에서 이 변수를 참조하면 effective final로 변경 int baseNumber = 10; // 람다 IntConsumer lambda = (i) -&gt; System.out.println(i + baseNumber); // i + 10 // 로컬 클래스 class LocalClass { void printBaseNumber() { System.out.println(baseNumber); // 10 } } // 익명 클래스 IntConsumer intConsumer = new IntConsumer() { @Override public void accept(int i) { System.out.println(i + baseNumber); // i + 10 } }; }
}
<br><br><br><br><br>
<br>자유 변수는 final로 선언되어 있어야 한다.
<br>final로 선언되지 않은 자유 변수는 final처럼 동작해야 한다. (effectively final)
<br><br>
<br>지역 변수는 JVM의 영역 중 stack영역에 생성된다.
<br>쓰레드별로 해당 stack영역을 별로 갖는다.
<br>즉, 쓰레드 끼리 공유가 되지 않는다.
<br>반면 인스턴스 변수는 Heap영역에 생성된다.
<br>즉, 인스턴스 변수는 공유가 가능하다.
람다는 별도의 쓰레드에서 실행이 가능하다.
따라서 지역 변수(자유 변수)가 있는 쓰레드가 사라졌을 때, 람다가 이 변수를 참조하고 있다면, 오류를 야기할 수 있는것이다.
<br><br>
<br>람다는 자유 변수를 참조할 때 직접 그 변수를 참조하는 것이 아닌,
자유 변수를 자신의 stack영역에 복사하여 참조하는 방법으로 참조 오류를 해결했다.
<br>이러한 이유로 자유 변수는 수정이 불가능하도록 final처럼 동작해야 하는 것이다.
<br><br>
<br>로컬 클래스 / 익명 클래스 / 람다 모두 자유 변수를 참조할 수 있다는 공통점이 있다.
<br>하지만 로컬클래스 / 익명클래스와 다르게 람다에서는 자유 변수와 같은 이름의 변수를 선언할 수 없다.
람다의 scope는 자유변수의 scope와 같기 때문이다.
반면 로컬/익명 클래스는 내부에 생성된 변수의 스코프가 더 지엽적이기 때문에 선언이 가능하다.
<br>]]></description><link>https://lts.kr/짧은-키워드/java의-람다란.html</link><guid isPermaLink="false">짧은 키워드/Java의 람다란.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:39:33 GMT</pubDate></item><item><title><![CDATA[Static 키워드에 대하여]]></title><description><![CDATA[<br><br>
<br>클래스 레벨의 변수나, 메서드, 블록 을 정의 할 때 사용된다.
<br>인스턴스(객체)생성 , new키워드 없이도 접근이 가능하다.
<br>모든 인스턴스에서 공유된다.
<br>static변수는 프로그램이 빌드될 때 메모리에 할당, 종료될 때 까지 유지.
static키워드의 남용은 OOP의 원칙과 상반되며, 메모리 사용량의 증가로 이어질 수 있으므로 주의가 필요하다.
<br><br>
<br>클래스 레벨에서 공유되는 값을 정의할 때 사용.
<br>인스턴스마다 별도의 복사본을 유지 할 필요가 없다.
<br>메모리 사용을 최적화 할 수 있다.
<br><br>
<br>클래스 생성없이 직접 호출 가능.
<br>유틸리티 함수나, 상태가 필요없는 연산에 주로 활용. ex) 수학 연산
<br>인스턴스 생성의 오버헤드 없이 빠른 실행이 가능하다.
단, static메서드는 해당 클래스 내의 다른 static메서드나, 변수에만 접근 할 수 있으므로 인스턴스 멤버에 접근해야하는 경우 사용할 수 없다.
<br><br>]]></description><link>https://lts.kr/짧은-키워드/static-키워드에-대하여.html</link><guid isPermaLink="false">짧은 키워드/Static 키워드에 대하여.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:39:17 GMT</pubDate></item><item><title><![CDATA[Java의 리플렉션이란?]]></title><description><![CDATA[<br><br>
<br>구체적인 Class Type을 알지 못하더라도 해당 Class의 method, type, variable들에 접근할 수 있도록 해주는 JAVA의 API이다.
<br>컴파일된 바이트 코드를 통해 Runtime에 동적으로 특정 Class의 정보를 추출할 수 있는 프로그래밍 기법
<br><br>
<br>프로그램에 사용된 구성 요소의 실제 값 또는 프로퍼티를 결정짓는 행위
-즉 프로그램에서 사용되는 변수나 메서드 등 모든 것들이 결정되도록 연결해주는 것
<br><br>- 컴파일 시점에 결정
- 프로그램이 실행 돼도 변하지 않음
- 오버로딩 : 컴파일 다형성, 메서드 타입,개수,순서 를 다르게 하여 정의하는 것
- private, final, static이 붙은 메서드
<br><br>- 런타임 시점에 결정
- 오버라이딩 : 런타임 다형성, 부모,상위 클래스의 메서드를 하위 클래스가 재정의하여 사용하는 것
- Java에서의 다형성, 상속이 가능한 이유
<br><br>
<br>
클래스의 수정 없이 유연하게 확장 가능한 코드를 작성할 수 있다. <br>
앞서 설명했던 것을 토대로 생각해보면, Reflection은 Runtime에 Class Type을 모르는채로 객체를 생성하고 이용하기 때문에 동적 바인딩을 제공한다. <br><br>
<br>코드 작성 시점에서는 어떠한 Class를 사용해야할지 모르지만 Runtime에 Class를 가져와서 실행해야하는 경우 (Spring Annotation)
<br><br>
<br>private 변수를 변경하고 싶거나 private method를 테스트할 경우
<br><br>
<br>IDE 사용 시 Da 입력만해도 이와 관련된 Class 혹은 Method 목록들을 IDE가 먼저 확인하고 사용자에게 제공한다
<br><br>
<br>Reflection은 아래와 같은 정보를 가져올 수 있다.
<br>
<br>Class/Interface
<br>Constructor
<br>Method
<br>Field
<br>해당 정보들을 통해 (1) 객체 생성 (2) 메서드 호출 (3) 변수 값을 변경할 수 있다.<br>[1] Class / Interface<br>public static void main(String[] args) throws Exception { // 1. class를 알고 있을 경우 Class car = Car.class; // 2. class 이름만 알고 있을 경우 Class car = Class.forName("com.reflection.test.Car"); // class.getName() -&gt; com.reflection.test.Car // 3. Default 생성자를 이용한 객체 생성 Car realCar = car.newInstance(); // 4. class에 구현된 interface 확인 Class[] interfaces = car.getInterfaces();
}
<br>[2] Constructor<br>public static void main(String[] args) throws Exception { Class car = Class.forName("com.reflection.test.Car"); // 1. 인자가 없는 생성자 가져오기 Constructor constructor = car.getDeclaredConstructor(); // 2. String 인자를 가진 생성자 가져오기 Constructor constructor = car.getDeclaredConstructor(String.class); // 3. 모든 생성자 가져오기 Constructor constructors[] = car.getDeclaredConstructors(); // 4. public 생성자만 가져오기 Constructor constructors[] = car.getConstructors(); // public com.reflection.test.Car() // public com.reflection.test.Car(java.lang.String) // 5. 생성자를 이용한 객체 생성 Car realCar = constructor.newInstance();
}
<br>[3] Method<br>public static void main(String[] args) throws Exception { Class car = Class.forName("com.reflection.test.Car"); // 1. 인자가 없는 method 가져오기 Method method = car.getDeclaredMethod("move"); // 2. String 인자를 가진 method 가져오기 Method method = car.getDeclaredMethod("move", String.class); // 3. 모든 method 가져오기 Method methods[] = car.getDeclaredMethods(); // 4. 상속받은 method와 public method 가져오기 Method methods[] = car.getMethods(); // public void com.reflection.test.Car.move() // public void com.reflection.test.Car.move(java.lang.String) // 5. method 호출 Class realCar = car.newInstance(); method.invoke(realCar, /*인자*/); // 6. 접근 제한자를 무시한 method 호출. method.setAccessible(true); method.invoke(realCar, /*인자*/);
}
<br>[4] Field<br>public static void main(String[] args) throws Exception { Class car = Class.forName("com.reflection.test.Car"); // 1. car 객체에서 name 에 해당하는 field 가져오기 Field field = car.getDeclaredField("name"); // 2. car + car super 객체를 포함하여 name에 해당하는 field 가져오기 Field field = car.getField("name"); // 3. car 객체에 선언된 모든 field 가져오기 Field[] fields = car.getDeclaredFields(); // private java.lang.String com.reflection.test.Car.name // public java.lang.Integer com.reflection.test.Car.type // 4. car + car super 객체의 모든 public field 가져오기 Field[] fields = car.getFields(); // public java.lang.Integer com.reflection.test.Car.age
}
<br>[5] Field 값 변경<br>public static void main(String[] args) throws Exception { Class class = Class.forName("com.reflection.test.Car"); Constructor constructor = class.getConstructor() Car car = constructor.newInstance() Field field = car.getField("name"); // 1. public field 일 경우 field.set(car, "아반떼"); // 2. private field 일 경우 field.setAccessible(true); field.set(car, "아반떼");
}
<br>]]></description><link>https://lts.kr/짧은-키워드/java의-리플렉션이란.html</link><guid isPermaLink="false">짧은 키워드/Java의 리플렉션이란.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:35:42 GMT</pubDate></item><item><title><![CDATA[JPA의 지연로딩]]></title><description><![CDATA[<br><br>
<br>JPA에서 실제 데이터가 필요한 시점까지 데이터베이스 조회를 지연하는 기법
<br>엔티티를 처음 조회할 때는 연관된 데이터를 즉시 로드하지 않고, 그 연관된 데이터가 실제로 사용될 때 데이터베이스에서 조회하는 방식
<br>불필요한 데이터 조회를 줄여서 성능을 최적화하는데 유리하다.
<br><br>
<br>지연 로딩을 설정하면 연관된 엔티티나 컬렉션은 처음에 프록시 객체로 로드된다. <br>프록시는 실제 엔티티를 대신하는 객체로, DB조회가 필요할 때 프록시가 실제 데이터를 조회하여 값을 제공 <br>처음 부터 연관된 데이터를 모두 로드하는것이 아닌, 실제 접근 시점에 DB에서 로드되도록 지연 <br><br>
<br>엔티티 A를 조회시 관련(Reference)되어 있는 엔티티 B를 한 번에 가져오지 않는다.
<br>프록시를 맵핑하고 실제 B를 조회할 때 쿼리가 나간다.
쿼리가 총 두 번 나간다. A조회시 한 번, B조회시 한 번
<br>]]></description><link>https://lts.kr/짧은-키워드/jpa의-지연로딩.html</link><guid isPermaLink="false">짧은 키워드/JPA의 지연로딩.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:24:48 GMT</pubDate></item><item><title><![CDATA[데코레이션 패턴 vs 프록시 패턴]]></title><description><![CDATA[<br><br><br>
<br>클라이언트에서 서버를 직접 호출하고, 처리결과를 받는다. -&gt; 직접호출
<br>클라이언트에서 서버를 직접 호출하지 않고, 대리자를 통해 간접적으로 서버에 요청 -&gt; 간접호출
<br><br><br>
<br> <br>권한에 따른 접근 차단, 지연로딩을 수행하는 접근 제어 <br> <br>서버의 기능에 다른 기능을 추가해주는 부가 기능 추가 ex) 로그, 가공 <br> <br>대리자가 또 다른 대리자를 호출하는 프록시 체인 <br><br>
<br> <br>아무 객체나 프록시가 되는것은 아니다. <br> <br>클라이언트는 서버에 요청한지, 프록시에게 요청한지 몰라야한다. <br>즉, 클라이언트의 코드를 건드리지 않고 프록시 추가와 런타임 객체 의존 관계 주입만 변경하여야 한다.
<br><br>
<br>두 패턴 모두 프록시를 사용하는 방법이다.
<br>또한, 둘 모두 원본 객체를 건드리지 않고, 추가 기능을 실행 할 수 있다.
<br>하지만 GOF 디자인 패턴에서는 이 둘을 의도(Intent)에 따라서 구분한다.
프록시 패턴 : 접근 제어가 목적
데코레이터 패턴 : 새로운 기능 추가가 목적
<br><br><br>1.객체들이 사용하는 코드를 훼손하지 않으면서 런타임에 추가 행동들을 객체들에 할당할 때 사용.<br>
<br>상속을 사용하여 객체의 행동을 호가장하는 것이 어색하거나, 불가능할 때 사용할 수 있다.
-만일 final 키워드가 기입된 클래스의 경우는 데코레이터 패턴을 통해 래핑하여 재사용 할 수 있다.
<br>ex)
택스트 편집기
- 택스트 편집기에서 굵게, 이텔릭체, 밑줄 등과 같은 다양한 텍스트 포맷을 지원한다.
Spring
- HttpServletRequestWrapper : Sevlet에서 제공하는 Wrapper로 데코레이터 패턴을 지원한다.<br><br>
<br>
가상 프록시, 지연 로딩이 필요한 경우 <br>부담되는 서비스 객체를 바로 초기화 한다면 리소스 낭비가 발생 할 수 있으므로, 프록시 객체를 통해 객체를 초기화 할 수 있다. <br>
보호 프록시, 접근 제어가 필요한 경우 <br>특정 클라이언트에 대해서만 서비스 객체를 이용할 수 있도록 하려는 경우 프록시 객체를 통해서 처리할 수 있다. <br>
원격 프록시, 원격 서비스의 로컬 실행이 필요한 경우 <br>서비스 객체가 원격 서버에 있는 경우에는 네트워크를 통해 클라이언트의 요청을 전달하여 처리할 수 있다. <br>
로깅 프록시, 서비스 객체에 대한 로깅이 필요한 경우 <br>프록시 객체에서 서비스에 전달하기 전과 후로 로깅을 진행할 수 있다. <br>
캐싱 프록시, 요청 결과를 캐시하고 생명주기를 관리해야 하는 경우 <br>ex) Spring JAP<br>
<br>JPA의 지연 로딩의 경우, 가상 프록시를 적용하여 실제로 객체를 조회하기 이전까지 프록시 객체로 Entity를 대신하여 제공한다.
ex) Spring AOP
<br>Spring AOP는 프록시 패턴을 사용하여 트렌젝션 관리, 로깅, 보안 등의 작업을 프록시에서 처리한다.
<br>
public void write(char cbuf[], int off, int len) throws IOException { synchronized (lock) { ensureOpen(); if ((off &lt; 0) || (off &gt; cbuf.length) || (len &lt; 0) || ((off + len) &gt; cbuf.length) || ((off + len) &lt; 0)) { throw new IndexOutOfBoundsException(); } else if (len == 0) { return; } if (len &gt;= nChars) { /* If the request length exceeds the size of the output buffer, flush the buffer and then write the data directly. In this way buffered streams will cascade harmlessly. */ flushBuffer(); out.write(cbuf, off, len); return; } int b = off, t = off + len; while (b &lt; t) { int d = min(nChars - nextChar, t - b); System.arraycopy(cbuf, b, cb, nextChar, d); b += d; nextChar += d; if (nextChar &gt;= nChars) flushBuffer(); } }
} ]]></description><link>https://lts.kr/짧은-키워드/데코레이션-패턴-vs-프록시-패턴.html</link><guid isPermaLink="false">짧은 키워드/데코레이션 패턴 vs 프록시 패턴.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:24:02 GMT</pubDate></item><item><title><![CDATA[Spring AOP]]></title><description><![CDATA[<br><br><br>
<br>컴파일 타임 위빙 (Compile-Time Weaving) <br>소스 코드 컴파일 시, Aspect가 대상 객체에 결합됩니다.
<br>AspectJ 같은 프레임워크에서는 가능하지만, Spring AOP는 이 방식을 지원하지 않습니다. <br>로드 타임 위빙 (Load-Time Weaving) <br>클래스 파일을 JVM에 로드할 때 Aspect를 결합합니다.
<br>Spring AOP는 기본적으로 지원하지 않으나, AspectJ 통합 설정을 통해 사용할 수 있습니다. <br>런타임 위빙 (Runtime Weaving) <br>Spring AOP의 기본 방식입니다.
<br>런타임에 프록시 객체를 생성하여 부가 기능을 결합합니다.
<br>JDK 동적 프록시 또는 CGLIB를 사용하여 대상 객체를 프록시로 감싸고, 프록시가 메서드 호출을 가로채서 Advice를 실행합니다. <br><br><br><br><br><br><br>
<br>프록시 생성 시: 클래스 단위에서 PointCut 조건에 따라 프록시가 생성됩니다.
<br>메서드 호출 시: 개별 메서드 단위에서 PointCut 조건을 재평가합니다.
<br><br>
<br>프록시 생성은 클래스 단위로 이루어지지만, PointCut 조건은 메서드 단위로 적용됩니다.
<br>런타임 정보(매개변수, 리턴 타입 등)를 기반으로 동적 조건을 평가해야 하는 경우가 있습니다.
<br>Spring AOP의 유연성과 확장성을 보장하기 위한 설계입니다.
<br><br><br>]]></description><link>https://lts.kr/짧은-키워드/spring-aop.html</link><guid isPermaLink="false">짧은 키워드/Spring AOP.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:23:24 GMT</pubDate></item><item><title><![CDATA[🛬 JDK와 JRE, JVM]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="https://lts.kr/?query=tag:Java" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Java</a> <a class="tag" href="https://lts.kr/?query=tag:JDK" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#JDK</a> <a class="tag" href="https://lts.kr/?query=tag:JVM" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#JVM</a> <br> <a href="https://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="https://lts.kr?query=tag:Java" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Java">#Java</a> <a href="https://lts.kr?query=tag:JDK" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#JDK">#JDK</a> <a href="https://lts.kr?query=tag:JVM" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#JVM">#JVM</a><br>
<br>자바 개발 키트의 약자로, 개발자들이 자바로 개발하는데 사용되는 SDK키트라고 생각하면 된다.
<br>자바 개발시 필요한 라이브러리와, javac, javadoc 등의 개발도구를 포함한다.
<br>자바 실행 프로그램인 JRE도 포함한다. (JRE에는 JVM이 들어가있다.)
<br>- 대표적으로, 안드로이드 스튜디오 등이 있다.
<br>
<br>Java SE(standard edition) : 가장 기본이 되는 표준 에디션의 자바 플랫폼.
<br>Java EE(enterprise edition) : 대규모 기업용 에디션. SE의 확장판
<br>Java ME(micro edition) : 피쳐폰/셋톱박스/프린터 와 같은 작은 임베디드 기기를 다루는데 이용하는 에디션
<br>Java FX : 가볍고 예쁜 그래픽 사용자 인터페이스를 제공하는 에디션
<br>
<br>JRE는 자바 실행환경의 약자로서, JVM과 자바 프로그램을 실행시킬 때 필요한 라이브러리 API를 함께 묶어서 배포되는 패키지.
<br>또한, 자바 런타임 환경에서 사용하는 프로퍼티 세팅과 리소스(jar)파일을 가지고 있다.
<br>JRE는 기본적으로 JDK에 포함되어있기 때문에 JDK를 설치하면 함께 설치된다.
<img alt="Pasted image 20250110101642.png" src="https://lts.kr/사진-및-문서/pasted-image-20250110101642.png" target="_self">
<br>
<br>JVM은 자바 가상머신의 약자로서, 직역하면 자바를 실행하는 머신, 자바를 돌리는 프로그램이다.
<br>자바로 작성된 모든 프로그램은 JVM에서만 실행될 수 있으므로, 자바 프로그램을 실행하기 위해서는 바늗시 자바 가상머신의 설치가 선행되어야 한다.
<br>
<br>java는 OS에 종속적이지 않다는 특징을 가지고 있다.
<br>
<br>
소스코드를 컴파일하여 기계어를 만드는 과정에서, window/mac/linux가 각기 다르게 컴파일을 시킨다. <br>
때문에 각 OS별로 상이한 문법을 사용하게 되는 일이 벌어진다. <br>
이러한 언어를 "이식성이 낮다" 라고 표한다. <br>
하지만 java는 jvm를 거쳐서 OS와 상호작용 하기때문에, OS에 구애받지 않게 된다. <br>
<br>위에서 c언어는 컴파일을 거치면 기계어가 된다고 했는데,
<br>java는 JVM을 거쳐 바이트 코드로 변환되게 된다. <br>이는 가상 머신이 이해할 수 있는 중간 레벨의 언어로, 반쪽짜리 컴파일 결과물 이라고 할 수 있다.
<br>이는 어떠한 환경에 종속적이지 않고 실행될 수 있다.
<br>즉, 재컴파일 할 필요없이 기계가 바로 읽고 실행 할 수 있는 코드를 만들어 주는것이다.
<br>하지만 자바 프로그램과 달리 JVM은 각 운영체제에 종속적이므로, 각 운영체제에 맞는 JVM을 알맞게 설치해주어야한다.<br>
<br>위의 설명과 같이 java는 일반 프로그램보다 JVM이라는 단계를 한 단계 더 거치기 때문에, 상대적으로 실행속도가 느리다는 단점을 내포하고 있다.
<br>이를 보환하기 위해, 필요한 부분만을 기계어로 바꾸어 속도를 향상시키는 JIT 컴파일러 같은 내부 프로그램이 있지만, 그럼에도 여전히 느리다.
<br><img alt="Pasted image 20250110103409.png" src="https://lts.kr/사진-및-문서/pasted-image-20250110103409.png" target="_self"><br>위 그림에서 Compiler는 javac.exe에 해당되고 JVM은 java.exe에 해당된다.
<br>소스코드(MyPrograme.java)를 작성한다.
<br>컴파일러(Compiler)는 자바 소스코드를 이용하여 클래스 파일(MyProgram.class)을 생성한다. 컴파일 된 클래스 파일은 JVM(Java Virtual Machine)이 인식할 수 있는 바이트 코드 파일이다.
<br>JVM은 클래스 파일의 바이트 코드를 해석하여 바이너리 코드로 변환하고 프로그램을 수행한다.
<br>MyProgram 수행 결과가 컴퓨터에 반영된다
<br>
<br>c또는 c++등으로 작성된 프로그램은 최종 결과물로 exe파일을 만들어낸다.
<br>java도 exe파일을 만들 수 있지만, class파일로 굳이 만들어내는 이유는 다음과 같다 <br>JVM이 exe에 포함되는 형식으로 가능하기 때문에 exe파일이 무척 커지게 되는 단점이 있다.
<br>때문에 보통의 경우 일부러 생성하지 않는것이다.]]></description><link>https://lts.kr/study/cs/🛬-jdk와-jre,-jvm.html</link><guid isPermaLink="false">study/CS/🛬 JDK와 JRE, JVM.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:21:08 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20250110101642.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20250110101642.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[객체지향설계 5원칙 S.O.L.I.D]]></title><description><![CDATA[<br><br><br>
<br>객체지향 설계시 지켜야 하는 5가지 원칙들의 앞글자를 딴것이다.
<br>순서는 노상관이다.
<br><br>책임 = 기능 이다. 수정시 영향도를 낮추는 주요한 원칙이다.
<br><br>- 추상화 사용을 통한 관계를 구축하기를 권장하는 의미이다.
- 추상클래스,인터페이스를 통한 관계를 구축하여 확장은 쉽고, 변경에는 영향도가 없어지도록 분리해라?
<br><br>- 코드에는 문제가 없더라도, 부모타입의 설계 목적에도 부합하도록 설계해라. -&gt; 부모의 동작의도대로 흘러가도록 설계해라
- Map a = new HashMap(); 같이 구현해서, 사용해도 문제 없도록 하는거다
- &gt; 변수는 Map타입으로, Map메서드만 사용가능하지만 객체는 HashMap이기 때문에 각각의 기능으로 수행되고, 수정시에도 Map을 상속받는 다른 클래스로 변경이 쉬워진다.
<br><br>- 인터페이스의 단일책임과 비슷하다. 기능별로 잘 분리하고, 수정을 최소화할수 있도록 처음부터 생각하라.
<br><br>- 리스코프 치환의 원칙을 따라 설계했다면, 의존성 역전의 원칙을 따르기 쉬워진다.
- 의존관계를 맺을때, 변화기 쉬운것 보다, 변화하기 어려운 것에 의존하라는 것이다.
<br>]]></description><link>https://lts.kr/짧은-키워드/객체지향설계-5원칙-s.o.l.i.d.html</link><guid isPermaLink="false">짧은 키워드/객체지향설계 5원칙 S.O.L.I.D.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:19:19 GMT</pubDate></item><item><title><![CDATA[상속과 합성]]></title><description><![CDATA[<br><br><br><br>Java는 다중 상속을 지원하지 않는다.(부모가 2명 이상인것)
<br><br>다중 상속 처럼 여러개를 상속받을 수 있다. 부모의 메서드를 사용하며, 동작이 의도대로 흘러가도록 강제할 수 있으나, 구현은 자식 클래스에서 하기때문에 결합도를 낮출 수 있다.
<br><br><br>
<br>상속은 부모 클래스의 내부 구현에 대해 상세히 알아야 하기 때문에, 자식과 부모 사이의 결합도가 높아질 수 밖에 없다.
<br>또한, 부모의 쓸모없는 기능까지 모두 받게 될 가능성이 있다.
<br>부모 클래스가 수정되면, 자식클래스도 동시에 수정해야하는 경우가 생긴다.
<br>단일 상속만 가능하기 때문에, 결국 인터페이스를 또 사용하게 된다.
<br><br>
<br>합성은 구현에 의존하지 않는 점에서 상속과 다르다. <br>합성을 이용했을 때는, 객체의 내부는 공개되지 않고 인터페이스를 통해 코드를 재사용하기 때문에,
구현에 대한 의존성을 인터페이스에 대한 의존성으로 변경하여 결합도를 낮출 수 있다.
<br>합성 관계는 실행 시점에 동적으로 변경될수 있다.(런타임) <br>public class Phone { private RatePolicy ratePolicy; // 클래스 합성 private List&lt;Call&gt; calls = new ArrayList&lt;&gt;(); // 클래스 합성 public Phone(RatePolicy ratePolicy) { this.ratePolicy = ratePolicy; } public List&lt;Call&gt; getCalls() { return Collections.unmodifiableList(calls); }
}
<br><br>]]></description><link>https://lts.kr/짧은-키워드/상속과-합성.html</link><guid isPermaLink="false">짧은 키워드/상속과 합성.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:18:54 GMT</pubDate></item><item><title><![CDATA[오버로딩 &amp; 오버라이딩]]></title><description><![CDATA[<br><br><br>- 컴파일 다형성
- 이름이 같지만, 매개변수의 타입/개수/순서 를 다르게 정의하여 사용하는 방법
- 어떤 메서드가 호출될지 컴파일 시점에서 결정
- 코드를 직관적이게 만드는데 사용
<br><br>- 런타임 다형성
- 부모클래스 또는 인터페이스에 정의된 메서드를 하위 클래스에서 재정의하여 사용하는 방법
- 어떤 메서드가 호출될지 런타임 시점에 결정된다.
<br>Map&lt;String, Integer&gt; map1 = new HashMap&lt;&gt;();
Map&lt;String, Integer&gt; map2 = new TreeMap&lt;&gt;();
<br>해당 형태로 map1 / 2를 구현했다면.
객체 타입은 각각 HashMap/TreeMap 이 되며,
변수 타입은 모두 Map이 된다.
- 즉 map1.add / map2.add 등 Map인터페이스가 가진 함수만을 사용할 수 있으며,
HashMap이나 TreeMap가 가진 고유메서드는 사용할 수 없다.
하지만, 오버라이딩(런타임 다형성)으로 재정의한 각각의 메서드로 해당 동작이
구현체의 특성에 맞게 실행되게 된다.<br>]]></description><link>https://lts.kr/짧은-키워드/오버로딩-&amp;-오버라이딩.html</link><guid isPermaLink="false">짧은 키워드/오버로딩 &amp; 오버라이딩.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:18:30 GMT</pubDate></item><item><title><![CDATA[🚨 RSA 암호화 방식의 이해와 적용 (feat.취약성점검)]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="https://lts.kr/?query=tag:Tokken" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Tokken</a> <a class="tag" href="https://lts.kr/?query=tag:Security" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Security</a> <a class="tag" href="https://lts.kr/?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <a class="tag" href="https://lts.kr/?query=tag:보안" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#보안</a> <br> <a href="https://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="https://lts.kr?query=tag:Tokken" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Tokken">#Tokken</a> <a href="https://lts.kr?query=tag:Security" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Security">#Security</a> <a href="https://lts.kr?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a> <a href="https://lts.kr?query=tag:보안" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#보안">#보안</a><br>1977년에 Rivest, Shamir, Adleman 이라는 세 명의 수학자가 고안해서 RSA라고 부른다.
이 방식은 지금도 SSL/TLS, 이메일, 디지털 서명, 인증서 등 보안의 핵심 인프라에서 계속 쓰이고 있는 방식이다.<br>
<br>RSA는 "공개키로 암호화하고, 개인키로 복호화" 또는 그 반대로 동작하는 비대칭 암호화 알고리즘이다.
<br>
<br>공개키로 암호화된 데이터는 개인키를 소유한 공개키 생성자만이 복호화 가능하다.
<br>사용자( Client )마다 공개키와 개인키를 접근 시 새로 생성/발급하여 원본 데이터 추적이 불가하다.
<br>결론
즉, 클라이언트의 요청이 들어오면 서버에서 공개키(클라이언트에게 제공할 키) 와 개인키(서버측에서 갖고있는, 공개키와 한쌍이 되는 키) 를 매번 새로 발급하기 때문에, 추적이 어렵고 암호화에 뛰어나다.
<br>
<br>서비스 특성에 따라 적절하게 적용할 필요가 있다.
<br>정보 <br>RSA 키 객체 (PublicKey, PrivateKey) 는 메모리 상에서만 동작할 수 있다.
<br>우리가 파일, 네트워크, DB로 키를 주고받을 때는 Base64 문자열 로 직렬화해야 해야한다. <br>[로그인 / 회원가입 페이지]<br>클라이언트에서 서버에 공개키 요청
<br>서버에서 키쌍 과 KeyUUID 생성
<br>개인키는 KeyUUID와 함께 캐쉬에 저장 / 공개키는 KeyUUID와 클라이언트에 전달
<br>클라이언트는 서버로부터 받은 공개키로 평문 암호화, 서버에 전달
<br>암호화된 평문을 KeyUUID로 찾은 공개키로 복호화 -&gt; 평문 완성
<br>정보
UUID자동 발급 및 매칭 로직은 공개하지 않음.
<br>
<br>암호화, 해시, 키 생성, 인증서 처리, 서명 등 암호학 기반 기능들을 제공하는 클래스들의 모음이다.
<br> private static final String INSTANCE_TYPE = "RSA"; // 2048bit RSA KeyPair 생성. public static KeyPair generateKeypair() throws NoSuchAlgorithmException { KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(INSTANCE_TYPE); keyPairGen.initialize(2048, new SecureRandom()); return keyPairGen.genKeyPair(); } <br>KeyPairGenerator (공개키/개인키 쌍 생성) 을 사용한다.
<br>NoSuchAlgorithmException : 지정한 알고리즘 이름이 현재 JVM 환경에서 지원되지 않거나 잘못된 경우 발생하는 체크 예외다.
<br>KeyPair타입 : PrivateKey와 PublicKey로 이루어져있는 데이터 타입
<br>SecureRandom을 시드로 사용해 보안 수준 향상
<br> 2048bit로 RSA암호화 방식을 사용하여 keyPair를 생성하는 코드이다.<br>	private static final String INSTANCE_TYPE = "RSA"; // 평문 + 공개키 Base64로 암호문 생성 public static String rsaEncode(String plainText, String publicKey) throws InvalidKeyException, InvalidKeySpecException, NoSuchAlgorithmException, NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException { Cipher cipher = Cipher.getInstance(INSTANCE_TYPE); cipher.init(Cipher.ENCRYPT_MODE, convertPublicKey(publicKey)); byte[] plainTextByte = cipher.doFinal(plainText.getBytes()); return base64EncodeToString(plainTextByte); } //Base64 공개키 -&gt; 공개키로 디코딩 public static PublicKey convertPublicKey(String publicKey) throws InvalidKeySpecException, NoSuchAlgorithmException { KeyFactory keyFactory = KeyFactory.getInstance(INSTANCE_TYPE); byte[] publicKeyByte = Base64.getDecoder().decode(publicKey.getBytes()); return keyFactory.generatePublic(new X509EncodedKeySpec(publicKeyByte)); }
<br>
Cipher : Java 보안 API에서 실제 암호화/복호화를 수행하는 핵심 클래스
AES, RAS, DES 같은 알고리즘을 직접 실행하는 암호 모듈 , 암호화 엔진 이다. <br>
Cipher cipher = Cipher.getInstance(INSTANCE_TYPE); : 타입에 따라, 암호화 모드와 패딩 방식이 결정된다. <br>
convertPublicKey : base64기반 코드를 실제 키 객체로 변환 <br>
KeyFactory : 키 복원용 펙토리 객체 <br>
keyFactory.generate... : 실제 키 객체 생성 <br>
X509EncodedKeySpec → 공개키 표준 포맷 스펙 <br>node-forge 패키지를 사용한다. base64, encode등 TLS프로토콜(암호화 도구)를 구현한 패키지 이다.
<br>&lt;script src="https://cdn.jsdelivr.net/npm/node-forge@1.3.1/dist/forge.min.js"&gt;&lt;/script&gt; &lt;script&gt;
/** * 서버에서 공개키를 받아서 RSA로 암호화하는 함수 * @param {string} plainText - 암호화할 평문 * @param {string} publicKeyBase64 - 서버로부터 받은 Base64 인코딩된 공개키 * @returns {string} 암호화된 Base64 문자열 */
function rsaEncryptWithBase64PublicKey(plainText, publicKeyBase64) { const forge = window.forge; // 1. Base64 디코딩 → DER 바이너리 const der = forge.util.decode64(publicKeyBase64); // 2. DER → ASN.1 파싱 → PublicKey 객체 const asn1 = forge.asn1.fromDer(der); const publicKey = forge.pki.publicKeyFromAsn1(asn1); // 3. RSA 암호화 const encryptedBytes = publicKey.encrypt(plainText, 'RSAES-PKCS1-V1_5'); // 4. 암호문을 Base64 인코딩해서 반환 return forge.util.encode64(encryptedBytes);
}
&lt;/script&gt;
<br>클라이언트 단에서 request전달 전, 암호화 하기 위한 코드 / 동작 구성은 2.1과 동일 하다
<br>	private static final String INSTANCE_TYPE = "RSA"; // 암호문 + 개인키 Base64로 평문 생성 public static String rsaDecode(String encryptedPlainText, String privateKey) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidKeySpecException, IllegalBlockSizeException, BadPaddingException { byte[] encryptedPlainTextByte = Base64.getDecoder().decode(encryptedPlainText.getBytes()); Cipher cipher = Cipher.getInstance(INSTANCE_TYPE); cipher.init(Cipher.DECRYPT_MODE, convertPrivateKey(privateKey)); return new String(cipher.doFinal(encryptedPlainTextByte)); } //Base64 개인키 -&gt; 개인키로 디코딩 public static PrivateKey convertPrivateKey(String privateKey) throws InvalidKeySpecException, NoSuchAlgorithmException { KeyFactory keyFactory = KeyFactory.getInstance(INSTANCE_TYPE); byte[] privateKeyByte = Base64.getDecoder().decode(privateKey.getBytes()); return keyFactory.generatePrivate(new PKCS8EncodedKeySpec(privateKeyByte)); }
<br>Cipher 객체를 사용하여 위와 동일하게 동작.
<br>PKCS8EncodedKeySpec → 개인키 표준 포맷 스펙
<br> public static String base64EncodeToString(byte[] byteData) { return Base64.getEncoder().encodeToString(byteData); }
<br>cipher.doFinal(...) 과 같은 코드는 바이너리 데이터로 리턴값을 보낸다.
<br>
<br>JUnit → 테스트 프레임워크 <br>AssertJ → 테스트 결과를 검증(assert)할 때 쓰는 강력한 assertion 도구
<br>JS코드는 제외<br>private static final String PLAIN_TEXT = "키 암/복호화 테스트 123 abc !@#"; @Test @DisplayName("RSA 키쌍 생성 및 암/복호화 통합 테스트") public void testGenerateKeypairAndEncryptDecrypt() throws Exception { // 키쌍 생성 KeyPair keyPair = rsaService.generateKeypair(); PublicKey publicKey = keyPair.getPublic(); PrivateKey privateKey = keyPair.getPrivate(); // 공개키, 개인키 → Base64 인코딩 String publicKeyBase64 = rsaService.base64EncodeToString(publicKey.getEncoded()); String privateKeyBase64 = rsaService.base64EncodeToString(privateKey.getEncoded()); System.out.println("공개키Base64 : " + publicKeyBase64); System.out.println("개인키Base64 : " + privateKeyBase64); // 암호화 String encryptedText = rsaService.rsaEncode(PLAIN_TEXT, publicKeyBase64); System.out.println("RSA암호화 텍스트 : " + encryptedText); // 복호화 (개인키 사용해야 함) String decryptedText = rsaService.rsaDecode(encryptedText, privateKeyBase64); System.out.println("RSA복호화 텍스트 : " + decryptedText); // 검증 Assertions.assertThat(decryptedText).isEqualTo(PLAIN_TEXT); }
<br>결과
<img alt="Pasted image 20250325102427.png" src="https://lts.kr/사진-및-문서/pasted-image-20250325102427.png" target="_self"><br>Base64기반 String 변환 및 암/복호화 테스트 완료
<br>js암호화도 동일하게 동작 확인
<br><img alt="Pasted image 20250325165845.png" src="https://lts.kr/사진-및-문서/pasted-image-20250325165845.png" target="_self">
<img alt="Pasted image 20250325172818.png" src="https://lts.kr/사진-및-문서/pasted-image-20250325172818.png" target="_self"><br>]]></description><link>https://lts.kr/issue_troubleshooting/🚨-rsa-암호화-방식의-이해와-적용-(feat.취약성점검).html</link><guid isPermaLink="false">Issue_TroubleShooting/🚨 RSA 암호화 방식의 이해와 적용 (feat.취약성점검).md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 06:15:45 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20250325102427.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20250325102427.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🍂 JPA, Mybatis , Dead Lock이슈]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:세미나" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#세미나</a> <a class="tag" href="https://lts.kr/?query=tag:이슈" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#이슈</a> <a class="tag" href="https://lts.kr/?query=tag:JPA" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#JPA</a> <a class="tag" href="https://lts.kr/?query=tag:Java" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Java</a> <a class="tag" href="https://lts.kr/?query=tag:Mybatis" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Mybatis</a> <a class="tag" href="https://lts.kr/?query=tag:DeadLock" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#DeadLock</a> <br> <a href="https://lts.kr?query=tag:세미나" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#세미나">#세미나</a> <a href="https://lts.kr?query=tag:이슈" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#이슈">#이슈</a> <a href="https://lts.kr?query=tag:JPA" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#JPA">#JPA</a> <a href="https://lts.kr?query=tag:Java" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Java">#Java</a> <a href="https://lts.kr?query=tag:Mybatis" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Mybatis">#Mybatis</a> <a href="https://lts.kr?query=tag:DeadLock" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#DeadLock">#DeadLock</a><br>정보
해당 내용은 Hello 주간 세미나 중 주제로 선정된,<br>
투자하기 Dead Lock이슈 해결과정에 대한 설명이다.
<br>
<br>server log
<br>Caused by: org.apache.ibatis.exceptions.PersistenceException:
###Error querying database. Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is java.sql.SQLTransientConnectionException: HikariPool-1 - Connection is not available, request timed out after 30008ms.
###The error occurred while executing a query
###Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is java.sql.SQLTransientConnectionException: HikariPool-1 - Connection is not available, request timed out after 30008ms.
Caused by: java.sql.SQLTransientConnectionException: HikariPool-1 - Connection is not available, request timed out after 30008ms.
at com.zaxxer.hikari.pool.HikariPool.createTimeoutException(HikariPool.java:696)
at com.zaxxer.hikari.pool.HikariPool.getConnection(HikariPool.java:197)
at com.zaxxer.hikari.pool.HikariPool.getConnection(HikariPool.java:162)
<br>해당 서버의 maximum-pool-size는 40으로 설정되어있으며,
30초의 대기를 했음에도 Connection Pool을 할당받지 못한 상황이다.<br>위 조건 발생 코드 예시
<br>public void deadLockMethod(){ mybatisSelectMethod(); jpaSelectMethod(); mybatisSelectMethod();
}
<br>
<br>해당 로직은 몇개월 전 수정 된 이후, 계속해서 정상적으로 운영되던 코드이다.
<br>순간적으로 트레픽이 몰린 상황을 가정하더라도, 40개의 pool이 30초간 점유를 지속한 것은 비정상 적이다.
<br>
<br>일반적으로 deadlock은 DB레벨에서의 트렌젝션이 서로 기다리는 경우에 많이 발생한다.
<br>하지만, Stack trace를 확인하였을 때, DB레벨의 deadlock은 아니었다.
<br>
<br>서비스 로직에서 한 서비스가 커넥션풀을 반환하지 않고, 또 다른 서비스가 커넥션 풀을 요청하면 무한 순환이 발생할 가능성이 있다.
<br>즉, 위 예시 코드에서 Connection Pool을 반환하지 않고 무한정 대기할 가능성이 가장 크다고 판단하였다.<br>public void deadLockMethod(){ mybatisSelectMethod(); jpaSelectMethod(); mybatisSelectMethod();
}
<br>커넥션 풀 상호 점유가 일어나고 있는 서비스 로직을 보았을 때, 특별한 점은 보이지 않는다.
그러나, 한가지
mybatis와 jpa를 혼용해서 사용중인 로직인 점이 눈에 뛴다.<br>@Transactional 이 걸려있지 않기 때문에, 순차적으로<br>mybatisSelectMethod(); : 커넥션 풀 점유 후 반환
<br>jpaSelectMethod(); : 앤티티 매니저에서 커넥션 풀 점유 후 close(반환)
<br>mybatisSelectMethod(); : 커넥션 풀 점유 후 반환
(이때 커넥션풀이 전부 점유중이라면 대기 30s )
<br>의 순서로 진행될 거라고 생각했다.<br>MyBatis는 내부적으로 JDBC 커넥션을 관리하지 않고, DataSource를 통해 커넥션을 가져옴.
즉, Spring에서 설정한 커넥션 풀(HikariCP, DBCP 등)을 통해 커넥션을 관리한다.**<br>
<br>MyBatis가 DataSource(ex: HikariCP)에서 커넥션을 요청
<br>SQL 실행 (SELECT 문 수행)
<br>커넥션이 자동 반환됨 (커밋/롤백 필요 없음)
<br>jpa또한 커넥션 풀을 통해 커넥션을 관리하지만, 영속성 컨텍스트(엔티티 매니저)에 권한을 위임한다.
앤티티 매니자 : 영속성 컨텍스트를 관리하는 핵심 객체<br>
<br>jpa가 앤티티 매니저를 통해 DataSource(ex: HikariCP)에서 커넥션을 요청
<br>SQL 실행 (find(SELECT 문) 수행)
<br>엔티티 매니저 Close <br>커넥션 반환
<br>
<br>앤티티 매니저가 Connection Pool을 반환하는 시점은 언제인가
<br><a data-tooltip-position="top" aria-label="https://velog.io/@seyoung755/%EC%82%BD%EC%A7%88%EA%B8%B0-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%A7%80%EC%86%8D-%EB%B2%94%EC%9C%84-feat.-OSIV" rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@seyoung755/%EC%82%BD%EC%A7%88%EA%B8%B0-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%A7%80%EC%86%8D-%EB%B2%94%EC%9C%84-feat.-OSIV" target="_self">영속성 컨텍스트의 지속 범위</a>
-&gt; 서치 중 위 내용을 참고하여, OSIV 라는 것을 알게되었다.<br><img alt="Pasted image 20250314122906.png" src="https://lts.kr/사진-및-문서/pasted-image-20250314122906.png" style="width: 675px; max-width: 100%;" target="_self">
OSIV란 View에 데이터를 전달할 때 지연 로딩 등의 이유로 영속성 컨텍스트를 지속해야 하는 경우에 사용되는 것이다.
즉, 영속성 컨택스트(앤티티 매니저)의 생명주기를 웹 요청이 끝날 때 까지 연장하는 옵션이다.
이 설정은 어플리케이션에 별다른 설정을 하지 않았다면 default ON 상태이다.<br>public void deadLockMethod(){ mybatisSelectMethod(); -- 1 jpaSelectMethod(); -- 2 mybatisSelectMethod(); -- 3
}
<br>다시 한번 위 코드를 보자.<br>트래픽이 몰려 커넥션 풀 40개가 전부 점유되었을 때를 가정하자.<br>@Service
public class TestServiceImpl implements TestService { private final MybatisRepo mybatisRepo; private final JpaRepo jpaRepo; public TestServiceImpl(MybatisRepo mybatisRepo, JpaRepo jpaRepo) { this.mybatisRepo = mybatisRepo; this.jpaRepo = jpaRepo; } public void test() { // JPA jpaRepo.somethingRun(); // MyBatis mybatisRepo.somethingRun(); }
} <br>조건<br>여러개의 클라언트의 요청이 동시에 발생
<br>2개 이상의 클라이언트가 2번함수를 수행 후, 영속성 컨택스트를 유지 중
<br>3번함수를 실행하려고 하나, 커넥션 풀이 가득차 대기상태에 돌입
<br>실행<br>개발자는 2번함수는 동작을 완료한 후 커넥션풀이 해제되길 기대함.
<br>OSIV 옵션이 켜져있을때, Lazy Loading이 view레이어 까지 이어짐. <br>즉, 동작이 완료되어도 커넥션풀을 해제하지 않음. <br>3번함수는 커넥션풀이 해제되길 무한정 기다림.
<br>
<br>해당 서버의 옵션을 끄면, 데이터 일관성 문제 및 커넥션 점유 문제를 해결 가능
한계 : 해당 서버의 다른 서비스 까지 직접적인 영향을 끼침
<br>
<br>@Transactional어노테이션을 사용하더라도 결과는 마찬가지. <br>오히려 OSIV옵션 OFF이더라도 같은 트렌젝션 안에 있다면 영속성 컨텍스트를 놔주지 않기 때문에 결과는 동일.
<br> 즉, DB커넥션 점유 시점의 차이만 생길 뿐, 반환시점의 차이는 없다.<br>단, 트렌젝션 매니저를 통합하여 코드를 리펙토링한다면 가능<br>
<br>JAP로 함수를 단일화 한다면, 동일한 커넥션(HikariCP) 안에서 실행되어, 커넥션 풀 무한 대기/선점 문제를 방지할 수 있다.
<br>또는 mybatis로 단일화 하더라도, 처리 즉시 커넥션풀을 반환하기 때문에 문제해결 가능
<br><a data-tooltip-position="top" aria-label="https://velog.io/@12onetwo12/%EC%9E%A5%EC%95%A0%ED%9A%8C%EA%B3%A0-DBCP-Connection-Leak-%ED%95%B4%EA%B2%B0-%EC%97%AC%EC%A0%95-feat.HikariCP-Dead-lock-QueryDSL" rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@12onetwo12/%EC%9E%A5%EC%95%A0%ED%9A%8C%EA%B3%A0-DBCP-Connection-Leak-%ED%95%B4%EA%B2%B0-%EC%97%AC%EC%A0%95-feat.HikariCP-Dead-lock-QueryDSL" target="_self">JPA, Mybatis 동시 사용시 발생할 수 있는 HikariCP Dead lock 해결 여정 ( feat.OSIV )</a>]]></description><link>https://lts.kr/study/dev-seminar/🍂-jpa,-mybatis-,-dead-lock이슈.html</link><guid isPermaLink="false">study/Dev Seminar/🍂 JPA, Mybatis , Dead Lock이슈.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 03:08:43 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20250314122906.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20250314122906.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[👩‍👧‍👦 marketing Analytics 공통모듈 제작기]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:프로젝트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로젝트</a> <a class="tag" href="https://lts.kr/?query=tag:개발" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#개발</a> <a class="tag" href="https://lts.kr/?query=tag:DB" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#DB</a> <a class="tag" href="https://lts.kr/?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <a class="tag" href="https://lts.kr/?query=tag:AOP" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#AOP</a> <br> <a href="https://lts.kr?query=tag:프로젝트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로젝트">#프로젝트</a> <a href="https://lts.kr?query=tag:개발" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#개발">#개발</a> <a href="https://lts.kr?query=tag:DB" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#DB">#DB</a> <a href="https://lts.kr?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a> <a href="https://lts.kr?query=tag:AOP" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#AOP">#AOP</a> <br>개요 <br>Hello Service의 유입/동작 통계 모듈의 공통화 작업이다.
<br>Spring AOP를 사용하여 구성하였다. <br>
<br>통계 필요 페이지 내에서(front &gt; back)
<br>
<br>쿠키 데이터 페이지 별 최초 진입 확인?
<br>
<br>기존 외부 유입 통계 로직의 단점 해결. <br>확장에 닫혀있음
<br>디테일한 행동 추적 불가능
<br>중복 접근자 처리로직의 부재 <br>
<br>해당 진입시점부터 특정 동작에 대한 모든 타임라인 로그
<br>
<br>레디스 가용 메모리에 대한 한계값 산정.
<br>
<br>URL + 함수명 조합
<br>- 관심사(Aspect)를 분리하여, 각 서비스 메서드에 반복해서 구현하는 것이 아닌, 별도의 Aspect로 관리하여 핵심로직을 공통으로 적용하기 위함이다.
<br>
<br>난수 생성 후 물고있기☑ <br>IP로 추적 <br>
Path를 명시적으로 설정하여 주지 않았을 때, 쿠키가 등록되지 않는 이유
<img alt="Pasted image 20241224144309.png" src="https://lts.kr/사진-및-문서/pasted-image-20241224144309.png" target="_self">
<br>쿠키가 필요한 페이지의 경로가 기본 path와 일치하는 경우(redirect url 이 SP_MARKETING_HIT_TEST1 의 하위 url일 경우)
에는 명시적으로 표시할 필요가 없지만,<br>AOP에서 Front-end 단의 특정 동작 필터링 하기<br>기존<br><img alt="Pasted image 20241226111559.png" src="https://lts.kr/사진-및-문서/pasted-image-20241226111559.png" target="_self"><br>DB<br><img alt="Pasted image 20250102160223.png" src="https://lts.kr/사진-및-문서/pasted-image-20250102160223.png" target="_self"><br>@Pointcut 어노테이션은 컴파일 시점에 고정된 문자열로 정의된 포인트컷 표현식을 기반으로 동작한다.<br>
<br>장점: <br>코드가 간결하고 읽기 쉽다.
<br>Spring의 AOP 인프라를 사용하여 메서드 인터셉션을 쉽게 구현할 수 있다. <br>단점:
- 포인트컷 조건은 컴파일 시점에 고정된다.
- 복잡한 조건이나 동적으로 변경되는 조건을 처리하기 어렵다. -&gt; @Pointcut 등의 조건에 부합하는 Bean객체를 컴파일 시점에 찾아내어 프록시를 감싼다.
<br>
<br>동적 생성: <br>런타임에 프록시를 생성하여 포인트컷과 어드바이스를 동적으로 적용.
<br>StaticMethodMatcherPointcut 또는 DynamicMethodMatcherPointcut을 사용하여 런타임 조건 기반으로 메서드 매칭. <br>장점: <br>런타임 조건에 따라 동적으로 포인트컷 생성 가능.
<br>복잡한 조건과 동적 필터링을 처리하기 용이.
<br>Spring AOP가 아닌 순수 Java 프록시 방식도 지원. <br>단점: <br>코드가 복잡해지고 추가 구현이 필요.
<br>Spring AOP와 동일한 수준의 간결성을 제공하지 않음. <br>-&gt; 해당 프록시 객체를 적용하고 싶은 Bean객체에 매번 생성(등록)해주어야 함.<br>import org.springframework.aop.Pointcut;
import org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;
import org.springframework.aop.support.DefaultPointcutAdvisor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration; @Configuration
public class AopConfig { @Bean public Pointcut customPointcut() { return new CustomPointcut(); } @Bean public CustomAdvice customAdvice() { return new CustomAdvice(); } @Bean public DefaultPointcutAdvisor customAdvisor(Pointcut customPointcut, CustomAdvice customAdvice) { return new DefaultPointcutAdvisor(customPointcut, customAdvice); } @Bean public DefaultAdvisorAutoProxyCreator proxyCreator() { return new DefaultAdvisorAutoProxyCreator(); }
} <br>
<br>@Pointcut 방식과 동일한 동작: <br>Spring 컨테이너가 관리하는 모든 빈에 대해 조건을 평가하고 프록시를 자동 생성합니다. <br>프록시를 명시적으로 선언할 필요 없음: <br>ProxyFactory처럼 수동으로 프록시를 생성하지 않아도 됩니다. <br>유연성과 효율성 향상: <br>Spring AOP 인프라를 활용하므로, 관리가 용이하고 런타임 성능이 개선됩니다. <br>
<br>BeanPostProcessor: <br>DefaultAdvisorAutoProxyCreator는 Spring의 BeanPostProcessor를 구현한 클래스이다.
<br>Spring 컨테이너는 애플리케이션 컨텍스트에 등록된 모든 BeanPostProcessor를 자동으로 호출하여 빈의 초기화 전후 작업을 수행한다.
<br>이를 통해, Spring AOP는 빈 생성 단계에서 프록시를 생성하고 조건에 맞는 빈에 대해 어드바이저를 적용. <br>Advisor 탐색: <br>DefaultAdvisorAutoProxyCreator는 Spring 컨텍스트에 등록된 모든 Advisor를 자동으로 탐색한다.
<br>이는 DefaultAdvisorAutoProxyCreator가 BeanFactory를 통해 컨테이너의 모든 Advisor 타입 빈을 조회하기 때문.
<br>탐색된 Advisor를 사용하여 각 빈의 메서드와 포인트컷 조건을 매칭. <br>Advisor와 빈의 매칭: <br>빈이 생성될 때, DefaultAdvisorAutoProxyCreator는 해당 빈의 메서드가 어떤 Advisor의 포인트컷 조건에 부합하는지 평가.
<br>조건에 부합하면, 해당 빈을 프록시 객체로 감싸고, 어드바이스를 연결. <br>위 방법의 문제점? <br>
<br>이렇게 맵핑이 되어야 하나, 이를 동적으로 탐지하지 못한다.
<br>/* * EnableAspectJAutoProxy &gt; 프록시 적용시 인터페이스/클래스 여부 자동 판단 * 클래스에 인터페이스가 있으면 JDK 동적 프록시. * 인터페이스가 없으면 CGLIB 프록시. * */@Configuration @EnableAspectJAutoProxy public class AopConfig { @Bean public Pointcut customPointcut() { return new CustomPointcut(); } @Bean public CustomAdvice customAdvice() { return new CustomAdvice(); } @Bean public DefaultPointcutAdvisor customAdvisor(Pointcut customPointcut, CustomAdvice customAdvice) { return new DefaultPointcutAdvisor(customPointcut, customAdvice); } /* * @EnableAspectJAutoProxy를 사용해 등록했기 때문에 불필요. * */ // @Bean // public DefaultAdvisorAutoProxyCreator proxyCreator() { // return new DefaultAdvisorAutoProxyCreator(); // } }
<br>Method Name: loanerLoginPage
javax.servlet.http.HttpServletRequest
org.springframework.web.bind.annotation.GetMapping <br><img alt="Pasted image 20241226152219.png" src="https://lts.kr/사진-및-문서/pasted-image-20241226152219.png" target="_self"><br>
이후 DB에 맵핑하여 admin에서 자동으로 관리로 변경 됨.
<br><img alt="Pasted image 20241226171158.png" src="https://lts.kr/사진-및-문서/pasted-image-20241226171158.png" target="_self"><br>
<br>외부링크 최초진입. hitCode, hitUid 발급 및 DB저장
<br>
<br>외부링크 재진입. hitCode는 변경될 수 있으므로 "p"파라미터로 재발급
=&gt; hitCode는 매번 재발급 / hitUid는 없을때만 발급
<br>
<br>일반사용자 이며, 아무동작 하지 않는다.
<br>
<br>외부링크 진입 후 동작. 없는 녀석 새로 발급 및 DB저장
<br>서비스 저장시 동시성 이슈가 발생할 수 있다?<br>@Override @Transactional public ResponseModel insertMarketingHitLog(String hitCode, String hitUid, String pageUrl, String pageType){ try { Optional&lt;HfMarketingHitLog&gt; existingLog = hfMarketingHitLogRepository.findByHitCodeAndHitUidAndPageUrlAndPageType(hitCode, hitUid, pageUrl, pageType); if (existingLog.isPresent()) { HfMarketingHitLog logToUpdate = existingLog.get(); logToUpdate.setUpdateDate(LocalDateTime.now()); hfMarketingHitLogRepository.save(logToUpdate); return new ResponseModel(ResponseModel.ResponseStatus.SUCCESS); } HfMarketingHitLog hfMarketingHitLog = HfMarketingHitLog.builder() .hitCode(hitCode) .hitUid(hitUid) .pageUrl(pageUrl) .pageType(pageType) .build(); hfMarketingHitLogRepository.save(hfMarketingHitLog); return new ResponseModel(ResponseModel.ResponseStatus.SUCCESS); } catch (Exception e) { return new ResponseModel(ResponseModel.ResponseStatus.FAILED, "데이터 처리 중 오류 발생"); } }
<br>
<br>여러 쓰레드(또는 트랜잭션)가 findByHitCodeAndHitUidAndPageUrlAndPageType 메서드를 호출하여 동일한 조건의 데이터를 동시에 조회할 수 있다.
<br>두 쓰레드가 모두 existingLog.isPresent() 조건에서 false를 확인한 후, 동시에 새로운 HfMarketingHitLog 객체를 생성하고 저장하려 하면 데이터 중복 문제가 발생할 수 있다.
<br>. Lock을 쓰면 되나, 이후 업데이트 로직 삭제(로그 테이블화) 변경으로 처리<br><img alt="Pasted image 20241230135801.png" src="https://lts.kr/사진-및-문서/pasted-image-20241230135801.png" target="_self"><br>1일의 유효기간을 갖는 uid를 발급하여, 인입코드 / Hit된 기능 주소 / 시간 을 저장한다.
<br>uid는 외부url로 접근시 발급
<br>page_url는 코드에 미리 등록 / hit_code는 모두(only 영문+숫자) 수용 가능
<br><img alt="Pasted image 20250102160213.png" src="https://lts.kr/사진-및-문서/pasted-image-20250102160213.png" target="_self">
<img alt="Pasted image 20250102160223.png" src="https://lts.kr/사진-및-문서/pasted-image-20250102160223.png" target="_self"><br>
<br>enum객체에 정의된 메서드를 DB로 전환하여 pointcut에서 해당 클래스, 메서드를 가져와 조건으로 정의
<br>해당 조건에 부합하는 메서드를 프록시로 전환
<br>
<br>api호출을 통해 advice내의 동작은 런타임 환경에서 동적으로 변경이 가능한 것을 확인했다.
<br>
<br>런타입 위빙 방식이라고 하더라도, 변경은 불가능하다.
<br>컴파일 위빙 방식은 컴파일 단계에서 원본 클래스 바이트코드를 변경하여 직접 위빙을 하는 방식이고,
런타임 위빙은 런타임단계에서 원본 클래스를 변경하지 않고 프록시 객체를 사용하여 교체하는 방식이다.
<br>=&gt; 해당하는 부분은 리빌드와 큰 차이가 없고, 각 class에 scope를 따로 적용해야했기 때문에 고려하지 않았다.<br>=&gt; 연관성 있는 모든 참조를 수동으로 재설정해야하기 때문에 매우 복잡해진다.<br>
<br>참조를 갱신하기 위해서는 Java리플렉션을 사용하여 강제로 참조를 갱신하거나, AspectJ의 런타임 위빙 방식을 활용해야 한다.
<br>따라서, 서버 Kill을 하는 것과 진배 없으며, 권장하지 않는 방법이다.
<br>이슈
내부통계기능(AOP)의 진입URL에서 네이버 아날리틱스(외부 통계 프로그램)가 작동하지 않는 이슈
<br>
<br>외부 유입통계 페이지의 인입 주소는 일반적인 메인 페이지가 아닌, Gate를 거쳐서(redirect) 동작하게 된다.
<br>이 때, 진입 referrer에 변동이 생기면서 집계가 되지 않는 오류가 발생한 것으로 보인다.
<br>
<br>해당 방법을 사용하여, View단을 추가하여 replace한다면, 처음 진입시 갖고 있는 referrer를 물고 갈수 있지 않을까?
<br>redirect대신 view단을 통해 진입하도록 만든 후, naver아날리틱스 스크립트를 추가한다.
<br>한계 : 외부 유입시 불필요한 페이지 방문이 생기게 되고, 유입과정의 시간이 증가한다. 또한, 해당 오류를 100% 해결할지 미지수
<br>
<br>해당 방법은 기존 naver아날리틱스를 사용하고 있는 로직을 그대로 사용하는 것이기 때문에 제일 확실하다.
<br>한계 : 외부유입자가 아닌, 모든 사용자에게 session및 uid체크가 들어가기 때문에 부하가 증가한다.(DB통신은 X)
<br>
<br>BEST🖐
<br>한계 : 네이버 아날리틱스의 내부로직 파악이 불가함
<br>
<br>현재 네이버의 내부 로직 파악이 불가하니, View를 추가하여 네이버 스크립트가 물고 가는지 먼저 TEST하도록 하기
<br>&lt;html xmlns:th="http://www/thymeleaf.org" th:replace="layout/mainLayout :: mainLayout('gate loan')"&gt; &lt;script th:inline="javascript"&gt; $(document).ready(function() { location.href = [[${urls.SP_LOAN}]]; }); &lt;/script&gt;
<br>mainLayout을 적용하여 해당 페이지에 default script를 적용시켰다.
결과는 추후 모니터링 예정<br>Quote
sp/loan기준으로 레퍼러를 https://www-stg.hellofunding.co.kr/sp/loan/gtLoan?p=Z29vZ2xlMXN0 인입페이지 주소를 갖고있는것을 확인했다.
<br>2025-02-25 14:34:04 [hello-app-staging-7985c4d74f-47qnx] INFO com.hellofintech.hellofunding.common.interceptor.ServiceHandlerInterceptor[mergeIntoVisitCount:187] - referer = https://www-stg.hellofunding.co.kr/sp/loan/gtLoan?p=Z29vZ2xlMXN0
<br><img alt="Pasted image 20250226145129.png" src="https://lts.kr/사진-및-문서/pasted-image-20250226145129.png" target="_self"><br>확인 결과이미 sendRedirect 로직에서도 Header의 Referer를 물고있었다.<br>
어떠한 referrer를 기준으로 집계를 하는지 정확한 파악이 필요하다.
<br>]]></description><link>https://lts.kr/project/hello-marketing/👩‍👧‍👦-marketing-analytics-공통모듈-제작기.html</link><guid isPermaLink="false">project/hello marketing/👩‍👧‍👦 marketing Analytics 공통모듈 제작기.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 03:07:16 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20241224144309.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20241224144309.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[프록시]]></title><description><![CDATA[<br><br>프록시(Proxy)는 대리자라는 뜻으로, 다른 객체에 대한 인터페이스 역할을 하는 객체를 말합니다. 프로그래밍에서 프록시는 실제 객체에 접근하기 전에 특정 작업(로깅, 보안, 트랜잭션 관리 등)을 수행하거나, 객체에 대한 접근을 제어하는 데 사용됩니다.<br><br>
<br>대리 객체: 프록시는 실제 객체에 대한 중간다리 역할을 합니다.
<br>동작 조정: 프록시는 요청을 가로채서 추가적인 작업을 수행하거나, 요청을 변형한 뒤 실제 객체에 전달할 수 있습니다.
<br>AOP와 연관: 프록시를 사용하면 코드를 변경하지 않고도 객체의 동작을 확장하거나 변경할 수 있습니다.
]]></description><link>https://lts.kr/짧은-키워드/프록시.html</link><guid isPermaLink="false">짧은 키워드/프록시.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 03:04:08 GMT</pubDate></item><item><title><![CDATA[🏹 예치금 차액 비교 Spring Batch 리펙토링]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:프로젝트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로젝트</a> <a class="tag" href="https://lts.kr/?query=tag:개발" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#개발</a> <a class="tag" href="https://lts.kr/?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <a class="tag" href="https://lts.kr/?query=tag:Batch" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Batch</a> <a class="tag" href="https://lts.kr/?query=tag:Partitioning" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Partitioning</a> <a class="tag" href="https://lts.kr/?query=tag:Chunk" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Chunk</a> <a class="tag" href="https://lts.kr/?query=tag:성능개선" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#성능개선</a> <br> <a href="https://lts.kr?query=tag:프로젝트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로젝트">#프로젝트</a> <a href="https://lts.kr?query=tag:개발" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#개발">#개발</a> <a href="https://lts.kr?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a> <a href="https://lts.kr?query=tag:Batch" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Batch">#Batch</a> <a href="https://lts.kr?query=tag:Partitioning" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Partitioning">#Partitioning</a> <a href="https://lts.kr?query=tag:Chunk" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Chunk">#Chunk</a> <a href="https://lts.kr?query=tag:성능개선" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#성능개선">#성능개선</a> <br>기존 예치금 차액비교 Batch의 Tasklet방식의 배치의 단점을 보완하는 chunk 방식의 배치를 구현하고,
나아가 다른 기능의 Batch에도 효과적으로 빠르게 적용할 수 있는재사용성/유지보수성 높은 코드, 선례를 만들기 위함이다.<br>
<br>Chunk, Partioning방식을 Job을 추가 개발 (기존 balanceJob 유지)
<br>당분간 두 Job을 병행하면서 비교
<br>추가한 Job 기능에 문제없다면 기존 balanceJob 삭제
<br><img alt="회사 은행 서비스1111.png" src="https://lts.kr/사진-및-문서/회사-은행-서비스1111.png" target="_self">
<img alt="Spring Batch Tasklet 예치금 잔액 비교 1.png" src="https://lts.kr/사진-및-문서/spring-batch-tasklet-예치금-잔액-비교-1.png" target="_self">
<img alt="Spring Batch Tasklet 예치금 잔액 비교 잘못된 차액발생 인식 타임라인.png" src="https://lts.kr/사진-및-문서/spring-batch-tasklet-예치금-잔액-비교-잘못된-차액발생-인식-타임라인.png" target="_self"><br>
<br>처음 가져온 Point 배치 완료시 까지 계속 물고있다. -&gt; 한 트렌젝션의 범위가 넓다.
<br>정보 <br>병목이 있진 않으나, 한 배치서비스의 트렌젝션에서 외부 api의 값 변동을 반영하지 못함. <br>
<br>G5-Point 등은 처음 7시 시점에 묶여있다. 회원별로 실데이터를 건건이 api(신한)를 호출하여 비교한다. 때문에, 7시 이후에 수정된데이터를 실시간으로 반영하지 못한다.
<br>
<br>목적 : batch의 step 레벨에서의 스레드 분리 ( 병렬처리 )
<br>
<br>독립적인 ExecutionContext가 주어져 상태를 안전하게 관리할 수 있다.
<br>
<br>목적 : 각 step내의 트렌젝션 단위 분리
<br>Reader / Processor / writer 가 역할을 분담
<br>
<br>
Partition 생성: <br>Partition 1 : ID 1 ~ 25 / 대기열1 : ID 101 ~ 125 / 대기열2 : ID 201 ~ 225
<br>Partition 2 : ID 26 ~ 50 / 대기열 : ID 126 ~ 150 / 대기열2 : ID 226 ~ 250
<br>Partition 3 : ID 51 ~ 75 / 대기열 : ID 151 ~ 175 / 대기열2 : -
<br>Partition 4 : ID 76 ~ 100 / 대기열 : ID 176 ~ 200 / 대기열2 : - <br>
각 Partition에서 Chunk 처리: <br>Partition 1: <br>Chunk 1: ID 1 ~ 10 → 커밋
<br>Chunk 2: ID 11 ~ 20 → 커밋
<br>Chunk 3: ID 21 ~ 25 → 커밋 <br>Partition 2: <br>Chunk 1: ID 26 ~ 35 → 커밋
<br>Chunk 2: ID 36 ~ 45 → 커밋
<br>Chunk 3: ID 46 ~ 50 → 커밋 <br>나머지 Partition도 동일 방식으로 처리. <br>
병렬 실행: <br>스레드 풀 크기 = 4이므로 4개의 Partition이 동시에 실행됩니다.
<br>Partition 처리 순서는 스레드 풀에서 처리되는 순서에 따라 다를 수 있음. <br>
트랜잭션 관리: <br>각 Partition은 독립적인 트랜잭션을 가짐.
<br>각 Chunk가 커밋될 때마다 트랜잭션이 종료됨. <br>
<br>
Partition 생성: <br>Partition 1 : ID 1 ~ 25 / 대기열1 : ID 101 ~ 125 / 대기열2 : ID 201 ~ 225
<br>Partition 2 : ID 26 ~ 50 / 대기열 : ID 126 ~ 150 / 대기열2 : ID 226 ~ 250
<br>Partition 3 : ID 51 ~ 75 / 대기열 : ID 151 ~ 175 / 대기열2 : ID 251 ~ 275
<br>Partition 4 : ID 76 ~ 100 / 대기열 : ID 176 ~ 200 / 대기열2 : ID 276 ~ 300
<br>추가 스레드 풀 생성
<br>Partition 5 : ID 300 ~ 325 / 대기열 : ID 326 ~ 350 / 대기열2 : ID 351 ~ 375
<br>추가 스레드 풀 생성
<br>Partition 6 : ID 376 ~ 400 / 대기열 : ID 401 ~ 425 / 대기열2 : ID 426 ~ 450 모든 대기열 소모 및 최대 스레드 풀 도달 =&gt; 작업 중단 및 오류 <br>-&gt; 이로볼때, 쿼리작업보다 api호출작업의 소요시간이 길어보임<br>범위 - 2017-11-07 ~ 2017-12-01
startDate=2017-11-07&amp;endDate=2017-12-01 ## 컬럼 개수 - 292개 기존 병렬처리 : 1분 7초
기존로직 : 6분 32초 t:스레드 개수 / c:각 스레드별 청크 파티션 수 ###### SimpleAsyncTaskExecutor vs ThreadPoolTaskExecutor SimpleAsyncTaskExecutor
g4/c10 : 1분 41.586초
g5/c10 : 1분 30.037초
g5/c3 : 1분 28.997초
g5/c1 : 1분 29.931초
g8/c10 : 1분 36.019초
g10/c1 : 1분 24.529초 - ThreadPoolTaskExecutor
Th min/maxSize64, g64/c10 : 1분 42.848초
Th min/maxSize32, g32/c10 : 1분 26.551초 Th min/maxSize16, g16/c10 : 1분 46.753초 / 1분 33.779초 / 2분 25.759초
1분 11.668초 / 2분 5.773초 / 2분 39.553초 Th min/maxSize32, g8/c20 : 3분 25.743초 Th min/maxSize16, g4/c10 : 2분 29.207초 / 2분 8.004초
<br>
<br>Grid사이즈(파티셔닝 갯수) 만큼 스레드 풀 계속 생성
<br>파티셔닝 갯수가 많아졌을 때, 스레드 생성/소멸에 드는 오버헤드 증가
<br>
<br>최소 스레드풀 개수 / 최대 스레드풀 개수 / 대기열 큐 크기 / 유휴 시간 모두 설정가능
<br>파티셔닝 갯수가 많을 경우, 처리 성능에 맞는 스레드 풀에서 대기작업으로 처리하여 오버헤드 감소
<br>
<br>총 처리량 기준 1/n로 각 스레드에 할당시 충분히 감당한 양으로, 대기열을 사용할 필요가 없다.
<br>
<br>쿼리 호출 및 페이징 기법 직접 구현
<br>
<br>Native Query 형태로 호출하여 자동 페이징
<br>
<br>Spring Batch에서는 공식적으로 지원하지 않음
<br>자동 페이징
<br>Querydsl형태로 쿼리 호출 가능
<br>
<br>기존(헬로)의 Querydsl기반 JPAQuery를 그대로 사용 가능
<br>자동 페이징
<br>그 외 Querydsl의 장점 보유
<br>
<br>기존 PagingItemReader의 메서드를 오버라이딩 하여 사용하며,
JPQL이 수행되던 부분에 코드를 수정하였다.
<br>@Bean @Scope(value = "step", proxyMode = ScopedProxyMode.TARGET_CLASS) public QuerydslPagingItemReader&lt;HfbatBankBalanceCheckDto&gt; balanceReader() { ExecutionContext jobContext = Objects.requireNonNull(StepSynchronizationManager.getContext()).getStepExecution().getJobExecution().getExecutionContext(); Date startDate = (Date) jobContext.get(START_DATE_KEY); Date endDate = (Date) jobContext.get(END_DATE_KEY); return new QuerydslPagingItemReader&lt;&gt;( entityManagerFactory, executionOrder, DEFAULT_CHUNK_SIZE, queryFactory -&gt; repository.newFindChangeBalanceMemberList( startDate, endDate )); }
<br>
<br>각 파티션 스레드 별 종료 시간이 크게 상이하다. 총 소요시간 기준 최대 약 20% 차이
<br>적용 한다면, 각 스레드 별로 even하게 작업을 수행하여 총 소요시간을 줄일 수 있을것이라 판단 <br>JOB private static AtomicLong executionOrder = new AtomicLong(0); ... new QuerydslPagingItemReader&lt;&gt;( entityManagerFactory, executionOrder, DEFAULT_CHUNK_SIZE, queryFactory -&gt; repository.newFindChangeBalanceMemberList( startDate, endDate ));
<br>job 레벨에서의 스레드 세이프한 전역 변수를 생성하였다.
<br>그 후, 각 파티션 별 리더에 인자값으로 넘긴다.
<br>long currentExecutionOrder = executionOrder.getAndIncrement(); long startIndex = (currentExecutionOrder) * getPageSize(); int totalRecords = stepContext.getInt("totalRecords"); if (startIndex &gt;= totalRecords) { initResults(); // 빈 결과로 초기화 tx.commit(); return; } int chunkSizeToRead = Math.min(getPageSize(), (int) (totalRecords - startIndex)); // 남은 데이터 크기만큼 읽기 // QueryDSL Query 생성 JPQLQuery&lt;T&gt; query = createQuery() .offset(startIndex) .limit(chunkSizeToRead);
<br>
<br>먼저 한 청크단위의 작업을 끝낸 파티션은 그 다음 작업을 즉시 할당받게 된다.
<br>즉, 총 처리시간 기준 가장 빨리끝난 파티션과 가장 늦게 끝난 파티션의 실행 시간 차이는 최대 한 청크사이즈를 처리하는 시간보다 크지 않게 된다.
<br>1차 비교 이후 차액이 발생한 녀석들의 List 를 한번 더 검증한 후, =&gt; 추후 변경 됨
검증된 녀석들을 <br>List&lt;BalanceCheckResultDto&gt; realDiffList= new ArrayList&lt;&gt;();
<br>최종적인 차액 리스트에 넣는다.<br>writer는 각 프로세서의 리턴으로 받은 녀석들을 하나의 DTO List로 합쳐 메세징 처리를 하게 된다.<br>
<br>유지보수성이 좋다.
<br>환경셋팅에 리소스가 많이든다. <br>
<br>구현 레벨이 가장 쉽다
<br>DTO(데이터)가 많아질 경우, 큰 리소스를 차지한다.
<br>
<br>방법 2.보다는 리소스가 적지만, 문자열 처리 시간이 추가로 소모된다.
<br>
<br>높은 쓰기 성능을 갖고있다.
<br>동시성 문제 없이 다중 스레드에서 사용 가능하다.
<br>인덱스로 접근이 불가능하다.
<br>QueueManager클래스를 생성하며 공통으로 사용 가능하도록 하였고,<br>@Slf4j public class QueueManager&lt;T&gt; { protected final ConcurrentLinkedQueue&lt;T&gt; sharedQueue = new ConcurrentLinkedQueue&lt;&gt;(); // 데이터 추가 public void addItemToSharedQueue(T item) { if (item != null) { sharedQueue.add(item); } }
<br>이를 상속받아 특정 오브젝트를 넘길 수 있도록 하였다.<br>public class BalanceQueue extends QueueManager&lt;BalanceCheckResultDto&gt;{ public List&lt;BalanceCheckResultDto&gt; getDtoFromQueue() { return super.getItemsFromQueue(); } }
<br><img alt="Pasted image 20241217150339.png" src="https://lts.kr/사진-및-문서/pasted-image-20241217150339.png" target="_self"><br>리스너에 너무 많은 역할이 부여된 모습
<br><img alt="Pasted image 20241219145746.png" src="https://lts.kr/사진-및-문서/pasted-image-20241219145746.png" target="_self"><br>
<br>StepExecution-Level ExecutionContext <br>
각 Step에 고유한 ExecutionContext가 생성됩니다. <br>
Step 내의 Reader, Processor, Writer 등에서 공유됩니다. <br>
다른 Step과는 공유되지 않습니다. <br>
balanceWorkerStep 내에서는 Reader, Processor, Writer가 동일한 ExecutionContext를 공유합니다. <br>
balancePartitionStep과 balanceWorkerStep의 ExecutionContext는 서로 독립적입니다. <br>JobExecution-Level ExecutionContext <br>Job 전체에서 공유되며, 모든 Step이 동일한 ExecutionContext에 접근할 수 있습니다.
<br>JobExecutionContext는 Step 간 데이터 전달이 필요할 때 유용합니다. <br>JobExecutionListener 객체 생성<br>@Slf4j public class JobTimerExecutionListener implements JobExecutionListener { private final String jobName; private long startTime = System.currentTimeMillis(); public JobTimerExecutionListener(String jobName) { this.jobName = jobName; } @Override public void beforeJob(JobExecution var1) { startTime = System.currentTimeMillis(); } @Override public void afterJob(JobExecution var1) { long endTime = System.currentTimeMillis(); long elapsedTime = endTime - startTime; long minutes = (elapsedTime / 1000) / 60; // 밀리초를 분으로 변환 double seconds = (elapsedTime / 1000.0) % 60; // 남은 밀리초를 초로 변환 (소수점 포함) log.info("{}-completed: {} ms | {} minutes {} seconds", jobName, elapsedTime, minutes, seconds); } }
<br>
<br>평균 소요시간: 약 17.35분
<br>최대 소요시간: 22분
<br>최소 소요시간: 12분
<img alt="output (1).png" src="https://lts.kr/사진-및-문서/output-(1).png" target="_self">
<br><img alt="output (9) 1.png" src="https://lts.kr/사진-및-문서/output-(9)-1.png" target="_self"><br><img alt="output (10).png" src="https://lts.kr/사진-및-문서/output-(10).png" target="_self"><br><img alt="do-messenger_screenshot_2024-12-23_14_40_21.png" src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2024-12-23_14_40_21.png" target="_self"><br><img alt="Pasted image 20241224093159.png" src="https://lts.kr/사진-및-문서/pasted-image-20241224093159.png" target="_self">
<img alt="Pasted image 20241224093207.png" src="https://lts.kr/사진-및-문서/pasted-image-20241224093207.png" target="_self">
<img alt="Pasted image 20241224093225.png" src="https://lts.kr/사진-및-문서/pasted-image-20241224093225.png" target="_self"><br>]]></description><link>https://lts.kr/project/hello-batch/🏹-예치금-차액-비교-spring-batch-리펙토링.html</link><guid isPermaLink="false">project/hello Batch/🏹 예치금 차액 비교 Spring Batch 리펙토링.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 02:32:48 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/회사-은행-서비스1111.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/회사-은행-서비스1111.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🍧 JPA의 영속성 상태와 데이터 Log 이슈]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:SQL" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SQL</a> <a class="tag" href="https://lts.kr/?query=tag:JPA" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#JPA</a> <a class="tag" href="https://lts.kr/?query=tag:이슈" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#이슈</a> <a class="tag" href="https://lts.kr/?query=tag:log" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#log</a> <a class="tag" href="https://lts.kr/?query=tag:로그" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#로그</a> <br> <a href="https://lts.kr?query=tag:SQL" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SQL">#SQL</a> <a href="https://lts.kr?query=tag:JPA" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#JPA">#JPA</a> <a href="https://lts.kr?query=tag:이슈" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#이슈">#이슈</a> <a href="https://lts.kr?query=tag:log" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#log">#log</a> <a href="https://lts.kr?query=tag:로그" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#로그">#로그</a><br>업무 중 한 가지 이슈가 있었고, JPA의 영속상태와 동작원리에 대해서 자세히 짚고 넘어가야할 필요가 있다고 느껴
해당 글을 쓰게 되었다.<br>상황은 다음과 같다.<br>신한은행의 계좌잔액(예치금)과 입금내역을 관리하는 DB의 계좌 잔액간의 차액이 발생했다는 알림을 받았다. <br>원인을 찾기위해 신한 전문을 쌓는 log테이블과, 회원 입급내역 log테이블을 비교하였다.
<br>이떄, 신한DB 에는 같은 금액의 중복 log가 없으나, 입금 내역 DB에는 차액만큼의 중복 입금 log를 발견할 수 있었다. <br>차액이 138만원 발생했다고 가정했을 때,<br>입금내역DB에는 10시 / 11시 총 2개의 138만원 입금내역이 LOG로 남아있었다. <br>여기서 해당 입금내역이 차액을 발생시켰을 것으로 예상할 수 있었다. <br>
<br>실제 신한의 전문을 저장하는 DB에는 11시의 입금내역만이 존재하고 있었다.
<br>
<br>신한 측문의 결과 입금에 문제가 생겼을 경우 해당 입금 전문을 동일하게 한 번 더 보낸다는 사실을 알 수 있었다. <br>보통의 상황이라면, 동일한(id값 동일) 전문을 받아 DB에 insert된다면 SQL Exception이 터졌을 것이라 생각하였다.
하지만 상황으로 미루어 볼때, insert가 아닌 update가 동작했을 것으로 예상할 수 있다.<br>해당 Insert쿼리는 Spring DATA JPA의 SAVE메서드로 구현되어있다.
<br>첫번째 save 후 두 번째 save동작 까지, 1시간의 시간 차이가 있다.
<br>트렌젝션이 종료된 이후(commit)임에도 기존의 id를 기억하여 update를 할 수 있었던 이유가 무었일까?<br>영속상태에 관한 관련된 또 다른 이슈.<br>영속성 컨텍스트에 대한 설명.<br><img alt="Pasted image 20250519144842.png" src="https://lts.kr/사진-및-문서/pasted-image-20250519144842.png" style="width: 700px; max-width: 100%;" target="_self"><br>
<br>아래 코드의 실행 결과로 알 수 있듯이, 비영속 상태의 엔티티를 save()하여 persist()를 수행했을 때, DB에 이미 동일한 ID(PK)가 있다면 예외를 발생시킨다.
<br>@Autowired private EntityManager em; @Test @Transactional void MemberPersistenceTest() { // 1) 새 엔티티 인스턴스 생성 → Transient 상태 HfMarketingCode testcode = new HfMarketingCode(); testcode.setHitCode("testCode1"); testcode.setCodeName("testName1"); em.persist(testcode); em.flush(); }
<br><img alt="Pasted image 20250520142253.png" src="https://lts.kr/사진-및-문서/pasted-image-20250520142253.png" target="_self"><br>주의
영속성 컨텍스트에 등록할 객체의 id 설정의 @GeneratedValue(strategy = GenerationType.IDENTITY)<br>
여부에 따라 주의해야 할 사항이 있다. <br>지연 쓰기가 동작하지 않을 수 있다. 기본키 생성에 대한 권한을 DB에 위임하기 때문에, JPA가 곧바로 id값을 알기위해 지연하지 않고, 바로 insert쿼리를 실행시킨다(IDENTITY 방식의 경우). <br>id값을 명시적으로 지정한 후, save()를 수행하면 예외가 발생한다. 그 이유는, 명시적으로id를 지정하는 순간 non-null의 id값을 갖게되고, isNew()의 첫 호출부터 id가 null이 아니기 때문에, 기존에 존재하는 id값에 대해 persist를 수행하게 되어 예외가 발생하는 것이다. <br>아래는 JPA save()의 isNew() 분기문<br>@Transactional public &lt;S extends T&gt; S save(S entity) { Assert.notNull(entity, "Entity must not be null."); if (this.entityInformation.isNew(entity)) { this.em.persist(entity); return entity; } else { return this.em.merge(entity); } }
<br>질문?
동일한 idx(pk)의 엔티티를 넘겨 save동작을 수행했을 때, persist(insert) 가 아닌 merge(update) 가 되었다면,<br>
해당 엔티티의 영속 상태는 어떻게 되는가?
<br>
엔티티 메니저는 트렌젝션이 종료될때 close되며, 이때 모든 영속석 컨텍스트에 등록된 엔티티를 준영속 상태로 돌린다.
따라서, 준영속 상태로 관리되고 있던 객체에 save() 연산이 수행되면서, update쿼리가 실행된 것.
<br>그렇다면 준영속 상태의 지속 범위는 어떻게 될까?<br>보통 엔티티 객체가 준영속 상태로 진입하게 되면, 엔티티 매니저와 모든 의존성을 끊기 때문에 일반적인 POJO 객체와 같이 GC(가비지 컬렉터) 에 의해 메모리를 해제하게 된다.
<br>그럼에도 1시간의 시간 차가 발생했음에도 GC로 정리가 되지 않은 부분은 조금 의아하다.
<br>해당 부분은 더 깊게 찾아보야 할것으로 보인다.
<br>
<br>
위에서 다음과 같이 표현한 부분이 있다. 이는 불가능하다는 것을 알게 되었다.. “ 비영속 상태의 엔티티를 save()하여 persist()를 수행했을 때,
DB에 이미 동일한 ID(PK)가 있다면 예외를 발생시킨다 ” <br>
물론, 이미 존재하는 id값을 갖는 엔티티를 persist()하면 pk중복 예외가 방생하는 것은 맞다. 영속성 컨텍스트에 등록여부를 판단 할 뿐, id값의 유뮤를 따지지(select하지) 않기 때문이다. <br>
하지만 이러한 상황이 발생하는 것이 정상적인 상황에서 불가능하다. <br>
그 이유에 대해서 설명하겠다. <br>: Assigned(사용자 id 직접 지정) 전략일 때, id == null or 0 일때만 “새 엔티티로써 판단한다.”<br>public boolean isNew(T entity) { ID id = this.getId(entity); Class&lt;ID&gt; idType = this.getIdType(); if (!idType.isPrimitive()) { return id == null; //null 이거나, } else if (id instanceof Number) { return ((Number)id).longValue() == 0L; //0 일때만 새로운 객체로 판단 } else { throw new IllegalArgumentException(String.format("Unsupported primitive id type %s", idType)); } }
<br>하지만 이때, Assigned으로 직접 id에 값을 어플리케이션에서 직접 지정했다면, (id값을 포함한 엔티티)
persist()가 아닌 merge()로 넘어갈 수밖에없게 된다는 것이다.<br>: JPA의 save()는 단순히 insert와 update의 통합이 아니다. 각 동작의 원리와 특성을 파악하여 예외사항을 정확히 판단하여 결과를 예상 가능하도록 설계해야한다.]]></description><link>https://lts.kr/issue_troubleshooting/🍧-jpa의-영속성-상태와-데이터-log-이슈.html</link><guid isPermaLink="false">Issue_TroubleShooting/🍧 JPA의 영속성 상태와 데이터 Log 이슈.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 02:26:06 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20250519144842.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20250519144842.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[영속성 컨텍스트]]></title><description><![CDATA[<br><br><br><br>- 엔티티를 영구적으로 저장하는 환경
- 앱과 DB사이의 객체를 보관하는 가상의 DB역할
- **엔티티 메니저**를 통해 저장하거나 조회한다.
<br><br><br><br><br>
<br>엔티티 매니저를 생성할 때 하나 만들어진다.
<br>엔티티 매니저를 통해서 영속성 컨텍스트에 접근하고 관리할 수 있다.
<br><br><br>JPA의 save() 함수는?
save()함수는 내부적으로 isNew(Entity)연산을 수행하여,<br>
해당 엔티티가 신규로 등록되는 엔티티이면 persist()를, 기존에 존재하는 엔티티면 merge()를 수행한다.
<br>+JPA의 FlushMode.AUTO(기본)에서는 “현재 컨텍스트에 반영된 변경 사항을쿼리 실행 전에 DB에 동기화(flush) 한다.<br>1 - HfMarketingCode A = new HfMarketingCode(); 2 - A.setHitCode("testCode1"); 3 - A.setCodeName("testName2"); 4 - hfMarketingCodeRepository.save(A); 5 - HfMarketingCode B = hfMarketingCodeRepository.findAllByHitCode("testCode1");
<br>
<br>testCode1을 id로 갖는 testName1의 값을 testName2로 바꿀때, 4번이 아닌, 5번 시점에 update가 발생한다.
<br><br><br><br><br><br>// 객체를 생성한 상태 (비영속)
Member member = new Member();
// 객체의 값 변경해도 영속상태에 영행 X
member.setName("이태성");
<br><br>// 객체를 생성한 상태(비영속)
Member member = new Member();
member.setName("이태성"); EntityManager em = emf.createEntityManager();
em.getTransaction().begin();
//엔티티 매니저를 사용하여 영속상태로 등록
em.persist(member);
<br><br>// 엔티티 매니저를 사용하여 영속상태를 분리 -&gt; 준영속 상태
em.detach(member);
<br>
<br>메모리에 식별자 값을 갖고는 있지만, 영속성 컨텍스트의 어떠한 동작도 하지 않느 상태
<br><br>// 엔티티 매니저를 사용하여 영속상태를 상태 -&gt; 삭제 상태
em.remove(member); // 영속성 컨텍스트를 비워도 관리되던 엔티티는 준영속성 상태가 된다.
em.clear(); // 영속성 컨텍스트를 종료해도 관리되던 엔티티는 준영속 상태가 된다.
em.close();
<br>
<br>영속성 컨텍스트를 비우거나(Clear) 종료해도(Close) 엔티티는 삭제되지 않는다(→ 준영속상태가 된다)
<br>오직 삭제(Remove)를 통해서만 영속상태를 삭제상태로 변경할 수 있다.
<br><br><br><br><br><br>
<br>영속 상태의 엔티티를 1차 캐쉬에 저장하여, 같은 엔티티를 조회할시 DB에서 재조회 하지 않아도 된다.
<br><br>Member a = em.find(Member.class, "A");
Member b = em.find(Member.class, "A"); System.out.println(a==b) // true
<br>
<br>1차 캐시로 격리 수준을 DB가 아닌 애플리케이션 차원에서 제공해 줄 수 있다.
<br><br>EntityManager em = emf.createEntityManager();
EntityTransaction transaction = em.getTransaction(); transaction.begin(); // 트렌젝션 시작 em.persist(memberA);
em.persist(memberB); // 커밋하는 순간 데이터베이스에 INSERT SQL을 보낸다.
transaction.commit(); // 트렌젝션 커밋
<br>영속성 컨텍스트에서 관리하는 객체는 수정되어도 DB에 바로 Insert 쿼리를 날리지 않는다.
SQL 쿼리들을 모아놓았다가 flush(커밋) 될 때 모아둔 쿼리를 모두 날린다.<br><br>EntityManager em = emf.createEntityManager();
EntityTransaction transaction = em.getTransaction();
transaction.begin(); // 영속 엔티티 조회
Member member = em.find(Member.class, "A"); // 영속 엔티티 데이터 수정
member.setName("이태성");
member.setJob("프로그래머"); transaction.commit(); // [트랜잭션] 커밋
<br>
<br>엔티티매니저에서 엔티티를 find()후 해당 객체의 값을 수정 후 커밋하면 어떻게 될까?
<br>따로 save나 update문이 없어 변경이 적용되지 않을것 같지만, 자동으로 변경점을 감지하여 반영된다.
<br>변경감지는 지연쓰기또한 동작한다.
<br><br><br>
<br>flush()는 영속성 컨텍스트의 변경 내용을 DB에 반영하는 행위이다. <br>플러시의 흐름<br>
<br>변경 감지가 동작해서 스냅샷(트렌젝션의 시작 시점)과 비교해서 변경점을 찾는다.
<br>변경된 엔티티에 대해서 수정 쿼리를 만들고 SQL 저장소에 등록한다.
<br>쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 반영한다.
<br>트랜잭션 커밋시 자동 호출
<br>JPQL 쿼리 실행 시 자동 호출
<br>em.flush()
]]></description><link>https://lts.kr/짧은-키워드/영속성-컨텍스트.html</link><guid isPermaLink="false">짧은 키워드/영속성 컨텍스트.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 21 May 2025 02:01:25 GMT</pubDate></item><item><title><![CDATA[🏠 taesung's Blog]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:home" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#home</a> <a class="tag" href="https://lts.kr/?query=tag:index" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#index</a> <a class="tag" href="https://lts.kr/?query=tag:blog" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#blog</a> <a class="tag" href="https://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <br> <a href="https://lts.kr?query=tag:home" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#home">#home</a> <a href="https://lts.kr?query=tag:index" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#index">#index</a> <a href="https://lts.kr?query=tag:blog" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#blog">#blog</a> <a href="https://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a><br><a data-tooltip-position="top" aria-label="https://github.com/LeeTaeSung0628" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/LeeTaeSung0628" target="_self"><span alt="prof2.jpg" src="prof2.jpg" class="internal-embed media-embed image-embed is-loaded" style="width: 250px; max-width: 100%;"></span></a><img alt="prof2.jpg" src="https://lts.kr/사진-및-문서/prof2.jpg" style="width: 250px; max-width: 100%;" target="_self"><br><a data-tooltip-position="top" aria-label="https://git.io/typing-svg" rel="noopener nofollow" class="external-link is-unresolved" href="https://git.io/typing-svg" target="_self"></a><img alt="Typing SVG" src="https://readme-typing-svg.demolab.com?font=Fira+Code&amp;pause=1000&amp;color=36A9F7&amp;random=false&amp;width=435&amp;lines=%EC%97%AC%EA%B8%B0%EB%8A%94+%EA%B3%B5%EB%B6%80%ED%95%98%EA%B3%A0%2C+%EA%B8%B0%EB%A1%9D%ED%95%98%EB%8A%94+%EA%B3%B3%EC%9E%85%EB%8B%88%EB%8B%A4" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br>]]></description><link>https://lts.kr/🏠-taesung's-blog.html</link><guid isPermaLink="false">🏠 taesung's Blog.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Tue, 20 May 2025 08:02:26 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/prof2.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/prof2.jpg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🌋 OSIV란 무엇인가]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="https://lts.kr/?query=tag:Java" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Java</a> <a class="tag" href="https://lts.kr/?query=tag:JPA" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#JPA</a> <a class="tag" href="https://lts.kr/?query=tag:OSIV" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#OSIV</a> <a class="tag" href="https://lts.kr/?query=tag:영속성컨텍스트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#영속성컨텍스트</a> <br> <a href="https://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="https://lts.kr?query=tag:Java" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Java">#Java</a> <a href="https://lts.kr?query=tag:JPA" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#JPA">#JPA</a> <a href="https://lts.kr?query=tag:OSIV" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#OSIV">#OSIV</a> <a href="https://lts.kr?query=tag:영속성컨텍스트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#영속성컨텍스트">#영속성컨텍스트</a><br>
<br>OSIV란 View에 데이터를 전달할 때 지연 로딩 등의 이유로 영속성 컨텍스트를 지속해야 하는 경우에 사용되는 옵션이다.
<br>즉, 영속성 컨택스트(앤티티 매니저)의 생명주기를 웹 요청이 끝날 때 까지 연장하는 옵션이다.
이 설정은 어플리케이션에 별다른 설정을 하지 않았다면 default ON 상태이다.<br>서버 실행 시 아래와 같은 로그를 확인할 수 있다.<br>spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering.Explicitly configure spring.jpa.open-in-view to disable this warning
<br><img alt="Pasted image 20250314152143.png" src="https://lts.kr/사진-및-문서/pasted-image-20250314152143.png" target="_self"><br>
OpenSessionInViewFilter 초기화 <br>OpenSessionInViewFilter는 Hibernate(JPA객체)세션을 요청 전체 처리동안 열어두기 위한 서블릿 필터이다.
<br>해당 필터는 sessionFactory의 openSession메서드를 호출하여 새로운 Hibernate세션을 얻는다. <br>
요청 처리 시작 <br>doFilter 메서드가 FilterChain 객체에 의해 호출되어 요청의 계속 처리를 허용한다. <br>
DispatcherServlet 및 컨트롤러 호출 <br>DispatcherServlet이 호출되어 HTTP 요청을 기본 컨트롤러(여기서는 PostController)로 라우팅한다. <br>
서비스 레이어 트랜잭션 <br>PostController는 PostService를 호출하여 Post 엔터티 목록을 가져온다. <br>PostService는 새로운 트랜잭션을 시작하며, HibernateTransactionManager OpenSessionInViewFilter에서 열린 동일한 Hibernate 세션을 재사용한다. <br>
데이터 액세스 레이어 <br>PostService는 PostDAO (데이터 액세스 객체)에게 Post 엔터티 목록을 가져오도록 위임한다. <br>PostDAO는 어떠한 게으른 연관성도 초기화하지 않고 Post 엔터티 목록을 검색한다. 게으른 연관성은 Hibernate에서 즉시 가져오지 않고 필요할 때 로드되는 관계이다. <br>
트랜잭션 커밋<br>
- PostService는 기본 트랜잭션을 커밋한다. 그러나 세션이 외부에서 열렸기 때문에( OpenSessionInViewFilter에서), 이 시점에서 세션은 닫히지 않는다.
주의
트렌젝션은 커멧 되더라도 오픈 세션(영속성 컨텍스트) 은 닫히지 않는다! <br>
뷰 렌더링 시작 <br>DispatcherServlet이 사용자 인터페이스 (UI)를 렌더링하기 시작한다. <br>
게으른 연관성 초기화 <br>렌더링 과정 중에 UI는 Post 엔터티의 게으른 연관성을 탐색한다. <br>이 탐색은 게으른 연관성의 초기화를 트리거하며 추가적인 데이터베이스 쿼리를 날린다. <br>Lazy Loading이 일어나는 시점
<br>세션 닫힘 <br>OpenSessionInViewFilter는 이제 Hibernate 세션을 닫을 수 있습니다. 렌더링 프로세스가 완료되었기 때문이다. <br>세션과 관련된 데이터베이스 연결이 해제된다. <br>
<br>
JPA의 영속성 컨텍스트가 DB커넥션을 얻는 시점은 DB트렌젝션을 시작할 때 이다.
@Transactional 어노테이션이 붙은 매서드가 실행될 때.
-없다면, 해당 JPA쿼리(Repository JPA 조회 메서드에 자동으로 트렌젝션 부여)가 실행되는 시점에 얻게 된다. <br>
DB커넥션을 반환하는 시점은 서비스 레이어의 @Transactional어노테이션이 붙은 메서드가 끝날때 이다.
이 떄, 영속성 컨텍스트가 사라지고 DB커넥션이 반환된다. <br>즉, 한 컨트롤러 안에서 여러개의 서비스 레이어의 함수를 여러개 실행할 경우,
각각의 메서드마다 영속성 컨텍스트가 생기고 사라지게 된다.<br>해당 방식은 DB커넥션을 최소한으로만 사용하기 때문에 트레픽이 중요한 경우 유연하고 효율적이다.<br>
<br>
JPA가 영속성 컨텍스트를 얻는 시점은 동일하다.
@Transactional 어노테이션이 붙은 매서드가 실행될 때.
-없다면, 해당 JPA쿼리가 실행되는 시점에 얻게 된다. <br>
DB커넥션을 반환하는 시점은
-api의 경우 : 데이터가 유저에게 반환될 때 까지.
-tamplate으로 갈 경우 : 모든 데이터가 렌더링 되어 출력될 때 까지. <br>즉, @Transactional메서드가 끝날 떄 즉시 반환하지 않고 프록시 객체가 Lazy Loading으로
호출될 수 있기 때문에, 영속성 컨텍스트를 살려 놓는것이다.<br>정보
영속성 컨텐스트는 DB커넥션을 보유해야 유지될 수 있다.
<br>해당 방식은 개발적인 측면에서 중복을 줄이고, 지연로딩을 사용할 수 있어 코드의 유지보수성에 큰 도움을 주지만, DB커넥션을 오래 물고 있기 때문에 자칫 성능적인 장애를 일으킬 수 있다.]]></description><link>https://lts.kr/study/cs/🌋-osiv란-무엇인가.html</link><guid isPermaLink="false">study/CS/🌋 OSIV란 무엇인가.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Mon, 19 May 2025 05:31:44 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20250314152143.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20250314152143.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🚞 Java 대용량 Excel 리펙토링]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:프로젝트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로젝트</a> <a class="tag" href="https://lts.kr/?query=tag:개발" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#개발</a> <a class="tag" href="https://lts.kr/?query=tag:JAVA" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#JAVA</a> <a class="tag" href="https://lts.kr/?query=tag:Excel" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Excel</a> <a class="tag" href="https://lts.kr/?query=tag:엑셀" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#엑셀</a> <a class="tag" href="https://lts.kr/?query=tag:성능개선" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#성능개선</a> <a class="tag" href="https://lts.kr/?query=tag:리펙토링" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#리펙토링</a> <br> <a href="https://lts.kr?query=tag:프로젝트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로젝트">#프로젝트</a> <a href="https://lts.kr?query=tag:개발" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#개발">#개발</a> <a href="https://lts.kr?query=tag:JAVA" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#JAVA">#JAVA</a> <a href="https://lts.kr?query=tag:Excel" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Excel">#Excel</a> <a href="https://lts.kr?query=tag:엑셀" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#엑셀">#엑셀</a> <a href="https://lts.kr?query=tag:성능개선" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#성능개선">#성능개선</a> <a href="https://lts.kr?query=tag:리펙토링" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#리펙토링">#리펙토링</a><br>
<br>기존 DataTables기반의 Excel export 기능의 성능 부진으로 인한 리펙토링
<br>클라이언트 → 서버사이드 로의 로직 변경
<br>DataTables 기반의 기존 처리
** DataTables란? HTML 테이블을 동적으로 처리하기 위한 jQuery 플러그인이다.
DataTables의 기능 중 Export 기능이 있는데, 클립보드 복사와 인쇄 등 의 기능도 지원한다.<br>
기존의 Excel출력 기능이 이 DataTables의 Export 기능으로 만들어져 있었다.
<br>
DataTables는 클라이언트 측에서 브라우저 메모리를 사용하여 엑셀 파일을 생성한다.
웹 HTML기반의 `DataTables Buttons`를 사용하여 데이터와 스타일을 엑셀 파일로 변환한다.<br>
<br>브라우저 메모리 한계 <br>브라우저는 서버보다 메모리와 CPU 성능이 낮다.
<br>대용량 데이터를 처리할 때 브라우저가 멈추거나 충돌할 가능성이 크다.
<br>DataTables는 전체 데이터를 메모리에 적재한 후 엑셀로 변환한다.
<br>Ajax로 부분 데이터를 불러오는 서버사이드 모드에서는 현재 페이지 데이터만 엑셀로 변환됩니다.
<br>모든 데이터를 한꺼번에 가져와 처리하면 처리 한계에 도달할 가능성이 더 커진다. <br>ex) 10만 개 이상의 행을 엑셀로 내보내면 브라우저의 메모리 한계를 초과하여 강제로 종료되는 경우가 많다.<br>
<br>파일 변환 속도 <br>JavaScript 기반으로 파일을 생성하는 데 시간이 많이 소요된다.
<br>데이터 변환과 파일 생성이 모두 싱글 스레드로 이루어져 병렬 처리의 이점을 활용하지 못한다. <br>
<br>스타일 커스터마이징의 복잡성 <br>엑셀 스타일을 커스터마이징하는 과정이 복잡하며, XML 직접 수정 방식은 성능 저하를 초래한다.
<br>파일의 구조와 스타일을 모두 제어하려면 JavaScript 메모리 부담이 더욱 커진다. <br>정리
소규모 데이터의 Export에는 간단한 설정으로 빠른 구현이 가능하나.<br>
10만개 이상의 대용량 데이터에서는 한계가 명확하다.
<br>... buttons: [ { extend: 'excel', name: 'Excel', text: 'Excel', filename: '엑셀출력_' + moment().format('YYYYMMDDhhmm'), title: '', action: serverSideButtonAction, customize: function(xlsx) { var sSh = xlsx.xl['styles.xml']; var lastXfIndex = $('cellXfs xf', sSh).length - 1; var sheet = xlsx.xl.worksheets['sheet1.xml']; // 스타일 적용 var n1 = '&lt;xf numFmtId="0" fontId="2" fillId="2" borderId="1" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyAlignment="1"&gt;' + '&lt;alignment horizontal="center"/&gt;&lt;/xf&gt;'; var n2 = '&lt;xf numFmtId="0" fontId="0" fillId="0" borderId="1" applyFont="0" applyFill="0" applyBorder="0" xfId="0" applyAlignment="0"&gt;' + '&lt;alignment horizontal="right"/&gt;&lt;/xf&gt;'; sSh.childNodes[0].childNodes[5].innerHTML += n1 + n2; var greyBoldCentered = lastXfIndex + 1; var value = lastXfIndex + 2; $('c', sheet).attr('s', value); $('row:first c', sheet).attr('s', greyBoldCentered); } }
] <br>
<br>서버의 자원 활용 <br>서버의 메모리와 CPU는 클라이언트보다 월등히 높아 대량 데이터 처리에 유리하다.
<br>서버가 Excel 파일을 직접 생성하여 브라우저에 전송하므로 클라이언트의 부담이 줄어든다. <br>
<br>대용량 데이터 처리 <br>수십만 건 이상의 데이터를 메모리 효율적으로 처리 가능
<br>Apache POI와 같은 라이브러리는 스트리밍 방식으로 데이터를 파일에 직접 기록하여 메모리 과부하를 방지한다.
<br>SXSSFWorkbook를 사용하여 매우 큰 데이터를 처리할 수 있습니다. <br>SXSSFWorkbook란?
Apache POI 라이브러리에서 제공하는 대용량 Excel 파일 생성용 클래스<br>
SXSSFWorkbook은 메모리 절약을 위해 디스크 기반 스트리밍 방식을 사용하여 메모리에 모든 데이터를 올리지 않고, 필요한 부분만 메모리에 유지한다.
<br>
<br>병렬 처리 <br>멀티스레딩을 통해 데이터 수집과 파일 생성을 병렬로 수행할 수 있다.
<br>서버 자원을 최대로 활용하여 성능을 극대화할 수 있다. <br>
<br>직접 파일 다운로드 <br>엑셀 파일을 서버에서 생성하고, URL을 통해 클라이언트가 다운로드 받도록 처리하여 브라우저 부담 최소화.
<br>응답을 스트리밍 방식으로 처리하여 중간에 데이터가 소실되지 않도록 보장한다. <br>
<br>엑셀 파일 처리 클래스
<br>엑셀파일 생성, 데이터 추가, 스타일 적용 등
<br>SXSSFWorkbook방식으로 스트리밍 처리 <br>대용량 처리에 적합
<br>일정 개수 이상의 row를 디스크로 flush
<br>OutOfMemory방지 <br>for (T t : data) { renderBody(t, rowNum, bodyStyle, totalStyle, accumStyle); if (rowNum % 10000 == 0 || rowNum == data.size()) { // 10,000건 마다 flush try { // 마지막 데이터의 경우, 남는 데이터 만큼만 flush, 아닌경우 10,000건씩 플러쉬 workbook.getSheet(sheetName).flushRows(rowNum == data.size() ? data.size() % 10000 : 10000); } catch (IOException e) { throw new BadRequestException(e.getMessage()); } } rowNum++; }
<br>Excel Sheet정보 파라미터로 받아서 초기화
<br>SimpleExcelMetaDataFactory를 이용하여 엑셀 메타데이터를 생성
<br>전체적인 엑셀 다운로드까지의 모든 단계를 포함하고 실제 랜더링해서 셀을 생성하는것
<br>
<br>싱글톤 객체로 생성
<br>엑셀로 출력할 DTO객체의 어노테이션을 파악해 메타데이터 정리
<br>SimpleExcelMetadata객체를 생성하기 위한 기본 틀 제공(헤더, 스타일, 필드 목록 등)
<br>CellStyleMap을 사용하여 각 필드의 스타일을 미리 캐싱 ( 스타일 중복 방지 )
<br>private void applyCellStyle(CellStyleMap cellStyleMap, ExcelColumnStyle fieldStyle, ExcelColumnStyle classDefaultStyle, String fieldName, CellPart part, Workbook workbook) { /* dto 의 field 값에 스타일이 설정되어 있는지 체크 */ boolean styleCheck = fieldStyle.excelCellStyleClass() != NullStyle.class; /* dto 의 field 에 스타일 존재 유무에 따라, ExcelCellKey 의 fieldName 지정 */ String fieldNameKey = styleCheck ? fieldName : "DEFAULT"; /* dto 의 field 에 스타일 존재 유무에 따라 스타일 설정 */ ExcelColumnStyle style = styleCheck ? fieldStyle : classDefaultStyle; ExcelCellKey excelCellKey = ExcelCellKey.of(fieldNameKey, part); /* 해당 키값과 같은 키값을 가진 데이터가 있는 경우 styleMap 에 추가하지 않음 */ if (!cellStyleMap.valueCheck(excelCellKey)) { cellStyleMap.put(decideAppliedStyle(style, workbook), excelCellKey, workbook); } }
<br>스타일, 정보등 dto 어노테이션 필드들을 읽어와서 파악하고, 가공하여 SimpleExcelFile에서 사용하기 쉽게 만드는 역할
<br>
<br>@DefaultExcelHeaderStyle: 엑셀 헤더에 기본 스타일 적용 <br>스타일: HeaderStyle.class <br>@DefaultExcelBodyStyle: 엑셀 데이터 행에 기본 스타일 적용 <br>스타일: BodyStyle.class <br>@DefaultExcelTotalRow: 합계 행에 기본 스타일 적용
<br>@DefaultExcelHeaderStyle(style = @ExcelColumnStyle(excelCellStyleClass = HeaderStyle.class)) @DefaultExcelBodyStyle(style = @ExcelColumnStyle(excelCellStyleClass = BodyStyle.class)) @DefaultExcelTotalRow(style = @ExcelColumnStyle(excelCellStyleClass = TotalRowStyle.class)) public class PgDepositListExcelDto { @ExcelColumn(headerName = "No") private String rowNum; @ExcelColumn(headerName = "회원번호") private String mbNo; @ExcelColumn(headerName = "아이디") private String mbId; @ExcelColumn( headerName = "금액", bodyStyle = @ExcelColumnStyle(excelCellStyleClass = AmountStyle.class), totalRowStyle = @ExcelColumnStyle(excelCellStyleClass = TotalAmountStyle.class) ) private long amt;
<br>실제 객체와 맵핑될 excelDTO객체
<br>SimpleExcelMetaDataFactory에서 @ExcelColumn 어노테이션이 붙은 필드를 수집하여 리스트에 저장<br>public SimpleExcelMetadata createSimpleExcelMetaData( Class&lt;?&gt; type, Workbook workbook, SheetType sheetType, boolean hasGroupHeader) { List&lt;Field&gt; fields = getExcelAnnotatedFields(type); List&lt;String&gt; headerNames = new ArrayList&lt;&gt;(); for (Field field : fields) { ExcelColumn excelColumn = field.getAnnotation(ExcelColumn.class); // 어노테이션 체크 String headerName = excelColumn.headerName(); headerNames.add(headerName); applyCellStyle(cellStyleMap, excelColumn.headerStyle(), null, field.getName(), HEADER, workbook); } return new SimpleExcelMetadata(headerNames, fields, cellStyleMap, groups);
} <br>
<br>엑셀로 출력할 기존 객체 → CustomExcelDto로 파싱 후 simpleExcelWrite로 엑셀 출력
<br>쿼리 데이터 조회시 페이징으로 메모리 관리
<br>// 1) 엑셀 파일 생성 (데이터 -&gt; ExcelFile)
SimpleExcelFile&lt;E&gt; excelFile = new SimpleExcelFile&lt;&gt;( simpleExcelWriteDto.getData(), simpleExcelWriteDto.getType(), simpleExcelWriteDto.getSheetName(), simpleExcelWriteDto.getSheetType() ); // 2) ExcelSetUpDto 간단히 만들어서, 기존 write(...) 메서드 사용 ExcelSetUpDto excelSetUpDto = ExcelSetUpDto.builder() .response(simpleExcelWriteDto.getResponse()) .excel(excelFile.getWorkbook()) .excelPreFileTitle(simpleExcelWriteDto.getPreFileTitle()) .excelFilePath(simpleExcelWriteDto.getFilePath()) .build(); // 3) 한 번에 write
excelFile.write(excelSetUpDto);
<br>case 1<br>입력 : 예치금 입금내역 셀 개수 : 40,000건 출력 : 실패
<br>case 2<br>입력 : 예치금 입금내역 셀 개수 : 5,000건 출력 : 성공
<br><img alt="Pasted image 20250516163401.png" src="https://lts.kr/사진-및-문서/pasted-image-20250516163401.png" target="_self">
case1(4만건) - 메모리 사용율 80% 초과로 인한 순단 발생
<img alt="Pasted image 20250516163522.png" src="https://lts.kr/사진-및-문서/pasted-image-20250516163522.png" target="_self">
이후, case2(5천건) - 메모리 사용율 51%<br>
<br>예치금 입금내역(9개의 속성 X 8,000필드) → 약 7만 셀
<br>test case<br>입력 : 예치금 입금내역 셀 개수 : 70,000건 출력 : 성공
<br>cpu 최대 사용율 17.2%
<br><img alt="Pasted image 20250513101628.png" src="https://lts.kr/사진-및-문서/pasted-image-20250513101628.png" target="_self"><br>메모리 469MB
<br><img alt="Pasted image 20250513101743.png" src="https://lts.kr/사진-및-문서/pasted-image-20250513101743.png" target="_self">
<img alt="Pasted image 20250516154726.png" src="https://lts.kr/사진-및-문서/pasted-image-20250516154726.png" style="width: 725px; max-width: 100%;" target="_self"><br>case1<br>입력 : 예치금 입금내역 셀 개수 : 70,000건 출력 : 성공
<br><img alt="Pasted image 20250516164727.png" src="https://lts.kr/사진-및-문서/pasted-image-20250516164727.png" target="_self">
<img alt="Pasted image 20250516164550.png" src="https://lts.kr/사진-및-문서/pasted-image-20250516164550.png" target="_self">
<img alt="Pasted image 20250516164537.png" src="https://lts.kr/사진-및-문서/pasted-image-20250516164537.png" target="_self">
<img alt="Pasted image 20250516165030.png" src="https://lts.kr/사진-및-문서/pasted-image-20250516165030.png" target="_self"><br>메모리 사용율 약 36%
<br>case2<br>입력 : 예치금 입금내역 셀 개수 : 140,000건 출력 : 성공
<br><img alt="Pasted image 20250516165307.png" src="https://lts.kr/사진-및-문서/pasted-image-20250516165307.png" target="_self">
<img alt="Pasted image 20250516165250.png" src="https://lts.kr/사진-및-문서/pasted-image-20250516165250.png" target="_self">
<img alt="Pasted image 20250516165344.png" src="https://lts.kr/사진-및-문서/pasted-image-20250516165344.png" target="_self"><br>메모리 사용율 약 38%
<br>case3<br>입력 : 예치금 입금내역 셀 개수 : 240,000건 출력 : 성공
<br><img alt="Pasted image 20250516165523.png" src="https://lts.kr/사진-및-문서/pasted-image-20250516165523.png" target="_self">
<img alt="Pasted image 20250516165617.png" src="https://lts.kr/사진-및-문서/pasted-image-20250516165617.png" target="_self">
<img alt="Pasted image 20250516165627.png" src="https://lts.kr/사진-및-문서/pasted-image-20250516165627.png" target="_self"><br>메모리 사용율 약 40%
<br>
<br>예치금 입금내역(9개의 속성 X 666,000필드) → 약 600만 셀
<br>
<br>최대 엑셀 셀 수용량 약 100배 증가.]]></description><link>https://lts.kr/project/🚞-java-대용량-excel-리펙토링.html</link><guid isPermaLink="false">project/🚞 Java 대용량 Excel 리펙토링.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Fri, 16 May 2025 08:56:51 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20250516163401.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20250516163401.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3.1 스프링 컨테이너 생성]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:SpringCoreBasic" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SpringCoreBasic</a> <a class="tag" href="https://lts.kr/?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <a class="tag" href="https://lts.kr/?query=tag:lectur" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#lectur</a> <a class="tag" href="https://lts.kr/?query=tag:강의" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#강의</a> <a class="tag" href="https://lts.kr/?query=tag:컨테이너" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#컨테이너</a> <a class="tag" href="https://lts.kr/?query=tag:Bean" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Bean</a> <a class="tag" href="https://lts.kr/?query=tag:빈" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#빈</a> <br> <a href="https://lts.kr?query=tag:SpringCoreBasic" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SpringCoreBasic">#SpringCoreBasic</a> <a href="https://lts.kr?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a> <a href="https://lts.kr?query=tag:lectur" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#lectur">#lectur</a> <a href="https://lts.kr?query=tag:강의" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#강의">#강의</a> <a href="https://lts.kr?query=tag:컨테이너" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#컨테이너">#컨테이너</a> <a href="https://lts.kr?query=tag:Bean" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Bean">#Bean</a> <a href="https://lts.kr?query=tag:빈" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#빈">#빈</a><br>//스프링 컨테이너 생성
ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
<br>
ApplicationContext 를 스프링 컨테이너라 한다. ApplicationContext 는 인터페이스이다. <br>
스프링 컨테이너는 XML을 기반으로 만들 수 있고, 애노테이션 기반의 자바 설정 클래스로 만들 수 있다. <br>
<br>자바 설정 클래스를 기반으로 스프링 컨테이너(ApplicationContext)를 만들어보자. <br>new AnnotationConfigApplicationContext(AppConfig.class); → AppConfig.class를 파라미터로 넘긴다.
<br>이 클래스는 ApplicationContext 인터페이스의 구현체이다. <br>참고
정확히 스프링 컨테이너 를 부를 때, <br>BeanFactory
<br>ApplicationContext 로 구분해서 불러야 하지만, BeanFactory를 직접 사용하는 경우는 거의 없어,<br>
일반적으로 ApplicationContext를 스프링 컨테이너 라고 부른다.
<br>new AnnotationConfigApplicationContext(AppConfig.class)
<br>해당 코드로 AppConfig.class 파일을 넘기면 스프링 컨테이너가 생성된다.<br><img alt="스크린샷 2025-05-15 오후 10.33.42.png" src="https://lts.kr/사진-및-문서/스크린샷-2025-05-15-오후-10.33.42.png" target="_self">
(스프링 컨테이너가 AppConfig.class의 구성 정보를 확인한 후 스프링 빈을 등록한다.)<br>@Bean
public MemberService memberService() { return new MemberServiceImpl(memberRepository());
}
<br>Bean어노테이션이 붙은 메서드의 이름을 사용하여 빈을 등록한다.
<br><img alt="스크린샷 2025-05-15 오후 10.38.28.png" src="https://lts.kr/사진-및-문서/스크린샷-2025-05-15-오후-10.38.28.png" target="_self"><br>** 빈 이름을 직접 부여할 수 있다. @Bean(name="memberService2")<br>
<br>@Bean이 붙은 메서드로 의존관계를 주입한다.
<br>단순히 자바 코드를 호출하는 것이 아닌, 싱글톤을 통해 객체 1개만 생성하도록 한다,
<br><img alt="스크린샷 2025-05-15 오후 10.41.15.png" src="https://lts.kr/사진-및-문서/스크린샷-2025-05-15-오후-10.41.15.png" target="_self"><br>
<br>스프링은 빈을 생성하고, 의존관계를 주입하는 단계가 나누어져 있다.
<br>class ApplicationContextInfoTest { AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class); @Test @DisplayName("모든 빈 출력하기") void findAllBean() { String[] beanDefinitionNames = ac.getBeanDefinitionNames(); for (String beanDefinitionName : beanDefinitionNames) { Object bean = ac.getBean(beanDefinitionName); System.out.println("name=" + beanDefinitionName + " object=" + bean); } }]]></description><link>https://lts.kr/lectur/3.1-스프링-컨테이너-생성.html</link><guid isPermaLink="false">lectur/3.1 스프링 컨테이너 생성.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Fri, 16 May 2025 08:00:15 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/스크린샷-2025-05-15-오후-10.33.42.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/스크린샷-2025-05-15-오후-10.33.42.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[💻 프로젝트]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:프로젝트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로젝트</a> <a class="tag" href="https://lts.kr/?query=tag:모음" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#모음</a> <br> <a href="https://lts.kr?query=tag:프로젝트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로젝트">#프로젝트</a> <a href="https://lts.kr?query=tag:모음" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#모음">#모음</a><br>프로젝트
public하게 공개할 수 있는 프로젝트의 제작 과정입니다.
<br>
<br><a data-href="🏹 예치금 차액 비교 Spring Batch 리펙토링" href="https://lts.kr/project/hello-batch/🏹-예치금-차액-비교-spring-batch-리펙토링.html" class="internal-link" target="_self" rel="noopener nofollow">🏹 예치금 차액 비교 Spring Batch 리펙토링</a>⭐
<br><a data-href="🏹 예치금 차액 비교 Spring Batch 리펙토링 부록" href="https://lts.kr/project/hello-batch/🏹-예치금-차액-비교-spring-batch-리펙토링-부록.html" class="internal-link" target="_self" rel="noopener nofollow">🏹 예치금 차액 비교 Spring Batch 리펙토링 부록</a>
<br><a data-href="✏ Chunk_Partitioning Batch 구조 드로잉" href="https://lts.kr/project/hello-batch/✏-chunk_partitioning-batch-구조-드로잉.html" class="internal-link" target="_self" rel="noopener nofollow">✏ Chunk_Partitioning Batch 구조 드로잉</a>
<br>
<br><a data-href="👩‍👧‍👦 marketing Analytics 공통모듈 제작기" href="https://lts.kr/project/hello-marketing/👩‍👧‍👦-marketing-analytics-공통모듈-제작기.html" class="internal-link" target="_self" rel="noopener nofollow">👩‍👧‍👦 marketing Analytics 공통모듈 제작기</a>⭐
<br><a data-href="👩‍👧‍👦 Analytics 공통모듈 ADMIN용 데이터 추출" href="https://lts.kr/project/hello-marketing/👩‍👧‍👦-analytics-공통모듈-admin용-데이터-추출.html" class="internal-link" target="_self" rel="noopener nofollow">👩‍👧‍👦 Analytics 공통모듈 ADMIN용 데이터 추출</a>
<br>
<br><a data-href="🚞 Java 대용량 Excel 리펙토링" href="https://lts.kr/project/🚞-java-대용량-excel-리펙토링.html" class="internal-link" target="_self" rel="noopener nofollow">🚞 Java 대용량 Excel 리펙토링</a>
<br>
<br><a data-href="✈MM_클라우드 마이그레이션" href="https://lts.kr/project/melometer-project/✈mm_클라우드-마이그레이션.html" class="internal-link" target="_self" rel="noopener nofollow">✈MM_클라우드 마이그레이션</a>
<br>
<br><a data-href="👻 Obsidian 정적호스팅 CICD 과정" href="https://lts.kr/project/note-ci_cd/👻-obsidian-정적호스팅-cicd-과정.html" class="internal-link" target="_self" rel="noopener nofollow">👻 Obsidian 정적호스팅 CICD 과정</a>
<br>
<br><a data-href="📘 SpringBoot &amp; Docker + Reids 연동" href="https://lts.kr/tools/docker/📘-springboot-&amp;-docker-+-reids-연동.html" class="internal-link" target="_self" rel="noopener nofollow">📘 SpringBoot &amp; Docker + Reids 연동</a>
<br><a data-href="🌥 aws(EC2)셋팅부터 배포까지" href="https://lts.kr/tools/aws/🌥-aws(ec2)셋팅부터-배포까지.html" class="internal-link" target="_self" rel="noopener nofollow">🌥 aws(EC2)셋팅부터 배포까지</a>]]></description><link>https://lts.kr/project/💻-프로젝트.html</link><guid isPermaLink="false">project/💻 프로젝트.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Thu, 08 May 2025 07:21:32 GMT</pubDate></item><item><title><![CDATA[🐹 MSA(Microservices Architecture)]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="https://lts.kr/?query=tag:구조" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#구조</a> <a class="tag" href="https://lts.kr/?query=tag:설계" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#설계</a> <a class="tag" href="https://lts.kr/?query=tag:MSA" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#MSA</a> <a class="tag" href="https://lts.kr/?query=tag:CloudNative" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#CloudNative</a> <br> <a href="https://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="https://lts.kr?query=tag:구조" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#구조">#구조</a> <a href="https://lts.kr?query=tag:설계" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#설계">#설계</a> <a href="https://lts.kr?query=tag:MSA" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#MSA">#MSA</a> <a href="https://lts.kr?query=tag:CloudNative" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#CloudNative">#CloudNative</a><br>
<br>msa는 대규모 애플리케이션을 독립적으로 배포 가능한 작은 서비스들의 집합으로 구성하는 소프트웨어 설계 접근 방식이다.
<br>각 서비스는 특정 비즈니스 기능을 담당하며, 자체 데이터 저장소를 보유하고(선택), 독립적으로 개발 및 배포가 가능하다.
<br>msa는 확장성, 유지보수성, 유연성 향상 등의 이점을 제공하지만 복잡한 운영과 통신 관리 등의 문제도 동반하고있다.
<br>모놀리식 아키텍처(Monolithic Architecture)
모든 기능이 단일 코드베이스에 포함되어 하나의 배포 단위로 운영되는 방식. <br>초기개발과 배포가 빠르고 간단하지만, 애플리케이션이 비대화 될 수록 다음과 같은 문제 발생 <br>확장성 제한: 전체 애플리케이션을 확장해야 하므로 자원 낭비가 발생할 수 있음
<br>배포 리스크 증가: 작은 변경도 전체 시스템의 재배포를 요구하여 위험이 증가
<br>유지보수 어려움: 코드베이스가 커지면 이해와 수정이 어려워짐 <br>MSA는 애플리케이션을 작은 서비스로 분리하여, 각 서비스가 독립적으로 개발, 배포, 확장 될 수 있도록 한다.
즉, 위의 모놀리식 아키텍처의 단점을 모두 보완하는 특징을 갖고 있다.<br>
<br>배포
<br>서비스별 개별 배포가 가능(배포시 전체 서비스의 중단이 없음)
<br>특정 서비스의 요구사항만을 반영하여, 빠르게 배포 가능
<br>확장
<br>특정 서비스에 대한 확장성(scale-out)이 유리하다.
<br>Cloud Native Architecture에 적합하다. <br>장애
<br>일부 장애가 전체 서비스로 확장될 가능성이 적다.(장애 격리가 쉽다)
<br>그 외
<br>새로운 기술을 적용하기 유연하다.(전체 서비스가 아닌 특정 서비스만 별도의 기술 또는 언어로 구현 가능)
<br>각각의 서비스에 대한 구조 파악 및 분석이 모놀리식 구조에 비해 쉽다.
<br>
<br>설계의 어려움
<br>MSA는 모놀리식에 비해 상대적으로 많이 복잡하다. 또한, 통신의 장애와 서버의 부하 등을 고려하여 transaction을 유지할지 결정해야 한다.
<br>성능
<br>서비스 간 호출 시 API를 사용하므로, 통신 비용이나 Latency에 대해 이슈가 존재.
<br>테스트/데이터 트랜잭션
<br>모놀리식에서는 단일 트랜잭션을 유지하면 됐지만 MSA에서는 비즈니스에 대한 DB를 가지고 있는 서비스도 각기 다르고, 서비스의 연결을 위해서는 통신이 포함되기 때문에 트랜잭션을 일관되게 유지하며 개발하는게 어렵다. <br>통합 테스트가 어렵다. 개발 환경과 실제 운영환경을 동일하게 가져가는 것의 어려움 <br>데이터 관리
<br>데이터가 여러 서비스에 분산되어 있어 관리하는데 어려움이 있다.
<br>그래서 msa가 무조건 좋은것인가? <br>설계방식에 대한 정답은 없다. 하지만, 많은 기업들이 MSA를 적용하여 글로벌 서비스를 성공적으로 확장시켰다는 것은 확실하다. <br>또한, Cloud 기반의 서비스에 매우적합한 방식이라는 것도 자명하다. 하지만, MSA를 무조건 적으로 적용하는 것 보다는 현재프로젝트의 규모, 통신 방식등을 적절하게 산정/예상하여 단점보다 장점이 커 보인다고 생각될 때 적용하는 것이 바람직 해 보인다. <br>
<br>MSA는 단순히 서비스를 여러 개로 나누는 것이 아니라, 개별 서비스가 독립적으로 개발, 배포, 운영될 수 있도록 설계하는 것이 핵심이다.
<br>그렇지 않으면 모놀리식 아키텍처와 다를 바 없다. 따라서, 적절한 설계 원칙을 적용하여 설계를 진행하여야 한다.
<br> SRP는 각 서비스가 하나의 명확한 역할을 수행해야 한다는 원칙이다. 이를 따르지 않으면 서비스가 점점 커지면서 결국 모놀리식 구조와 다름없어질 수 있음을 알아야 한다.<br>
<br>서비스 내부의 응집도는 높이고, 서비스 간의 결합도는 낮춰야 한다. 응집도가 높은 서비스는 유지보수가 용이하며, 변경 시 다른 기능에 영향을 최소화할 수 있다. 반면, 결합도가 높으면 서비스 간 변경 사항이 전파되면서 독립적인 배포가 어려워지고, 장애 전파의 위험도 커진다.
<br>
<br>각 서비스는 명확한 도메인 역할을 가져야 한다(DDD). 예를 들어, 주문 서비스는 주문 관련 로직만을 담당하고, 결제 서비스는 결제와 관련된 기능만을 처리해야 한다. 이를 통해 개발, 배포, 확장이 용이해지고, 운영 비용을 절감할 수 있다.
<br>서비스는 서로 독립적으로 운영될 수 있어야 한다. 특정 서비스가 다운되더라도 전체 시스템이 영향을 받지 않도록 설계하는 것이 중요하다.<br>
<br>서비스 간 통신은 동기 호출보다는 비동기 메시징 또는 이벤트 기반 방식을 활용하는 것이 좋다. 이를 통해 특정 서비스가 응답하지 않아도 전체 시스템이 멈추지 않도록 할 수 있다.
<br>
<br>서비스 간의 직접적인 의존성을 최소화해야 한다. 예를 들어, 한 서비스가 다른 서비스의 데이터베이스에 직접 접근하는 것은 피해야 하며, API나 이벤트 기반 방식으로 데이터를 교환해야 한다.
<br>MSA 환경에서는 특정 서비스에서 장애가 발생하더라도 다른 서비스로 확산되지 않도록 격리하는 것이 필수적이다.<br>
<br>서킷 브레이커는 특정 서비스가 응답하지 않을 때, 일정 횟수 이상 요청이 실패하면 추가 요청을 차단하는 패턴이다. 이를 통해 과부하를 방지하고, 장애가 확산되는 것을 막을 수 있다.
<br>
<br>서비스 장애 발생 시, 기본적인 대체 응답을 제공하는 폴백 전략을 사용하면 사용자 경험을 유지할 수 있다. 예를 들어, 추천 서비스가 장애가 발생하면 기본 인기 상품 목록을 반환하는 식.
<br>
<br>서비스의 상태를 지속적으로 모니터링하여 장애 발생을 사전에 감지하고 대응할 수 있도록 해야 한다.
<br>MSA에서는 수많은 서비스가 존재하므로 수작업으로 운영하기에는 한계가 있다. 따라서 <a data-href="CICD" href="https://lts.kr/짧은-키워드/cicd.html" class="internal-link" target="_self" rel="noopener nofollow">CICD</a> 파이프라인과 Kubernetes 기반의 자동화가 필수적이다.<br>
<br>코드 변경 사항을 빠르게 배포할 수 있도록 지속적인 통합 및 배포(CI/CD)를 구축해야 한다. 이를 통해 배포 속도를 높이고, 변경에 대한 위험을 줄일 수 있다.
<br>
<br>Kubernetes를 활용하면 서비스 배포, 확장, 롤백을 자동화할 수 있다. 이를 통해 인프라 관리의 복잡도를 줄이고, 서비스 안정성을 확보할 수 있다.
<br>MSA에서는 서비스가 분산되어 있기 때문에, 효과적인 모니터링과 로깅이 필수적이다.<br>
<br>서비스 간 요청 흐름을 추적하기 위해 분산 추적 시스템(OpenTelemetry, Jaeger)을 활용하여 성능 저하 원인을 빠르게 파악할 수 있다.
<br>
<br>각 서비스에서 발생하는 로그를 한곳에 수집하여 관리해야 한다. 중앙 집중식 로깅 시스템(ELK Stack, Grafana Loki)을 활용하면 장애 발생 시 원인을 빠르게 분석할 수 있다.
<br>
<br>서비스의 CPU, 메모리 사용량, 응답 시간 등을 지속적으로 모니터링하고, 이상 징후를 사전에 감지하여 대응할 수 있도록 해야 한다.
<br> <br>MSA를 설계할 때, 적절한 서비스 분해 전략을 선택하는 것 또한 매우 중요하다.
일반적인 분해 전략은 다음과 같다.<br>비즈니스 기능 기반 분해: 각 서비스가 특정 비즈니스 기능을 담당하도록 분해한다. 예를 들어, 주문 관리, 결제 처리, 사용자 인증 등을 각각의 서비스로 나눌 수 있다.
<br>
<br>하위 도메인 기반 분해: 도메인 주도 설계(DDD)를 활용하여 하위 도메인별로 서비스를 분리한다. 고객이 발생시키는 이벤트를 시작점으로 하여 Path를 발경하는 Event Storming 기법도 있다.
<br>
<br>트랜잭션 경계 기반 분해: 트랜잭션 경계를 기준으로 서비스를 분리하여 데이터 일관성을 유지한다.
<br>이러한 분해 전략을 통해 서비스 간의 결합도를 낮추고, 독립적인 개발과 배포가 가능하도록 설계할 수 있다.<br>주의점
MSA를 도입하며, 기능(도메인)의 경계를 명확히 하는것은 생각보다 쉽지 않다.<br>
특히 핵심 기능을 분리할 때 어려운 점이 있다. <br>핵심 기능은 다른 기능들과의 결합도가 높다
<br>핵심 기능일 수록 장기간의 유지보수로 인하여, 도메인간의 경계가 명확하지 않을 가능성이 높다 이러한 핵심 기능들은 사람의 눈으로만 판단하는데 어려움이 있기 떄문에, 다양한 정적 분석도구를 활용하면 좋다.
<br>다음은 MSA에서 유연성과 확장성을 확보하기 위한 주요 서비스 분리 원칙이다.
<br>
<br>분리 대상 서비스를 확정하고 나서는, 기존 모놀리식 코드를 재사용 할것인지, 재개발 할것인지를 고민해야한다.
<br>일반적으로 코드를 재사용하여 서비스를 구성하는 것이 효율적으로 보이지만 오히려 비효율을 초래할 가능성이 크다.
<br>오랜 기간 유지보수 된 코드의 문제점
<br>기술부채가 많이 쌓여있고, 기술 자체가 오래되었을 가능성이 큼
<br>수없이 변경된 요구사항으로, 비즈니스 도메인이 명확하게 반영되어있지 않을 가능성이 큼
<br>
<br>기능의 완전한 재작성의 장점
<br>요구사항을 다시 파악하여 해당 기능에 대한 비즈니스 도메인을 명확히 할 수 있음
<br>비즈니스에 대한 더놓은 이해를 바탕으로 아키텍처 재설계 가능
<br>기존의 기술부채 해결
<br>새로운 기술 스텍을 도입할 수 있음
<br>모놀리식으로 구현되어있는 코드 전체를 MSA로 전환하는 것은 아주 길고 비용이 많이 드는 일이다.
때문에, 작고 명확한 계획의 여러단계를 만들어 진행하는 것이 유리하다.<br>또한, 서비스를 분리할 때 서비스 범위를 너무 좁게 잡으면 각서비스는 응집도 높은 비즈니스 없이 CRUD만 수행하며 개수는 크게 증가하여 복잡도만 높아질 수 있다.<br>
<br>우선 서비스 단위를 크게 분리한 후, 이후에 설계에 대한 고민을 반복적으로 수행하며 분리작업을 점진적으로 진행하는 것이 가장 바람직 하다고 볼 수 있겠다.
<br> <br>마이크로서비스 아키텍처에서는 서비스 간 통신과 데이터 관리가 중요한 이슈이다.<br>
<br>동기 통신: <a data-href="RESTful API" href="https://lts.kr/짧은-키워드/restful-api.html" class="internal-link" target="_self" rel="noopener nofollow">RESTful API</a>, gRPC 등을 사용하여 실시간으로 요청과 응답을 주고받는 방식. 구현이 간단하지만, 서비스 간의 강한 결합을 초래할 수 있다.
<br>비동기 통신: 메시지 큐(Kafka, RabbitMQ 등)를 활용하여 비동기적으로 메시지를 전달하는 방식. 이는 서비스 간 결합도를 낮추고, 시스템의 확장성과 탄력성을 향상시킨다.
<br>
<br>데이터베이스 분리: 각 서비스는 자체 데이터베이스를 보유하여 데이터 독립성을 확보한다.
<br>데이터 일관성 유지: 분산 트랜잭션을 피하기 위해 SAGA 패턴, 이벤트 소싱 등을 활용하여 데이터 일관성을 유지한다.
<br>MSA는 단순히 시스템을 여러 개의 서비스로 나누는 것이 아니라, 서비스의 독립성, 장애 격리, 자동화, 모니터링 등의 원칙을 철저히 준수하는 것이 핵심이다. 이러한 원칙이 지켜지지 않으면, 시스템은 오히려 더 복잡해지고 운영 비용이 증가할 뿐 아니라 장애 대응도 어려워진다.<br>특히 단일 책임 원칙, 서비스 독립성, 장애 격리, 자동화, 모니터링은 MSA에서 반드시 적용해야 하는 필수 요소이다. 이 원칙들을 바탕으로 MSA를 설계하면 유연한 확장성, 높은 가용성, 효율적인 운영이 가능한 시스템을 구축할 수 있겠다.]]></description><link>https://lts.kr/study/cs/🐹-msa(microservices-architecture).html</link><guid isPermaLink="false">study/CS/🐹 MSA(Microservices Architecture).md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Thu, 08 May 2025 01:02:44 GMT</pubDate></item><item><title><![CDATA[✈MM_클라우드 마이그레이션]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:프로젝트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로젝트</a> <a class="tag" href="https://lts.kr/?query=tag:개발" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#개발</a> <a class="tag" href="https://lts.kr/?query=tag:Cloud" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Cloud</a> <a class="tag" href="https://lts.kr/?query=tag:CloudNative" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#CloudNative</a> <a class="tag" href="https://lts.kr/?query=tag:CI/CD" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#CI/CD</a> <br> <a href="https://lts.kr?query=tag:프로젝트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로젝트">#프로젝트</a> <a href="https://lts.kr?query=tag:개발" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#개발">#개발</a> <a href="https://lts.kr?query=tag:Cloud" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Cloud">#Cloud</a> <a href="https://lts.kr?query=tag:CloudNative" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#CloudNative">#CloudNative</a> <a href="https://lts.kr?query=tag:CI/CD" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#CI/CD">#CI/CD</a><br><img alt="do-messenger_screenshot_2025-05-02_14_28_33.png" src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-05-02_14_28_33.png" target="_self"><br>
<br>해당 프로젝트는 Swift Native iOS 애플리케이션이다.
<br>프로젝트 ‘MeloMeter’의 기능 확장 및 유지보수를 위해 FireBase Cloud에서 다른 Cloud로의 마이그레이션 작업이 필요함을 느꼈다.
<br>FireBase는 백앤드 인프라를 별도로 구축하지 않고도 앱 개발을 시작할 수 있는 Backend-as-a-Service(BaaS) 플랫폼이다. iOS 어플리케이션을 서버 설정, 데이터베이스 구축, 인증 시스템 구현 등 복잡한 작업 없이 빠르게 개발/배포가 가능했다.<br>BaaS란?
서비스형 백엔드(BaaS) 는 개발자가 웹 또는 모바일 애플리케이션의 모든 백그라운드 측면을 아웃소싱하여 프런트엔드만 작성하고 유지 관리하면 되는 클라우드 서비스 모델이다. BaaS 벤더는 사용자 인증, 데이터베이스 관리, 원격 업데이트, 푸시 알림(모바일 앱용), 클라우드 스토리지, 호스팅 등 서버에서 이루어지는 활동을 위해 미리 작성된 소프트웨어를 제공한다.
<br>Firebase의 Realtime Database와 Cloud Firestore는 실시간 데이터 동기화를 지원하며, 짧은 지연시간을 제공하여 MeloMeter의 사용자 간의 위치 데이터 공유나 채팅 기능 등 실시간 기능 구현에 용이하다.<br>Firebase는 인증(Authentication), 클라우드 메시징(Cloud Messaging), 호스팅(Hosting), 스토리지(Storage), 분석(Analytics) 등 다양한 서비스를 통합적으로 제공하여, 별도의 외부 서비스 연동 없이도 앱의 주요 기능을 구현할 수 있다.<br>
ex) 클라우드 메시징을 사용한 유저 통합 알림 / 유저 핸드폰 인증, 로그인 서비스
<br>Firebase는 Google의 서비스로, 특정 기능이나 API에 종속되어있다. Realtime Database와 Cloud Firestore 모두 독자규격을 갖도록하여 프로젝트 규모와 기능이 확장될 수록 다른 벤더로의 이전이 점점 더 어려워진다.<br>Firebase는 공식적으로 RDB를 지원하지 않는다. 또한 Realtime Database는 NoSQL기반 이므로 복잡한 쿼리나, 트렌젝션을 처리하기에 적합하지 않다. 따라서 각 상황에 맞추어 DB를 선택할 수 있는 여타 클라우드 서비스와 다르게 확장에 제한적이다.<br>데이터 구조나 API의 차이로 Firebase에서 다른 데이터베이스로의 마이그레이션은 복잡하고 시간이 많이 걸릴 수 있다. 위엑서 언급한 내용이나, 이또한 프로젝트 규모가 커질수록 단점으로 다가올 수 있다.<br>Firebase는 Google이 개발한 플랫폼으로, Android에 비해 iOS에 대한 지원이 상대적으로 부족하다. 예를 들어, Firebase Test Lab은 Android에 비해 iOS 기기 지원이 제한적이며, 일부 기능은 iOS에서 완벽하게 작동하지 않는다.<br>가장 큰 이유
위의 단점 모두 FireBase에서도 어느정도 해결 할 수 있는 문제이다.<br>
그럼에도 Cloud를 이전하려고 하는 가장큰 이유는 BaaS기반의 클라우드 서비스에서 다양한 캐쉬전략, 트렌젝션 관리 등 좀더 자유롭게 백앤드로 로직을 개발하고, 유연하게 관리하기 위함이 크다
<br>]]></description><link>https://lts.kr/project/melometer-project/✈mm_클라우드-마이그레이션.html</link><guid isPermaLink="false">project/MeloMeter Project/✈MM_클라우드 마이그레이션.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 07 May 2025 07:40:28 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-05-02_14_28_33.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-05-02_14_28_33.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🌩 Cloud-Native Architecture 분석]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="https://lts.kr/?query=tag:구조" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#구조</a> <a class="tag" href="https://lts.kr/?query=tag:설계" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#설계</a> <a class="tag" href="https://lts.kr/?query=tag:MSA" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#MSA</a> <a class="tag" href="https://lts.kr/?query=tag:CloudNative" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#CloudNative</a> <br> <a href="https://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="https://lts.kr?query=tag:구조" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#구조">#구조</a> <a href="https://lts.kr?query=tag:설계" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#설계">#설계</a> <a href="https://lts.kr?query=tag:MSA" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#MSA">#MSA</a> <a href="https://lts.kr?query=tag:CloudNative" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#CloudNative">#CloudNative</a><br>
<br>CNA는 클라우드 환경의 특성을 최대한 활용하여 애플리케이션을 설계하고 운영하는 접근 방식이다.
<br>이는 유연성, 확장성, 탄력성, 복원성 등의 장점을 극대화하여 빠르게 변화하는 비즈니스 요구에 대응할 수 있도록 하기 위함이다.
<br>
<br>클라우드(AWS, Azure 등..)의 보편화에 따라, 해당 환경(클라우드 시스템 환경)에 맞는 적절한 프로그램(애플리케이션)설계 기법이 필요해졌고, 그렇게 등장한 것이 클라우드 네이티브 아키텍처 CNA이다.
<br>우리 모두가 아는 ‘넷플릭스(NETFLIX)’의 사례를 보도록하자.<br> 넷플릭스는 2008년 매월 수천 편의 영상을, 수백만 명의 고객들에게 스트리밍 서비스로 제공하며, 데이터 량이 빠르게 늘어나고 있었다.
이때, 넷플릭스는 자체적인 데이터 센터를 운영하고 있었는데 매일 급격하게 증가하는 볼륨을 감당하는데 무리가 있었고, 전체 서비스가 3일간 다운되는 큰 손실이 발생한 사례가 있다.<br>이후 넷플릭스는 사내 모든 컴퓨팅 인프라를 클라우드 환경으로 옮겨, 안정적인 스트리밍과 서비스 확장을 이뤄냈다.<br>꼭 매년 크게 성장하는 기업들 만이 클라우드 시스템에 유리한 것은 아니다.
한가지 사례를 더 가정해보자.<br>평균적으로 매 시간 100만명의 유저가 서비스를 이용한다고 가정해보자.
이때, 우리의 서버는 100만명을 수용할 수 있는 스펙이 되어야한다.
하지만, 연말 연초 연휴에 서비스 사용자들이 크게 몰려 시간 당 1000만명 수준이 유지된다고 한다면 어떠한 선택을 해야할까?<br>일반적인 회사는 특정한 상황에 몰리는 사용자들을 위해 10배 이상의 서버를 증설할 여력이 없다.
여기서 클라우드 컴퓨팅 시스템이 이러한 문제를 해결해 줄 수 있다.
<br>
<br>클라우드는 온디맨드 셀프 서비스 (On-demand Self-Service) 를 지원한다.
사용자는 필요한 자원을 요청하고 즉시 사용할 수 있다. 때문에, 초기 인프라 구축 비용 없이 사용량만큼만 비용을 지불하여 하드웨어 운영 인건비를 절감할 수 있으며
자본 기반 지출에서 → 운영 기반 지출로 지출 구조를 전환 할 수 있다.
주의점
하지만, 비용 예측의 어려움 또한 존재한다.<br>
사용량 기반 과금구조 이기 때문에, 과도한 사용시 요금이 폭주할 가능성이 있으며,
리소스 낭비 및 Auto Scaling의 작동범위를 항상 주의하여 운영해야한다. <br>
<br>방금 기술했던 특징으로, 트래픽 증가시 손쉽게 리소스를 확장 가능하다.
<br>또한, 광범위한 네트워크 접근성으로 글로벌 서비스를 제공할 수 있다.
<br>
<br>DR(Disaster Recovery) 시스템을 손쉽게 구성할 수 있는 다양한 기능을 제공.
<br>스냅샷, 복제본 등 고가용성 및 복구 설계가 수월하다.
<br>
<br>클라우드 시스템들은 일정 수준 이상의 보안을 항상 유지해주기 때문에,
하드웨어 보안에 필요한 노력을 줄일 수 있다.
<br>다음과 같은 기술들은 위에서 기술한 클라우드 시스템의 장점을 100%로 활용 가능하도록 도와준다.<br>
<br>상세한 설명 ▶▶ <a data-href="🐹 MSA(Microservices Architecture)" href="https://lts.kr/study/cs/🐹-msa(microservices-architecture).html" class="internal-link" target="_self" rel="noopener nofollow">🐹 MSA(Microservices Architecture)</a>
<br>애플리케이션은 API호출을 통해 세분화 되고, 느슨하게 결합된 구성 요소로 분해되어 관리된다.
<br>
<br>컨테이너 기술 ▶▶ <a data-href="🐋 docker 란" href="https://lts.kr/tools/docker/🐋-docker-란.html" class="internal-link" target="_self" rel="noopener nofollow">🐋 docker 란</a>
<br>CI/CD동안 모든 소프트웨어 어플리케이션과 모든 종속성은 컨테이너로써 관리되어
환경 전반에 거린 솔루션의 이식성을 향상시킨다.
<br>
<br>오케스트레이션 기술 ▶▶ <a data-href="🚢Kubernetes(k8s)란" href="https://lts.kr/tools/kubernetes/🚢kubernetes(k8s)란.html" class="internal-link" target="_self" rel="noopener nofollow">🚢Kubernetes(k8s)란</a>
<br>컨테이너화된 어플리케이션을 실행하고 배포하고 확장하기 위한 클러스터를 관리하는 기술이다.
<br>많은 수의 컨테이너를 직접관리하지 않고 자동화 함으로 효율을 증대할 수 있다.
<br>
<br>개념 설명 ▶▶ <a data-href="CICD" href="https://lts.kr/짧은-키워드/cicd.html" class="internal-link" target="_self" rel="noopener nofollow">CICD</a>
<br>소프트웨어 릴리즈의 효율성을 높여준다.
<br>빈번하고 반복적인 릴리즈를 신속한 피드백과 함께 간소화하고 자동화 시킬 수 있다.
<br>
<br>클라우드 네이티브 아키텍천은 현대의 빠르게 변화하는 비즈니스 환경에서 유연하고 확장 가능한 시스템을 구축하는데, 필수적인 접근방식임은 틀림없다.
<br>이를 통해 기업은 빠른 서비스 출기, 안정적인 운영, 효율적인 리소스 활용등의 장점을 모두 취할 수 있다.]]></description><link>https://lts.kr/study/cs/🌩-cloud-native-architecture-분석.html</link><guid isPermaLink="false">study/CS/🌩 Cloud-Native Architecture 분석.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Fri, 02 May 2025 01:54:34 GMT</pubDate></item><item><title><![CDATA[🍎 Redis로 Key관리하기]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="https://lts.kr/?query=tag:Redis" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Redis</a> <a class="tag" href="https://lts.kr/?query=tag:Cash" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Cash</a> <a class="tag" href="https://lts.kr/?query=tag:memory" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#memory</a> <a class="tag" href="https://lts.kr/?query=tag:다중서버" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#다중서버</a> <a class="tag" href="https://lts.kr/?query=tag:NoSql" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#NoSql</a> <br> <a href="https://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="https://lts.kr?query=tag:Redis" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Redis">#Redis</a> <a href="https://lts.kr?query=tag:Cash" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Cash">#Cash</a> <a href="https://lts.kr?query=tag:memory" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#memory">#memory</a> <a href="https://lts.kr?query=tag:다중서버" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#다중서버">#다중서버</a> <a href="https://lts.kr?query=tag:NoSql" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#NoSql">#NoSql</a><br>
<br>주로 애플리케이션 캐시 또는 빠른 응답 데이터베이스로 사용되는 오픈소스,
인매모리, NoSql &lt;키, 벨류&gt; 저장소이다.
<br>또한, redis는 보조기억장치(HDD / SSD)가 아닌 메모리에 데이터를 저장하여
탁월한 속도, 안정성, 성능을 제공할 수 있다.<br> 애플이케이션이 외부 데이터 소스에 의존하는 경우 트레픽이 증가하거나, 애플리케이션이 확장될때 소스의 지연 시간과 처리량으로 인하여 병목현상이 발생할 수 있다.
이때 Redis를 적용하면, 데이터를 메모리에 저장하여 읽거나 쓸때 지연 시간을 최소화 할 수 있다.<br>
<br>redis는 앱 성능 향상을 위해 특별히 설계되어, 기존 NoSQL 데이터 저장소와 차별화 되는 기능이 있다.
<br>
<br>MongoDB, PostgreSql 과 같은 NoSQL DB와 달리, 메모리를 저장소로 사용하여
읽기 쓰기 성능이 월등히 높다. 또한 고가용성과 확장성을 보장하는데 도움이된다.
<br>고가용성 이란?
가용성 : 서버 또는 네트워크 등의 정보 시스템이 정상적으로 사용 가능한 정도를 의미.<br>
== 정상적인 사용시간 / 전체 사용시간 = 시스템 가동률(가용성) 여기서, 고가용성이란 가용성이 99%, 99.9% 등과 같이 높은 가용성을 지닌 시스템을 의미한다.
<br>
<br>redis는 웹 클라이언트가 평소보다 처리하는데 오래 걸릴 수 있는 작업을 대기열에 넣을 수 있다.
요청/응답 주기의 백그라운드에서 실행되는 자동화된 프로세스를 쉽게 구현할 수 있는 것이다.
<br>
<br>redis는 기술적으로는 키/벨류 저장소 이지만, 여러 데이터 유형과 구조를 지원하는 데이터 구조 서버이다.
<br>
<br>고유하고 정렬되지 않은 문자열
<br>바이너리 세이프 데이터
<br>하이퍼로그
<br>비트 배열
<br>해시
<br>목록
<br>
<br>
<br>build.gradle에 의존성 추가 <br>implementation 'org.springframework.boot:spring-boot-starter-data-redis' <br>yml redis 속성 추가 <br>cache: type: redis redis: cache-null-values: true redis: host: `레디스 호스트`
port: `레디스 포트`
<br>
<br>@Configuration으로 redis사용에 필요한 셋팅을 Bean으로 등록할 클래스.
<br>@Configuration public class RedisConfiguration { @Value("${spring.redis.host}") private String host; @Value("${spring.redis.port}") private int port;
}
<br>Redis 서버와 연결을 생성 및 관리해주는 인터페이스<br>@Bean public RedisConnectionFactory redisConnectionFactory() { return new LettuceConnectionFactory(host, port); }
<br>어플리케이션 서버와 Redis 서버 간의 데이터 송수신을 하는 클라이언트
<br>대표적으로 Lettuce와 Jedis, Redisson 이 있다.
<br>
<br>비동기 및 논블로킹 I/O를 기반으로 하여 고부하, 다중 스레드 환경에 적합
<br>
<br>블로킹 I/O(동기) 방식을 사용.
<br>고부하나 비동기 처리가 중요한 환경에서는 효울이 떨어진다.
<br>
<br>단순히 Redis 연결을 관리하는 것을 넘어 분산 락, 분산 컬렉션, 분산 캐시 등 고급 기능을 제공.
<br>직접 RedisConnectionFactory로 사용하기보다는 RedissonClient를 빈으로 등록하고 이를 통해 분산 락이나 캐시 매니저를 구성.
<br> ▶ <a data-href="🔐 상품 투자하기 서비스 Lock기법 개선안" href="https://lts.kr/issue_troubleshooting/🔐-상품-투자하기-서비스-lock기법-개선안.html" class="internal-link" target="_self" rel="noopener nofollow">🔐 상품 투자하기 서비스 Lock기법 개선안</a>
<br>따라서 해당 코드에는 비동기 성능이 높은 좋은 Lettuce 선택.<br>Redis에 저장될 캐시의 기본 직렬화 및 만료 시간(TTL) 등의 설정을 담당.<br>private RedisCacheConfiguration redisCacheDefaultConfiguration() { return RedisCacheConfiguration .defaultCacheConfig() .serializeKeysWith(RedisSerializationContext.SerializationPair .fromSerializer(new StringRedisSerializer())) .serializeValuesWith(RedisSerializationContext.SerializationPair .fromSerializer(new GenericJackson2JsonRedisSerializer());
}
<br>serializeKeysWith : StringRedisSerializer를 사용하여 키를 문자열로 직렬화합니다.
<br>serializeValuesWith : GenericJackson2JsonRedisSerializer와 ObjectMapper를 사용해 JSON 형식으로 직렬화 GenericJackson2JsonRedisSerializer : 직렬화 방식 중 하나로, JSON형식을 지원. <br>여러 캐시 이름에 대해 각기 다른 TTL(Time To Live)을 동적으로 설정.<br>private Map&lt;String, RedisCacheConfiguration&gt; redisCacheConfigurationMap() { Map&lt;String, RedisCacheConfiguration&gt; cacheConfigurations = new HashMap&lt;&gt;(); for (Map.Entry&lt;String, Long&gt; cacheNameAndTimeout : cacheProperties.getTtl().entrySet()) { cacheConfigurations .put(cacheNameAndTimeout.getKey(), redisCacheDefaultConfiguration().entryTtl( Duration.ofSeconds(cacheNameAndTimeout.getValue()))); } return cacheConfigurations; }
<br>//cacheProperties.yml<br>cache: ttl: CacheName: 10 #만료 시간
<br>외부 설정(CacheProperties)에서 캐시별 TTL 정보를 읽어와 각 캐시의 만료 시간을 지정
이를 통해 특정 캐시만 별도의 만료 정책 등을 적용할 수 있다.
<br>entryTtl : 기본 만료시간 설정
<br>Spring의 캐시 추상화에서 Redis를 캐시 저장소로 사용하기 위한 캐시 매니저를 생성
위에서 설정한 redisCacheDefaultConfiguration과 cacheConfigurations(커스텀) 이 삽입된다.<br>@Bean
public CacheManager redisCacheManager(RedisConnectionFactory redisConnectionFactory) { return RedisCacheManager.RedisCacheManagerBuilder .fromConnectionFactory(redisConnectionFactory) .cacheDefaults(redisCacheDefaultConfiguration()) .withInitialCacheConfigurations(redisCacheConfigurationMap()) .build();
}
<br>withInitialCacheConfigurations : RedisCacheManager를 생성할 때 미리 정의된 특정 캐시 이름에 대해 개별적인 설정을 적용할 수 있도록 해주는 메서드입니다.
<br>▶ <a data-href="🚨 RSA 암호화 방식의 이해와 적용 (feat.취약성점검)" href="https://lts.kr/issue_troubleshooting/🚨-rsa-암호화-방식의-이해와-적용-(feat.취약성점검).html" class="internal-link" target="_self" rel="noopener nofollow">🚨 RSA 암호화 방식의 이해와 적용 (feat.취약성점검)</a> 에서 이어진다.<br>@Service public class TestServiceImpl { private final CacheManager cacheManager; private final RedisTemplate&lt;String, Object&gt; redisTemplate; public TestServiceImpl(CacheManager cacheManager, RedisTemplate&lt;String, Object&gt; redisTemplate) { this.cacheManager = cacheManager; this.redisTemplate = redisTemplate; }
}
<br>(생성자 주입)<br>위(RedisConfiguration)에서 생성한 CacheManager 및 RedisTemplate의 빈을 주입한다.
<br>주의
만약, Bean으로 생성된 CacheManager객체나, RedisTemplate객체가 여러개라면,<br>
@Qualifier 어노테이션으로 Bean이름을 명시해야한다. `ex) @Qualifier("CustomCacheManager") CacheManager cacheManager ...` <br>	Cache privateKeyCache = cacheManager.getCache("CacheName"); public void putCache() { if (privateKeyCache != null) { privateKeyCache.put(keyId, 벨류); } else { // 캐시가 없으면 예외 처리 또는 로깅 throw new IllegalStateException("privateKeyCache 가 유요하지 않습니다."); } } public void getCache() { if (privateKeyCache == null) { throw new IllegalStateException("rsaPrivateKeyCache 가 유요하지 않습니다."); } String privateKeyValue = privateKeyCache.get(keyId, String.class); // 1회용 사용을 위해 조회 후 캐시에서 제거할 수 있다. rsaPrivateKeyCache.evict(keyId); // 1회용 사용: 캐시에서 제거 }
<br>getCache.(CacheName)으로 캐쉬를 객체를 가져온다.
<br>put(keyId, 벨류); / get(keyId, String.class); 로 삽입 / 가져오기가 가능하다.
<br>.evict(keyId)로 삭제 ( 1회성 사용이 가능하다. )
<br>1회성으로 사용하는 이유
나의 경우에 RSA키를 매번 발급 받기 때문에 값을 꺼냄과 동시에 해당 키벨류를 삭제한다.<br>
Exception이 터지더라도, cacheProperties 에 설정한 TTL이 초과되면 삭제된다.
<br><img alt="Pasted image 20250328120415.png" src="https://lts.kr/사진-및-문서/pasted-image-20250328120415.png" target="_self"><br>application.yml / properties ↓
CacheProperties (ttl map 관리) ↓
redisCacheConfigurationMap() → 캐시별 TTL 매핑 ↓
redisCacheDefaultConfiguration() → 기본 설정 (ex: serializer, 기본 TTL) ↓
redisCacheManager() → 최종 CacheManager 생성
<br>다음과 같이 TTL 시간 및 <a data-href="Redis 만료 정책" href="https://lts.kr/짧은-키워드/redis-만료-정책.html" class="internal-link" target="_self" rel="noopener nofollow">Redis 만료 정책</a>을 맵핑 할 수 있다.]]></description><link>https://lts.kr/study/cs/🍎-redis로-key관리하기.html</link><guid isPermaLink="false">study/CS/🍎 Redis로 Key관리하기.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 30 Apr 2025 07:23:51 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20250328120415.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20250328120415.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[정의]]></title><description><![CDATA[<br><br>
<br>CI/CD는 지속적 통합(Continuous Integration) 및 지속적 제공/배포(Continuous Delivery/Deployment) 를 의미하며, 소프트웨어 개발 라이프사이클을 간소화하고 가속화하는 것을 목표로 한다.
<br><br>
<br>코드 변경 사항을 공유 소스 코드 리포지토리에 자동으로 자주 통합하는 사례를 나타낸다. <br><br>
<br>코드 변경 사항의 통합, 테스트, 제공을 나타내는 프로세스로, 두 가지 부분으로 구성된다. 지속적 제공에는 자동 프로덕션 배포 기능이 없는 반면, 지속적 배포는 업데이트를 프로덕션 환경에 자동으로 릴리스된다.
<br><br><br><br><br><br>]]></description><link>https://lts.kr/짧은-키워드/cicd.html</link><guid isPermaLink="false">짧은 키워드/CICD.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 30 Apr 2025 06:50:46 GMT</pubDate></item><item><title><![CDATA[RESTful API]]></title><link>https://lts.kr/짧은-키워드/restful-api.html</link><guid isPermaLink="false">짧은 키워드/RESTful API.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 30 Apr 2025 06:15:43 GMT</pubDate></item><item><title><![CDATA[🐡 Spring Security와 Filter]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:프로젝트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로젝트</a> <a class="tag" href="https://lts.kr/?query=tag:개발" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#개발</a> <a class="tag" href="https://lts.kr/?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <a class="tag" href="https://lts.kr/?query=tag:Security" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Security</a> <a class="tag" href="https://lts.kr/?query=tag:Filter" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Filter</a> <br> <a href="https://lts.kr?query=tag:프로젝트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로젝트">#프로젝트</a> <a href="https://lts.kr?query=tag:개발" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#개발">#개발</a> <a href="https://lts.kr?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a> <a href="https://lts.kr?query=tag:Security" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Security">#Security</a> <a href="https://lts.kr?query=tag:Filter" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Filter">#Filter</a><br>
<br>Spring Security는 Java기반 웹 어플리케이션의 보안을 제공하는 강력한 프레임워크다.
<br>웹보안(HTTP인증, 접근제어) 뿐 아니라, 메소드 레벨 보안, 세션 관리, JWT 등 다양한 보안 시나리오를 제공한다.
<br>Spring Security는 Filter기반 아키텍처를 사용한다.
<br>Filter를 통해 HTTP요청과 응답을 가로채어 인증(Authentication), 인가(Authorization) 과정을 수행한다.<br>먼저, 스프링 시큐리티가 동작하기 위해서는 Filter가 필요하다.
여기서 Servlet Filter는 Spring의 관리에서 벗어나기 때문에, DI사용에 한계가 있다.<br><img alt="do-messenger_screenshot_2025-04-29_15_37_33.png" src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-04-29_15_37_33.png" target="_self">
이에 따라 스프링은, 요청을 위임하는 DelegatingFilterProxy 를 만들었다.<br>
<br>Servlet Container(Tomcat 등..)는 오직 Servlet Filter만 인식할 수 있다.
이때, Spring Security의 인증, 인가 로직은 Spring Bean으로 만들어진다.
<br>즉, <br>Tomcat입장에서는 Spring Bean을 직접 호출할 방법이 없다.
<br>Spring입장에서는 Servlet Filter Chain에 진입하여야 한다.
<br>이 두개를 연결해 주는 역할을 하는것이 DelegatingFilterProxy 이다. <br>
<br>클라이언트가 서버로 HTTP 요청을 보낸다.
<br>톰캣(Servlet Container)이 Filter Chain을 조회하여 DelegatingFilterProxy를 호출한다.
<br>DelegatingFilterProxy는 <br>Spring ApplicationContext에서 자신이 참조할 Bean 이름(보통 "springSecurityFilterChain")을 찾는다.
<br>해당 이름의 Bean을 가져온다.
<br>가져온 Bean(보통 FilterChainProxy)의 doFilter() 메서드를 호출하여 실제 보안 처리를 진행한다. <br>FilterChainProxy는 내부에 등록된 다수의 SecurityFilter 들을 순서대로 호출한다.
<br>이때 DelegatingFilterProxy가 직접 보안 로직을 수행하는 것이 아닌,
"Spring의 필터야, 이 요청 처리 좀 해줘" 하고 넘긴다.<br>[ Client Request ] ↓
[ Servlet Container Filter Chain ] ↓
[ DelegatingFilterProxy (web.xml 등록) ] ↓ (Spring Bean 호출)
[ FilterChainProxy (Spring Security 설정에 따라 동작) ] ↓
[ Security Filter1 → Security Filter2 → ... → Security FilterN ] ↓
[ DispatcherServlet ] ↓
[ Controller 처리 ]
<br>사용자가 누구인지를 확인하는 과정. ex) 아이디와 비밀번호로 로그인하여 사용자를 식별.
<br>사용자가 로그인 폼을 통해 아이디와 비밀번호를 제출
<br>UsernamePasswordAuthenticationFilter가 이 요청을 가로챔
<br>사용자 입력값을 바탕으로 UsernamePasswordAuthenticationToken 생성
<br>AuthenticationManager에 인증 요청을 위임
<br>AuthenticationProvider가 UserDetailsService를 통해 사용자 정보를 로드
<br>PasswordEncoder로 비밀번호 비교
<br>인증 성공 시 Authentication 객체를 SecurityContextHolder에 저장
<br>인증된 사용자가 어떤 리소스에 접근할 수 있는지 결정하는 과정. ex) 일반 사용자는 `/admin/**`에 접근 불가, ROLE_ADMIN 만 접근 가능
<br>요청이 들어옴
<br>FilterSecurityInterceptor가 요청 URL에 대한 접근 권한 체크
<br>인증된 Authentication 객체에 포함된 권한(GrantedAuthority) 목록과 비교
<br>인가 실패 시 AccessDeniedException 발생 → AccessDeniedHandler로 위임
<br>SecurityContext는 현재 사용자에 대한 보안 정보를 저장하는 객체다.<br>
Spring Security는 이 컨텍스트를 통해 현재 요청이 어떤 사용자에 의해 수행되는지 알 수 있다.<br>저장 위치:<br>기본적으로 ThreadLocal을 사용
<br>이는 각 스레드마다 고유한 컨텍스트를 유지할 수 있도록 해준다
<br>Spring Security의 인증 상태를 나타내는 핵심 인터페이스다. 주요 구성 요소는 다음과 같다<br>Spring Security는 비밀번호를 절대 평문으로 비교하지 않는다.<br>
항상 PasswordEncoder를 통해 암호화된 상태로 비교해야 한다.<br>기본적으로 BCryptPasswordEncoder가 권장되며, 단방향 해시 함수로 안전하다.<br>@Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); }
<br>인증 시 비밀번호 비교는 이렇게 이뤄진다<br>String raw = "plain_pw"; String hashed = userDetails.getPassword(); boolean match = passwordEncoder.matches(raw, hashed);]]></description><link>https://lts.kr/study/cs/🐡-spring-security와-filter.html</link><guid isPermaLink="false">study/CS/🐡 Spring Security와 Filter.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Tue, 29 Apr 2025 09:10:58 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-04-29_15_37_33.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-04-29_15_37_33.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Servlet이란 무엇인가]]></title><description><![CDATA[<br><br>Servlet은 간단히 말하면,<br>
"자바로 작성된 웹 요청/응답을 처리하는 서버 측 프로그램"이다.
<br>
<br>Servlet = Server + Applets의 합성어. <br>웹 브라우저의 요청(Request)을 받고, 그에 대한 응답(Response)을 생성하는 자바 클래스. <br>HTTP 통신 기반으로 동작한다. (하지만 이론상은 TCP 기반도 가능) <br>공식적 정의:<br>
서블릿은 Java 언어로 작성된 서버 측 컴포넌트로서, HTTP 요청을 받아 처리하고, HTTP 응답을 생성하는 역할을 한다.<br>
(Java Servlet Specification, 현재 버전은 6.0)
<br><br>
<br>서버 시작 시 또는 요청 시 로딩 <br>톰캣(Tomcat) 같은 서블릿 컨테이너가 Servlet 클래스를 메모리에 로딩하고 객체를 생성한다. <br>init() 호출 <br>생성된 서블릿 인스턴스에 대해 init(ServletConfig config) 메서드가 1회 호출된다. <br>초기화 작업(리소스 연결 등)을 한다. <br>요청마다 service() 호출 <br>클라이언트 요청이 들어오면 service(ServletRequest req, ServletResponse res)가 호출된다. <br>여기서 HTTP 요청 종류(GET, POST 등)에 따라 알맞은 메서드(doGet, doPost 등)가 분기 호출된다. <br>서버 종료 시 destroy() 호출 <br>서버 종료나 재배포 시, destroy() 메서드가 호출되어 리소스 정리(clean-up)한다. <br><br><br>Servlet 컨테이너는 Servlet의 생명주기를 관리하고 HTTP 요청을 대신 받아 Servlet에 연결해준다.<br>컨테이너가 하는 일은:<br>
<br>HTTP 요청 수신 <br>URL 매핑 → 해당 Servlet 호출 <br>Servlet 인스턴스 생성/관리 <br>멀티 스레드로 각 요청 처리 <br>Servlet API 제공 (HttpServletRequest, HttpServletResponse 등) <br>대표적인 Servlet 컨테이너: Apache Tomcat, Jetty, Undertow, WildFly 등]]></description><link>https://lts.kr/짧은-키워드/servlet.html</link><guid isPermaLink="false">짧은 키워드/Servlet.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Tue, 29 Apr 2025 06:58:38 GMT</pubDate></item><item><title><![CDATA[GitOps]]></title><description><![CDATA[<br>
<br>
DevOps(개발과 운영을 통합하여 효율성,협력,안정성을 개선하는 개발/운영 방법론)의 실천 방법중 하나로, 애플리케이션 배포와 운영에 관련된 모든요소를 Git에서 관리(Opertation)한다는 뜻이다. <br>
Git의 버전관리 시스템과 운영환경간의 일관성을 유지하여 소프트웨어간의 불일치 문제를해결할 수 있다. ]]></description><link>https://lts.kr/짧은-키워드/gitops.html</link><guid isPermaLink="false">짧은 키워드/GitOps.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Tue, 29 Apr 2025 06:55:23 GMT</pubDate></item><item><title><![CDATA[🪓 도구]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:Tools" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Tools</a> <a class="tag" href="https://lts.kr/?query=tag:모음" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#모음</a> <a class="tag" href="https://lts.kr/?query=tag:도구" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#도구</a> <br> <a href="https://lts.kr?query=tag:Tools" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Tools">#Tools</a> <a href="https://lts.kr?query=tag:모음" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#모음">#모음</a> <a href="https://lts.kr?query=tag:도구" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#도구">#도구</a><br>툴 모음
제가 사용하고 있는 편리/유용한 TOOL을 소개하고 설명하는 곳 입니다.
<br>
<br><a data-href="🍊 aws EC2란" href="https://lts.kr/tools/aws/🍊-aws-ec2란.html" class="internal-link" target="_self" rel="noopener nofollow">🍊 aws EC2란</a>
<br><a data-href="🌥 aws(EC2)셋팅부터 배포까지" href="https://lts.kr/tools/aws/🌥-aws(ec2)셋팅부터-배포까지.html" class="internal-link" target="_self" rel="noopener nofollow">🌥 aws(EC2)셋팅부터 배포까지</a>
<br><a data-href="🍌 Elastic IP(탄력적 IP)란" href="https://lts.kr/tools/aws/🍌-elastic-ip(탄력적-ip)란.html" class="internal-link" target="_self" rel="noopener nofollow">🍌 Elastic IP(탄력적 IP)란</a>
<br>
<br><a data-href="🐋 docker 란" href="https://lts.kr/tools/docker/🐋-docker-란.html" class="internal-link" target="_self" rel="noopener nofollow">🐋 docker 란</a>
<br><a data-href="📘 SpringBoot &amp; Docker + Reids 연동" href="https://lts.kr/tools/docker/📘-springboot-&amp;-docker-+-reids-연동.html" class="internal-link" target="_self" rel="noopener nofollow">📘 SpringBoot &amp; Docker + Reids 연동</a>
<br>
<br><a data-href="👔 Jenkins란" href="https://lts.kr/tools/jenkins/👔-jenkins란.html" class="internal-link" target="_self" rel="noopener nofollow">👔 Jenkins란</a>
<br>
<br><a data-href="🚢Kubernetes(k8s)란" href="https://lts.kr/tools/kubernetes/🚢kubernetes(k8s)란.html" class="internal-link" target="_self" rel="noopener nofollow">🚢Kubernetes(k8s)란</a>
<br>
<br><a data-href="🍎 Redis로 Key관리하기" href="https://lts.kr/study/cs/🍎-redis로-key관리하기.html" class="internal-link" target="_self" rel="noopener nofollow">🍎 Redis로 Key관리하기</a>
<br><a data-href="🔐 상품 투자하기 서비스 Lock기법 개선안" href="https://lts.kr/issue_troubleshooting/🔐-상품-투자하기-서비스-lock기법-개선안.html" class="internal-link" target="_self" rel="noopener nofollow">🔐 상품 투자하기 서비스 Lock기법 개선안</a>
<br><a data-href="🔻 Redis 캐쉬 전략 - hello 서비스에 적용하여 성능개선 가능성" href="https://lts.kr/study/dev-seminar/🔻-redis-캐쉬-전략-hello-서비스에-적용하여-성능개선-가능성.html" class="internal-link" target="_self" rel="noopener nofollow">🔻 Redis 캐쉬 전략 - hello 서비스에 적용하여 성능개선 가능성</a>
<br>
<br><a data-href="🎵 Obsidian" href="https://lts.kr/tools/🎵-obsidian.html" class="internal-link" target="_self" rel="noopener nofollow">🎵 Obsidian</a>
<br><a data-href="👻 Obsidian 정적호스팅 CICD 과정" href="https://lts.kr/project/note-ci_cd/👻-obsidian-정적호스팅-cicd-과정.html" class="internal-link" target="_self" rel="noopener nofollow">👻 Obsidian 정적호스팅 CICD 과정</a>
<br>
<br>🩹추가예정!!]]></description><link>https://lts.kr/tools/🪓-도구.html</link><guid isPermaLink="false">Tools/🪓 도구.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Thu, 24 Apr 2025 00:49:30 GMT</pubDate></item><item><title><![CDATA[🚢Kubernetes(k8s)란]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:Tools" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Tools</a> <a class="tag" href="https://lts.kr/?query=tag:Kubernetes" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Kubernetes</a> <a class="tag" href="https://lts.kr/?query=tag:k8s" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#k8s</a> <br> <a href="https://lts.kr?query=tag:Tools" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Tools">#Tools</a> <a href="https://lts.kr?query=tag:Kubernetes" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Kubernetes">#Kubernetes</a> <a href="https://lts.kr?query=tag:k8s" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#k8s">#k8s</a><br>
<br>과거에는 서버 1대에 하나의 앱을 설치하는 방식 → 리소스 낭비
<br>가상화(VM)는 개선책이었지만 느리고 무겁다
<br>
<br>Docker를 사용한 컨테이너(꼭 Docker가 아니더라도..) 기술은 경량화된 격리 실행환경 제공
<br>문제: 수백~수천 개의 컨테이너를 관리, 스케줄링, 모니터링를 사람이 직접 한다는것은 많이 어렵다.
<br>
<br>구글이 자사 서비스에서 10년 넘게 써온 내부 컨테이너 오케스트레이터 “Borg”의 아이디어를 오픈소스로 풀어낸 것이 Kubernetes(줄여서 k8s)이다.
<br>
<br>위에서 설명했듯 여러개의 컨테이너를 자동으로 배포, 스케일링, 복구, 관리하는 컨테이너 오케스트레이션 플랫폼이다.
<br> +-------------------+ | Master Node | |-------------------| | - API Server | | - Scheduler | | - Controller Mgr | | - etcd (DB) | +---------+---------+ | ┌────────────┴────────────┐ ↓ ↓ +-------------+ +---------------+ | Worker Node| | Worker Node | |-------------| |---------------| | kubelet | | kubelet | | kube-proxy | | kube-proxy | | containerd | | containerd | +-------------+ +---------------+ ↓ ↓ [Pod: 컨테이너 + 네트워크 + 볼륨]
<br>k8s가 컨테이너 오케스트레이션 플랫폼 (어디에, 어떠게 배포할지 결정 )이라면,
argoCD는 <a data-href="GitOps" href="https://lts.kr/짧은-키워드/gitops.html" class="internal-link" target="_self" rel="noopener nofollow">GitOps</a>기반의 Continuous Delivery 도구 (무엇을, 언제, 어떤 방식으로 배포할지 관리) 이다.<br>
<br>k8s의 모든 배포는 yaml파일을 통해 이뤄진다.
→이때, 배포를 수행하는 개발자마다 각자의 PC에서 yaml파일을 만들어 관리한다면, 많은 노력이 들어가게 된다.
따라서, <a data-href="GitOps" href="https://lts.kr/짧은-키워드/gitops.html" class="internal-link" target="_self" rel="noopener nofollow">GitOps</a>방법론에 따라, 배포와 관련된 모든 코드를 Git을 통해 관리하도록 하는것이다.
<br>즉, ArgoCD는 Kubernetes를 위한 GitOps 자동 배포 계층이다.<br>Git Repository (Manifest 저장) ← (감시) ← Argo CD → (반영) → Kubernetes Cluster<br>
<br>Argo CD는 Kubernetes의 배포 자동화 담당
<br>Kubernetes는 애플리케이션을 실행하고, Argo CD는 그것을 배포/관리함
<br>Git을 소스 오브 트루스로 삼고, Argo CD는 상태를 감시하고 Kubernetes와 싱크 맞춤
<br>실시간 배포 이력 추적, 자동 복구, 롤백, 멀티클러스터 지원 등 GitOps 핵심 도구
<br>Kubernetes를 쓰는 조직이라면 Argo CD는 필수에 가까움 (Jenkins는 CI로만 남게 됨)
<br>]]></description><link>https://lts.kr/tools/kubernetes/🚢kubernetes(k8s)란.html</link><guid isPermaLink="false">Tools/Kubernetes/🚢Kubernetes(k8s)란.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 23 Apr 2025 09:14:09 GMT</pubDate></item><item><title><![CDATA[👔 Jenkins란]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:Tools" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Tools</a> <a class="tag" href="https://lts.kr/?query=tag:도커" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#도커</a> <a class="tag" href="https://lts.kr/?query=tag:Docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Docker</a> <br> <a href="https://lts.kr?query=tag:Tools" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Tools">#Tools</a> <a href="https://lts.kr?query=tag:도커" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#도커">#도커</a> <a href="https://lts.kr?query=tag:Docker" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Docker">#Docker</a><br>
<br>Jenkins는 오픈소스 기반의 자동화 서버로, 주로 지속적 통합(CI: Continuous Integration)과 지속적 배포(CD: Continuous Delivery/Deployment)를 자동화하기 위해 사용된다.
<br>특징<br>java기반으로 만들어져, OS에 상관없이 실행 가능
<br>파이프라인 기반으로 소프트웨어 빌드, 테스트, 배포 자동화
<br>플러그인 아키텍처로 확장성이 뛰어남
<br>
<br>개발자가 코드 변경 시 자동으로 빌드 + 테스트 수행
<br>코드 병합 시 문제 조기 탐지
<br>코드 품질 유지 + 릴리즈 주기 단축
<br>
<br>테스트 통과 후 자동으로 스테이징 또는 운영 서버에 배포
<br>릴리즈 주기 자동화 → 빠른 피드백 루프
<br>
<br>빌드 → 테스트 → 배포 → 모니터링까지의 전체 과정을 파이프라인으로 시각화
<img alt="Pasted image 20250421164348.png" src="https://lts.kr/사진-및-문서/pasted-image-20250421164348.png" style="width: 750px; max-width: 100%;" target="_self">
<br>Git Hook, Cron, Webhook, Polling 등 다양한 트리거 지원
<br>Webhook vs Polling
폴링(Poliing) : 일정 시간 간격으로 저장소의 변경사항을 확인<br>
웹훅(Webhook) : 저장소(Git 등)에 변경사항이 발생했을 때, 젠킨스에 즉시 알려주는 방식
<br>이를 설정하는 방법은 젠킨스의 파이프 라인 설정을 통해 이루어 진다.<br>파이프라인 구조 예시
<br>pipeline { agent any triggers { // GitHub에서 Webhook을 통해 이벤트가 올 때 트리거됨 githubPush() } stages { stage('Checkout') { steps { git url: 'https://github.com/your-org/your-repo.git', branch: 'main' } } stage('Build') { steps { sh 'echo Building...' } } } ---- agent any triggers { // 5분마다 Git 변경사항 확인 (cron 표현식) pollSCM('H/5 * * * *') } stages { stage('Checkout') { steps { git url: 'https://github.com/your-org/your-repo.git', branch: 'main' } } stage('Build') { steps { sh 'echo Building...' } } }
}
<br>
<br>Freestyle Job: 기본 작업 단위 (빌드, 테스트, 배포 설정)
<br>Pipeline: Groovy 기반 DSL로 멀티스텝 작업 정의
<br>Multibranch Pipeline: 브랜치마다 파이프라인 분기 설정
<br>
<br>1,800개 이상의 공식 플러그인
<br>주요 플러그인: <br>Git / GitHub / Bitbucket
<br>Docker
<br>Slack / Email Notification
<br>Kubernetes
<br>SonarQube
<br>Artifactory / Nexus <br>
<br>이메일, Slack, Teams, Webhook 등 다양한 알림 지원
<br>실패/성공/경고 상태에 따라 조건부 메시지 전송 가능
<br>
<br>작업당 빌드 결과 로그 저장
<br>실패 시 어떤 스텝에서 실패했는지 명확히 추적 가능
<br>
<br>LDAP, Active Directory 연동
<br>Role 기반 접근 제어 (RBAC)
<br>Job/Folder 단위 권한 설정 <br>
<br>Master는 Job 스케줄링 및 관리
<br>Agent (노드)는 실제 빌드 실행 담당
<br>스케일아웃 구조로 부하 분산 가능
<br>젠킨스와 도커는 서버 자동화(CI/CD)환경에서 매우 자주 함께 활용된다.
두 도구의 역할은 서로 다르지만 서로를 보완해주는 역할을 한다.<br>먼저 도커의 주 역할은 애플리케이션 실행 환경의 캡슐화 이다.
이렇게 캡슐화된 것을 이미지 또는 컨테이너라고 한다.<br>이미지와 컨테이너?
이미지와 컨테이너는 사실상 같은 개념을 가리키는 용어이다.
도커 이미지 : Docker라는 특정 기술/플랫폼을 통해 생성되고 관리되는 이미지. Docker에 종속적<br>
컨테이너 : 보다 일반적인 용어로, 컨테이너 기술을 사용하는 모든 플랫폼의 이미지를 뜻한다.
<br>즉, 젠킨스와 도커의 관계를 요약하자면
Jenkins는 Docker를 사용해 컨테이너 환경에서 빌드와 테스트를 실행하거나, 애플리케이션을 Docker 이미지로 빌드하고 레지스트리에 배포하며, 필요 시 Jenkins 자체도 Docker 컨테이너로 실행할 수 있다.<br>
<br>파이프라인 실행 트리거 <br>GitHub/GitLab에서 코드 변경 발생 시: <br>✅ Webhook: 변경 사항을 Jenkins에 즉시 알림
<br>✅ Polling: Jenkins가 주기적으로 변경 여부 확인 <br>소스코드 + Dockerfile 가져오기 <br>트리거 감지 후 Jenkins가 Git 저장소에서 코드와 Dockerfile을 `checkout <br>dockerfile
→ 컨테이너 이미지를 만들기 위한 설정 파일(스크립트)<br>
쉽게 말해, “어떤 OS에, 어떤 앱을 설치하고, 어떤 명령을 실행할 것인지”를 정의한 레시피라고 볼 수 있다.
<br>Docker 이미지 빌드 <br>docker build -t my-app . 명령으로 컨테이너 이미지 생성 <br>컨테이너 기반 테스트 수행 (선택) <br>docker run으로 테스트 자동화 실행 <br>Docker 이미지 푸시 <br>DockerHub, ECR 등에 docker push 수행 <br>서버 또는 클러스터에 배포 <br>SSH, Docker Compose, Kubernetes 등을 통해 자동 배포
▶ <a data-href="🚢Kubernetes(k8s)란" href="https://lts.kr/tools/kubernetes/🚢kubernetes(k8s)란.html" class="internal-link" target="_self" rel="noopener nofollow">🚢Kubernetes(k8s)란</a> <br>알림 및 로그 저장 <br>Slack, Email 알림 전송 + Jenkins에 빌드 로그 기록]]></description><link>https://lts.kr/tools/jenkins/👔-jenkins란.html</link><guid isPermaLink="false">Tools/Jenkins/👔 Jenkins란.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 23 Apr 2025 06:30:56 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20250421164348.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20250421164348.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🐋 docker 란]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:Tools" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Tools</a> <a class="tag" href="https://lts.kr/?query=tag:도커" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#도커</a> <a class="tag" href="https://lts.kr/?query=tag:Docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Docker</a> <br> <a href="https://lts.kr?query=tag:Tools" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Tools">#Tools</a> <a href="https://lts.kr?query=tag:도커" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#도커">#도커</a> <a href="https://lts.kr?query=tag:Docker" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Docker">#Docker</a><br><img alt="Pasted image 20250221114743.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114743.png" target="_self"><br>...aws의 설명에 의하면<br>
<br>애플리케이션을 신속하게 구축, 테스트 및 배포할 수 있는 소프트웨어 플랫폼이다.
<br>소프트웨어를&nbsp;컨테이너&nbsp;라는 표준화된 유닛으로 패키징하여 관리한다.
&nbsp;2-1. 컨테이너에는 라이브러리, 시스템 도구, 코드, 런타임 등 소프트웨어를 실행하는 데 필요한 모든것이 포함되어 있다.
<br>Docker는 AWS와 협업하여 다양한 규모에서 안정적이고 저렴하게 애플리케이션을 구축, 제공할 수 있게 한다.
<br>
<br>코드, 런타임, 시스템도구 등등등 소프트웨어를 실행하는 데 필요한 모든 것을 포함하는 독립 실행형 실행 가능 패키지 이다.
<br>다른컨테이너나 호스트 시스템을 방해하지 않고, Docker runtime을 사용하여 모든 호스트에서 실행할 수 있는 소프트웨어의 격리된 단위로 설계되어있다.
<br>
<br>별도의 하드웨어 에뮬레이션 없이 리눅스 커널을 공유해 컨테이너를 실행한다.
<br>
<br>하드웨어 에뮬레이션이 없어서 매우 빠르다. 또한 하나의 머신에서 프로세스만큼 많이 실행하는 것이 가능하다.
<br>
<br>컨테이너는 호스트의 환경이 아닌 독자적인 실행환경을 갖고 있다.
<br>이 환경은 파일(Dockerfile)들로 구성되며, 공유될 수 있다.
<br>
<br>모든 이미지에는 계층이 있으며, 현재의 이미지가 적절하지 않은 경우 이전 버전으로 롤백이 가능하다.
<br>CI/CD를 수행하는 데 도움을 준다.
<br>
<br>
서버를 처음 설정할때, OS, 라이브러리, 컴파일러 등 많은 설정이 필요하고, 버전으 변경되고 업데이트 될 때 마다 다시 재설정이 필요하다. <br>
하지만, 이러한 설정 등을 도커 컨테이너 위에서 진행한다면, 호스트 OS에 아무런 영향을 주지 않는다.
즉, 로컬 환경의 간섭 없이 독립적으로 구동된다! <br>
또한 다른 서버로 이사를 가는 상황에서 이미지만을 가져와 새로운 서버에 컨테이너를 만들어 쉽게 동일한 환경을 구성할 수 있다. <br>
<br>마이크로 서비스 구조로, 애플리케이션이 독립적인 구성 요소로 구축되어 각 애플리케이션 프로세스가 서비스로 실행된다.
<br>
<br>도커는 각 환경마다 쓸 수 있는 자원이 고정적으로 정해져 있지 않기 때문에, 유동적으로 자원을 할당하여 기존의 가상화 방식보다 훨씬 자원적, 성능적으로 뛰어나다
<br>]]></description><link>https://lts.kr/tools/docker/🐋-docker-란.html</link><guid isPermaLink="false">Tools/docker/🐋 docker 란.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Mon, 21 Apr 2025 07:39:44 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20250221114743.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20250221114743.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[📘 SpringBoot &amp; Docker + Reids 연동]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:Tools" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Tools</a> <a class="tag" href="https://lts.kr/?query=tag:도커" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#도커</a> <a class="tag" href="https://lts.kr/?query=tag:Docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Docker</a> <a class="tag" href="https://lts.kr/?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <a class="tag" href="https://lts.kr/?query=tag:Boot" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Boot</a> <a class="tag" href="https://lts.kr/?query=tag:Redis" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Redis</a> <br> <a href="https://lts.kr?query=tag:Tools" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Tools">#Tools</a> <a href="https://lts.kr?query=tag:도커" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#도커">#도커</a> <a href="https://lts.kr?query=tag:Docker" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Docker">#Docker</a> <a href="https://lts.kr?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a> <a href="https://lts.kr?query=tag:Boot" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Boot">#Boot</a> <a href="https://lts.kr?query=tag:Redis" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Redis">#Redis</a> <br><img alt="Pasted image 20250221114306.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114306.png" target="_self"><br>먼저 도커에 대한 간단한 이전 글!<br>aws의 설명에 의하면 Docker란 <br>애플리케이션을 신속하게 구축, 테스트 및 배포할 수 있는 소프트웨어 플랫폼이다. <br>소프트웨어를 컨테이너 라는 표준화된 유닛으로 패키징하여 관리한다. <br><a data-tooltip-position="top" aria-label="https://docs.docker.com/desktop/install/mac-install/" rel="noopener nofollow" class="external-link is-unresolved" href="https://docs.docker.com/desktop/install/mac-install/" target="_self">도커 다운로드 링크</a><br>각 기기에 맞는 docker 버전을 다운로드 받는다.
<img alt="Pasted image 20250221114324.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114324.png" target="_self"><br>다운로드 받은 후 명령어를 입력하여 docker의 현재 버전을 볼 수 있다.<br>※ 터미널에 'docker' 를 입력하게 되면 다양한 명령어들을 확인할 수 있다.
<img alt="Pasted image 20250221114327.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114327.png" target="_self"><br>제대로 다운로드 받았다면 docker에 기본적으로 만들어져있는 이미지들을 확인 할수 있다. 밑에 사진은 도커 데스트톱 이라는 앱이다.<br><img alt="Pasted image 20250221114334.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114334.png" target="_self"><br>터미널에서도 확인할 수 있다.<br><img alt="Pasted image 20250221114339.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114339.png" target="_self"><br>이제&nbsp;도커 파일&nbsp;을 이용하여&nbsp;도커 이미지를 생성한 후, 이미지를 빌드하여&nbsp;컨테이너를 생성해 줄것이다.<br>여기서 여러 용어들이 나오는데...<br>용어들에 대한 설명이다<br><img alt="Pasted image 20250221114345.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114345.png" target="_self"><br><img alt="Pasted image 20250221114353.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114353.png" target="_self"><br>Dockerfile을 생성하기에 앞서, .jar 파일을 생성해야한다.<br>gradle 이나 maven 을 사용하여 프로젝트를 빌드 할것이다.<br>여기서는 Maven 을 사용한다.<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://maven.apache.org/download.cgi" target="_self">https://maven.apache.org/download.cgi</a><br>홈페이지에서 직접 다운받아도 되고, brew를 사용해 각자 다운받으면 된다.<br>이후에, 프로젝트의 루트 디렉토리에서 'mvn install' 명령어를 사용하여 프로젝트를 빌드 할 수 있다.<br><img alt="Pasted image 20250221114400.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114400.png" target="_self"><br>빌드를 마치면, 프로젝트 내에&nbsp;target이 생성 됨을 볼 수 있다.<br><img alt="Pasted image 20250221114406.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114406.png" target="_self"><br>그 후, 루트 디렉토리에 'Dockerfile' 을 생성하여 준다.<br><img alt="Pasted image 20250221114411.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114411.png" target="_self"><br><img alt="Pasted image 20250221114423.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114423.png" target="_self"><br>Dockerfile 생성시 사용되는 명령어들은 다음과 같다.<br><img alt="Pasted image 20250221114428.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114428.png" target="_self"><br>나는 기본적인 옵션만 넣어서 test 하였다.<br>FROM 태그에 나의 java(jdk)버전을 확인하여 baseimage를 지정하고
( dockerRpository에서 다양한 이미지를 가져다 사용할 수 있으므로 찾아보세요)<br>ADD 태그에 maven을 통해 생성된 .jar파일과 경로를 입력한다<br>이외에 태그는 자유롭게 작성해 줄 수 있다.<br>프롬프트에 <br>docker build -t ${"도커파일 명"} ${"디렉토리"} <br>형식으로 사용할 수 있다.<br><img alt="Pasted image 20250221114434.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114434.png" target="_self"><br><img alt="Pasted image 20250221114439.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114439.png" target="_self"><br>해당 단계를 마치면 이미지가 생성된 것을 확인할 수 있다.<br>프롬프트에 <br>docker run -p ${사용할 포트번호} ${이미지 명}
<br>을 사용한다.<br>본인은 8000번 포트를 직접 사용하여 8080포트인 도커 컨테이너에 접근할 것이다.<br><img alt="Pasted image 20250221114443.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114443.png" target="_self"><br>짜잔!&nbsp; &nbsp;정상적으로 동작한다.
<img alt="Pasted image 20250221114501.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114501.png" target="_self">
<img alt="Pasted image 20250221114448.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114448.png" target="_self"><br>docker는 다운받아져 있는걸로 알고..&nbsp;<br>'docker pull redis:latest' 명령어를 사용하여 최신버전의 redis를 받아온다.<br><img alt="Pasted image 20250221114522.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114522.png" target="_self"><br>그 다음, <br>docker network create redis-network --driver bridge
<br>명령어를 사용하여 네트워크를 생성해 준다.<br>※ docker network : 컨테이너간의 통신 및 데이터 공유를 위한 가상 네트워크<br><img alt="Pasted image 20250221114527.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114527.png" target="_self"><br>이제, 'sudo vim redis.conf' 명령어를 사용하여 redis.conf 파일을 수정하여 설정을 잡아준다.<br><img alt="Pasted image 20250221114531.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114531.png" target="_self"><br>docker run \ -d \ --name redis \ -p 6379:6379 \ --network redis-network \ -v ~/${데이터를 저장할 파일 경로} /redis.conf:/etc/redis/redis.conf \ -v redis_data:/data \
redis:latest redis-server /etc/redis/redis.conf
<br><img alt="Pasted image 20250221114535.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114535.png" target="_self"><br>포트번호와, 방금 설정한 네트워크, 데이터 저장 경로를 잡아준다.<br>이렇게 설정을 마쳤으면 redis 이미지가 생성되었음을 확인할 수 있다.<br><img alt="Pasted image 20250221114539.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114539.png" target="_self"><br>최종적으로 생성된 이미지로 컨테이너를 만들어 준다.<br><img alt="Pasted image 20250221114543.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114543.png" target="_self"><br>docker run --name myredis \ -p 6379:6379 \ --network redis-network \ -v /Users/lts/Desktop/docker/redis:/data \ -d redis:latest redis-server \ --appendonly yes
<br><img alt="Pasted image 20250221114600.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114600.png" target="_self"><br>컨테이너까지 생성완료!<br>docker exec -it myredis redis-cli --raw
<br>명령어를 사용하여 컨테이너 실행<br><img alt="Pasted image 20250221114605.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114605.png" target="_self"><br>프롬프트를 보면 정상적으로 접속됨을 확인할 수 있다.<br>※ 해당 프로젝트는 Maven 을 사용한 프로젝트이다.<br>spring.cache.type=redis
spring.redis.host=localhost
spring.redis.port=6379
<br><img alt="Pasted image 20250221114610.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114610.png" target="_self"><br><img alt="Pasted image 20250221114616.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114616.png" target="_self"><br>import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.serializer.StringRedisSerializer; @Configuration
public class RedisConfig { @Value("${spring.redis.host}") private String host; @Value("${spring.redis.port}") private int port; @Bean public LettuceConnectionFactory redisConnectionFactory() { return new LettuceConnectionFactory(host, port); } @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate() { RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.setValueSerializer(new StringRedisSerializer()); redisTemplate.setConnectionFactory(redisConnectionFactory()); return redisTemplate; } @Bean public StringRedisTemplate stringRedisTemplate() { final StringRedisTemplate stringRedisTemplate = new StringRedisTemplate(); stringRedisTemplate.setKeySerializer(new StringRedisSerializer()); stringRedisTemplate.setValueSerializer(new StringRedisSerializer()); stringRedisTemplate.setConnectionFactory(redisConnectionFactory()); return stringRedisTemplate; }
}
<br><img alt="Pasted image 20250221114621.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114621.png" target="_self"><br>import lombok.AllArgsConstructor; import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.Id;
import org.springframework.data.redis.core.RedisHash;
import org.springframework.data.redis.core.index.Indexed; import java.time.LocalDateTime; @Getter
@RedisHash(value = "resultHistory", timeToLive = 3600) // Redis Repository 사용을 위한
@AllArgsConstructor
@NoArgsConstructor
public class ResultHistory { @Id private String id; @Indexed // 필드 값으로 데이터를 찾을 수 있도록 설정 (findByAccessToken) private String ip; private String originalText; private String translatedText; @Indexed private LocalDateTime createDateTime; @Builder public ResultHistory(String ip, String originalText, String translatedText, LocalDateTime createDateTime) { this.ip = ip; this.originalText = originalText; this.translatedText = translatedText; this.createDateTime = createDateTime; }
}
<br><img alt="Pasted image 20250221114628.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114628.png" target="_self"><br>import com.teamTS.funfun.model.ResultHistory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository; import java.util.List;
import java.util.Optional; @Repository
public interface ResultRedisRepository extends JpaRepository&lt;ResultHistory, String&gt; { Optional&lt;List&lt;ResultHistory&gt;&gt; findByIpOrderByCreateDateTimeAsc(String ip);
}
<br><img alt="Pasted image 20250221114633.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114633.png" target="_self"><br> @GetMapping("/hello") public String HelloWorld(Model model) { redisConnectionTest(); List&lt;TestModel&gt; tm = testRepository.getTestData(); model.addAttribute("data", tm.get(0).getTitle()); return "home/homeView"; } void redisConnectionTest() { final String key = "a"; final String data = "1"; final ValueOperations&lt;String, String&gt; valueOperations = redisTemplate.opsForValue(); valueOperations.set(key, data); final String s = valueOperations.get(key); } }
<br><img alt="Pasted image 20250221114638.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114638.png" target="_self"><br>Error starting ApplicationContext. To display the condition evaluation report re-run your application with 'debug' enabled.
<br>원인은 기존 MapperRepository와 Redis용 JpaRepository에서<br>@Repository
<br>해당 어노테이션을 사용하여 충돌한듯 하다.
이럴때는<br>spring.main.allow-bean-definition-overriding=true
<br>한 줄을 추가하여 준다.<br><img alt="Pasted image 20250221114644.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114644.png" target="_self"><br>성공적인 실행.<br><img alt="Pasted image 20250221114648.png" src="https://lts.kr/사진-및-문서/pasted-image-20250221114648.png" target="_self"><br>&nbsp;이후 ' keys * ' 명령어를 사용하여 데이터가 정상적으로 추가된 것을 확인할 수 있다.<br>]]></description><link>https://lts.kr/tools/docker/📘-springboot-&amp;-docker-+-reids-연동.html</link><guid isPermaLink="false">Tools/docker/📘 SpringBoot &amp; Docker + Reids 연동.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Mon, 21 Apr 2025 07:39:42 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20250221114306.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20250221114306.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🥇 정보처리 기사 실기 키워드]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:정보처리기사" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정보처리기사</a> <a class="tag" href="https://lts.kr/?query=tag:실기" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#실기</a> <a class="tag" href="https://lts.kr/?query=tag:키워드" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#키워드</a> <a class="tag" href="https://lts.kr/?query=tag:정리" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정리</a> <br> <a href="https://lts.kr?query=tag:정보처리기사" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정보처리기사">#정보처리기사</a> <a href="https://lts.kr?query=tag:실기" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#실기">#실기</a> <a href="https://lts.kr?query=tag:키워드" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#키워드">#키워드</a> <a href="https://lts.kr?query=tag:정리" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정리">#정리</a><br>
<br>시제품을 끊임없이 제작하며 사이클을 반복하는 개발 방법론
<br>워터폴과 대조적이며, 소프트웨어 개발을 넘어 기업 경영 전반에서 사용되고 있다.
<br>고객의 변화하는 요구사항과 환경 변화에 능동적인 소프트웨어 개발 방법론
<br>
<br>소프트웨어 공학에서 리펙토링(Refactoring)을 하는 목적에 대해 간략히 서술하시오.
<br>
리펙토링의 목적은 프로그램을 쉽게 이해하고 수정하여 빠르게 개발할 수 있도록 하기 위함이다.
<br>
<br>( 1 ) 요구사항은 시스템이 무엇을 하는지, 어떤 기능을 하는지 등 사용자가 시스템을 통해 제공받기를 원하는 기능이나 시스템이 반드시 수행해야하는 기능을 의미한다.
<br>( 2 ) 요구사항은 품질이나 제약사항과 관련된 요구사항으로, 시스템의 장비 구성, 성능, 인터페이스, 테스트, 보안 등의 요구사항을 말한다.
<br>
<br>UML에 관한 다음 괄호에 공통으로 들어갈 알맞은 용어는?
<br>( ) 다이어그램은 UML다이어그램중 객체(Object)들을 ( )로 추상화하여 표현하는 다이어그램으로, 대표적인 구조적 다이어그램이다.
<br>( )는 각각의 객체들이 갖는 속성과 메소드를 표현한 것으로 3개의 구획으로 나눠 이름, 속성, 메서드를 표기한다.
<br>
<br>UML은 시스템 분석, 설계, 구현 등 시스템 개발 과정에서 시스템 개발자와 고객 또는 개발자 상호 간의 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어로 사물, ( 1 ), 다이어그램 으로 이루어져있다.
<br>( 1 )는 사물과 사물사이의 연관성을 표현하는 것으로 연관, 집합, 포함, 일반화 등 다양한 형태의 ( 1 )가 존재한다.
<br>( 2 )는 UML에 표현되는 사물의 하나로, 객체가 갖는 속성과 동작을 표현한다. 일반적으로 직사각형으로 표현하며, 직사각형 안에 이름, 속성, 동작을 표기한다.
<br>( 3 )는 ( 2 )와 같은 UML에 표현되는 사물의 하나로, ( 2 )나 컴포넌트의 동작을 모아놓은 것이며, 외부적으로 가시화되는 행동을 표현한다. 단독으로 사용되는 경우는 없으며, ( 3 )구현을 위한 ( 2 )또는 컴포넌트와 함께 사용된다.
<br>
<br>관계(Relationship)는 사물과 사물 사이의 연관성을 표현하는 것이다.
<br>1 - 하나의 사물이 다른 사물에 포함되어 있는 관계로, 전체와 부분으로 구분되어지며, 서로 독립적이다.
<br>2 - 상위 모듈이 하위 모듈보다 더 일반적인 개념을 가지고 있으며, 하위 모듈이 상위 모듈보다 더 구체적인 개념을 가진다.
<br>
[보기]
-Association(연관 관계) : 객체간의 기본적인 관계를 나타낸다.
-Dependency(의존 관계) : 한 객체가 다른 객체에 의존하거나 영향을 받는다.
-Aggregation(집합 관계) : 부분과 전체의 관계를 나타내며, 부분이 독립적으로 존재할 수 있는 경우를 말한다.
-Realization(실체화 관계) : 인터페이스와 이를 구현하는 클래스 간의 관계
-Composition(합성 관계) : 집합관계의 특수한 형태로, 부분이 전체와 생명 주기를 공유하며 독립적으로 존재할 수 없는 경우
-Generalization(일반화 관계) : 상위 클래스와 하위 클래스 간의 관계로, 상속을 통해 일반적인 특성을 공유한다.
<br>
<br>UML을 이용한 다이어그램 중 다음 그림에 해당하는 다이어그램을 쓰시오.
<br>[ ] &lt;&lt;import&gt;&gt; [Security]
Order ----------------&gt; +(Credentials) / ( ) +(MDSCrupt)
<br>
<br>LOC기법에 의하여 예측된 총 라인 수가 30,000라인, 개발에 참여할 프로그래머가 5명, 프로그래머들의 평균 생산성이 월간 300라인일 때 개발에 소요되는 기간을 계산식과 함께 쓰시오.
<br>
<br>데이터베이스 스키마(Schema)에 대해 간략히 서술하시오.
<br>
스키마는 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 것이다.
<br>
<br>DB 설계에 대한 설명. 괄호를 채우시오
<br>( 1 ) : 논리적 구조로 표현된 데이터를 디스크 등의 저장장치에 저장할 수 있는 데이터로 변환하는 과정으로, 파일의 저장 구조 및 엑세스 경로를 결정하며, 테이블 정의서 및 명세서가 산출된다.
<br>( 2 ) : 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정으로, 개념 스키마 모델링과 트렌젝션 모델링을 수행하며, 요구 조건 명세를 E-R 다이어그램으로 작성한다.
<br>( 3 ) : 현실의 자료를 특정 DBMS가 지원하는 자료구조로 변환하는 과정으로, 트렌젝션의 인터페이스를 설계하고, 정규화를 통해 스키마를 평가 및 정제한다.
<br>
<br>다음은 데이터베이스 구축까지의 과정을 나열한 것이다. 순서대로 괄호를 채우시오. 요구분석 → ( ) → ( ) → ( ) → 구현 <br>
<br>데이터 모델이 구성 요소에 대한 다음 설명에서 괄호(1, 2)에 들어갈 용어를 쓰시오
<br>( 1 )은 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세서로서 데이터베이스를 조작하는 기본 도구에 해당된다.
<br>( 2 )는 논리적으로 표현된 객체 타입들 간의 관계로서 데이터의 구성 및 정적 성질을 표현한다.
<br>제약조건은 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건을 의미한다.
<br><img alt="do-messenger_screenshot_2025-02-10_15_04_45.png" src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-02-10_15_04_45.png" target="_self">
-다음 E-R다이어그램을 참고하여 괄호(1~5)의 설명에 적합한 요소를 찾아 기호로 표시<br>( 1 ) : 관계 집합을 의미한다.
<br>( 2 ) : 관계 집합과 속성을 연결한다.
<br>( 3 ) : 개체 집합을 의미하며, 키로 사용되는 항목에는 밑줄을 표시한다.
<br>( 4 ) : 관계 집합의 속성을 의미한다.
<br>( 5 ) : 개체 집합과 집합을 연결한다.
<br>
1 → ㄴ
2 → ㄷ
3 → ㄱ
4 → ㄹ
5 → ㅁ
<br>-키(Key)에 대한 다음 설명에서 괄호(1, 2)에 들어갈 용어를 쓰시오.<br>키는 데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 기준이 되는 속성을 말한다.
<br>슈퍼키는 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키로, 릴레이션을 구성하는 모든 튜플에 대해 ( 1 )을 만족한다.
<br>후보키(Candidate Key)는 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해 사용되는 속성들의 부분집합으로, ( 1 )과 ( 2 )을 만족하는 특징이 있다.
<br>
<br>
관계대수란 관계형 데이터베이스에서 원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절차적인 언어이다. 관계 대수에 사용되는 연산은 다음과 같다. <br>
합집합(UNION)은 두 릴레이션에 존재하는 튜플의 합집합을 구하되, 결과로 생성된 릴레이션에서 중복되는 튜플은 제되는 연산으로, 기호는 ( 1 )이다. <br>
차집합(DIFFERENCCE)은 두 릴레이션에 존재하는 튜플의 차집합을 구하는 연산으로, 사용하는 기호는 ( 2 )이다. <br>
교차곱(CARTESIAN PRODUCT)은 두 릴레이션에 있는 튜플들의 순서쌍을 구하는 연산으로, 사용하는 기호는 ( 3 )이다. <br>
프로젝트(PROJECT)는 주어진 릴레이션에서 속성 리스트(Attribute List)에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 연산으로, 사용하는 기호는 ( 4 )이다. <br>
조인(JOIN)은 공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산으로, 사용하는 기호는 ( 5 )이다. <br>
1 → U
2 → ㅡ
3 → x
4 → ㅠ
5 → |&gt;&lt;|
<br>
<br>릴레이션 A, B가 있을 때, 릴레이션 B의조건에 맞는 것들만 릴레이션 A에서 분리하여 프로젝션을 하는 연산은?
<br>
<br>( )은 관계 데이터의 연산을 표현하는 방법으로, 관계 데이터 모델의 제안자인 코드(E. F. Codd)가 수학의 술어 해석(Predicate Calculus)에 기반을 두고 관계 데이터베이스를 위해 제안했다.
<br>원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성을 지니며, 원하는 정보를 정의할 때 계산 수식을 사용한다.
<br>튜플 해석식을 사용하는 튜플 ( )과 도메인 해석식을 사용하는 도메인 ( )으로 구분된다.
<br>
<br>데이터의 중복으로 인해 테이블 조작 시 문제가 발생하는 현상을 이상(Anomaly)이라고 한다. 이상 중 삭제 이상(Deletion Anomaly)에 대해 간략히 서술하시오.
<br>
테이블에서 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는 현상.
<br>
<br>데이터베이스의 이상(Anomaly)의 종류 3가지를 쓰시오.
<br>
삽입 이상(Insertion Anomaly)
삭제 이상(Deletion Anomaly)
갱신 이상(Update Anomaly)
<br><img alt="do-messenger_screenshot_2025-02-10_17_10_58.png" src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-02-10_17_10_58.png" target="_self"><br>테이블 &lt;R&gt;에서 성적은 기본키인 {학생, 학과}에 대해 ( 1 ) Functional Dependency이다.
<br>테이블 &lt;R&gt;에서 학년은 기본키인 {학생, 학과} 중 학생만으로 식별이 가능하므로 기본키에 대해 ( 2 ) Functional Dependency이다.
<br>임이의 테이블에 속성 A, B, C가 있을 떄, A → B이고 B → C일 때 A → C인 관계는 ( 3 )Functional Dependency이다.
<br> <br>Full - 완전 함수 종속
<br>Partial - 부분 함수 종속
<br>Transitive - 이행적 함수 종속 <br>
<br>데이터베이스에서 비(반)정규화(Denormalization)의 개념을 서술하시오.
<br>
비정규화는 정규화된 데이터 모델을 통합, 중복, 분리 하는 과정으로, 의도적으로 정규화 원칙을 위배하는 행위이다.
<br>
<br>데이터베이스의 상태 변화를 일으키는 트렌젝션(Transaction)의 특성
<br> <br>원자성 : <br>트렌젝션의 연산은 데이터베이스에 모두 반영되도록 완료(Commit)되든지 아니면 전혀 반영되지 않도록 복구(Rollback)되어야 한다. <br>일관성 : <br>트렌젝션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다. <br>독립성 : <br>둘 이상의 트렌젝션이 동시에 병행 실행되는 경우 어느 하나의 트렌젝션 실행중에 다른 트렌젝션의 연산이 끼어들 수 없다. <br>지속성 <br>성공적으로 완료된 트렌젝션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다. <br>
<br>파일의 구조는 파일을 구성하는 레코드들이 보조기억장치에 편성되는 방식을 의미하는 것으로, 크게 순차, ( ), 해싱으로 구분한다.
<br>( ) 파일 구조는 &lt;값, 주소&gt; 쌍으로 구성되는 데이터 구조를 활용하여 데이터에 접근하는 방식으로, 자기 디스크서 주로 활용된다.
<br>
<br>비상 상황이 발생한 경우 비상사태 또는 업무중단 시점부터 업무가 복구되어 다시 정상 가동 될 때까지의 시간을 의미한다.
<br>
<br>접근통제는 데이터가 저장된 객체와 이를 사용하려는 주체 사이의 정보 흐름을 제한하는 것이다. 이러한 접근통제에 관한 기술 중 ( )는 데이터에 접근하는 사용자의 신원에 따라 접근 권한을 부여하여 제어하는 방식으로, 데이터의 소유자가 접근통제 권한을 지정하고 제어한다.
<br>객체를 생성한 사용자가 생성된 객체에 대한 모든 권한을 부여받고, 부여된 권한을 다른 사용자에게 허가할 수도 있다.
<br>
<br>DBMS는 데이터베이스에 치명적인 손실이 발생했을 때 이를 복구하기 위해 데이터베이스의 처리내용이나 이용 상황 등 상태 변화를 시간의 흐름에 따라 기록한 로그를 생성한다.
<br>( 1 ) : 데이터베이스가 비정상적으로 종료되었을 때, 디스크에 저장된 로그를 분석하여 트렌젝션의 시작(start)과 완료(commit)에 대한 기록이 있는 트렌젝션들의 작업을 재작업 한다. 즉, 로그를 이용하여 해당 데이터 항목에 대해 이전 값을 이후값으로 변경하는 연산이다.
<br>( 2 ) : 데이터베이스가 비정상적으로 종료되었을 때, 디스크에 저장된 로그를 분석하여 트렌젝션의 시작을 나타는 'start'는 있지만 완료를 나타내는 'commit' 기록이 없는 트렌젝션들이 작업한 내용들을 모두 취소한다. 즉 로그를 이용하여 해당 데이터 항목에 대해 이후 값을 이전 값으로 변경한다.
<br>
<br>웹 페이지의 기본 형식인 HTML의 문법이 각 웹 브라우저에서 상호 호환적이지 못한다는 문제와 SGML의 복잡함을 해결하기 위하여 개발된 ( )은 다른 특수한 목적을 갖는 마크업 언어이다.
<br>원활한 데이터의 연계를 위해 송.수신 시스템 간에 전송되는 데이터가 동일한 구조로 구성될 수 있도록 형태를 정의는 역할을 수행하며, 다음과 같은 특징이 있다.
<br>
<br>텍스트 데이터 형식으로 유니코드를 사용하여 전 세계 언어를 지원한다.
<br>
<br>대다수의 웹 브라우저가 해석을 위한 번역기(Parser)를 내장하고 있다.
<br>
<br>XML문서의 문자들은 마크업과 내용으로 구분된다.
<br>일반적으로 마크업은 &lt;로 시작하여 &gt;로 끝나는 태그(Tag)를 의미하고, 그 외의 문자열은 내용에 해당한다.
<br>
<br>마크업과 내용으로 이루어지는 하나의 요소를 의미한다.
<br>
<br>통합 구현과 관련하여 다음 설명의 괄호에 공통으로 들어갈 알맞은 용어는?
<br>( )는 HTTP, HTTPS, SMTP 등을 사용하여 xml 기반의 메시지를 네트워크상에서 교환하는 프로토콜이다.
<br>( ) envelope, 헤더, 바디 등이 추가된 xml 문서이다.
<br>( )는 복잡하고 무거운 구조로 구성되어 있어, ( )보다는 RESTful 프로토콜을 이용하기도 한다.
<br>
<br>웹 서비스와 관련된 다음 설명에 해당되는 용어는?
<br>웹 서비스와 관련된 서식이나 프로토콜 등을 표준적인 방법으로 기술하고 게시하기 위한 언어.
<br>XML로 작성되며 UDDI의 기초가 된다. SOAP, XML 스키마와 결합하여 인터넷에서 웹 서비스를 제공하기 위해 사용되며, 클라이언트는 이것을 통해 서버에서 어떠한 조작이 가능한지를 파악할 수 있다.
<br>Tip!
XML에서 언어이면 WSDL / 프로토콜이면 SOAP
<br>다음 럼바우 데이터 모델링에 대한 설명에서 각 지문(1~3)에 해당하는 모델링을 매칭시키기<br>ㄱ. 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링
ex) 자료흐름도(DFD)<br>ㄴ. 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링
ex) 상태 변화도(STD), 사건 추적도<br>ㄷ. 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 표시하는 모델링
ex) ER 다이어그램(ERD)<br>
1 → Function(기능)
2 → Dynamic(동적)
3 → Information(객체) <br>
<br>자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다는 객체지향 설계 원칙 중 하나다.
<br>예를 들어 프린터, 펙스, 복사 기능을 가진 복합기의 경우 3가지 기능을 모두 가지 범용 인터페이스보다는, 프린터 인터페이스, 팩스 인터페이스, 복사 인터페이스로 분리함으로써 하나의 기능 변경으로 인해 다른기능이 영향을 받지 않도록 해야한다.
<br>
<br>결합도(Coupling)의 종류 중 단순 처리 대상인 데이터만 전달되는 것이 아니라, 어떻게 처리해야 하는지를 결정하는 제어 요소가 전달되는 경우의 결합도를 영문으로 쓰면?
<br>
<br>( 1 )는 모듈간의 인터페이스로, 데이터,지역변수 등을 직접 참조하거나 수정할 때의 결합도다.
<br>( 2 )는 모듈간의 인터페이스로, 배열이나 레코드 등의 자료구조가 전달될 때의 결합도다.
<br>( 3 )는 모듈간의 인터페이스로, 파라미터가 아닌 모듈 밖에 선언된 전역 변수를 사용하여 전역 변수를 갱신하는 방식으로 상호작용하는 때의 결합도다.
<br>
1 → 내용 결합도
2 → 스탬프 결합도
3 → 공통 결합도
<br>
<br>내부의 요소들이 기능적으로 연관성은 없으나, 순차적으로 실행될 때의 응집도 <br>서로 다른 기능을 수행하지만 동일한 입력과 출력을 사용할 때의 응집도 <br>하나의 기능에 밀접하게 관련되어 있거나 연관되어 있을 때의 응집도 <br>우연적 응집도 &lt; 논리적 응집도 &lt; 시간적 응집도 &lt; 절차적 응집도 &lt; 통신적 응집도 &lt; 순차적 응집도 &lt; 기능적 응집도<br>기능적 응집도(Functional Cohesion) <br>모듈 내부의 모든 기능이 단일한 목적을 위해 수행되는 경우 <br>순차적 응집도(Sequential Cohesion) <br>모듈 내의 한 활동으로부터 나온 출력값을 모듈 내의 다른 활동이 사용할 경우 <br>교환적 응집도(Communicational Cohesion) <br>서로 다른 기능을 수행하지만 동일한 입력과 출력을 사용하는 활동들이 모여있을 경우 <br>절차적 응집도(Procedural Cohesion) <br>모듈 안의 구성요소들이 서로 다른 기능을 하지만 그 기능을 순차적으로 수행할 경우 <br>시간적 응집도(Temporal Cohesion) <br>연관된 기능이라기 보단 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리할 경우 <br>논리적 응집도(Logical Cohesion) <br>실제와 달리 논리적으로만 같은 그룹으로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우 <br>우연적 응집도(Coincidental Cohesion) <br>모듈 내부의 각 구성요소들이 연관이 없을 경우 <br>
1 → 절차적 응집도
2 → 교환적 응집도
3 → 기능적 응집도
<br>
<br>모듈간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합이다.
<br>복수의 프로세스를 수행하며 이뤄지는 프로세스 간 통신까지 구현이 가능하다.
<br>대표적인 메소드에는 공뮤 메모리(Shared Memory), 소켓, 세마포어, 파이프와 네임드 파이프, 메세지 큐잉이 있다.
<br>IPC(Inter-Process Communication)<br>
<br>( )패턴은 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴이다.
<br>상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당한다.
<br>다른 이름으로는 가상 생성자(Virtual Constructor) 패턴 이라고도 한다.
<br>Factory Method 패턴<br>
<br>( 1 )패턴은 구현부에서 추상층을 분리하여, 서로가 독립적으로 확장할 수 있도록 구성한 패턴으로, 기능과 구현을 두 개의 별도 클래스로 구현한다는 특징이 있다.
<br>( 2 )패턴은 한 객체의 상태가 변화하면 객체의 상속된 다른 객체들에게 변화된 상태를 전달하는 패턴으로, 일대다의 의존성을 정의한다. 주로 시스템 간에 이벤트를 생성.발행(Publish)하고, 이를 수신(Subscribe)해야할 떄 이용된다.
<br>
1 → Bridge 패턴
2 → Observer 패턴
<br>
<br>디자인 패턴은 모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예젤를 의미한다. <br>그 중 ( )패턴은 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴으로, Interpreter, Observer, Command 등이 그 예에 해당한다.
<br>디자인 패턴(Design Patterns) : GoF(생 구 행) <br>&nbsp; 1.&nbsp;생성(Creational) : 객체 생성 과정 캡슐화(싱 팩 추 빌 프)<br>
-싱글톤(Singleton) : 1객체<br>
-팩토리 메서드(Factory Method) : 책임 위임<br>
-추상 팩토리(Abstract Factory) : 여러 객체그룹 생성<br>
-빌더(Builder) : 생성 단계 캡슐화<br>
-프로토타입(Prototype) : 원본 객체 복사<br>&nbsp; 2.&nbsp;구조(Structural) : 클래스 객체 조합(어 데 퍼 프 브 컴 플)<br>
-어댑터(Adapter) : 클래스 연결<br>
-데코레이터(decorator) : 소스 변경X, 기능확장<br>
-퍼사드(Facade) : 단순화된 1인터페이스 제공<br>
-프록시(Proxy) : 원 객체작업 대신처리 / 대리<br>
-브릿지(Bridge) : 구현부 추상층 분리, 독립적 확장, 결합도 낮춤<br>
-컴포지트(Composite) : 개별 객체와 복합 객체를 동일 / 트리<br>
-플라이웨이트(Flyweight) : 공유<br>&nbsp; 3.&nbsp;행동(Behavioral) : 상호작용, 역할분담(옵 스 커 템 스 메 중 인 방 책 이)<br>
-옵저버(Observer) : 다른객체 알림 및 자동갱신<br>
-스트래티지(Strategy) : 알고리즘 캡슐화<br>
-커맨드(Command) : 요청을 객체로 캡슐화<br>
-템플릿 메서드(Template Method) : 구조 - 상위 / 구현 - 하위<br>
-스테이트(State) : 객체 상태에 따라 다른 행동 / 다형성<br>
-메멘토(Memento) : 객체상태 미리 저장 후 복구<br>
-중재자(Mediator) : 객체간 상호작용 조정<br>
-인터프리터(Interpreter) : 문법 정의 및 구문 해석<br>
-방문자(Visitor) : 객체 구조 및 처리기능 분리 / 캡슐화 위배<br>
-책임 연쇄(Chain of Responsibility) : 객체간 연결고리 / 연속적<br>
-이터레이터(Iterator) : 순차적 접근 / 반복 캡슐 / Cursor<br>&nbsp;&nbsp;&nbsp; <br>행위(Behavioral)<br>
<br>기업 내 각종 어플리케이션 및 플랫폼 간의 정보 전달, 연계, 통합 등 상호 연동이 가능하게 해주는 솔루션.
<br>Point-to-Point, Hub&amp;Spoke, Message Bus, Hybrid 등의 다양한 방식으로 구축이 가능한 모듈 연계 방법.
<br>EAI(Enterprise Application Integration)<br><img alt="do-messenger_screenshot_2025-02-11_13_47_16.png" src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-02-11_13_47_16.png" style="width: 900px; max-width: 100%;" target="_self"><br>EAI(Enterprise Application Integration)는 기업 내 비즈니스 간 통합 및 연계성을 증대시켜 효율성 및 각 시스템 간의 확정성(Determinacy)을 높여 준다. EAI의 구축 유형은 위와 같다.
<br>
1 → Point-to-Point
2 → Hub &amp; Spoke
<br>
<br>네트워크 트래픽에 대해 IP(Internet Protocol) 계층에서 IP패킷 단위의 데이터 변조 및 은닉 기능을 제공하는 네트워크 계층에서의 보안 통신 규약을 쓰시오.
<br>IPSec(Internet Protocol Security)<br>
<br>Kent Beck과 Erich Gamma 등이 개발한 자바 프로그래밍 언어용 유닛 테스트 프레임워크.
<br>xUnit계열의 한 종류이다. 같은 테스트 코드를 여러 번 작성하지 않게 도와주며, 테스트마다 예상 결과를 기억 할 필요가 없는 자동화된 해법을 제공한다.
<br>JUnit<br>
<br>사용자 인터페이스 UI(User Interface)의 설계 원칙
<br>
직관성 : 누구나 쉽게 이해하고 사용할 수 있어야 한다
유효성 : 사용자의 목적을 정확하고 완벽하게 달성해야 한다
학습성 : 누구나 쉽게 배우고 익힐 수 있어야 한다
유연성 : 사용자의 요구사항을 최대한 수용하고 실수를 최소화해야 한다
<br>
<br>애플리케이션 테스트에서 사용되는 살충제 패러독스(Pesticide Paradox)의 개념을 간략히 설명
<br> <br>살충제 패러독스는 동일한 테스트 케이스로 동일한 테스트를 반복하면 더 이상 결함이 발견되지 않는 현상을 의미한다. <br>
<br>테스트에 대한 다음 설명에서 각 (1~3)에 해당되는 커버리지(기준)을 찾으시오.
<br>최소 한번은 모든 문장이 수행되도록 구성하는 검증 기준
<br>조건식이 참 / 거짓일 때 수행되도록 구성하는 검증 기준
<br>2번과 달리 조건식에 상관없이 개별 조건이 참 / 거짓일 때 수행되도록 구성하는 검증기준
<br>
1 → 구문(문장) 커버리지
2 → 결정(분기) 커버리지
3 → 조건 커버리지
<br>
<br>소프트웨어가 수행할 특정 기능을 알기 위해서 각 기능이 완전히 작동되는 것을 입증하는 테스트.
<br>동치 클래스 분해 및 경계값 분석을 이용하는 테스트 기법이다.
<br><img alt="do-messenger_screenshot_2025-02-11_15_32_34.png" src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-02-11_15_32_34.png" target="_self"><br>다음 중 블랙박스 테스트에 속하는 녀석들은?
<br>
경계값 분석(Boundary Value Analysis)
입력값의 경계 부분(최소, 최대값 등)에서 오류가 발생할 가능성이 높다는 점을 이용하여 테스트하는 기법
동등(동치) 분할(Equivalence Partitioning)
입력값을 유사한 동작을 하는 그룹으로 나누고 각 그룹에서 대표값을 선택해 테스트하는 기법
원인-결과 그래프(Cause-Effect Graph)
그래프를 활용하여 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한 다음 효용성이 높은 테스트 케이스를 선정하여 검사하는 기법
<br>
<br>테스트 기법 중 다음과 같이 평가 점수표를 미리 정해 놓은 후 각 영역에 해당하는 입력 값을 넣고, 예상되는 출력값이 나오는지 실제 값과 비교하는 명세 기밥 테스트 기법을 쓰시오.
<br><img alt="do-messenger_screenshot_2025-02-11_16_31_10.png" src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-02-11_16_31_10.png" style="width: 1025px; max-width: 100%;" target="_self"><br>개발 단계에 따른 애플리케이션 테스트에 대한 다음 V-모델에서 (1~4)에 들어갈 알맞은 테스트를 작성하시오.
<br>
1 → 단위 테스트(Unit Test)
- 코딩 직후 소프트웨어 설계의 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 수행하는 테스트
2 → 통합 테스트(Integration Test)
- 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트
3 → 시스템 테스트(System Test)
4 → 인수 테스트(Acceptance Test)
<br>
<br>인수 테스트는 개발한 소프트웨어가 사용자의 요구사항을 충족하는지에 중점을 두고 테스트한다.
<br>( 1 ) : 선정된 최종 사용자가 여러 명의 사용자 앞에서 행하는 테스트 기법으로, 실제 업무를 가지고 사용자가 직접 테스트한다.
<br>( 2 ) : 개발자의 장소에서 사용자가 개발자 앞에서 행하는 테스트 기법으로, 테스트는 통제된 환경에서 행해지며, 오류와 사용상의 문제점을 사용자와 개발자가 함께 확인하면서 기록한다.
<br>
1 → 베타 테스트(Beta Test)
2 → 알파 테스트(Alpha Test)
<br>
<br>통합 테스트 기법 중, 두 방법에 대한 설명이다.
<br>상향식 통합 테스트는 미완성이거나 문제가 있는 상위 모듈을 대체할 수 있는 테스트 드라이버가 있다.
<br>하향식 통합 테스트는 미완성이거나 문제가 있는 하위 모듈을 대체할 수 있는 테스트 ( )가 있어야 한다.
<br>
<br>통합 테스트로 인해 변경된 모듈이나 컴포넌트에 새로운 오류가 있는지 확인하는 테스트.
<br>이미 테스트된 프로그램의 테스팅을 반복하는 것이다.
<br>수정한 모듈이나 컴포넌트가 다른 부분에 영향을 미치는지, 오류가 생기지 않았는지 테스트하여 새로운 오류가 발생하지 않음을 보증하기 위해 반복 테스트한다.
<br>
<br>특정한 몇몇 테스트 케이스의 입력 값들에 대해서만 기대하는 결과를 제공하는 오라클로, 전수 테스트가 불가능한 경우 사용하고, 경계값 및 구간별 예상값 결과 작성시 사용하는 오라클은?
<br>
<br>애플리케이션 성능 측정의 지표에 대한 다음 설명을 채우십시오
( 1 ) - 일정 시간 내에 애플리케이션이 처리하는 일의 양을 의미한다.
( 2 ) - 애플리케이션에 요청을 전달한 시간부터 응답이 도착할 때까지 걸린 시간을 의미한다.
( 3 ) - 애플리케이션에 작업을 의뢰한 시간부터 처리가 완료될 떄까지 걸린 시간을 의미한다.
자원 활용률 - 애플리케이션이 의뢰한 작업을 처리하는 동안의 CPU, 메모리, 네트워크 등의 자원 사용률을 의미.
<br>
1 → 처리량(Throughput)
2 → 응답 시간(Response Time)
3 → 경과 시간(Turn Around Time)
<br>
<br>소스 코드의 코딩 스타일, 코드에 설정된 코딩 표준, 코드의 복잡도, 코드에 존재하는 메모리 누수 현상, 스레드 결함 등을 발견하기 위해 사용하는 분석 도구이다.
<br>각각 소스코드 품질 분석에 대한 정의를 작성하세요.
<br>
<br>작성한 소스 코드를 실행하지 않고, 코딩 표준이나 코딩 스타일, 결함 등을 확인하는 코드 분석 도구.
<br>
<br>소스 코드를 직접 실행하여 프로그램의 동작이나 반응을 추적하고 보고하는 분석 도구로, 프로그램 모니터링 기능이나 스냅샷 생성 기능을 포함하고 있다.
<br>
<br>데이터를 제어하는 DCL의 하나인 GRANT의 기능에 대해 간략히 서술하시오.
<br>
GRANT는 데이터베이스 관리자가 데이터베이스 사용자에게 권한을 부여하는 데 사용하는 명령어 이다.
<br>
<br>데이터를 제어하는 DCL의 하나인 ROLLBACK에 대해 간략히 서술하시오.
<br>
ROLLBACK은 트렌젝션이 실패한 경우 작업을 취소하고 이전 상태로 되돌리기 위한 명령어이다.
<br>
<br>데이터베이스 보안에서 가용성(Availability)에 대해 간략히 서술하시오.
<br>
자산이 적절한 시간에 인가된 당사자에게 접근 가능 해야 하는 것.
위협요소 - Dos/DDoS 공격 등
<br>추가
기밀성 - 자산이 인가된 당사자에 의해서만 접근하는 것을 보장하는 것.<br>
무결성 - 자산이 인가된 당사자에 의해서, 인가된 방법으로만 변경 가능한것.
<br>
<br>보안 위협의 하나인 SQL Injection에 대해 간략히 서술하시오.
<br>
SQL Injection은 웹 응용 프로그램에 SQL 구문을 삽입하여 내부 DB서버의 데이터를 유출 및 변조하고 관리자 인증을 우회하는 공격 기법이다.
<br>
<br>
다음은 암호화 알고리즘에 대한 설명이다. 괄호를 채우시오. <br>
암호화 알고리즘은 패스워드, 주민번호, 은행계좌와 같은 중요 정보를 보호하기 위해 평문을 암호화된 문장으 만드는 절차 또는 방법을 말한다. <br>
스위스의 라이(Lai)와 메시(Messey)는 1990년 PES를 발표하고, 이후 이를 개선한 IPES를 발표하였다. IPES는 128비트의 Key를 사용하여 64비트 블록을 암호화하는 알고리즘이며 현재는 ( 1 )라고 불린다. <br>
( 2 )은 국가 안전 보장국(NSA)에서 개발한 암호화 알고리즘으로, 클리퍼 칩(Clipper Chip)이라는 IC 칩에 내장되어 있다. 80비트의 Key를 사용하여 64비트 블록을 암호화하며, 주로 전화기와 같은 음성 통신 장비에 삽입되어 음성 데이터를 암호화 한다. <br>
전화기와 같은 음성을 암호화하는데 주로 사용된다. <br>
1 → IDEA(Internetional Data Encryption Algorithm)
2 → Skipjack(가다랑어)
<br>
<br>무선랜 보안에 사용된 WEP 방식을 보완한 데이터 보안 프로토콜로, 임시 키 무결성 프로토콜이라도 한다.
<br>WEP의 취약성을 보완하기 위해 암호 알고리즘의 입력 키 길이를 128비트로 늘리고 패킷당 키할당, 키값 재설정 등 키 관리 방식을 개선하였다.
<br>
<br>1974년 IBM이 개발하고, 1975년 NBS에 의해 미국의 국가 표준으로 발표된 암호화 알고리즘
<br>블록 크기는 64비트, 키 길이는 56비트이며, 16회의 라운드를 수행한다.
<br>컴퓨터 기술이 발달함에 따라 해독이 쉬워지면서 미국의 국가 표준이 2001년 AES로 대체되었다.
<br>
<br>2001년 미국 표준 기술 연구소(NIST)에서 발표한 대칭키 암호화 알고리즘이다.
<br>DES의 한계를 느낀 NIST에서 공모한 후 발표하였다.
<br>블록 크기는 128비트이며, 키 길이에 따라 128, 192, 256으로 분류된다.
<br>
<br>1991년 R.ricest가 MD4를 개선한 암호화 알고리즘으로, 각각의 512비트짜리 입력 메세지 블록에 대해 차례동작한다.
<br>각 512비트 입력 메시지 블록을 처리하고 나면 128비트 스테이트(stat)의 값이 변하는 암호화 알고리즘이다.
<br>
<br>( ) 스푸핑은 로컬 네트워크(LAN)에서 사용하는 ( )프로토콜의 취약점을 이용한 공격 기법으로, 자신의 물리적 주소(MAC)를 변조하여 다른 PC에게 도달해야 하는 데이터 패킷을 가로채거나 방해한다.
<br>이 공격은 데이터 링크 상의 프로토콜인 ( )를 이용하기 때문에 근거리상의 통신에서만 사용할 수 있는 공격이다.
<br>
<br>아래의 패킷 로그와 같이, 공격자가 패킷의 출발지 주소(Address) 또는 포트를 임의로 변경하여 송신측 IP주소 또는 포트를 동일하게 함으로써, 송신 IP주소가 자신이므로 자신에게 응답을 수행하게 된다.
<br>자신에 대해 무한히 응답하는 패킷을 계속 전송하여 컴퓨터의 실행 속도를 느리게 하거나 동작을 마비 시켜 서비스 거부 상태에 빠지도록 하는 네워크 공격 유형은?
<br>#### source : 192.168.1.200
#### destination : 192.168.1.200
#### protocol : 6
#### src port : 21845
#### dst port : 21845
<br>
<br>( 1 )은 컴퓨터 보안에 있어서, 인간 상호 작용(사회)의 깊은 신뢰를 바탕으로 사람들을 속여 정상 보안 절차를 깨트리기 위한 비기술적 시스템 침입 수단을 의미한다.
<br>( 2 )는 특정 목적을 가지고 데이터를 수집하였으나, 이후 활용되지 않고 저장만 되어있는 대량의 데이터를 의미한다. 미래에 사용될 가능성을 고려하여 저장 공간에서 삭제되지 않고 보관되어 있으나, 이는 저장 공간의 낭비뿐만 아니라 보안 위험을 초래할 수도 있다.
<br>
1 → 사회 공학(Social Engineering)
2 → 다크 데이터(Dark Data)
<br>
<br>( )은 ‘세션을 가로채다’라는 의미로, 정상적인 연결을 RST패킷을 통해 종료시킨 후 재연결 시 희생자가 아닌 공격자에게 연결하는 공격 기법이다.
<br>TCP ( )은 공격자가 TCP 3-Way-Handshake과정에 끼어듦으로써 서버와 상호 간의 동기화된 시퀀스 번호를 갖고 인가되지 않은 시스템의 기능을 이용하거나 중요한 정보에 접근할 수 있게 된다.
<br>
<br>목표 조직이 자주 방문하는 웹 사이트를 사전에 감염시켜(웅덩이), 목표 조직의 일원이 웹 사이트에 방문했을 때 악성 코드에 감연되게 한다.
<br>이후에는 감염된 PC를 기반으로 조직의 중요 시스템에 접근하거나 불능으로 만드는 등의 영향력을 행사하는 웹 기반 공격이다.
<br>
<br>AAA서버는 사용자의 컴퓨터 자원 접근 처리와 서비스 제공에 있어서의 다음 3가지 기능을 제공하는 서버이다.
<br>접근하는 사용자의 신원을 검증하는 기능
<br>신원이 검증된 사용자에게 특정된 권한과 서비스를 허용하는 기능
<br>사용자가 어떤 종류의 서비스를 이용했고, 얼마만큼의 자원을 사용했는지 기록 및 보관하는 기능
<br>각각 무엇인지 ?
<br>
1 → Authentication - 검증
2 → Authorization - 권한 부여
3 → Accounting - 기록
<br>
<br>다양한 장비에서 발생하는 로그 및 보안 이벤트를 통합하여 관리하는 보안 솔루션으로, 방화벽, IDS, IPS, 웹 방화벽, VPN 등에서 발생한 로그 및 보안 이벤트를 통합하여 관리함으로써 비용 및 자원을 절약할 수 있는 특징이 있다.
<br>보안 솔루션 간의 상호 연동을 통해 종합적인 보안 관리 체계를 수립할 수 있다.
<br>머신러닝 기술을 이용하여 it시스템에서 발생하는 대량의 로그를 통합 관리한다.
<br>이상 징후 미리 감지
<br>
<br>헝가리안 표기법(Hungarian Notation)에 대해 간략히 서술.
<br>
헝가리안 표기법은 변수명 작성시 변수의 자료형을 알 수 있도록 자료형을 의미하는 문자를 포함하여 작성하는 방법.
ex) bool bIsTrue / int nCnt
<br>
<br>스니핑(Sniffing)은 사전적 의미로 ‘코를 킁킁 거리다, 냄새를 맡다’이다. 네트워크 보안에서 스니핑에 대한 개념을 간략히 작성.
<br>
스니핑은 네트워크의 중간에서 남의 패킷 정보를 도청하는 해킹 유형의 하나로 수동적 공격에 해당한다.
<br>
<br>C++에서 생성자에 대해 간략히 서술하시오.
<br>
생성자는 객체 변수 생성에 사용되는 메소드로, 객체 변수를 생성하면서 초기화를 수행한다.
<br>
<br>1960년대 AT&amp;T 벨(Bell) 연구소가 MIT, GM사와 함께 공동 개발한 운영체제 이다.
<br>시분할 시스템(Time Sharing System)을 위해 설계된 대화식 운영체제 이다.
<br>대부분 c언어로 작성되어 있어 이식성이 높으며, 장치/프로세스 간의 호환성이 높다.
<br>트리 구조의 파일 시스템을 갖는다.
<br><img alt="do-messenger_screenshot_2025-02-12_14_04_58.png" src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-02-12_14_04_58.png" target="_self"><br>
1 → 준비(Ready)
2 → 실행(Run)
3 → 대기(Wait)
<br>
<br>HRN 비선점형 스케줄링 우선순위를 구하는 계삭식을 쓰시오.
<br>
<br>( 1 )는 준비상태 큐에서 기다리고 있는 프로세스들 중에서 실행시간이 가장 짧은 프로세스에게 먼저 CPU를 할당하는 기법이다. 가장 적은 평균 대기 시간을 제공하는 최적 알고리즘이지만, 실행 시간이 긴 프로세스는 실행 시간이 짧은 프로세스에게 할당 순위가 밀려 무한 연기 상태가 발생 될 수 있다.
<br>
<br>( 2 )은 시분할 시스템을 위해 고안된 방식으로, 준비상태 큐에 먼저 들어온 프로세스가 먼저 CPU를 할당받지만 각 프로세스는 시간 할당량 동안만 실행한 후 실행이 완료되지 않으면 다음 프로세스에게 CPU를 넘겨고 준비상태 큐의 가장 뒤로 배치된다. 할당되는 시간이 작을 경우 문맥 교환 및 오버헤드가 자주 발생되어 요청된 작업을 신속히 처리할 수 없다.
<br>
<br>( 3 )는 현재 실행중인 프로세스의 남은 시간과 준비상태 큐에 새로 도착한 프로세스의 실행시간을 비교하 가장 짧은 실행 시간을 요구하는 프로세스에게 CPU를 할당하는 기법으로, 시분할 시스템에 유용하다. 준비상태 큐에 있는 각 프로세스의 실행 시간을 추적하여 보유하고 있어야 하므로 오버헤드가 증가한다.
<br>
1 → SJF(Shortest Job First)
2 → RR(Round Robin)
3 → SRT(Shortest Remaining Time)
<br>
<br>리눅스 또는 유닉스에서 a.txt 파일에 대해 다음 처리 조건과 같이 권한을 부여하고자 한다.
<br>사용자에게 읽기,쓰기,실행 권한을 부여한다.
<br>그룹에게 읽기,실행 권한을 부여한다.
<br>기타 사용자에게 실행 권한을 부여한다.
<br>한 줄로 작성하고, 8진법 숫자를 이용한 명령문을 이용한다.
<br>
<br>192.168.1.0/24 네트워크를 FLSM 방식으로 3개의 Subnet으로 나누는 방법
<br>즉, 64개씩 호스트를 할당하면,<br>
<br>여분의 서브넷 = 192.168.1.192/26
<br>
<br>서브넷팅(Subnetting)에 대한 설명
<br>현재 IP주소가 192.168.1.132이고, 서브넷 마스크가 255.255.255.192 일 때, 네트워크 주소와 사용가능 호스트 개수는?
<br>
<br>A Class - 0~127 / 기본 서브넷 - 255.0.0.0 (/8)
<br>B Class - 128~191 / 기본 서브넷 - 255.255.0.0 (/16)
<br>C Class - 192~223 / 기본 서브넷 - 255.255.255.0 (/24)
<br>D Class - 224~239 / 기본 서브넷 - 멀티캐스트 전용 (서브넷 X)
<br>이 때, 네트워크 개수는 2^2(추가된 1의 개수) = 4개<br>호스트개수는 256 / 4(네트워크 개수) = 64개<br>즉, 이를 표로 나타내면 →<br>여기서 192.168.1.13 는 3번째 네트워크 주소에 속하므로,
네트워크 주소는 192.168.1.128 이며, 사용 가능 호스트 주소는 네트워크와 브로드캐스트 주소를 뺀 64-2 <br>
<br>OSI 7 Layer에 대한 설명
<br>
물리적으로 연결된 두 개의 인접한 개방 시스템들 간에 신뢰성 있고 효율적인 정보 전송을 할 수 있도록 연결 설정, 데이터 전송, 오류 제어 등의 기능을 수행한다. <br>
개방 시스템들 간의 네트워크 연결을 관리하며, 경로 제어, 패킷 교환, 트래픽 제어 등의 기능을 수행한다. <br>
서로 다른 데이터 표현 형태를 갖는 시스템 간의 상호 접속을 위해 필요한 계층으로, 코드변환, 데이터 암호화, 데이터 압축, 구문 검색 등의 기능을 수행한다. <br>
다양한 전송매체를 통해 비트 스트림을 전송. 전송에 필요한 두 장치 간의 실제 접속과 절단 등 기계적, 전기적, 기능적, 절차적 특성에 대한 규칙을 정의한다. <br>
1 → 데이터 링크 계층(Data Link Layer)
2 → 네트워크 계층(Network Layer)
3 → 표현 계층(Presentation Layer)
4 → 물리 계층(Physical Layer)
<br>
<br>심리학자 톰 마릴은 컴퓨터가 메시지를 전달하고, 메시지가 제대로 도착했는지 확인하며, 도착하지 않았을 경우 메시지를 재전송하는 일련의 방법을 ‘기술적 은어’를 뜻하는 ( )이라는 용어로 정의하였다.
<br>
<br>프로토콜은 서로다른 기기들 간의 데이터 교환을 원활하게 수행할 수 있도록 표준화 시켜놓은 통신 규약이다. 프로토콜의 기본요소 3가지를 쓰시오.
<br>
구문(Syntex)
의미(Semantics)
시간(Timing)
<br>
<br>( 1 ) : 연결형 통신에서 주로 사용되는 방식으로, 출발지와 목적지의 전송 경로를 미리 연결하여 논리적으로 고정한 후 통신하는 방식
<br>( 2 ) : 비연결형 통신에서 주로 사용되는 방식으로, 사전에 접속 절차를 수행하지 않고 헤더에 출발지에서 목적지까지의 경로 지정을 위한 충분한 정보를 붙여서 개별적으로 전달하는 방식
<br>
1 → 가상 회선(Virtual Circuit)
2 → 데이터그램(Datagram)
<br>
<br>인터넷 환경에서의 호스트 상호 간 통신에서 연결된 네트워크 접속 장치의 물리적 주소인 MAC 주소를 이용하여 IP주소를 찾는 인터넷 계층의 프로토콜로, 역순 주소 결정 프로토콜이라 불린다.
<br>
RARP(Reverse Address Resolution protocol)
<br>
<br>( )는 한 번의 로그인으로 개인이 가입한 모든 사이트를 이용할 수 있게 해주는 시스템을 말한다.
<br>개인의 경우, 사이트에 접속하기 위하여 아이디와 패스워드는 물론 이름, 전화번호 등 개인정보를 각 사이트마다 일일이 기록해야 하던 것이 한 번의 작업으로 끝나므로 불편함이 해소되며, 기업에서는 회원에 대한 통합관리가 가능해 마케딩을 극대화시킬 수 있다는 장점이 있다.
<br>
SSO(Single Sign On)
<br>
<br>재난 및 군사 현장과 같이 별도의 고정된 유선망을 구축할 수 없는 장소에서 모바일 호스트만을 이용하여 구성한 네트워크.
<br>망을 구성한 후 단기간 사용되는 경우나 유선망을 구성하기 어려운 경우에 적합하다.
<br>멀티 홉 라우팅 기능을 지원한다.
<br>
애드 혹 네트워크(Ad-hoc Network)
<br>
<br>우리말로 번역하면 '네트워크 주소 변환'이라는 의미의 영문 3글자 약자이다.
<br>1개의 정식 IP 주소에 다량의 가상 사설 IP 주소를 할당 및 연결하는 방식이다.
<br>1개의 IP 주소를 사용해서 외부에 접속할 수 있는 노드는 어느 시점에서 1개만으로 제한되는 문제가 있으나, 이 때에는 IP 마스커레이드(Masquerade)를 이용하면 된다.
<br>
NAT(Network Address Translation)
<br>
<br>
정의
웹상에 존재하는 데이터를 개별 URI로 식별하고, 각 URI에 링크 정보를 부여함으로써 상호 연결된 웹을 지향하는 모형이다.
링크 기능이 강조된 시맨틱웹의 모형에 속한다고 볼 수 있으며, 팀 버너스 리의 W3C를 중심으로 발전하고있다. <br>
주요 기능 <br>공개된 데이터를 이용하면 내가 원하는 데이터가 이미 존재하는지, 어디에 존재하는지 알 수 있다.
<br>URI로 구별되는 데이터 리소스의 자유로운 접근 및 이용이 가능하므로 큰 노력 없이 데이터의 매쉬업이 가능하다.
<br>내가 만든 데이터가 아니라도 URI를 이용하여 링크만 해주면 이용할 수 있다. <br>
4대 원칙 <br>통합 자원 식별자(URI)를 사용한다,
<br>URI는 HTTP 프로토콜을 통해 접근할 수 있어야 한다.
<br>RDF나 스파클 같은 표준을 사용한다,
<br>풍부한 링크 정보가 있어야 한다. <br>
Linked Data와 Open Data를 결합한 용어이다. <br>
LOD(개방형 링크드 데이터)
<br>
<br>경로 제어 프로토콜은 크게 자율 시스템 내부의 라우팅에 사용되는 (①) 와 <br>자율 시스템 간의 라우팅에 사용되는 (②) 로 구분할 수 있다.
<br>설명 <br>(①) 는 소규모 동종 자율 시스템에서 효율적인 RIP와 대규모 자유 시스템에서 많이 사용되는 (③) 로 나누어진다.
<br>(③) 는 링크 상태(Link State)를 실시간으로 반영하여 최단 경로로 라우팅을 지원하는 특징이 있다.
<br>(④) 는 (②) 의 단점을 보완하여 만들어진 라우팅 프로토콜로, 처음 연결될 때는 전체 라우팅 테이블을 교환하고, 이후에는 변환된 정보만을 교환한다. <br>
<br>BGP
<br>AS
<br>HOP
<br>OSPF
<br>NAT
<br>ISP
<br>EGP
<br>IGP
<br> <br>IGP
<br>EGP
<br>OSPF
<br>BGP <br>
<br>P2P 네트워크를 이용하여 온라인 금융 거래 정보를 온라인 네트워크 참여자(Peer)의 디지털 장비에 분산 저장하는 기술은?
<br>
블록체인(Blockchain)
<br>
<br>정보 자산을 안전하게 보호하기 위한 보호 절차와 대책으로, 정보보호 관리 체계라고 한다.
<br>조직에 맞는 정보보호 정책을 수립하고, 위험에 상시 대응하는 여러 보안 대책을 통합 관리한다.
<br>공공 부문과 민간 기업 부문에서 이것을 평가하고 인증하는 사업을 한국인터넷진흥원(KISA)에서 운영중이다.
<br>
<br>( 1 )은 칩 설계 회사인 ARM에서 개발한 기술로, 하나의 프로세서 내에 일반 애플리케이션을 처리하는 일반 구역과, 보안이 필요한 애플리케이션을 처리하는 보안 구역으로 분할하여 관리하는 하드웨어 기반의 보안기술이다.
<br>( 2 )은 네티즌들이 사이트에 접속할 때 주소를 잘못 입력하거나 철자를 빠뜨리는 실수를 이용하기 위해 이와 유사한 유명 도메인을 미리 등록하는 것으로 URL하이재킹이라고도 한다. <br>
<br>Pharming
<br>Typosquatting
<br>Ransomware
<br>Tvishing
<br>Hacktivism
<br>CSRF
<br>Trustzone
<br>Watering Hole
<br>APT
<br>Smurfing
<br> <br>Trustzone
<br>Typosquatting <br>
<br>RAID(Redundant Array of Independent Disks)란 여러개의 하드디스크를 조합하여 성능 향상과 데이터 보호기능을 제공하는 기술이다.
<br> <br>RAID 0: 성능 최우선, 데이터 보호 없음.
<br>RAID 1: 데이터 안정성 높음, 저장 용량 절반 사용.
<br>RAID 5: 성능과 안정성 균형, 최소 3개 디스크 필요.
<br>RAID 6: RAID 5보다 높은 안정성, 최소 4개 디스크 필요.
<br>RAID 10: RAID 0과 RAID 1의 조합, 고성능과 고안정성 제공. <br>
<br>오픈 소스 기반 분산 컴퓨팅 플랫폼 이다.
<br>분산 저장된 데이터들은 클러스터 환경에서 병렬 처리된다.
<br>일반 PC급 컴퓨터들로 가상화된 대형 스토리지를 형성하고 그 안에 보관된 거대한 데이터 세트를 병렬로 처리할 수 있도록 개발되었다.
<br>더그 커팅과 마이크 캐퍼렐라가 개발했으며, 구글의 맵리듀스(MapReduce) 엔진을 사용하고 있다.
<br>
<br>데이터 마이닝(Data Mining)의 개념을 간략히 서술하시오.
<br>
데이터 마이닝은 대량의 데이터를 분석하여 데이터에 내재된 변수 사이의 상호관계를 규명하여 일정한 패턴을 찾아내는 기법이다.
<br>
<br>데이터베이스 회복(Recovery) 기법에 관련된 내용.
<br>( )은 트렌젝션이 데이터를 변경하면, 트렌젝션이 부분 완료되기 전이라도 즉시 실제 DB에 그 내용을 반영하는 기법.
<br>장애가 발생하여 회복 작업할 경우를 대비하여 갱신된 내용들을 로그에 보관시킨다.
<br>( )에서 회복 작업을 수행할 경우 Redo와 Undo 모두 수행이 가능하다.
<br>
즉각 갱신 기법(Immediate Update)
<br>
<br>데이터베이스 병행제어(Concurrency Control) 기법 중 하나로이다.
<br>접근한 데이터에 대한 연산을 모두 마칠 때 까지 추가적인 접근을 제한함으로써 상호 배타적으로 접근하여 작업을 수행하도록 하는 기법이다.
<br>
<br>
릴리즈 노트는 개발 과정에서 정리된 릴리즈 정보를 고객과 공유하기 위한 문서이다. <br>
릴리즈 노트는 정확하고 완전한 정보를 기반으로 개발팀에서 직접 현재 시제로 작성해야 한다. <br>
릴리즈 노트 작성시 노트 이름, 소프트웨어, 릴리즈 버전, 릴리즈 날짜, 릴리즈 노트 날짜, 버전 등이 포함되는 항목은? <br>
<br>소프트웨어 개발에서의 작업 중 형상 통제에 대해 간략히 서술하시오.
<br>
형상 통제는 식별된 형상 항목에 대한 변경 요구를 검토하여 현재의 기준선이 잘 반영될 수 있도록 조정하는 작업이다.
<br>
<br>소프트웨어 ( )는 소프트웨어 개발 단계의 각 과정에서 만들어지는 프로그램, 문서, 데이터등을 관리하는 것을 말한다.
<br>소프트웨어의 개발 과정에서 만들어지는 여러 버전들의 변경사항을 관리하는 일련의 활동이며 이를 지원하는 도구로 Git, SVN 등이 있다.
<br>
형상관리(SCM)
<br> 다음 설명하는 네트워크 공격 방법은?<br>ICMP, 송신 주소를 공격 대상의 IP 주소로 위장하고, 수신 주소를 해당 네트워크 라우터의 브로드캐스트 주소로 설정하는 공격으로 과부화 시키는 기법은? ICMP 패킷을 크게 만들어서 과부화 시키는 죽음의 핑과 같은 서비스 공격 유형이다.
<br>
스머핑(Smurfing)
<br>다음으로 알맞은 용어는?<br>인터넷을 통해 장치 간 사설 네트워크 연결을 생성하는 서비스로 장치의 실제 IP 주소를 가상 IP 주소로 대체하고, 데이터를 암호화하고, 데이터를 전 세계 보안 네트워크로 라우팅함으로써 정보를 보호하는 기법
<br>디바이스 간에 사설 네트워크 연결을 생성, 안전하게 익명으로 전송하는데 사용
<br>
VPN
<br>
<br>
코드 내의 각 분기점이 true 또는 false로 평가될 때마다 해당 분기점이 모두 테스트 되는 것을 목표로 한다. 각 분기점이 모든 가능한 경로로 실행되었는지 확인하는 데 사용되는 커버리지 ( ) <br>
코드의 흐름을 여러 갈래로 나누는 조건문 또는 선택문을 의미한다. 예를 들어, if-else 문이나 switch 문에서 조건에 따라 실행 경로가 달라질 때를 의미한다. ( ) <br>
개별 조건문 내에 있는 각각의 조건이 true와 false 모두를 만족하도록 테스트하는 것을 의미한다. 예를 들어, if (A &amp;&amp; B)와 같은 구문에서 A와 B가 각각 true와 false가 되는 경우를 테스트하는 것이 목표이다. ( ) <br>(보기)
㉠ 조건/결정 커버리지
㉡ 결정 커버리지
㉢ 조건 커버리지
㉣ 분기 커버리지
㉤ 변경 조건/결정 커버리지
㉥ 문장 커버리지
㉧ 다중 조건 커버리지<br> <br>문장 / 2. 분기 / 3. 조건 <br>
<br>다음 라우터 A에서 라우터 F까지 경로를 설정하기 위해 RIP 방식을 사용한다고 할 때, 라우터가 지나가는 경로를 순서대로 쓰시오.(단, 간선 위의 숫자는 라우터 간의 거리를 의미한다.)
<img alt="스크린샷 2025-04-14 오전 12.06.09.png" src="https://lts.kr/사진-및-문서/스크린샷-2025-04-14-오전-12.06.09.png" target="_self">
<br>RIP 는 최단 경로 탐색이다. (거리 벡터 라우팅 프로토콜)
<br>조건 1. 홉의 수가 최단이 되어야 한다. 그래서 C -&gt; E -&gt; F 로 가지 않고, C -&gt; F 로 간다.
<br>조건 2. 홉의 수가 같다면 비용을 최소로 한다.
<br>조건 3. 홉의 수가 15가 넘는다면 불가능으로 판단한다.
<br>
A -&gt; D -&gt; C -&gt; F
<br>
<br>대표적인 링크 상태 라우팅 프로토콜이다. 이것은 인터넷에서 연결된 링크의 상태를 감시하여 최적의 경로를 선택한다는것이다.
<br>단일 자율 시스템 내에서 라우팅 정보를 배포하는 데 사용되는 내부 게이트웨이 프로토콜이다.
<br>모든 대상에 도달하기 위한 최단 경로를 구축하고 계산하며 최단 경로는 Dijkstra 알고리즘을 사용하여 계산된다.
<br> &nbsp;아래 내용의 각각의 설명에 대한 답을 작성하시오.<br>(1) 조인에 참여하는 두 릴레이션의 속성 값을 비교하여 조건을 만족하는 튜플만 반환한다.<br>(2) 조건이 정확하게 '=' 등호로 일치하는 결과를 반환한다. <br>(3) ( (2) ) 조인에서 조인에 참여한 속성이 두 번 나오지 않도록 중복된 속성을 제거한 결과를 반환한다.<br>-조인에 참여하는 두 릴레이션의 속성 값을 비교하여 조건을 만족하는 투플만 반환한다.<br>-동등조인의 결과 릴레이션의 차수는 첫 번째 릴레이션과 두 번째 릴레이션의 차수를 합한 것.<br>-동등조인에서 조인에 참여한 속성이 두 번 나오지 않도록 중복된 속성(두 번째 속성)을 제거한 결과를 반환<br> -왼쪽 외부조인(left outer join):
왼쪽 투플 기준으로 자연조인 시 실패한 투플을 모두 보여주되 값이 없는 대응 속성에는 NULL 값을 채워서 반환한다.
-오른쪽 외부조인(right outer join):
오른쪽 투플 기준으로 자연조인 시 실패한 투플을 모두 보여주되 값이 없는 대응 속성에는 NULL 값을 채워서 반환한다.
-완전 외부조인(full outer join):
양쪽 투플 기준으로 자연조인 시 실패한 투플을 모두 보여주되 값이 없는 대응 속성에는 NULL 값을 채워서 반환한다.<br>-자연조인을 한 후 두 릴레이션 중 한쪽 릴레이션의 결과만 반환<br> <br>세타 조인
<br>동등 조인
<br>자연 조인 <br>
<br>다음 아래 내용을 보고 보기에서 알맞는 용어를 골라 작성하시오.
<br>인터넷 공격자의 존재를 숨기면서 이 공격자에게 시스템에 대한 무제한 접근 권한을 부여하는 악성 프로그램이다.
해커가 자신의 존재를 숨기면서 허가되지 않은 컴퓨터나 소프트웨어에 접근할 수 있도록 설계된 도구이다.
일반적으로 펌웨어, 가상화 계층 등의 다양한 시스템 영역에서 작동하며, 운영체제의 시스템콜을 해킹하여 악성코드의 실행여부를 숨겨 안티바이러스 탐지를 우회할 수 있다.<br>
백도어(Backdoor)
<br>
<br>다음 아래 내용에 알맞는 공격 방법은?
<br>
불특정 다수가 아닌 명확한 표적을 정하여 지속적인 정보수집 후 공격감행할 수 있다. <br>
시스템에 직접 침투하는 것뿐 아니라 표적 내부직원들이 이용하는 다양한 단말을 대상으로 한다. <br>
한가지 기술만이 아닌 Zero-day 취약점, 악성코드 등 다양한 보안 위협 공격 기술을 사용한다. <br>
일반적으로 공격은 침투, 검색, 수집 및 유출의 4단계로 실행되며, 각 단계별로 다양한 공격 기술을 사용한다. <br>
APT
<br>
<br>다음이 설명하는 디자인 페턴은? <br>
구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴이다. <br>
연관성이 있는 객체 군이 여러개 있을 경우 이들을 묶어 추상화하고, 어떤 구체적인 상황이 주어지면 팩토리 객체에서 집합으로 묶은 객체 군을 구현화 하는 생성 패턴이다 <br>
관련성 있는 여러 종류의 객체를 일관된 방식으로 생성하는 경우에 유용하다. <br>kit라고도 불린다.<br>
추상펙토리 패턴(Abstract Factory)
<br>
<br>
다음 설명은 서버 접근 통제의 유형이다. 괄호 안에 들어갈 용어를 작성하시오. ('영어 약자'로 작성하시오.) <br>
( ① )은/는 규칙 기반(Rule-Based) 접근통제 정책으로, 객체에 포함된 정보의 허용 등급과 접근 정보에 대하여 주체가 갖는 접근 허가 권한에 근거하여 객체에 대한 접근을 제한하는 방법이다. <br>
( ② )은/는 중앙 관리자가 사용자와 시스템의 상호관계를 통제하며 조직 내 맡은 역할(Role)에 기초하여 자원에 대한 접근을 제한하는 방법이다. <br>
( ③ )은/는 신분 기반(Identity-Based) 접근통제 정책으로, 주체나 그룹의 신분에 근거하여 객체에 대한 접근을 제한하는 방법이다. <br>
1 → MAC
2 → RDAC
3 → DAC
<br>
<br>다음 설명에 대해 괄호 안에 알맞는 용어를 작성하시오. ('영어 약자' 로 작성하시오.)
<br>
( )은/는 자료를 일정한 크기로 정하여 순서대로 전송하는 자료의 전송 방식이다. <br>
셀이라 부르는 고정 길이 패킷을 이용하여 처리가 단순하고 고속망에 적합하며, 연속적으로 셀을 보낼 때 다중화를 하지 않고 셀단위로 동기가 이루어지지만 경우에 따라 동기식 시간 분할 다중화를 사용하기도 한다. <br>
가상 채널 (Virtual Channel) 기반의 연결 지향 서비스로 셀이라 부르는 고정 길이(53바이트) 패킷을 사용하며 통계적 다중화 방식을 이용한다. <br>
ATM
<br>
<br>&nbsp;IP 패킷에서 외부의 공인 IP주소와 포트 주소에 해당하는 내부 IP주소를 재기록하여 라우터를 통해 네트워크 트래픽을 주고받는 기술은 무엇인가?
<br>
NAT
<br>
<br>다음은 클라우드에 대한 유형 문제이다. 괄호안에 알맞는 답을 보기에 골라 작성하시오.
<br><img alt="Pasted image 20250415182923.png" src="https://lts.kr/사진-및-문서/pasted-image-20250415182923.png" target="_self"><br>PaaS / SaaS / IaaS
<br>IaaS : 서비스로서의 인프라, 개발 및 테스트 환경의 구축 및 제거가 빠르고 유연, AWS, Azure, GC가 대표적, 사용자가 컨트롤할 수 있는 범위가 넓음 - os, middleware runtime, data, applications<br>PaaS : 서비스로서의 플랫폼, 제공업체가 자체 인프라에서 하드웨어와 소프트웨어를 호스팅, Elastic Beanstalk, Heroku, Red Hat OpenShift, 사용자가 컨트롤할 수 있는 범위 - Applications, Data<br>SaaS : 서비스로서의 소프트웨어, 모든 애플리케이션은 제공업체가 관리, 웹 브라우저를 통해 제공, 사용자는 대시보드 또는 API를 통해 애플리케이션에 연결, 개별 시스템에 소프트웨어를 설치할 필요가 없음, Dropbox, salesforce, google apps, red hat insights<br> <br>→ IaaS
<br>→ PaaS
<br>→ SaaS <br>
<br>&nbsp;다음은 데이터베이스에 관련된 문제이다. 괄호 안에 알맞는 답을 작성하시오.
<br>
( ) 무결성은 관계 데이터베이스 관계 모델에서 2개의 관련 있던 관계 변수(테이블) 간의
일관성(데이터 무결성)을 말한다. <br>
종종 기본 키 또는 키가 아닌 후보 키와 외래 키의 조합으로 강제 적용된다. <br>
외래 키가 선언된 관계 변수의 외래 키를 구성하는 속성(열)의 값은 그 관계 변수의 부모가 되는 관계 변수의 기본 키 값 또는 기본 키가 아닌 후보 키 값으로 존재해야 한다. <br>
참조 무결성
<br>
<br>다음 보기는 암호화 알고리즘에 대한 내용이다. 대칭키와 비대칭키에 해당하는 용어를 보기의 내용 참고하여 작성하시오.
<br>[보기]
DES, RSA, AES, ECC, PKI, ARIA, SEED<br>
대칭키 : ( ) <br>
비대칭키 : ( ) <br>
대칭키 → DES / AES / ARIA / SEED
비대칭키 → RSA / ECC
<br>
<br>아래 내용을 확인하여 알맞는 답을 작성하시오.
○ 2 계층(데이터링크 계층)에서 구현되는 터널링 기술 중 하나
○ L2F와 PPTP가 결합된 프로토콜로 VPN과 인터넷 서비스 제공자(ISP)가 이용
○ IPsec을 함께 사용하면 PPTP보다 훨씬 안전하지만 보안보다 익명화에 더 적합
<br>
L2TP
<br>
<br>다음 설명에 해당하는 알맞은 용어를 영문 3글자로 쓰시오.
<br>○ 다른 컴퓨터에 로그인, 원격 명령 실행, 파일 복사 등을 수행할 수 있도록 다양한 기능을 지원하는 프로토콜 또는 이를 이용한 응용 프로그램이다.<br>○ 데이터 암호화와 강력한 인증 방법으로 보안성이 낮은 네트워크에서도 안전하게 통신할 수 있다.<br>○ 키(Key)를 통한 인증 방법으로 사용하려면 사전에 클라이언트의 공개키를 서버에 등록해야 한다.<br>○기본적으로는 22번 포트를 사용한다.<br>
SSH
<br>
<br>다음 보안 관련 설명으로 괄호안에 알맞는 용어를 작성하시오.
<br>( )은/는 TCP/IP에서 IP 패킷을 처리할 때 발생되는 문제를 알려주는 프로토콜이다.<br>( ) 프로토콜은 보통 다른 호스트나 게이트웨이 와 연결된 네트웍에 문제가 있는지 확인하기 위한 목적으로 주로 사용된다.<br>( ) 을/를 이용한 공격에는 ( ) Flooding가 있는데 ping 명령어를 통한 ( ) 패킷을 연속적으로 계속 보내어 서버의 요청에 응답으로 인한 다른작업을 하지 못하도록 하는 공격이다.<br>
ICMP
<br>
<br>다음 설명하는 디자인 패턴은?
( )은/는 복잡한 시스템을 개발하기 쉽도록 클래스나 객체을 조합하는 패턴에 속하며,
대리라는 이름으로도 불린다. 내부에서는 객체 간의 복잡한 관계를 단순하게 정리해 주고,
외부에서는 객체의 세부인 내용을 숨기는 역할을 한다.
<br>
proxy
<br>
<br>다음 파이썬 코드의 알맞는 출력값을 작성하시오.
<br>a = {'한국', '중국', '일본'}
a.add('베트남')
a.add('중국')
a.remove('일본')
a.update({'홍콩', '한국', '태국'})
print(a)
<br>
{'한국,'중국','베트남',홍콩','태국'}
<br>
<br>&nbsp;다음은 스키마와 관련된 내용이다. 각 괄호안에 알맞는 답을 작성하시오.
<img alt="Pasted image 20250416171828.png" src="https://lts.kr/사진-및-문서/pasted-image-20250416171828.png" target="_self">
<br>
1 → 외부스키마
2 → 개념스키마
3 → 내부스키마
<br>
<br>다음 아래 제어 흐름 그래프가 분기 커버리지를 만족하기 위한 테스팅 순서를 쓰시오.
<img alt="Pasted image 20250416172118.png" src="https://lts.kr/사진-및-문서/pasted-image-20250416172118.png" target="_self">
<br>
1234561
124567
<br>
<br>다음 관계 대수 항목에 대해 괄호안에 들어갈 기호를 쓰시오.
<br>
U
<br>X
π
⋈
<br>
<br>&nbsp;다음은 디자인 패턴에 대한 설명이다. 괄호안에 알맞는 답을 작성하시오.
<br>( 1 )은/는 기능을 처리하는 클래스와 구현을 담당하는 추상 클래스로 구별한다.
구현뿐 아니라 추상화도 독립적 변경이 필요할 때 ( 1 ) 패턴을 사용한다.
기존 시스템에 부수적인 새로운 기능들을 지속적으로 추가할 때 사용하면 유용하며,
새로운 인터페이스를 정의하여 기존 프로그램의 변경 없이 기능을 확장할 수 있다.<br>( 2 )은/는 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달해주는 패턴이다.
일대다 관계를 가지며, ​주로 분산된 시스템 간에 이벤트를 생성·발행(Publish)하고, 이를 수신(Subscribe)해야 할 때 이용한다.<br>
1 → 브릿지
2 → 옵저버
<br>
<br>. 다음 보기 중 형상 관리 도구에 해당하는 것을 모두 고르시오.
<br>ATM, CVS, OLAP, DDOS, SVN, Cyber Kill Chain, OLTP, Git<br>
SVN / GIT / CVS
<br>
<br>다음은 스케줄링에 관한 내용이다. 괄호안에 알맞는 답을 작성하시오.
<img alt="Pasted image 20250416181833.png" src="https://lts.kr/사진-및-문서/pasted-image-20250416181833.png" target="_self">
<br>
A → FCFS
B → SJF
C → RR
D → SRT
<br>
<br>다음은 E-R다이어그램의 표기 방법이다. 각 칸에 들어갈 알맞은 답을 골라 쓰시오.
<img alt="Pasted image 20250416182123.png" src="https://lts.kr/사진-및-문서/pasted-image-20250416182123.png" target="_self">
<br>
A → 개체 타입
B → 약한 개체 타입
C → 관계 타입
D → 약한 관계 타입
E → 속성
F → 키 속성
G → 다중값 속성
<br>-&nbsp;아래에서 설명하는 내용을 영문 약자로 쓰시오.<br>키보드나 마우스와 같은 장치 없이 말이나 행동 그리고 감정과 같은 인간의 자연스러운 표현으로 컴퓨터나 장치를 제어할 수 있는 환경?<br>
NUI
<br>
<br>OSI 7 Layer에 대한 설명이다. 다음 각 설명에 해당되는 계층을 적으시오.
<br>(1) 물리계층을 통해 송수신되는 정보의 오류와 흐름을 관리하여 안전한 정보의 전달을 수행할 수 있도록 도와주는 역할
(2) 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능
(3) 수신자에서 데이터의 압축을 풀수 있는 방식으로 된 데이터 압축<br>물리 - 기계적, 전기적 특성. X.21, 리피터, 허브
데이터 링크 - 흐름 제어, 오류 검출과 회복, HDLC, MAC, 랜카드, 브리지, 스위치
네트워크 - 경로 설정(Routing), 트래픽 제어, 패킷, X.25, IP, 라우터
전송 - 다중화, 오류 제어, 흐름 제어, TCP, UDP, 게이트웨이
세션 - 송수신 측 간의 관련성을 유지, 대화 제어
표현 - 데이터 암호화, 데이터 압축, 형식 변환
응용 - 파일 전송, 전자 사서함(메일), 정보 교환, 가상 터미널
★ 데이터 링크는 노드 사이의 흐름과 오류 제어.
★ 전송은 단말기 사이의 흐름과 오류 제어.****<br>
1 → 데이터링크 계층
2 → 네트워크 계층
3 → 표현계층
<br>
<br>데이터 모델 구성요소 3가지를 쓰시오.
<br>개체 데이터 모델에서는 ( A ) 을/를 이용하여 실제 데이터를 처리하는 작업에 대한 명세를 나타내는데 논리 데이터 모델에서는 ( B ) 을/를 어떻게 나타낼 것인지 표현한다.
( C ) 은/는 데이터 무결성 유지를 위한 데이터베이스의 보편적 방법으로 릴레이션의 특정 칼럼에 설정하는 제약을 의미하며, 개체무결성과 참조 무결성 등이 있다.<br>
A → 연산
B → 구조
C → 제약조건
<br>
<br>다음은 결합도에 대한 설명이다. 빈칸에 들어갈 알맞은 용어를 보기에서 찾아 쓰시오.
<br>( A ) 은/는 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우의 결합도
( B ) 은/는 모듈 간의 인터페이스로 배열이나 객체, 구조 등이 전달되는 경우의 결합도
( C ) 은/는 파라미터가 아닌 모듈 밖에 선언된 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호작용하는 경우의 결합도<br>[보기] : 자료 결합도 / 스탬프 결합도 / 제어 결합도 / 공통 결합도 / 내용 결합도 / 외부 결합도<br>내용 → 내부에 있는 변수/기능
공통 → 전역 변수
외부 → 외부, 다른 어쩌구
제어 → 제어 어쩌구
스탬프 → 배열, 구조 어쩌구
자료 → 파라미터 만 의존<br>
A - 내용 결합도
B - 스탬프 결합도
C - 공통 결합도
<br>다음 내용에 해당하는 알맞는 답을 작성하시오.<br>
소프트웨어에서 워터마크 삭제 등과 같이 소프트웨어가 불법으로 변경(unauthorized modifications)되었을 경우, 그 소프트웨어가 정상 수행되지 않게 하는 기법이다. <br>
소프트웨어 변조 공격을 방어하기 위해 프로그램에 변조검증코드(tamper-proofing code)를 삽입하는 것도 한 방법으로, 변조검증코드의 용도는 첫째 프로그램이 변경되었는지를 탐지하는 것이고, 둘째는 변조가 탐지되었다면 프로그램이 실행되지 않게 한다. <br>
소프트웨어의 위변조 방지 역공학 기술의 일종으로 디지털 콘텐츠의 관련 산업이나 전자상거래 또는 보호해야 할 소프트웨어가 있는 다양한 산업 분야에 적용된다. <br>
템퍼 프루핑 (Tamper Proofing)
<br>시스템 분석 및 설계, 또는 문서화에 사용되는 기법으로 시스템 실행 과정인 입력, 처리, 출력의 기능을 표현한 용어를 영문약어로 쓰시오.<br>
HIPO(Hierarchy Input Process Output)
<br>
<br>
BIA(Business Impact Analysis) - 장애나 재해로 인해 운영상의 주요 손실을 볼 것을 가정하여 시간 흐름에 따른 영향도 및 손실평가를 조사하는 BCP를 구축하기 위한 비즈니스 영향 분석 <br>
RTO(Recovery Time Objective) - 업무중단 시점부터 업무가 복구되어 다시 가동될 때까지의 시간 <br>
RPO(Recovery Point Objective) - 업무중단 시점부터 데이터가 복구되어 다시 정상가동될 때 데이터의 손실 허용 시점 <br>
DRP(Disaster Recovery Plan) - 재난으로 장기간에 걸쳐 시설의 운영이 불가능한 경우를 대비한 재난 복구 계획 <br>
DRS(Disaster Recovery System) - 재해복구계획의 원활한 수행을 지원하기 위하여 평상시에 확보하여 두는 인적,물적 자원 및 이들에 대한 지속적인 관리체계가 통합된 재해복구센터 <br>(비즈니스 연속성 계획(BCP)이란 각종 재해나 재난발생에 대비하여 핵심 업무 기능수행의 연속성을 유지하여 고객 서비스의 지속성 보장과 고객에 대한 신뢰도를 높이는 신속한 절차와 체계를 구축해 기업의 가치를 최대화 해주는 방법론)<br>구조적 방법론(Structured Development) - 전체 시스템을 기능에 따라 나누어 개발하고, 이를 통합하는 분할과 정복 접근 방식의 방법론<br>정보공학 방법론(Information Engineering Development) - 정보시스템 개발에 필요한 관리 절차와 작업 기반을 체계화한 방법론<br>개체지향 방법론(Object-Oriented Development) - '객체'라는 기본 단위로 시스템을 분석 및 설계하는 방법론<br>컴포넌트 기반 방법론(CBD : Component Based Development) - 소프트웨어를 구성하는 컴포넌트를 조립해서 하나의 새로운 응용 프로그램을 작성하는 방법론<br>애자일 방법론(Agile Development) - 절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적용하면서 효율적으로 시스템을 개발할 수 있는 신속 적응적 경량 개발방법론<br>제품 계열 방법론(Product Line Development) - 특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론<br>참 오라클 - 모든 입력값에 대하여 기대하는 결과를 생성함으로써 발행된 오류를 모두 검출할 수 있는 오라클<br>샘플링 오라클 - 특정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공해주는 오라클<br>휴리스틱 오라클 - 샘플링 오라클을 개선한 오라클로, 특정 입력값에 대해 올바른 결과를 제공하고, 나머지 값들에 대해서는 휴리스틱(추정)으로 처리하는 오라클<br>일관성 검사 오라클 - 애플리케이션 변경이 있을 때, 수행 전과 후의 결과값이 동일한지 확인하는 오라클<br>(테스트 오라클은 테스트의 결과가 참인지 거짓인지를 판단하기 위해서 사전에 정의된 참값을 입력하여 비교하는 기법입니다.)<br>IP (Internet Protocol) - 송수신 간의 패킷 단위로 데이터를 교환하는 네트워크에서 정보를 주고받는 데 사용하는 통신 프로토콜<br>ARP (Address Resolution Protocol) - IP 네트워크상에서 IP 주소를 MAC 주소(물리 주소)로 변환하는 프로토콜<br>RARP (Reverse Address Resolution Protocol) - IP 호스트가 자신의 물리 네트워크 주소(MAC)는 알지만 IP주소를 모르는 경우, 서버로부터 IP 주소를 요청하기 위해 사용하는 프로토콜<br>ICMP (Internet Control Message Protocol) - IP 패킷을 처리할 때 발생하는 문제를 알려주는 프로토콜 메세지 형식은 8bit 헤더와 가변 길이의 데이터 영역으로 분리<br>IGMP (Internet Group Management Protocol) - 인터넷 그룹 관리 프로토콜은 호스트 컴퓨터와 인접 라우터가 멀캐스트 그룹 멤버십을 구성하는데 사용하는 통신 프로토콜<br>라우팅 프로토콜 (Routing Protocol) - 데이터 전송을 위해 목적지까지 갈 수 있는 여러 경로 중 최적의 경로를 설정해 주는 라우터 간의 상호 통신 프로토콜]]></description><link>https://lts.kr/study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-키워드.html</link><guid isPermaLink="false">study/정보처리기사/정보처리기사 실기/🥇 정보처리 기사 실기 키워드.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Mon, 21 Apr 2025 01:40:00 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-02-10_15_04_45.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/do-messenger_screenshot_2025-02-10_15_04_45.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🥇 정보처리 기사 실기 SQL 문제]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:정보처리기사" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정보처리기사</a> <a class="tag" href="https://lts.kr/?query=tag:실기" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#실기</a> <a class="tag" href="https://lts.kr/?query=tag:SQL" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SQL</a> <a class="tag" href="https://lts.kr/?query=tag:정리" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정리</a> <br> <a href="https://lts.kr?query=tag:정보처리기사" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정보처리기사">#정보처리기사</a> <a href="https://lts.kr?query=tag:실기" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#실기">#실기</a> <a href="https://lts.kr?query=tag:SQL" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SQL">#SQL</a> <a href="https://lts.kr?query=tag:정리" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정리">#정리</a><br>CREATE TABLE 부서 ( 부서코드 INT PRIMARY KEY, 부서명 VARCHAR(20)
); CREATE TABLE 직원 ( 직원코드 INT PRIMARY KEY, 부서코드 INT, 직원명 VARCHAR(20), FOREIGN KEY(부서코드) REFERENCES 부서(부서코드) ON DELETE CASCADE
); INSERT INTO 부서 VALUES(10, '영업부');
INSERT INTO 부서 VALUES(20, '기획부');
INSERT INTO 부서 VALUES(30, '개발부'); INSERT INTO 직원 VALUES(1001, 10, '이진수');
INSERT INTO 직원 VALUES(1002, 10, '곽명경');
INSERT INTO 직원 VALUES(1003, 20, '김건길');
INSERT INTO 직원 VALUES(1004, 20, '최민수');
INSERT INTO 직원 VALUES(1005, 20, '이용광');
INSERT INTO 직원 VALUES(1006, 30, '한성광');
INSERT INTO 직원 VALUES(1007, 30, '박미경');
<br>SELECT DISTINCT COUNT(부서코드) FROM 직원 WHERE 부서코드 = 20;
<br>결과: 3<br>해설 :<br>DISTINCT(중복 제거)는 부서코드가 아닌 COUNT(부서코드)에 적용되므로, 여전히 부서코드가 20인 컬럼의 수 '3'이 된다.
<br>DELETE FROM 부서 WHERE 부서코드 = 20;
SELECT DISTINCT COUNT(부서코드) FROM 직원;
<br>결과: 4<br>해설 :<br>부서코드가 20인 컬럼을 삭제한 후, 모든 직원테이블의 부서코드 개수를 센다. 이때 DISTINCT(중복 제거)는 COUNT에 적용되므로
여전히 '4'이다.
<br>
<br>DEPT는 '학과'를 뜻한다
<br>가정: 전기과 학생 50명, 전자과 학생 100명, 전산과 학생 50명<br>SELECT DEPT FROM STUDENT;
<br>결과: 200<br>SELECT DISTINCT DEPT FROM STUDENT;
<br>결과: 3<br>해설 :<br>전기/전자/화학 3가지 종류로 이루어진 DEPT 속성의 중복을 제거하면 '3'이 남는다.
<br>SELECT COUNT(DISTINCT DEPT) FROM STUDENT WHERE DEPT = '전산과';
<br>결과: 1<br>해설 :<br>전산과인 학생들의 학과를 뽑는다. 이후 해당 학과의 중복을 제거하면 1개만 남게 된다.
<br>
<br>'H'제조사의 '단가' 보다 높은 '단가'를 가진 제품의 정보를 조회하는 SQL문이다.
<br>SELECT 제품명, 단가, 제조사
FROM 제품
WHERE 단가 &gt; ( ) (SELECT 단가 FROM 제품 WHERE 제조사 = 'H');
<br>답: ALL<br>해설 :<br>해당 쿼리는, where절의 하위 질의에 결과를 반영하여 본 질의의 조건에 추가하는 SQL이다.
<br>만약 서브쿼리에서 'H'제조사의 제품의 단다가 100/200/400 이 나왔다면,
<br>해당 단가들 보다 높은 단가를 찾기 위해서는 100/200/400을 모두 비교하여야 한다.
<br>따라서 ALL키워드가 들어간다면 모든 단가를 비교할 수 있다.
<br>서브쿼리 앞에 아무 키워드도 붙지 않는다면, 서브쿼리가 다중 행일때 오류를 발생시킨다.
이때, ANY나 ALL 연산자를 사용하여 다중행을 비교할 수 있다.<br>ANY -&gt; 서브쿼리 결과 중 하나라도 참이면 해당 행은 참
ALL -&gt; 서브쿼리 결과 중 모든 것에 참이어야 해당 행은 참<br>TABLE<br>SELECT COUNT(COL2)
FROM TABLE
WHERE COL1 IN (2, 3) OR COL2 IN (3, 5);
<br>결과: 3<br>해설 :<br>COL1 컬럼에 2나 3이 포함되었거나, COL2컬럼에 3이나 5가 포함된 컬럼 (4개)를 찾는다,
<br>
<br>여기서 NULL은 COUNT에 집계가 되지 않으므로 답은 '3'이다.
<br><img alt="Pasted image 20250225161448.png" src="https://lts.kr/사진-및-문서/pasted-image-20250225161448.png" target="_self"><br>결과 :<br>① TTL - ② 부장 - ③ 대리 - ④ 과장 - ⑤ 차장
<br>해설 :<br>해당 관계 대수식의 파이는 속성 리스트에 제시된 속성값만을 추출하여 새로운 릴레이션을 만드는 PROJECT연산이다
<br>따라서, TTL속성이 추출되어 속성명인 TTL부터 모든 속성값이 결과로 나타난다.
= SELECT TTL FROM EMPLOYEE
<br>이 연산들은 관계형 데이터베이스의 데이터를 검색하고 변형하는 데 사용됩니다.<br>관계 대수에서 테이블을 하나의 집합(Set)으로 간주하고 수행하는 연산입니다.<br>(단, SQL문은 ISO/IEC 9075 표준을 기반으로 작성하시오.) <br>( 1 ) TABLE 학생 ( 2 ) 주소 VARCHAR(20);
<br>답 :
1 -&gt; ALTER
2 -&gt; ADD<br>해설 :<br>속성을 추가한다 -&gt; 테이블을 수정한다 -&gt; ALTER
<br>ALTER + ADD 속성 추가.
<br>
<br>3, 4학년의 학번, 이름을 조회한다.
<br>IN 예약어를 사용해야 한다.
<br>속성명 아래의 괄호는 속성의 자료형을 의미한다.
<br>정답 :<br>SELECT 학번, 이름 FROM 학생 WHERE 학년 IN (3, 4);
<br>해설 :<br>IN예약어는 WHERE절과 함께 쓰이며, WHERE 속성 IN (조건,조건,...) 방식으로 사용된다.
<br>해당 조건을 포함하고 있는 모든 속성이 선택되게 된다.
<br>student 테이블<br>정답 :<br>CREATE INDEX idx_name ON student(name);
<br>해설 :<br>인덱스 생성 문법 :
CREATE INDEX 인덱스명 ON 테이블명(속성);
<br>(단, 아래의 실행 결과가 되도록 한다.)<br>
<br>
WHERE 조건절은 사용할 수 없다. <br>
GROUP BY는 반드시 포함한다. <br>
집계함수(Aggregation Function)를 적용한다. <br>
학과별튜플수 컬럼명을 출력에 Alias(AS)를 활용한다. <br>
문장 끝의 세미콜론(;)은 생략해도 무방하다. <br>
인용부호 사용이 필요한 경우 단일 따옴표(' ')를 사용한다.
정답 : <br>SELECT 학과, COUNT(*) AS 학과별튜플수
FROM 학생
GROUP BY 학과;
<br>&lt;처리 조건&gt;을 참고하여 적합한 SQL문을 작성하시오.<br>
<br>WHERE문은 사용하지 않는다.
<br>GROUP BY와 HAVING을 이용한다.
<br>집계함수(Aggregation Function)를 사용하여 명령문을 구성한다.
<br>최소점수, 최대점수는 별칭(Alias)을 위한 AS문을 이용한다.
<br>명령문 마지막의 세미콜론(;)은 생략 가능하다.
<br>인용 부호가 필요한 경우 작은따옴표(')를 사용한다.
<br>정답 :<br>SELECT 과목이름, MIN(점수) AS 최소점수, MAX(점수) AS 최대점수 FROM 성적 GROUP BY 과목이름 HAVING AVG(점수) &gt;= 90;
<br>해설 :<br>과목이름별로 여러 점수의 통계를 내는것 이기 때문에, GROUP BY 과목이름을 사용한다.
<br>이때, GROUP BY ~ HAVING 조건 을 사용하여, 해당 그릅화된 데이터 중 다음 조건을 만족하는 그룹만 포함한다.
<br>SELECT COUNT(*) CNT FROM A CROSS JOIN B WHERE A.NAME LIKE B.RULE;
<br>답 : 4<br>해설 :<br>SELECT COUNT(*) CNT 에서 CNT는 as CNT 가 생략된 형태이다.
<br>CROSS JOIN이란 카디션 프로덕트(곱)을 수행하는 조인방식으로써,
A테이블의 모든 행과, B테이블의 모든 행의 모든 가능한 조합을 구한다.
<br>따라서, 저 중 a.name컬럼이 b.rule을 따르는(like 연산을 했을 때, 참인 결과는)<br>총 4개이다.<br>
<br>. 다음 빈칸에 들어갈 UNION 연산의 결과값을 작성하시오.
<img alt="Pasted image 20250415181225.png" src="https://lts.kr/사진-및-문서/pasted-image-20250415181225.png" target="_self">
<br>[쿼리]
SELECT A FROM T1
UNION
SELECT A FROM T2
ORDER BY A DESC;
<br>UNION → 중복 제거
<br>UNION ALL → 중복 허용
<br>
4
3
1
<br>
<br>다음 조건을 참고하여, SQL문에서 괄호안에 알맞는 단어를 작성하시오.
<br>[조건]
학생 테이블을 참조하는 다른 VIEW나 제약 조건까지 모두 삭제되어야 한다.
단, 용어의 대·소문자는 상관하지 않는다.<br>DROP VIEW 학생 ( )<br>
CASCADE
<br>
<br>
다음은, 테이블에서 조건값을 실행한 화면이다. 이에 대한 알맞는 결과값을 작성하시오.
<img alt="Pasted image 20250417121150.png" src="https://lts.kr/사진-및-문서/pasted-image-20250417121150.png" target="_self"> <br>
CROSS JOIN 은 카디션 곱으로, 각 행으로 만들수 있는 모든 경우 즉 6개의 행이 생긴다. <br>
그 중, s로 시작하고 , t를 포함하고 있는 컬럼은 총 4개이다. <br>
4
<br>]]></description><link>https://lts.kr/study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-sql-문제.html</link><guid isPermaLink="false">study/정보처리기사/정보처리기사 실기/🥇 정보처리 기사 실기 SQL 문제.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Fri, 18 Apr 2025 08:20:16 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20250225161448.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20250225161448.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🥇 정보처리 기사 실기 기타문제]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:정보처리기사" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정보처리기사</a> <a class="tag" href="https://lts.kr/?query=tag:실기" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#실기</a> <a class="tag" href="https://lts.kr/?query=tag:키워드" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#키워드</a> <a class="tag" href="https://lts.kr/?query=tag:정리" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정리</a> <br> <a href="https://lts.kr?query=tag:정보처리기사" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정보처리기사">#정보처리기사</a> <a href="https://lts.kr?query=tag:실기" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#실기">#실기</a> <a href="https://lts.kr?query=tag:키워드" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#키워드">#키워드</a> <a href="https://lts.kr?query=tag:정리" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정리">#정리</a><br>7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1
<br>LRU(Least Recently Used)​​는 가장 오랫동안 사용되지 않는 녀석을 교체한다.
<br>LFU(Least Frequently Used)는 최소 사용횟수 우선 교체 이다. 동일한 빈도의 경우, 가장오래된 페이지를 선택. 주의
부재 횟수를 구할떄, 초기 비어있는 프레임에 페이지가 삽입될때도 횟수를 센다. <br>**[테이블]**
사원 [사원번호(PK), 이름, 나이, 부서]
부서 [사원번호(PK), 이름, 주소, 나이] ① 신입사원이 들어와서 부서 테이블에 새로운 사람을 추가
INSERT INTO 부서 (사원번호, 이름, 주소, 나이) **( ① )** (240728, '홍길동', '서울', 30); ② 부서 테이블에서 추가한 사원을 검색한 후 사원 테이블에 추가
INSERT INTO 사원 (사원번호, 이름, 나이, 부서)
**( ② )** 사원번호, 이름, 나이, ‘영업’ FROM 부서 WHERE 이름 = '홍길동'; ③ 전체 사원 테이블 조회
SELECT * **( ③ )** 사원; ④ 사원의 퇴사로 인해 부서에 해당하는 값을 '퇴사'로 변경
UPDATE 사원 **( ④ )** 부서 = '퇴사' WHERE 사원번호 = 240728;
<br> <br>values
<br>select
<br>from
<br>set <br>
<br>다음은 운영체제 페이지 순서를 참고하여 할당된 프레임의 수가 3개일 때 LRU와 LFU 알고리즘의 페이지 부재 횟수를 작성하시오.
<br> 페이지 참조 순서 : 1, 2, 3, 1, 2, 4, 1, 2, 5, 7
<br>
(1) LRU : 6
(2) LFU : 6
<br>class Parent { int x, y; Parent(int x, int y) { //1 this.x=x; this y=y; } int getT() { //2 return x*y; }
} ​class Child extend Parent { int x; Child (int x) { //3 super(x+1, x); this.x=x; } int getT(int n){ //4 return super.getT()+n; }
} class Main { public static void main(String[] args) { //5 Parent parent = new Child(3); //6 System.out.println(parent.getT()); //7 }
} 실행 순서 : 5 → ( ) → ( ) → ( ) → ( ) → ( )
<br>new Child(3)로 Child클래스의 생성자가 실행된다. 6 → 3
<br>이후 super에서 Parent의 생성자가 실행된다. 3 → 1
<br>그리고 7번 print가 실행되면, 다형성에 의해 2번 getT가 실행된다. 7 → 2
<br>
5 → 6 → 3 → 1 → 7 → 2
<br>]]></description><link>https://lts.kr/study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-기타문제.html</link><guid isPermaLink="false">study/정보처리기사/정보처리기사 실기/🥇 정보처리 기사 실기 기타문제.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Tue, 15 Apr 2025 08:09:13 GMT</pubDate></item><item><title><![CDATA[🥇 정보처리 기사 실기 프로그래밍-포인터]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:정보처리기사" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정보처리기사</a> <a class="tag" href="https://lts.kr/?query=tag:실기" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#실기</a> <a class="tag" href="https://lts.kr/?query=tag:프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로그래밍</a> <a class="tag" href="https://lts.kr/?query=tag:정리" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정리</a> <a class="tag" href="https://lts.kr/?query=tag:포인터" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#포인터</a> <br> <a href="https://lts.kr?query=tag:정보처리기사" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정보처리기사">#정보처리기사</a> <a href="https://lts.kr?query=tag:실기" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#실기">#실기</a> <a href="https://lts.kr?query=tag:프로그래밍" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로그래밍">#프로그래밍</a> <a href="https://lts.kr?query=tag:정리" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정리">#정리</a> <a href="https://lts.kr?query=tag:포인터" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#포인터">#포인터</a><br>#include &lt;stdio.h&gt; int len(char* p);
int main( ) { char* p1 = "2022"; char* p2 = "202207"; int a = len(p1); int b = len(p2); printf("%d", a + b);
} int len(char* p) { int r = 0; while (*p != '\0') { p++; r++; } return r;
}
<br>int len(char* p); -&gt; len() 함수의 프로토타입 선언이다.
<br>p1과 p2는 문자형 포인터 변수로 각 문자가 저장된 주소의 주소로 초기화 된다.
<img alt="Pasted image 20250312144444.png" src="https://lts.kr/사진-및-문서/pasted-image-20250312144444.png" target="_self">
ex) p1에는 '2'가 저장되어있는 1000번째 주소가 삽입되어있으며,
p1+1 은 '0' , p1+4 는 1004번째 주소로, '\0'이 들어가 있다.
<br>즉, 4 + 6 <br>#include &lt;stdio.h&gt; int main( ) { int a[4] = { 0, 2, 4, 8 }; int b[3]; int* p; int sum = 0; for (int i = 1; i &lt; 4; i++) { p = a + i; b[i - 1] = *p - a[i - 1]; sum = sum + b[i - 1] + a[i]; } printf("%d", sum); }
<br>p -&gt; 정수형 포인터 변수
<br>i = 1,2,3 반복문
<br>첫번째 반복 i = 1 `p = a + i` =&gt; a배열의 두번째 요소의 주소 저장 `b[0]` = (*p =&gt; p의 주소가 가리키는곳의 값)2 - 0 = 2 sum = 0 + 2 + 2 = 4
두번째 반복 i = 2 a배열의 세번째요소 4 `b[1]` = 4 - 2 = 2 sum = 4 + 2 + 4 = 10
세번째 반복 i = 3 a배열의 네번째요소 8의 주소 'b[2]' = 8 - 4 = 4 sum = 10 + 4 + 8 = 22 <br>포인터 변수로 선언된 p에 배열을 직접대입하는것은 주소값을 넣는것이다.
<br>포인터 변수를 사용할때 p*처럼 사용하면, 해당 주소값 내의 값을 의미한다.
p에 직접 대입할 때 말고는 다 배열과 사칙연산이다.
<br>#include &lt;stdio.h&gt; int main() { int* array[3]; int a = 12, b = 24, c = 36; array[0] = &amp;a; array[1] = &amp;b; array[2] = &amp;c; printf("%d", *array[1] + **array + 1);
}
<br>정수형 포인터를 저장하는 배열 array [ , , ]
<br>array[0] = &amp;a;는 a의 시작 주소를 삽입하는 것이다.
<br>array[1] 은 &amp;b(b의 주소값)이고, *array[1] 은 그 주소가 지니고 있는 실제 값 24이다.
<br>**array + 1 =&gt; <br>array : 배열의 이름만 지정하면 배열의 첫 번째 요소의 주소인 &amp;array[0], 즉 array의 첫주소값
<br>*array : array의 첫주소값(array)이 가지는 실제 값 &amp;a 즉 int a의 주소값.
<br>**array : int a의 주소값의 실제 지니고 있는값 12이다. <br>즉, 24 + 12 + 1<br>#include &lt;stdio.h&gt; int main() { int ary[3]; int s = 0; *(ary + 0) = 1; ary[1] = *(ary + 0) + 2; ary[2] = *ary + 3; for (int i = 0; i &lt; 3; i++) s = s + ary[i]; printf("%d", s); }
<br>*(ary + 0) = 1; -&gt; arr의 첫 주소값의 실제값에 1 대입 / arr[1 , , ]
<br>ary[1] = *(ary + 0) + 2; -&gt; arr[1]에 1+2 대입 / arr[1 , 3 , ]
<br>ary[2] = *ary + 3; -&gt; arr[2]에 1+3 대입 / arr[1 , 3 , 4]
<br>1+3+4 = 8<br>#include &lt;stdio.h&gt; main() { char* p = "KOREA"; printf("%s\n", p); printf("%s\n", p + 3); printf("%c\n", *p); printf("%c\n", *(p + 3)); printf("%c\n", *p + 2); }
<br>문자열을 저장하는 경우 문자열의 끝을 의미하는 널 문자\0 가 추가로 저장되며,
출력시 널 문자는 표시되 지 않는다.
<br>printf("%s", P) 의 %s는 널(\0) 문자가 나올 때까지 문자열을 출력한다.
<br>[K , O , R , E , A , \0]<br>P : 문자형 포인터 변수 p 의 시작주소값 -&gt; KOREA
<br>P + 3 : p의 시작주소값의 3번째 뒤의 주소 -&gt; E의 시작 주소값 -&gt; EA
<br>*P : p 의 시작주소값의 실제 값 -&gt; K
<br>*(P + 3) : P의 시작주소값의 3번째 뒤의 주소의 실제 값 -&gt; E
<br>*P + 2 : P의 시작 주소의 실제값 K(ASCII 코드 75) + 2 =&gt; 77 =&gt; M
<br>KOREA
EA
K
E
M
<br>]]></description><link>https://lts.kr/study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-프로그래밍-포인터.html</link><guid isPermaLink="false">study/정보처리기사/정보처리기사 실기/🥇 정보처리 기사 실기 프로그래밍-포인터.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Tue, 15 Apr 2025 03:14:10 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20250312144444.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20250312144444.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🥇 정보처리 기사 실기 프로그래밍-사용자 정의 함수]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:정보처리기사" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정보처리기사</a> <a class="tag" href="https://lts.kr/?query=tag:실기" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#실기</a> <a class="tag" href="https://lts.kr/?query=tag:프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로그래밍</a> <a class="tag" href="https://lts.kr/?query=tag:정리" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정리</a> <a class="tag" href="https://lts.kr/?query=tag:함수" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#함수</a> <br> <a href="https://lts.kr?query=tag:정보처리기사" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정보처리기사">#정보처리기사</a> <a href="https://lts.kr?query=tag:실기" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#실기">#실기</a> <a href="https://lts.kr?query=tag:프로그래밍" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로그래밍">#프로그래밍</a> <a href="https://lts.kr?query=tag:정리" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정리">#정리</a> <a href="https://lts.kr?query=tag:함수" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#함수">#함수</a><br>public class Test { public static void main(String[] args) { System.out.print(Test.check(1)); } "( 1 )" String check(int num){ return (num &gt;= 0) ? "positive" : "negative"; }
}
<br>static은 클래스 이름으로 메소드에 접근하기 위해 사용되는 예약어이다.
<br>main메서드는 static이다. 즉 객체를 생성하지 않고 바로 실행된다. 이떄,,,, <br>메소드를 사용하기 위해서는 메소드가 포함된 클래스의 객체 변수를 선언한 후
[객체변수].[메소드]의 방식으로 접근해야하지만,
static을 이용한다면 객체변수 없이 [클래스이름].[메소드]방식으로 접근하는것이 가능하다.
<br>즉 메인 메서드가 아니더라도, static메서드 안에서 일반 메서드를 호출하면 오류를 야기한다.<br>int increment() { static int x = 0; x += 2; return x;
} int main() { int x = 1; int sum = 0; for (int i = 0; i &lt; 4; i++) { x++; sum += increment(); } printf("%d", sum);
}
<br>static int x는 "static" 으로 선언하여 전역변수(어느곳에서든 참조가능한 변수)로 사용되어 호출(사용) 이후에도 초기화 되지않는다.
<br>즉 2+4+6+8
<br>def test(v): if type(v) == type(""): return len(v) elif type(v) == type(100): return 101 else: return 20
a = "100.0" b = 100.0 c = (100.0, 200.0)
print(test(a) + test(b) + test(c))
<br>type(v) == type("") : v가 문자열 타입이면
<br>type(v) == type(100) : v가 정수형 타입이면
<br>100.0은 실수형으로, 정수형 타입이 아니다. <br>a : 문자열 / b : 실수형 / c : 실수형 - 5 + 20 + 20
<br>public class Main { public static void main(String[] args) { int sum = 0; try { func(); } catch(NullPointerException e) { sum = sum + 1; } catch(Exception e) { sum = sum + 10; } finally { sum = sum + 100; } System.out.print(sum); } static void func() throws Exception { throw new NullPointerException(); }
}
<br>func함수는 NullPointerException을 발생시키는 함수이다.
<br>두 개의 catch함수는 익셥션을 감지한다.
<br>이 때, Exception 타입은 모든 익셉션을 가지고 있다.
<br>하지만, 순서대로 NullPointerException이 catch되고, 한개의 case가 catch되었으므로,
<br>finally로 이동한다.
<br>class B { int x = 3; int getX() { return x * 2; }
} class A extends B { int x = 7; @Override int getX() { return x * 3; }
} public class Annotation { public static void main(String[] args) { B b1 = new A(); A b2 = new A(); System.out.print(b1.getX() + b1.x + b2.getX() + b2.x); }
}
<br>b1객체는 B객체이지만 함수는 오버라이딩 된다. 즉, 필드 변수는 3 함수는 21
-B객체이지만, A로 초기화를 할때, 오바라이딩 된다고 이해하면 된다.
<br>b2객체는 필드변수 7, 함수는 21
<br>21 + 3 + 21 + 7
<br>#include void swap() { int a = 11; int b = 19; int t = a; a = b; b = t;
} int main() { int a = 11; int b = 19; swap(); switch(a) { case 1: b += 1; case 11: b += 2; default: b += 3; break; } printf("%d", a-b);
}
<br>swap함수는 출력도 없으며, 리턴도 없음 ( c언어는 콜바이벨류 이다. 이때는 변수를 새로 선언했기 때문에 그에도 해댱하지 않는다.)
<br>따라서 a 는 11로 case문을 타게 되고, break문이 없으므로 default문을 타게된다.
<br>(break 가 있었으면 default문을 타지 않는다.)
<br>class Connection { private static Connection _inst = null; private int count = 0; static public Connection get() { if(_inst == null) { _inst = new Connection(); return _inst; } return _inst; } public void count() { count++; } public int getCount() { return count; }
} public class main { public static void main(String[] args) { Connection conn1 = Connection.get(); conn1.count(); Connection conn2 = Connection.get(); conn2.count(); Connection conn3 = Connection.get(); conn3.count(); conn1.count(); System.out.print(conn1.getCount()); } }
<br>싱글톤 패턴을 구현한 것으로 보인다.
<br>conn1/2/3/4 모두 한 객체이므로 count를 공유한다.
<br>]]></description><link>https://lts.kr/study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-프로그래밍-사용자-정의-함수.html</link><guid isPermaLink="false">study/정보처리기사/정보처리기사 실기/🥇 정보처리 기사 실기 프로그래밍-사용자 정의 함수.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Tue, 15 Apr 2025 03:11:02 GMT</pubDate></item><item><title><![CDATA[🥇 정보처리 기사 실기 프로그래밍-제어문]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:정보처리기사" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정보처리기사</a> <a class="tag" href="https://lts.kr/?query=tag:실기" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#실기</a> <a class="tag" href="https://lts.kr/?query=tag:프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로그래밍</a> <a class="tag" href="https://lts.kr/?query=tag:정리" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정리</a> <br> <a href="https://lts.kr?query=tag:정보처리기사" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정보처리기사">#정보처리기사</a> <a href="https://lts.kr?query=tag:실기" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#실기">#실기</a> <a href="https://lts.kr?query=tag:프로그래밍" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로그래밍">#프로그래밍</a> <a href="https://lts.kr?query=tag:정리" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정리">#정리</a><br>#include &lt;stdio.h&gt;
main() { int s, el = 0; for (int i = 6; i &lt;= 30; i++) { s = 0; for (int j = 1; j &lt;= i / 2; j++) if (i % j == 0) s = s + j; if (s == i) el++; } printf("%d", el);
}
<br>j &lt;= i / 2; -&gt; 나머지가 몇이든 버린다.
<br>하나하나 분석하면, <br>6~30까지 자신의 약수(나누어 떨어지는 수)를 모두 더한다
<br>모두 더한 수와 자신이 같은지 판단하여 출력한다.
<br>6과 28이 해당한다.
<br>public class Test { public static void main(String[] args) { int r = 0; for (int i = 1; i &lt; 999; i++) { if (i % 3 == 0 &amp;&amp; i % 2 == 0) r = i; } System.out.print(r); } }
<br>1 ~ 998까지
<br>3으로 나누어 떨어지면서,
<br>2로도 나누어 떨어지는 녀석 즉, 2와 3의 공배수(6의 배수)
<br>일때, 가장 큰수(매번 초기화 하므로)를 구한다.
<br>public class Test { public static void main(String[] args) { int i = 3, k = 1; switch(i) { case 1: k++; case 2: k -= 3; case 3: k = 0; case 4: k += 3; case 5: k -= 10; default: k--; } System.out.print(k); }
}
<br>i가 3이므로 case3을 찾아간다.
<br>break문이 없으므로 그 밑으로 쭉 수행한다 ( 조건식에 부합하지 않더라도, )
<br>1234의 역순은 4321이다. 단 1230처럼 0으로 끝나는 정수는 고려하지 않는다.<br>#include &lt;stdio.h&gt; int main() { int number = 1234; int div = 10, result = 0; while (number "( 1 )" 0) { result = result * div; result = result + number "( 2 )" div; number = number "( 3 )" div; } printf("%d", result); }
<br>한자리수씩 커지면서 바꾸는거다.
<br>&gt; : 0보다 클때까지 반복한다.
<br>% : 나머지를 가져온다
<br>/ : 나누고, 나머지를 버린다.
<br>첫 사이클
0
4
123
<br>두 번쨰
40
43
12
<br>세 번째
430
432
1
<br>네 번째
4320
4321
0
<br>public class Test { public static void main(String[] args) { int w = 3, x = 4, y = 3, z = 5; if((w == 2 | w == y) &amp; !(y &gt; z) &amp; (1 == x ^ y != z)) { w = x + y; if(7 == x ^ y != w) System.out.println(w); else System.out.println(x); } else { w = y + z; if(7 == y ^ z != w) System.out.println(w); else System.out.println(z); } } }
<br>
&amp; , | -&gt; 비트 연산으로써, 2진법을 비트연산하면 된다. <br>
x ^ y 연산은 비트 XOR연산으로써,
001 -&gt; y != z
000 -&gt; 1 == x
--- (같으면 0 / 다르면 1)
001 -&gt; 4 가 된다. <br>a = 100 result = 0 for i in range(1,3): result = a &gt;&gt; i result = result + 1 print(result)
<br>i = 1,2 수행
<br>a &gt;&gt; i 는 오른쪽 시프트 연산자로써, a값을 오른쪽으로 i비트 움직인다는 뜻이다.
<br>파이썬에서 정수는 4Byte이므로, 8bit x 32개 로 계산하면 된다.
<br>
100을 먼저 2진수로 변환
0000 ... 0001100100 -&gt; 100 (4 + 32 + 64) <br>
시프트 연산을 한번 수행하면
0000 ... 0000110010 -&gt; 50 (2 + 16 + 32)
+1 을 하면 51 -&gt; 110011 <br>
한번 더 수행하면 100을 두칸 시프트 한다
0000 ... 0000011001 -&gt; 25 (1 + 8 + 16)
25+1 = 26 <br>파이썬의 print 기본적으로 파이썬의 print는 print(end='\n') 이 포함된 식이다. (줄바꿈 디펄트)<br>
즉 print("123", end=' ')로 표현하면 줄바꿈 대신 공백이 삽입된다.
<br>public class Test { public static void main(String[]args) { int a[] = new int[8]; int i = 0; int n = 10; while( "( 1 )" ) { a[i++] = "( 2 )"; n /= 2; } for(i = 7; i &gt;= 0; i--) System.out.print(a[i]); } }
<br>n /= 2;란 n = n / 2랑 동일한 문법이다.
<br>먼저, 10진수를 2진수로 변환하기 위해서는, 2로 계속해서 나누어, 나머지를 삽입하면된다.<br>10 / 2 = 5(0)
5 / 2 = 2(1)
2 / 2 = 1(0) (1)
10 -&gt; 1010 (8+2) 19 / 2 = 9(1)
9 / 2 = 4(1)
4 / 2 = 2(0)
2 / 2 = 1(0)
(1)
19 -&gt; 10011 (16+2+1)
<br>JAVA는 배열 선언시 초기화를 하지 않으면 0 이 삽입된다
a[i++] = x 를 수행하면 i번째 자리에 값 삽입 후, i값을 증가시킨다.<br>첫번째 조건식에는 n &gt; 0을 넣는다.
<br>16일때, a[] 배열에는 11001 순서로 들어가게된다.
<br>n % 2(나머지가 계속 들어간다.)
10 -&gt; 5 -&gt; 2 -&gt; 1 -&gt; 0(조건식에 부합) 실행 X
0 1 0 1
a = [0,1,0,1,0,0,0,0]
<br>를 역순으로 출력하면 1010 이 된다.
출력은 00001010이 된다.
<br>public class Main { static void func(String[] m, int n) { for (int i = 1; i &lt; n; i++) { if (m[i-1].equals(m[i])) { System.out.print("O"); } else { System.out.print("N"); } } for (String mo : m) { System.out.print(mo); } } public static void main(String[] args) { String[] m = new String[3]; m[0] = "A"; m[1] = "A"; m[2] = new String("A"); func(m, 3); }
}
<br>JAVA에서 .equals함수는 객체가 아닌 값 자체를 비교하기 때문에 같은 값으로 취급한다.
<br>def test(lst): for i in range(len(lst) // 2): lst[i], lst[-i-1] = lst[-i-1], lst[i]
ls = [1,2,3,4,5,6]
test(ls)
print(sum(ls[::2]) - sum(ls[1::2]))
<br>파이썬에서 list[a::b]형태는 a부터 시작해서(없다면 0) b칸씩 건너 뛰어 가져오는 것.
<br>따라서, test함수로 리버스된 리스트 [::2] -&gt; 6,4,2 / [1::2] -&gt; 5,3,1 이다.
<br>]]></description><link>https://lts.kr/study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-프로그래밍-제어문.html</link><guid isPermaLink="false">study/정보처리기사/정보처리기사 실기/🥇 정보처리 기사 실기 프로그래밍-제어문.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Mon, 14 Apr 2025 09:18:55 GMT</pubDate></item><item><title><![CDATA[🥇 정보처리 기사 실기 프로그래밍-구조체(structuer)]]></title><description/></item></channel></rss>