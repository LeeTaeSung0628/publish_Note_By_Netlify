<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[taesunglog]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib/media/favicon.png</url><title>taesunglog</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Fri, 28 Feb 2025 09:18:50 GMT</lastBuildDate><atom:link href="lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Fri, 28 Feb 2025 09:18:38 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[🏹 예치금 차액 비교 Spring Batch 리펙토링]]></title><description><![CDATA[<a class="tag" href="?query=tag:프로젝트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로젝트</a> <a class="tag" href="?query=tag:개발" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#개발</a> <a class="tag" href="?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <a class="tag" href="?query=tag:Batch" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Batch</a> <a class="tag" href="?query=tag:Partitioning" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Partitioning</a> <a class="tag" href="?query=tag:Chunk" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Chunk</a> <br> <a href=".?query=tag:프로젝트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로젝트">#프로젝트</a> <a href=".?query=tag:개발" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#개발">#개발</a> <a href=".?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a> <a href=".?query=tag:Batch" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Batch">#Batch</a> <a href=".?query=tag:Partitioning" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Partitioning">#Partitioning</a> <a href=".?query=tag:Chunk" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Chunk">#Chunk</a><br>기존 예치금 차액비교 Batch의 Tasklet방식의 배치의 단점을 보완하는 chunk 방식의 배치를 구현하고,<br>
나아가 다른 기능의 Batch에도 효과적으로 빠르게 적용할 수 있는재사용성/유지보수성 높은 코드, 선례를 만들기 위함이다.<br>
<br>Chunk, Partioning방식을 Job을 추가 개발 (기존 balanceJob 유지)
<br>당분간 두 Job을 병행하면서 비교
<br>추가한 Job 기능에 문제없다면 기존 balanceJob 삭제
<br><img alt="회사 은행 서비스1111.png" src="사진-및-문서/회사-은행-서비스1111.png" target="_self"><br>
<img alt="Spring Batch Tasklet 예치금 잔액 비교 1.png" src="사진-및-문서/spring-batch-tasklet-예치금-잔액-비교-1.png" target="_self"><br>
<img alt="Spring Batch Tasklet 예치금 잔액 비교 잘못된 차액발생 인식 타임라인.png" src="사진-및-문서/spring-batch-tasklet-예치금-잔액-비교-잘못된-차액발생-인식-타임라인.png" target="_self"><br>
<br>평균 소요시간: 약 17.35분
<br>최대 소요시간: 22분
<br>최소 소요시간: 12분<br>
<img alt="output (1).png" src="사진-및-문서/output-(1).png" target="_self">
<br>
<br>처음 가져온 Point 배치 완료시 까지 계속 물고있다. -&gt; 한 트렌젝션의 범위가 넓다.
<br>정보 <br>병목이 있진 않으나, 한 배치서비스의 트렌젝션에서 외부 api의 값 변동을 반영하지 못함. <br>
<br>G5-Point 등은 처음 7시 시점에 묶여있다. 회원별로 실데이터를 건건이 api(신한)를 호출하여 비교한다. 때문에, 7시 이후에 수정된데이터를 실시간으로 반영하지 못한다.
<br>
<br>목적 : batch의 step 레벨에서의 스레드 분리 ( 병렬처리 )
<br>
<br>독립적인 ExecutionContext가 주어져 상태를 안전하게 관리할 수 있다.
<br>
<br>목적 : 각 step내의 트렌젝션 단위 분리
<br>Reader / Processor / writer 가 역할을 분담
<br>
<br>
Partition 생성: <br>Partition 1 : ID 1 ~ 25 / 대기열1 : ID 101 ~ 125 / 대기열2 : ID 201 ~ 225
<br>Partition 2 : ID 26 ~ 50 / 대기열 : ID 126 ~ 150 / 대기열2 : ID 226 ~ 250
<br>Partition 3 : ID 51 ~ 75 / 대기열 : ID 151 ~ 175 / 대기열2 : -
<br>Partition 4 : ID 76 ~ 100 / 대기열 : ID 176 ~ 200 / 대기열2 : - <br>
각 Partition에서 Chunk 처리: <br>Partition 1: <br>Chunk 1: ID 1 ~ 10 → 커밋
<br>Chunk 2: ID 11 ~ 20 → 커밋
<br>Chunk 3: ID 21 ~ 25 → 커밋 <br>Partition 2: <br>Chunk 1: ID 26 ~ 35 → 커밋
<br>Chunk 2: ID 36 ~ 45 → 커밋
<br>Chunk 3: ID 46 ~ 50 → 커밋 <br>나머지 Partition도 동일 방식으로 처리. <br>
병렬 실행: <br>스레드 풀 크기 = 4이므로 4개의 Partition이 동시에 실행됩니다.
<br>Partition 처리 순서는 스레드 풀에서 처리되는 순서에 따라 다를 수 있음. <br>
트랜잭션 관리: <br>각 Partition은 독립적인 트랜잭션을 가짐.
<br>각 Chunk가 커밋될 때마다 트랜잭션이 종료됨. <br>
<br>
Partition 생성: <br>Partition 1 : ID 1 ~ 25 / 대기열1 : ID 101 ~ 125 / 대기열2 : ID 201 ~ 225
<br>Partition 2 : ID 26 ~ 50 / 대기열 : ID 126 ~ 150 / 대기열2 : ID 226 ~ 250
<br>Partition 3 : ID 51 ~ 75 / 대기열 : ID 151 ~ 175 / 대기열2 : ID 251 ~ 275
<br>Partition 4 : ID 76 ~ 100 / 대기열 : ID 176 ~ 200 / 대기열2 : ID 276 ~ 300
<br>추가 스레드 풀 생성
<br>Partition 5 : ID 300 ~ 325 / 대기열 : ID 326 ~ 350 / 대기열2 : ID 351 ~ 375
<br>추가 스레드 풀 생성
<br>Partition 6 : ID 376 ~ 400 / 대기열 : ID 401 ~ 425 / 대기열2 : ID 426 ~ 450 모든 대기열 소모 및 최대 스레드 풀 도달 =&gt; 작업 중단 및 오류 <br>-&gt; 이로볼때, 쿼리작업보다 api호출작업의 소요시간이 길어보임<br>범위 - 2017-11-07 ~ 2017-12-01
startDate=2017-11-07&amp;endDate=2017-12-01
<br>## 컬럼 개수 - 292개 기존 병렬처리 : 1분 7초
기존로직 : 6분 32초 t:스레드 개수 / c:각 스레드별 청크 파티션 수 ###### SimpleAsyncTaskExecutor vs ThreadPoolTaskExecutor SimpleAsyncTaskExecutor
g4/c10 : 1분 41.586초
g5/c10 : 1분 30.037초
g5/c3 : 1분 28.997초
g5/c1 : 1분 29.931초
g8/c10 : 1분 36.019초
g10/c1 : 1분 24.529초 - ThreadPoolTaskExecutor
Th min/maxSize64, g64/c10 : 1분 42.848초
Th min/maxSize32, g32/c10 : 1분 26.551초 Th min/maxSize16, g16/c10 : 1분 46.753초 / 1분 33.779초 / 2분 25.759초
1분 11.668초 / 2분 5.773초 / 2분 39.553초 Th min/maxSize32, g8/c20 : 3분 25.743초 Th min/maxSize16, g4/c10 : 2분 29.207초 / 2분 8.004초
<br>
<br>Grid사이즈(파티셔닝 갯수) 만큼 스레드 풀 계속 생성
<br>파티셔닝 갯수가 많아졌을 때, 스레드 생성/소멸에 드는 오버헤드 증가
<br>
<br>최소 스레드풀 개수 / 최대 스레드풀 개수 / 대기열 큐 크기 / 유휴 시간 모두 설정가능
<br>파티셔닝 갯수가 많을 경우, 처리 성능에 맞는 스레드 풀에서 대기작업으로 처리하여 오버헤드 감소
<br>
<br>총 처리량 기준 1/n로 각 스레드에 할당시 충분히 감당한 양으로, 대기열을 사용할 필요가 없다.
<br>
<br>쿼리 호출 및 페이징 기법 직접 구현
<br>
<br>Native Query 형태로 호출하여 자동 페이징
<br>
<br>Spring Batch에서는 공식적으로 지원하지 않음
<br>자동 페이징
<br>Querydsl형태로 쿼리 호출 가능
<br>
<br>기존(헬로)의 Querydsl기반 JPAQuery를 그대로 사용 가능
<br>자동 페이징
<br>그 외 Querydsl의 장점 보유
<br>
<br>기존 PagingItemReader의 메서드를 오버라이딩 하여 사용하며,<br>
JPQL이 수행되던 부분에 코드를 수정하였다.
<br>@Bean @Scope(value = "step", proxyMode = ScopedProxyMode.TARGET_CLASS) public QuerydslPagingItemReader&lt;HfbatBankBalanceCheckDto&gt; balanceReader() { ExecutionContext jobContext = Objects.requireNonNull(StepSynchronizationManager.getContext()).getStepExecution().getJobExecution().getExecutionContext(); Date startDate = (Date) jobContext.get(START_DATE_KEY); Date endDate = (Date) jobContext.get(END_DATE_KEY); return new QuerydslPagingItemReader&lt;&gt;( entityManagerFactory, executionOrder, DEFAULT_CHUNK_SIZE, queryFactory -&gt; repository.newFindChangeBalanceMemberList( startDate, endDate )); }
<br>
<br>각 파티션 스레드 별 종료 시간이 크게 상이하다. 총 소요시간 기준 최대 약 20% 차이
<br>적용 한다면, 각 스레드 별로 even하게 작업을 수행하여 총 소요시간을 줄일 수 있을것이라 판단 <br>JOB private static AtomicLong executionOrder = new AtomicLong(0); ... new QuerydslPagingItemReader&lt;&gt;( entityManagerFactory, executionOrder, DEFAULT_CHUNK_SIZE, queryFactory -&gt; repository.newFindChangeBalanceMemberList( startDate, endDate ));
<br>job 레벨에서의 스레드 세이프한 전역 변수를 생성하였다.
<br>그 후, 각 파티션 별 리더에 인자값으로 넘긴다.
<br>long currentExecutionOrder = executionOrder.getAndIncrement(); long startIndex = (currentExecutionOrder) * getPageSize(); int totalRecords = stepContext.getInt("totalRecords"); if (startIndex &gt;= totalRecords) { initResults(); // 빈 결과로 초기화 tx.commit(); return; } int chunkSizeToRead = Math.min(getPageSize(), (int) (totalRecords - startIndex)); // 남은 데이터 크기만큼 읽기 // QueryDSL Query 생성 JPQLQuery&lt;T&gt; query = createQuery() .offset(startIndex) .limit(chunkSizeToRead);
<br>
<br>먼저 한 청크단위의 작업을 끝낸 파티션은 그 다음 작업을 즉시 할당받게 된다.
<br>즉, 총 처리시간 기준 가장 빨리끝난 파티션과 가장 늦게 끝난 파티션의 실행 시간 차이는 최대 한 청크사이즈를 처리하는 시간보다 크지 않게 된다.
<br>1차 비교 이후 차액이 발생한 녀석들의 List 를 한번 더 검증한 후, =&gt; 추후 변경 됨<br>
검증된 녀석들을 <br>List&lt;BalanceCheckResultDto&gt; realDiffList= new ArrayList&lt;&gt;();
<br>최종적인 차액 리스트에 넣는다.<br>writer는 각 프로세서의 리턴으로 받은 녀석들을 하나의 DTO List로 합쳐 메세징 처리를 하게 된다.<br>
<br>유지보수성이 좋다.
<br>환경셋팅에 리소스가 많이든다. <br>
<br>구현 레벨이 가장 쉽다
<br>DTO(데이터)가 많아질 경우, 큰 리소스를 차지한다.
<br>
<br>방법 2.보다는 리소스가 적지만, 문자열 처리 시간이 추가로 소모된다.
<br>
<br>높은 쓰기 성능을 갖고있다.
<br>동시성 문제 없이 다중 스레드에서 사용 가능하다.
<br>인덱스로 접근이 불가능하다.
<br>QueueManager클래스를 생성하며 공통으로 사용 가능하도록 하였고,<br>@Slf4j public class QueueManager&lt;T&gt; { protected final ConcurrentLinkedQueue&lt;T&gt; sharedQueue = new ConcurrentLinkedQueue&lt;&gt;(); // 데이터 추가 public void addItemToSharedQueue(T item) { if (item != null) { sharedQueue.add(item); } }
<br>이를 상속받아 특정 오브젝트를 넘길 수 있도록 하였다.<br>public class BalanceQueue extends QueueManager&lt;BalanceCheckResultDto&gt;{ public List&lt;BalanceCheckResultDto&gt; getDtoFromQueue() { return super.getItemsFromQueue(); } }
<br>이게 무슨소리인지? <br>보통의 Batch 서비스라면 I/O 작업에 부하가 걸려있겠지만, 현재 예치금 차액 배치는 processor 즉, 예치금 비교 연산에서 큰 리소스를 소모하고있다.
<br>이에 해당하는 시간 소모를 줄이기 위해 processor(서비스로직) 을 병렬처리 함으로 최종 처리시간 단축을 꾀할 수 있을지에 대한 고민이다.
<br>이후 설명하겠지만, 내부 병렬처리 로직은 청크의 트렌젝션을 무너뜨릴 가능성이 크므로 지양해야함. <br><img alt="Pasted image 20241206113120.png" src="사진-및-문서/pasted-image-20241206113120.png" target="_self"><br>소요시간 : 1분 9초
<br>-&gt; 기존 limit절을 이용한 로직보다 속도가 더빠르며,<br>
JpaPagingReader를 적용한다면 중복 select횟수를 줄여 더 빨라질 것으로 예상된다.<br>결론 : 둘 중 하나<br>#### 292 컬럼
## Processor 삭제(병렬처리)로직
#### grid-size:6 / chunk-size:20
54679 ms
54416 ms
## Processor 순차처리(writer만 병렬처리) 로직 #### grid-size:6 / chunk-size:20
60440 ms
62271 ms
#### grid-size:10 / chunk-size:20
58129 ms
56723 ms
#### grid-size:16 / chunk-size:20
58595 ms
56314 ms #### grid-size:32 / chunk-size:20
- SQLTransientConnectionException
- 스레드풀 점유갯수 초과
<br>하지만, 이후 청크 방식 Batch의 확장성과 유지보수성을 고려하여 리더,프로세서,라이터 방식으로 구현하기로 정했다.<br>청크사이즈가 다름에도 처리속도가 똑같은 이유?<br>grid-size:12 / chunk-size:30
-
3분 22.856초
3분 23.096초 grid-size:12 / chunk-size:20
-
3분 23.546초
3분 23.784초 grid-size:12 / chunk-size:10
-
3분 24.243초
3분 22.389초
3분 24.667초
3분 24.789초 grid-size:12 / chunk-size:5
-
3분 24.953초
3분 24.353초
<br>
<br>트렌젝션 분리가 되어있지 않았기 떄문에 청크사이즈를 아무리 잘게 쪼개도 시간이 같았던 것이다.
<br>그럼 트렌젝션이 분리되지 않은 이유는?
<br>dtoList.stream().parallel() .forEach(dto -&gt; {});
<br>parallel문으로 내부 병렬처리로직을 구현했기 때문에, chunk의 트렌젝션에서 벗어나,<br>
매 insert문 마다 커밋을 하였던 것이다.<br>반복 TEST 중.. 커넥션풀 Time Out 문제??<br>SHOW VARIABLES LIKE 'max_connections'; //최대 개수<br>
SHOW STATUS LIKE 'Threads_connected'; //사용중인 개수<br><img alt="Pasted image 20241213102128.png" src="사진-및-문서/pasted-image-20241213102128.png" target="_self"><br>
<br>배치를 완료한 이후에도 스레드 풀(히카리 풀)을 반환하지 않는지 확인
<br><img alt="Pasted image 20241213102229.png" src="사진-및-문서/pasted-image-20241213102229.png" target="_self"><br>
<br>Step이 마무리될때, 적어도 Job이 마무리 될때 entityManager를 클로즈 시키는것이 자명한데, 어째서 커넥션풀이 해제되지 않는가??
<br><img alt="Pasted image 20241213143101.png" src="사진-및-문서/pasted-image-20241213143101.png" target="_self"><br><img alt="Pasted image 20241213143217.png" src="사진-및-문서/pasted-image-20241213143217.png" target="_self"><br><img alt="Pasted image 20241213103503.png" src="사진-및-문서/pasted-image-20241213103503.png" target="_self"><br><img alt="Pasted image 20241217150339.png" src="사진-및-문서/pasted-image-20241217150339.png" target="_self"><br>리스너에 너무 많은 역할이 부여된 모습
<br><img alt="Pasted image 20241219145746.png" src="사진-및-문서/pasted-image-20241219145746.png" target="_self"><br>
<br>StepExecution-Level ExecutionContext <br>
각 Step에 고유한 ExecutionContext가 생성됩니다. <br>
Step 내의 Reader, Processor, Writer 등에서 공유됩니다. <br>
다른 Step과는 공유되지 않습니다. <br>
balanceWorkerStep 내에서는 Reader, Processor, Writer가 동일한 ExecutionContext를 공유합니다. <br>
balancePartitionStep과 balanceWorkerStep의 ExecutionContext는 서로 독립적입니다. <br>JobExecution-Level ExecutionContext <br>Job 전체에서 공유되며, 모든 Step이 동일한 ExecutionContext에 접근할 수 있습니다.
<br>JobExecutionContext는 Step 간 데이터 전달이 필요할 때 유용합니다. <br>JobExecutionListener 객체 생성<br>@Slf4j public class JobTimerExecutionListener implements JobExecutionListener { private final String jobName; private long startTime = System.currentTimeMillis(); public JobTimerExecutionListener(String jobName) { this.jobName = jobName; } @Override public void beforeJob(JobExecution var1) { startTime = System.currentTimeMillis(); } @Override public void afterJob(JobExecution var1) { long endTime = System.currentTimeMillis(); long elapsedTime = endTime - startTime; long minutes = (elapsedTime / 1000) / 60; // 밀리초를 분으로 변환 double seconds = (elapsedTime / 1000.0) % 60; // 남은 밀리초를 초로 변환 (소수점 포함) log.info("{}-completed: {} ms | {} minutes {} seconds", jobName, elapsedTime, minutes, seconds); } }
<br><img alt="output (9) 1.png" src="사진-및-문서/output-(9)-1.png" target="_self"><br><img alt="output (10).png" src="사진-및-문서/output-(10).png" target="_self"><br><img alt="do-messenger_screenshot_2024-12-23_14_40_21.png" src="사진-및-문서/do-messenger_screenshot_2024-12-23_14_40_21.png" target="_self"><br><img alt="Pasted image 20241224093159.png" src="사진-및-문서/pasted-image-20241224093159.png" target="_self"><br>
<img alt="Pasted image 20241224093207.png" src="사진-및-문서/pasted-image-20241224093207.png" target="_self"><br>
<img alt="Pasted image 20241224093225.png" src="사진-및-문서/pasted-image-20241224093225.png" target="_self"><br>🙇‍♂<a data-href="🏹 예치금 차액 비교 Spring Batch 리펙토링 부록" href="project/hello-batch/🏹-예치금-차액-비교-spring-batch-리펙토링-부록.html" class="internal-link" target="_self" rel="noopener nofollow">🏹 예치금 차액 비교 Spring Batch 리펙토링 부록</a>]]></description><link>project/hello-batch/🏹-예치금-차액-비교-spring-batch-리펙토링.html</link><guid isPermaLink="false">project/hello Batch/🏹 예치금 차액 비교 Spring Batch 리펙토링.md</guid><pubDate>Fri, 28 Feb 2025 09:15:46 GMT</pubDate><enclosure url="사진-및-문서/회사-은행-서비스1111.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="사진-및-문서/회사-은행-서비스1111.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[📓 EntityManager와 Transaction 그리고 ConnectionPool]]></title><description><![CDATA[<a class="tag" href="?query=tag:트러블슈팅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#트러블슈팅</a> <a class="tag" href="?query=tag:EntityManager" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#EntityManager</a> <a class="tag" href="?query=tag:Transaction" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Transaction</a> <a class="tag" href="?query=tag:트렌젝션" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#트렌젝션</a> <br> <a href=".?query=tag:트러블슈팅" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#트러블슈팅">#트러블슈팅</a> <a href=".?query=tag:EntityManager" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#EntityManager">#EntityManager</a> <a href=".?query=tag:Transaction" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Transaction">#Transaction</a> <a href=".?query=tag:트렌젝션" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#트렌젝션">#트렌젝션</a><br>청크사이즈가 다름에도 처리속도가 똑같은 이유?<br>grid-size:12 / chunk-size:30
-
3분 22.856초
3분 23.096초 grid-size:12 / chunk-size:20
-
3분 23.546초
3분 23.784초 grid-size:12 / chunk-size:10
-
3분 24.243초
3분 22.389초
3분 24.667초
3분 24.789초 grid-size:12 / chunk-size:5
-
3분 24.953초
3분 24.353초
<br>
<br>트렌젝션 분리가 되어있지 않았기 떄문에 청크사이즈를 아무리 잘게 쪼개도 시간이 같았던 것이다.
<br>그럼 트렌젝션이 분리되지 않은 이유는?
<br>dtoList.stream().parallel() .forEach(dto -&gt; {});
<br>parallel문으로 내부 병렬처리로직을 구현했기 때문에, chunk의 트렌젝션에서 벗어나,<br>
매 insert문 마다 커밋을 하였던 것이다.<br>반복 TEST 중.. 커넥션풀 Time Out 문제??<br>SHOW VARIABLES LIKE 'max_connections'; //최대 개수<br>
SHOW STATUS LIKE 'Threads_connected'; //사용중인 개수<br><img alt="Pasted image 20241213102128.png" src="사진-및-문서/pasted-image-20241213102128.png" target="_self"><br>
<br>배치를 완료한 이후에도 스레드 풀(히카리 풀)을 반환하지 않는지 확인
<br><img alt="Pasted image 20241213102229.png" src="사진-및-문서/pasted-image-20241213102229.png" target="_self"><br>
<br>Step이 마무리될때, 적어도 Job이 마무리 될때 entityManager를 클로즈 시키는것이 자명한데, 어째서 커넥션풀이 해제되지 않는가??
<br><img alt="Pasted image 20241213143101.png" src="사진-및-문서/pasted-image-20241213143101.png" target="_self"><br><img alt="Pasted image 20241213143217.png" src="사진-및-문서/pasted-image-20241213143217.png" target="_self"><br><img alt="Pasted image 20241213103503.png" src="사진-및-문서/pasted-image-20241213103503.png" target="_self">]]></description><link>issue_troubleshooting/📓-entitymanager와-transaction-그리고-connectionpool.html</link><guid isPermaLink="false">Issue_TroubleShooting/📓 EntityManager와 Transaction 그리고 ConnectionPool.md</guid><pubDate>Fri, 28 Feb 2025 09:15:41 GMT</pubDate><enclosure url="사진-및-문서/pasted-image-20241213102128.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="사진-및-문서/pasted-image-20241213102128.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[⚔ 도대체 어디서 StckOverflow가..]]></title><description><![CDATA[<br><img alt="Pasted image 20250228143143.png" src="사진-및-문서/pasted-image-20250228143143.png" target="_self">]]></description><link>issue_troubleshooting/⚔-도대체-어디서-stckoverflow가...html</link><guid isPermaLink="false">Issue_TroubleShooting/⚔ 도대체 어디서 StckOverflow가...md</guid><pubDate>Fri, 28 Feb 2025 09:15:05 GMT</pubDate><enclosure url="사진-및-문서/pasted-image-20250228143143.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="사진-및-문서/pasted-image-20250228143143.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🏠 taesung's Blog]]></title><description><![CDATA[<a class="tag" href="?query=tag:home" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#home</a> <a class="tag" href="?query=tag:index" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#index</a> <a class="tag" href="?query=tag:blog" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#blog</a> <a class="tag" href="?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <br> <a href=".?query=tag:home" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#home">#home</a> <a href=".?query=tag:index" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#index">#index</a> <a href=".?query=tag:blog" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#blog">#blog</a> <a href=".?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a><br><a data-tooltip-position="top" aria-label="https://github.com/LeeTaeSung0628" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/LeeTaeSung0628" target="_self"><span alt="Pasted image 20250220144552.png" src="Pasted image 20250220144552.png" class="internal-embed media-embed image-embed is-loaded" style="width: 220px; max-width: 100%;"></span></a><img alt="Pasted image 20250220144552.png" src="사진-및-문서/pasted-image-20250220144552.png" style="width: 220px; max-width: 100%;" target="_self"><br>
<a data-tooltip-position="top" aria-label="https://github.com/LeeTaeSung0628" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/LeeTaeSung0628" target="_self"><font color="#ffffff"></font></a>🔗git Hub 이동<br><a data-tooltip-position="top" aria-label="https://git.io/typing-svg" rel="noopener nofollow" class="external-link is-unresolved" href="https://git.io/typing-svg" target="_self"></a><img alt="Typing SVG" src="https://readme-typing-svg.demolab.com?font=Fira+Code&amp;pause=1000&amp;color=36A9F7&amp;random=false&amp;width=435&amp;lines=%EC%97%AC%EA%B8%B0%EB%8A%94+%EA%B3%B5%EB%B6%80%ED%95%98%EA%B3%A0%2C+%EA%B8%B0%EB%A1%9D%ED%95%98%EB%8A%94+%EA%B3%B3%EC%9E%85%EB%8B%88%EB%8B%A4" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br> <br> <br> <br> <br> <br> <br> <br> <br> <br>Soon <br>깃 레포에서도 블로그 주소로 이어질 수 있도록 Readme 설정하기. <br>리드미 또한 옵시디언에서 작업이 가능하다. <br>Netlify 셋팅 추가하기]]></description><link>index.html</link><guid isPermaLink="false">index.md</guid><pubDate>Fri, 28 Feb 2025 09:15:03 GMT</pubDate><enclosure url="사진-및-문서/pasted-image-20250220144552.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="사진-및-문서/pasted-image-20250220144552.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Lock ( 데이터베이스 락 ) 이란?]]></title><description><![CDATA[<br>왜 락이 풀리지?
lock으로 묶여있는 로직 안에 너무 많은 동작이 몰려있다.<br>
-&gt; 그때, 4초가 넘어 버리게 된다면, 락을 놓아버리고 동시성이 깨질 수 있는 가능성이 있다.
어쩨서?? <br>A, B에 대해 단일 투자자가 투자를 했을 때,<br>
A상품에 대한 투자를 완료처리하여 예치금 차감이 되지 않은 상태에서 락이 풀려버린다면?<br>
B상품에 대한 투자도 정상처리가 되어버린다. <br><br><br>세션2에서 동시에 같은 데이터를 수정하게 되면 여러가지 문제가 발생한다.<br>
이런문제를 방지하기 위해, 세션이 트렌젝션을 시작하고 데이터를 수정하는 동안에 커밋이나 롤백 전까지<br>
다른세션에서 해당 데이터를 수정할 수 없게 막아야 한다. 이런 문제를 해결하기 위해 DB에서는<br>
LOCK 락 이라는 개념을 제공한다.<br>
<br>락은 언제 사용하는가? : 트렌젝션 종료 시점까지 해당 데이터를 다른 곳에서 변경하지 못하도록 강제로 막아야 할 때 사용한다.
<br>일반적인 조회는 락을 사용하지 않는다.
<br>락 타임아웃(다른 세션이 데이터를 점유하고 있을때 대기시간이 초과된 경우)에는 익셉션이 발생하게 된다.
<br><br>동시성 제어(Concurrency Control)란,&nbsp;여러 사용자나 프로세스가 데이터를 공유할 때 발생할 수 있는 문제를 해결하기 위해, 데이터베이스 시스템이 트랜잭션을 순서대로 실행하는 것이 아니라, 트랜잭션이 동시에 실행될 수 있도록 허용하면서도 데이터의 일관성과 무결성을 유지할 수 있도록 하는 기술이며, 데이터베이스 시스템에서 매우 중요한 개념 중 하나이다.<br><br>
<br>여러 사용자가 DB에 접근하더라도&nbsp;데이터의 일관성을 보장하고 데이터의 무결성을 유지
<br>위를 만족하며 데이터베이스 시스템의 성능과 효율성을 유지하는 것
<br>
<br>분실된 갱신(Lost Update) <br>두개의 트랜잭션이 같은 데이터를 갱신하는 작업을 진행하게 되면서 하나의 작업이 진행되지 않는 경우 <br>모순성(Inconsistency) <br>두개의 트랜잭션이 같은 데이터를 동시에 갱신하게되어 사용자가 원하는 결과와 일치하지 않은 상태가 되는 경우 <br>연쇄복귀(Cascading Rollback) <br>두개의 트랜잭션이 같은 데이터를 갱신하는 작업을 진행하는 과정에서 하나의 트랜잭션이 실패하면 원자성에 의해 두 트랜잭션 모두 복귀하는 경우 <br>비완료 의존성(Uncommitted Dependency) <br>한개의 트랜잭션이 실패하였을때, 이 트랜재션이 회복하기전에 다른 트랜잭션이 실패한 수행 결과를 참조하는 경우 <br><br><br>
<br>Locking은 공유 자원에 대한 동시 액세스를 제어하는 전통적인 방법이다.
<br>단일 스레드 또는 단일 프로세스에서만 동작하며, 한 번에 하나의 스레드만 공유 자원에 액세스할 수 있다.
<br>신뢰성과 안전성이 높으며, 어떤 수준의 locking을 적용하느냐에 따라 교착 상태나 경쟁 조건과 같은 문제를 방지할 수 있다.
<br>하지만 동시성 처리 속도가 저하될 수 있고, 대기 시간이 발생할 수 있다.
<br>기본적으로 lock 연산과 unlock 연산을 사용한다.
<br><br>
<br>
공유 잠금 (shared lock/s-lock): 데이터를 읽을 때 사용하는 락 <br>공유잠금을 설정한 트랜잭션은 데이터 항목에 대해&nbsp;읽기 연산(read)만 가능하다. <br>T1에서 x에 대해 S-lock을 설정했다면, T1은 read(x) 연산만 가능하다. <br>하나의 데이터 항목에 대해&nbsp;여러 개의 공유잠금이(S-lock) 가능하다. <br>T1에서 x에 대해 S-lock을 설정한 경우, 동시에 T2에서도 x에 대해 S-lock을 설정할 수 있다. <br>다른 트랜잭션도 읽기 연산(read) 만을 실행할 수 있다. <br>T1에서 x에 대해 S-lock을 설정했다면, T2에서도 T1이 S-lock(x)을 실행하는 동안 read(x) 연산만 가능하다. <br>
배타 잠금 (exclusive lock/x-lock): 데이터를 변경할 때 사용하는 락 <br>배타잠금을 설정한 트랜잭션은 데이터 항목에 대해서&nbsp;읽기 연산(read)과 쓰기 연산(write) 모두 가능하다. <br>T1에서 x에 대해 S-lock을 설정했다면, T1은 read(x) 연산과 write(x) 연산 모두 가능하다. <br>하나의 데이터 항목에 대해서는&nbsp;하나의 배타잠금(X-lock)만 가능하다.
<br>동시에 여러 개의 배타잠금은 불가능하다. <br>T1에서 x에 대해 X-lock을 설정했다면, T1에서 unlock(x)를 하기 전까지 T2에서 x에 대해 X-lock을 설정할 수 없다. <br>다른 트랜잭션은 읽기 연산(read)와 쓰기 연산(write) 모두 불가능하다. <br>T1에서 x에 대해 X-lock을 설정했다면, T2에서는 T1에서 unlock(x)를 하기 전까지 read(x), write(x) 연산이 모두 불가능하다. <br>
추가) 교착상태 (deadlock) <br>모든 transaction이 대기 상태에 들어가 아무런 진행이 일어나지 않는 상태를 교착상태라고 한다. 교착상태에 빠지면 외부에서 강제로 트랜잭션을 중단하거나 잠금을 해제하지 않는 이상 무한정 대기 상태로 남게 된다. <br><br><br>
<br>
낙관적 락 (optimistic lock) <br>충돌이 발생할 가능성이 낮은 경우 사용되는 동시성 제어 기법이다.
<br>충돌이 발생하면 재시도 또는 병합을 통해 충돌을 해결한다.
<br>실제로 lock을 사용하지 않고&nbsp;version을 이용함으로서 정합성을 맞추는 방법이다. 데이터를 읽을 때 lock을 사용하지 않고, 업데이트 시&nbsp;내가 읽은 version이 맞는지 충돌 여부를 확인하여 처리한다.
<br>즉, 자원에 lock을 직접 걸어서 선점하지 않고, 동시성 문제가 실제로 발생하면 그때가서 처리하는 방식이다. <br>
비관적 락 (pessimistic lock) <br>충돌이 발생할 가능성이 높은 경우 사용되는 동시성 제어 기법이다.
<br>데이터를 읽거나 수정하기 전에 lock을 획득하여 다른 사용자의 액세스를 차단하고, lock을 가진 스레드만 접근하도록 제어한다.
<br>데이터에 대한 배타적인 액세스 권한을 보장하여 충돌을 방지한다.
<br>실제로 데이터에 lock을 걸어서 정합성을 맞추는 방법으로, 자원 요청에 따른 동시성 문제가 발생할 것이라고 예상하고 lock을 걸어버리는 방법이다.
<br>즉, 트랜젝션이 시작할 때 s-lock이나 x-lock을 실제로 걸고 시작한다. <br>
낙관적 락 vs. 비관적 락<br>
<img alt="Pasted image 20250228150552.png" src="사진-및-문서/pasted-image-20250228150552.png" target="_self"> <br>
분산락 (distributed lock) <br>여러 컴퓨터 또는 프로세스 간에 공유된 자원에 대한 동시 액세스를 제어하기 위해 사용된다.
<br>분산 시스템에서 동시성 문제를 해결하기 위해 사용되며,&nbsp;분산된 서버 또는 클러스터 간의 상호작용이 필요하다.
<br>주로&nbsp;데이터베이스나 메시지 큐 등의 분산 시스템에서 사용된다.
<br>대표적인 분산락 기법으로는 ZooKeeper, Redis 등이 있다.
<br>Redis는 RedLock이라는 알고리즘을 제안하며 3가지 특성을 보장해야한다고 한다. <br>오직 한 순간에 하나의 작업자만이 락(lock) 을 걸 수 있다.
<br>락 이후, 어떠한 문제로 인해 락을 풀지 못하고, 종료된 경우라도 다른 작업자가 락을 획득할 수 있어야합니다.
<br>Redis 노드가 작동하는한, 모든 작업자는 락을 걸고 해체할 수 있어야합니다. <br>분산 락을 구현하기 위해 lock에 대한 정보를 Redis에 저장하고 있어야한다. 그리고 분산환경에서 여러대의 서버들은 공통된 Redis를 바라보며, 자신이 공유 자원에 접근할 수 있는지 확인한다. <br>
스핀락 (spin lock) <br>자원에 대한 접근이 필요할 때 무한루프를 돌면서 반복적으로 확인하며, 다른 스레드가 lock을 해제할 때까지 대기한다.
<br>경쟁 상태 (2개 이상의 프로세스가 공유 자원을 동시에 읽거나 쓰는 상황)가 짧고 자원 점유 시간이 길지 않은 경우에 효과적이다.
<br>주로 멀티코어 시스템에서 사용되며, 락 획득을 위해 CPU를 계속 사용하므로 서버에 많은 부하를 주어 주의해야 한다.
<br> <br>]]></description><link>issue_troubleshooting/🔐-lock이란-무엇인가.-데이터-정합성을-위한-여정.html</link><guid isPermaLink="false">Issue_TroubleShooting/🔐 Lock이란 무엇인가. 데이터 정합성을 위한 여정.md</guid><pubDate>Fri, 28 Feb 2025 09:14:49 GMT</pubDate><enclosure url="사진-및-문서/pasted-image-20250228150552.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="사진-및-문서/pasted-image-20250228150552.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[👩‍👧‍👦 Analytics 공통모듈 ADMIN용 데이터 추출]]></title><description><![CDATA[<a class="tag" href="?query=tag:프로젝트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로젝트</a> <a class="tag" href="?query=tag:개발" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#개발</a> <a class="tag" href="?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <a class="tag" href="?query=tag:AOP" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#AOP</a> <br> <a href=".?query=tag:프로젝트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로젝트">#프로젝트</a> <a href=".?query=tag:개발" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#개발">#개발</a> <a href=".?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a> <a href=".?query=tag:AOP" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#AOP">#AOP</a><br>hf_marketing_code<br>hf_marketing_target<br>hf_marketing_hit_log<br><img alt="Pasted image 20250102181842.png" src="사진-및-문서/pasted-image-20250102181842.png" target="_self"><br>=&gt; 해당형태로 컬럼을 고정시키고, 동적으로 유입 수 를 출력한다.<br>-&gt; 그 후 페이지에 뿌려주기<br>Date: 01-02
Ad Type: 구글광고
Total Inflow: 4
Total Hit: 27
Detail Information: Page Name: 대출하기 페이지 Hit: 9 Page Name: 한도조회 버튼 Hit: 12 Page Name: 이용안내 페이지 Hit: 6]]></description><link>project/hello-marketing/👩‍👧‍👦-analytics-공통모듈-admin용-데이터-추출.html</link><guid isPermaLink="false">project/hello marketing/👩‍👧‍👦 Analytics 공통모듈 ADMIN용 데이터 추출.md</guid><pubDate>Fri, 28 Feb 2025 09:10:43 GMT</pubDate><enclosure url="사진-및-문서/pasted-image-20250102181842.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="사진-및-문서/pasted-image-20250102181842.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[👩‍👧‍👦 marketing Analytics 공통모듈 제작기]]></title><description><![CDATA[<a class="tag" href="?query=tag:프로젝트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로젝트</a> <a class="tag" href="?query=tag:개발" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#개발</a> <a class="tag" href="?query=tag:DB" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#DB</a> <a class="tag" href="?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <a class="tag" href="?query=tag:AOP" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#AOP</a> <br> <a href=".?query=tag:프로젝트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로젝트">#프로젝트</a> <a href=".?query=tag:개발" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#개발">#개발</a> <a href=".?query=tag:DB" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#DB">#DB</a> <a href=".?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a> <a href=".?query=tag:AOP" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#AOP">#AOP</a> <br>
<br>기존 외부 유입 통계 로직의 단점 해결. <br>확장에 닫혀있음
<br>디테일한 행동 추적 불가능
<br>중복 접근자 처리로직의 부재 <br>Hello Service의 유입/동작 통계 모듈의 공통화 작업이다.
Spring AOP를 사용하여 구성하였다.
<br>
<br>통계 필요 페이지 내에서(프론트), 쿠키 데이터 페이지 별 최초 진입 확인?
<br>
<br>해당 진입시점부터 특정 동작에 대한 모든 타임라인 로그
<br>
<br>레디스 가용 메모리에 대한 한계값 산정. -&gt; 아직 적용 X
<br>
<br>URL + 함수명 조합
<br>=&gt; 메인 테이블<br>
=&gt; 백로직에서 쿠키 데이터 쌓기<br>=&gt; 디테일 테이블 - 타임라인으로 관리 단, 메인테이블에 존재하는 내셕들에 대해서<br>
=&gt; AOP에서 특정 서비스or메서드orURL로 지정하여 로그 쌀기<br>- 관심사(Aspect)를 분리하여, 각 서비스 메서드에 반복해서 구현하는 것이 아닌, 별도의 Aspect로 관리하여 핵심로직을 공통으로 적용하기 위함이다.
<br>
<br>난수 생성 후 물고있기☑ <br>IP로 추적 <br><img alt="Pasted image 20241224144309.png" src="사진-및-문서/pasted-image-20241224144309.png" target="_self"><br>쿠키가 필요한 페이지의 경로가 기본 path와 일치하는 경우(redirect url 이 SP_MARKETING_HIT_TEST1 의 하위 url일 경우)<br>
에는 명시적으로 표시할 필요가 없지만,<br>AOP에서 Front-end 단의 특정 동작 필터링 하기<br><img alt="Pasted image 20241226111559.png" src="사진-및-문서/pasted-image-20241226111559.png" target="_self"><br>
<br>장점: <br>코드가 간결하고 읽기 쉽다.
<br>Spring의 AOP 인프라를 사용하여 메서드 인터셉션을 쉽게 구현할 수 있다. <br>단점:
- 포인트컷 조건은 컴파일 시점에 고정된다.
- 복잡한 조건이나 동적으로 변경되는 조건을 처리하기 어렵다. -&gt; @Pointcut 등의 조건에 부합하는 Bean객체를 컴파일 시점에 찾아내어 프록시를 감싼다.
<br>
<br>동적 생성: <br>런타임에 프록시를 생성하여 포인트컷과 어드바이스를 동적으로 적용.
<br>StaticMethodMatcherPointcut 또는 DynamicMethodMatcherPointcut을 사용하여 런타임 조건 기반으로 메서드 매칭. <br>장점: <br>런타임 조건에 따라 동적으로 포인트컷 생성 가능.
<br>복잡한 조건과 동적 필터링을 처리하기 용이.
<br>Spring AOP가 아닌 순수 Java 프록시 방식도 지원. <br>단점: <br>코드가 복잡해지고 추가 구현이 필요.
<br>Spring AOP와 동일한 수준의 간결성을 제공하지 않음. <br>-&gt; 해당 프록시 객체를 적용하고 싶은 Bean객체에 매번 생성(등록)해주어야 함.<br>import org.springframework.aop.Pointcut;
import org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;
import org.springframework.aop.support.DefaultPointcutAdvisor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration; @Configuration
public class AopConfig { @Bean public Pointcut customPointcut() { return new CustomPointcut(); } @Bean public CustomAdvice customAdvice() { return new CustomAdvice(); } @Bean public DefaultPointcutAdvisor customAdvisor(Pointcut customPointcut, CustomAdvice customAdvice) { return new DefaultPointcutAdvisor(customPointcut, customAdvice); } @Bean public DefaultAdvisorAutoProxyCreator proxyCreator() { return new DefaultAdvisorAutoProxyCreator(); }
} <br>
<br>@Pointcut 방식과 동일한 동작: <br>Spring 컨테이너가 관리하는 모든 빈에 대해 조건을 평가하고 프록시를 자동 생성합니다. <br>프록시를 명시적으로 선언할 필요 없음: <br>ProxyFactory처럼 수동으로 프록시를 생성하지 않아도 됩니다. <br>유연성과 효율성 향상: <br>Spring AOP 인프라를 활용하므로, 관리가 용이하고 런타임 성능이 개선됩니다. <br>
<br>BeanPostProcessor: <br>DefaultAdvisorAutoProxyCreator는 Spring의 BeanPostProcessor를 구현한 클래스이다.
<br>Spring 컨테이너는 애플리케이션 컨텍스트에 등록된 모든 BeanPostProcessor를 자동으로 호출하여 빈의 초기화 전후 작업을 수행한다.
<br>이를 통해, Spring AOP는 빈 생성 단계에서 프록시를 생성하고 조건에 맞는 빈에 대해 어드바이저를 적용. <br>Advisor 탐색: <br>DefaultAdvisorAutoProxyCreator는 Spring 컨텍스트에 등록된 모든 Advisor를 자동으로 탐색한다.
<br>이는 DefaultAdvisorAutoProxyCreator가 BeanFactory를 통해 컨테이너의 모든 Advisor 타입 빈을 조회하기 때문.
<br>탐색된 Advisor를 사용하여 각 빈의 메서드와 포인트컷 조건을 매칭. <br>Advisor와 빈의 매칭: <br>빈이 생성될 때, DefaultAdvisorAutoProxyCreator는 해당 빈의 메서드가 어떤 Advisor의 포인트컷 조건에 부합하는지 평가.
<br>조건에 부합하면, 해당 빈을 프록시 객체로 감싸고, 어드바이스를 연결. <br>위 방법의 문제점? <br>
<br>이렇게 맵핑이 되어야 하나, 이를 동적으로 탐지하지 못한다.
<br>/* * EnableAspectJAutoProxy &gt; 프록시 적용시 인터페이스/클래스 여부 자동 판단 * 클래스에 인터페이스가 있으면 JDK 동적 프록시. * 인터페이스가 없으면 CGLIB 프록시. * */@Configuration @EnableAspectJAutoProxy public class AopConfig { @Bean public Pointcut customPointcut() { return new CustomPointcut(); } @Bean public CustomAdvice customAdvice() { return new CustomAdvice(); } @Bean public DefaultPointcutAdvisor customAdvisor(Pointcut customPointcut, CustomAdvice customAdvice) { return new DefaultPointcutAdvisor(customPointcut, customAdvice); } /* * @EnableAspectJAutoProxy를 사용해 등록했기 때문에 불필요. * */ // @Bean // public DefaultAdvisorAutoProxyCreator proxyCreator() { // return new DefaultAdvisorAutoProxyCreator(); // } }
<br>프록시(Proxy)는 대리자라는 뜻으로, 다른 객체에 대한 인터페이스 역할을 하는 객체를 말합니다. 프로그래밍에서 프록시는 실제 객체에 접근하기 전에 특정 작업(로깅, 보안, 트랜잭션 관리 등)을 수행하거나, 객체에 대한 접근을 제어하는 데 사용됩니다.<br>
<br>대리 객체: 프록시는 실제 객체에 대한 중간다리 역할을 합니다.
<br>동작 조정: 프록시는 요청을 가로채서 추가적인 작업을 수행하거나, 요청을 변형한 뒤 실제 객체에 전달할 수 있습니다.
<br>AOP와 연관: 프록시를 사용하면 코드를 변경하지 않고도 객체의 동작을 확장하거나 변경할 수 있습니다.
<br>Method Name: loanerLoginPage<br>
javax.servlet.http.HttpServletRequest<br>
org.springframework.web.bind.annotation.GetMapping <br><img alt="Pasted image 20241226152219.png" src="사진-및-문서/pasted-image-20241226152219.png" target="_self"><br><img alt="Pasted image 20241226171158.png" src="사진-및-문서/pasted-image-20241226171158.png" target="_self"><br>
<br>외부링크 최초진입. hitCode, hitUid 발급 및 DB저장
<br>
<br>외부링크 재진입. hitCode는 변경될 수 있으므로 "p"파라미터로 재발급<br>
=&gt; hitCode는 매번 재발급 / hitUid는 없을때만 발급
<br>
<br>일반사용자 이며, 아무동작 하지 않는다.
<br>
<br>외부링크 진입 후 동작. 없는 녀석 새로 발급 및 DB저장
<br>서비스 저장시 동시성 이슈가 발생할 수 있다?<br>@Override @Transactional public ResponseModel insertMarketingHitLog(String hitCode, String hitUid, String pageUrl, String pageType){ try { Optional&lt;HfMarketingHitLog&gt; existingLog = hfMarketingHitLogRepository.findByHitCodeAndHitUidAndPageUrlAndPageType(hitCode, hitUid, pageUrl, pageType); if (existingLog.isPresent()) { HfMarketingHitLog logToUpdate = existingLog.get(); logToUpdate.setUpdateDate(LocalDateTime.now()); hfMarketingHitLogRepository.save(logToUpdate); return new ResponseModel(ResponseModel.ResponseStatus.SUCCESS); } HfMarketingHitLog hfMarketingHitLog = HfMarketingHitLog.builder() .hitCode(hitCode) .hitUid(hitUid) .pageUrl(pageUrl) .pageType(pageType) .build(); hfMarketingHitLogRepository.save(hfMarketingHitLog); return new ResponseModel(ResponseModel.ResponseStatus.SUCCESS); } catch (Exception e) { return new ResponseModel(ResponseModel.ResponseStatus.FAILED, "데이터 처리 중 오류 발생"); } }
<br>
<br>여러 쓰레드(또는 트랜잭션)가 findByHitCodeAndHitUidAndPageUrlAndPageType 메서드를 호출하여 동일한 조건의 데이터를 동시에 조회할 수 있다.
<br>두 쓰레드가 모두 existingLog.isPresent() 조건에서 false를 확인한 후, 동시에 새로운 HfMarketingHitLog 객체를 생성하고 저장하려 하면 데이터 중복 문제가 발생할 수 있다.
<br>. Lock을 쓰면 되나, 이후 업데이트 로직 삭제(로그 테이블화) 변경으로 처리<br><img alt="Pasted image 20241230135801.png" src="사진-및-문서/pasted-image-20241230135801.png" target="_self"><br>1일의 유효기간을 갖는 uid를 발급하여, 인입코드 / Hit된 기능 주소 / 시간 을 저장한다.
<br>uid는 외부url로 접근시 발급
<br>page_url는 코드에 미리 등록 / hit_code는 모두(only 영문+숫자) 수용 가능
<br><img alt="Pasted image 20250102160213.png" src="사진-및-문서/pasted-image-20250102160213.png" target="_self"><br>
<img alt="Pasted image 20250102160223.png" src="사진-및-문서/pasted-image-20250102160223.png" target="_self"><br>
<br>enum객체에 정의된 메서드를 DB로 전환하여 pointcut에서 해당 클래스, 메서드를 가져와 조건으로 정의
<br>해당 조건에 부합하는 메서드를 프록시로 전환
<br>
<br>api호출을 통해 advice내의 동작은 런타임 환경에서 동적으로 변경이 가능한 것을 확인했다.
<br>
<br>런타입 위빙 방식이라고 하더라도, 변경은 불가능하다.
<br>컴파일 위빙 방식은 컴파일 단계에서 원본 클래스 바이트코드를 변경하여 직접 위빙을 하는 방식이고,<br>
런타임 위빙은 런타임단계에서 원본 클래스를 변경하지 않고 프록시 객체를 사용하여 교체하는 방식이다.
<br>=&gt; 해당하는 부분은 리빌드와 큰 차이가 없고, 각 class에 scope를 따로 적용해야했기 때문에 고려하지 않았다.<br>=&gt; 연관성 있는 모든 참조를 수동으로 재설정해야하기 때문에 매우 복잡해진다.<br>
<br>참조를 갱신하기 위해서는 Java리플렉션을 사용하여 강제로 참조를 갱신하거나, AspectJ의 런타임 위빙 방식을 활용해야 한다.
<br>따라서, 서버 Kill을 하는 것과 진배 없으며, 권장하지 않는 방법이다.
<br>이슈
내부통계기능(AOP)의 진입URL에서 네이버 아날리틱스(외부 통계 프로그램)가 작동하지 않는 이슈
<br>
<br>외부 유입통계 페이지의 인입 주소는 일반적인 메인 페이지가 아닌, Gate를 거쳐서(redirect) 동작하게 된다.
<br>이 때, 진입 referrer에 변동이 생기면서 집계가 되지 않는 오류가 발생한 것으로 보인다.
<br>
<br>해당 방법을 사용하여, View단을 추가하여 replace한다면, 처음 진입시 갖고 있는 referrer를 물고 갈수 있지 않을까?
<br>redirect대신 view단을 통해 진입하도록 만든 후, naver아날리틱스 스크립트를 추가한다.
<br>한계 : 외부 유입시 불필요한 페이지 방문이 생기게 되고, 유입과정의 시간이 증가한다. 또한, 해당 오류를 100% 해결할지 미지수
<br>
<br>해당 방법은 기존 naver아날리틱스를 사용하고 있는 로직을 그대로 사용하는 것이기 때문에 제일 확실하다.
<br>한계 : 외부유입자가 아닌, 모든 사용자에게 session및 uid체크가 들어가기 때문에 부하가 증가한다.(DB통신은 X)
<br>
<br>BEST🖐
<br>한계 : 네이버 아날리틱스의 내부로직 파악이 불가함
<br>
<br>현재 네이버의 내부 로직 파악이 불가하니, View를 추가하여 네이버 스크립트가 물고 가는지 먼저 TEST하도록 하기
<br>&lt;html xmlns:th="http://www/thymeleaf.org" th:replace="layout/mainLayout :: mainLayout('gate loan')"&gt; &lt;script th:inline="javascript"&gt; $(document).ready(function() { location.href = [[${urls.SP_LOAN}]]; }); &lt;/script&gt;
<br>mainLayout을 적용하여 해당 페이지에 default script를 적용시켰다.<br>
결과는 추후 모니터링 예정<br>Quote
sp/loan기준으로 레퍼러를 https://www-stg.hellofunding.co.kr/sp/loan/gtLoan?p=Z29vZ2xlMXN0 인입페이지 주소를 갖고있는것을 확인했다.
<br>2025-02-25 14:34:04 [hello-app-staging-7985c4d74f-47qnx] INFO com.hellofintech.hellofunding.common.interceptor.ServiceHandlerInterceptor[mergeIntoVisitCount:187] - referer = https://www-stg.hellofunding.co.kr/sp/loan/gtLoan?p=Z29vZ2xlMXN0
<br><img alt="Pasted image 20250226145129.png" src="사진-및-문서/pasted-image-20250226145129.png" target="_self"><br>확인 결과이미 sendRedirect 로직에서도 Header의 Referer를 물고있었다.<br>
어떠한 referrer를 기준으로 집계를 하는지 정확한 파악이 필요하다.
<br>[부록]<br>
<a data-href="👩‍👧‍👦 Analytics 공통모듈 ADMIN용 데이터 추출" href="project/hello-marketing/👩‍👧‍👦-analytics-공통모듈-admin용-데이터-추출.html" class="internal-link" target="_self" rel="noopener nofollow">👩‍👧‍👦 Analytics 공통모듈 ADMIN용 데이터 추출</a>]]></description><link>project/hello-marketing/👩‍👧‍👦-marketing-analytics-공통모듈-제작기.html</link><guid isPermaLink="false">project/hello marketing/👩‍👧‍👦 marketing Analytics 공통모듈 제작기.md</guid><pubDate>Fri, 28 Feb 2025 09:10:39 GMT</pubDate><enclosure url="사진-및-문서/pasted-image-20241224144309.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="사진-및-문서/pasted-image-20241224144309.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[💻 프로젝트]]></title><description><![CDATA[<a class="tag" href="?query=tag:프로젝트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로젝트</a> <a class="tag" href="?query=tag:모음" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#모음</a> <br> <a href=".?query=tag:프로젝트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로젝트">#프로젝트</a> <a href=".?query=tag:모음" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#모음">#모음</a><br>프로젝트
public하게 공개할 수 있는 프로젝트의 제작 과정입니다.
<br>
<br><a data-href="👻 Obsidian 정적호스팅 CICD 과정" href="project/note-ci_cd/👻-obsidian-정적호스팅-cicd-과정.html" class="internal-link" target="_self" rel="noopener nofollow">👻 Obsidian 정적호스팅 CICD 과정</a>
<br><a data-href="⛈ Obsidian-AWS연동" href="project/note-ci_cd/⛈-obsidian-aws연동.html" class="internal-link" target="_self" rel="noopener nofollow">⛈ Obsidian-AWS연동</a>
<br>
<br><a data-href="🏹 예치금 차액 비교 Spring Batch 리펙토링" href="project/hello-batch/🏹-예치금-차액-비교-spring-batch-리펙토링.html" class="internal-link" target="_self" rel="noopener nofollow">🏹 예치금 차액 비교 Spring Batch 리펙토링</a>
<br><a data-href="🏹 예치금 차액 비교 Spring Batch 리펙토링 부록" href="project/hello-batch/🏹-예치금-차액-비교-spring-batch-리펙토링-부록.html" class="internal-link" target="_self" rel="noopener nofollow">🏹 예치금 차액 비교 Spring Batch 리펙토링 부록</a>
<br><a data-href="✏ Chunk_Partitioning Batch 구조 드로잉" href="project/hello-batch/✏-chunk_partitioning-batch-구조-드로잉.html" class="internal-link" target="_self" rel="noopener nofollow">✏ Chunk_Partitioning Batch 구조 드로잉</a>
<br>
<br><a data-href="👩‍👧‍👦 marketing Analytics 공통모듈 제작기" href="project/hello-marketing/👩‍👧‍👦-marketing-analytics-공통모듈-제작기.html" class="internal-link" target="_self" rel="noopener nofollow">👩‍👧‍👦 marketing Analytics 공통모듈 제작기</a>
<br><a data-href="👩‍👧‍👦 Analytics 공통모듈 ADMIN용 데이터 추출" href="project/hello-marketing/👩‍👧‍👦-analytics-공통모듈-admin용-데이터-추출.html" class="internal-link" target="_self" rel="noopener nofollow">👩‍👧‍👦 Analytics 공통모듈 ADMIN용 데이터 추출</a>
<br>
<br><a data-href="📘 SpringBoot &amp; Docker + Reids 연동" href="tools/docker/📘-springboot-&amp;-docker-+-reids-연동.html" class="internal-link" target="_self" rel="noopener nofollow">📘 SpringBoot &amp; Docker + Reids 연동</a>
<br><a data-href="🌥 aws(EC2)셋팅부터 배포까지" href="tools/aws/🌥-aws(ec2)셋팅부터-배포까지.html" class="internal-link" target="_self" rel="noopener nofollow">🌥 aws(EC2)셋팅부터 배포까지</a>]]></description><link>project/💻-프로젝트.html</link><guid isPermaLink="false">project/💻 프로젝트.md</guid><pubDate>Fri, 28 Feb 2025 09:10:39 GMT</pubDate></item><item><title><![CDATA[📕 공부]]></title><description><![CDATA[<a class="tag" href="?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="?query=tag:모음" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#모음</a> <br> <a href=".?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href=".?query=tag:모음" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#모음">#모음</a><br>공부
보고 배운 지식 중 공유하고 싶은 정보를 모아둔 카테고리 입니다.
<br>
<br><a data-href="⏰ Script 로딩 지연 트러블 슈팅" href="issue_troubleshooting/⏰-script-로딩-지연-트러블-슈팅.html" class="internal-link" target="_self" rel="noopener nofollow">⏰ Script 로딩 지연 트러블 슈팅</a>
<br><a data-href="📓 EntityManager와 Transaction 그리고 ConnectionPool" href="issue_troubleshooting/📓-entitymanager와-transaction-그리고-connectionpool.html" class="internal-link" target="_self" rel="noopener nofollow">📓 EntityManager와 Transaction 그리고 ConnectionPool</a>
<br><a data-href="🔐 Lock이란 무엇인가. 데이터 정합성을 위한 여정" href="issue_troubleshooting/🔐-lock이란-무엇인가.-데이터-정합성을-위한-여정.html" class="internal-link" target="_self" rel="noopener nofollow">🔐 Lock이란 무엇인가. 데이터 정합성을 위한 여정</a>
<br><a data-href="⚔ 도대체 어디서 StckOverflow가.." href="issue_troubleshooting/⚔-도대체-어디서-stckoverflow가...html" class="internal-link" target="_self" rel="noopener nofollow">⚔ 도대체 어디서 StckOverflow가..</a>
<br>
<br><a data-href="☕ JAVA , OOP" href="study/cs/☕-java-,-oop.html" class="internal-link" target="_self" rel="noopener nofollow">☕ JAVA , OOP</a>
<br><a data-href="🍃 Spring" href="study/cs/🍃-spring.html" class="internal-link" target="_self" rel="noopener nofollow">🍃 Spring</a>
<br><a data-href="🎩 DevOps" href="study/cs/🎩-devops.html" class="internal-link" target="_self" rel="noopener nofollow">🎩 DevOps</a>
<br><a data-href="📔 DataBase" href="study/cs/📔-database.html" class="internal-link" target="_self" rel="noopener nofollow">📔 DataBase</a>
<br><a data-href="📭 Server" href="study/cs/📭-server.html" class="internal-link" target="_self" rel="noopener nofollow">📭 Server</a>
<br><a data-href="🐞 etc" href="study/cs/🐞-etc.html" class="internal-link" target="_self" rel="noopener nofollow">🐞 etc</a>
<br>
<br><a data-href="🤠 Coding Test 풀이 모음" href="study/coding-test/🤠-coding-test-풀이-모음.html" class="internal-link" target="_self" rel="noopener nofollow">🤠 Coding Test 풀이 모음</a>
<br><a data-href="👽 Algorithm" href="study/coding-test/👽-algorithm.html" class="internal-link" target="_self" rel="noopener nofollow">👽 Algorithm</a>
<br>
<br><a data-href="🔻 Redis 캐쉬 전략 - hello 서비스에 적용하여 성능개선 가능성" href="study/dev-seminar/🔻-redis-캐쉬-전략-hello-서비스에-적용하여-성능개선-가능성.html" class="internal-link" target="_self" rel="noopener nofollow">🔻 Redis 캐쉬 전략 - hello 서비스에 적용하여 성능개선 가능성</a>
<br><a data-href="🍂 JPA, Mybatis , Dead Lock" href="study/dev-seminar/🍂-jpa,-mybatis-,-dead-lock.html" class="internal-link" target="_self" rel="noopener nofollow">🍂 JPA, Mybatis , Dead Lock</a>
<br><a data-href="🔹 TDD에 대하여" href="study/dev-seminar/🔹-tdd에-대하여.html" class="internal-link" target="_self" rel="noopener nofollow">🔹 TDD에 대하여</a>
<br><a data-href="🪕 JPA 에 대한 고찰" href="study/dev-seminar/🪕-jpa-에-대한-고찰.html" class="internal-link" target="_self" rel="noopener nofollow">🪕 JPA 에 대한 고찰</a>
<br><a data-href="🔒 투자하기 서비스 락(Lock)기법 개선안" href="study/dev-seminar/🔒-투자하기-서비스-락(lock)기법-개선안.html" class="internal-link" target="_self" rel="noopener nofollow">🔒 투자하기 서비스 락(Lock)기법 개선안</a>
<br><a data-href="🥗 Spring Security_토큰-세션-쿠키-JWT 에 대하여" href="study/dev-seminar/🥗-spring-security_토큰-세션-쿠키-jwt-에-대하여.html" class="internal-link" target="_self" rel="noopener nofollow">🥗 Spring Security_토큰-세션-쿠키-JWT 에 대하여</a>
<br><a data-href="📔 DB 테이블 설계, 어떻게 하는게 옳은 방법인가" href="study/dev-seminar/📔-db-테이블-설계,-어떻게-하는게-옳은-방법인가.html" class="internal-link" target="_self" rel="noopener nofollow">📔 DB 테이블 설계, 어떻게 하는게 옳은 방법인가</a>
<br>
<br><a data-href="🥈 필기 1과목 - 소프트웨어 설계" href="study/정보처리기사/정보처리기사-필기/🥈-필기-1과목-소프트웨어-설계.html" class="internal-link" target="_self" rel="noopener nofollow">🥈 필기 1과목 - 소프트웨어 설계</a>
<br><a data-href="🥈 필기 2과목 - 소프트웨어 개발" href="study/정보처리기사/정보처리기사-필기/🥈-필기-2과목-소프트웨어-개발.html" class="internal-link" target="_self" rel="noopener nofollow">🥈 필기 2과목 - 소프트웨어 개발</a>
<br><a data-href="🥈 필기 3과목 - 데이터베이스 구축" href="study/정보처리기사/정보처리기사-필기/🥈-필기-3과목-데이터베이스-구축.html" class="internal-link" target="_self" rel="noopener nofollow">🥈 필기 3과목 - 데이터베이스 구축</a>
<br><a data-href="🥈 필기 4과목 - 프로그래밍 언어 활용" href="study/정보처리기사/정보처리기사-필기/🥈-필기-4과목-프로그래밍-언어-활용.html" class="internal-link" target="_self" rel="noopener nofollow">🥈 필기 4과목 - 프로그래밍 언어 활용</a>
<br><a data-href="🥈 필기 5과목 - 정보시스템 구축관리" href="study/정보처리기사/정보처리기사-필기/🥈-필기-5과목-정보시스템-구축관리.html" class="internal-link" target="_self" rel="noopener nofollow">🥈 필기 5과목 - 정보시스템 구축관리</a>
<br>
<br><a data-href="🥇 정보처리 기사 실기 키워드" href="study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-키워드.html" class="internal-link" target="_self" rel="noopener nofollow">🥇 정보처리 기사 실기 키워드</a>
<br><a data-href="🥇 정보처리 기사 실기 SQL 문제" href="study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-sql-문제.html" class="internal-link" target="_self" rel="noopener nofollow">🥇 정보처리 기사 실기 SQL 문제</a>]]></description><link>study/📕-공부.html</link><guid isPermaLink="false">study/📕 공부.md</guid><pubDate>Fri, 28 Feb 2025 09:07:41 GMT</pubDate></item><item><title><![CDATA[⏰ Script 로딩 지연 트러블 슈팅]]></title><description><![CDATA[<a class="tag" href="?query=tag:트러블슈팅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#트러블슈팅</a> <a class="tag" href="?query=tag:스크립트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#스크립트</a> <a class="tag" href="?query=tag:로딩지연" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#로딩지연</a> <br> <a href=".?query=tag:트러블슈팅" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#트러블슈팅">#트러블슈팅</a> <a href=".?query=tag:스크립트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#스크립트">#스크립트</a> <a href=".?query=tag:로딩지연" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#로딩지연">#로딩지연</a><br><img alt="Pasted image 20241105110415.png" src="사진-및-문서/pasted-image-20241105110415.png" style="width: 575px; max-width: 100%;" target="_self"><br>mainLayout은 Contents loading 후 Script를 호출하기 때문에, 특정 정적 오브젝트의 로딩이 완전히 마무리 될때 까지 실행되지 않음.<br>
=&gt; ex) 상품이 로딩되지 않은 상태로 최대 20초 가량을 대기 하게 됨<br>
<img alt="Pasted image 20250227140437.png" src="사진-및-문서/pasted-image-20250227140437.png" style="width: 600px; max-width: 100%;" target="_self">
<br><img alt="Pasted image 20250227140620.png" src="사진-및-문서/pasted-image-20250227140620.png" target="_self"><br>icon(아이콘)
<br>font(폰트)
<br> 현재 원인이 되는 외부자원(이미지/CSS)가 로딩되기 이전에 이벤트를 트리거 할 수 있다.<br>
이때, HTML DOM 트리가 준비 된 후(HTML 템플릿이 준비된 후)에 실행되기 때문에 modelAndView.addObject()로 전달한 데이터를 확정적으로 받아올 수 있다.<br>
<br>기존 메인 진입 소요시간 case 1 (로컬)<br>
<img alt="Pasted image 20241105110637.png" src="사진-및-문서/pasted-image-20241105110637.png" style="width: 500px; max-width: 100%;" target="_self"><br>
23초
<br>
<br>기존 메인 진입 소요시간 case 2 (로컬)<br>
<img alt="Pasted image 20241105110713.png" src="사진-및-문서/pasted-image-20241105110713.png" style="width: 500px; max-width: 100%;" target="_self"><br>
22초
<br>
<br>기존 메인 진입 소요시간 case 1 (운영)<br>
<img alt="Pasted image 20241107115602.png" src="사진-및-문서/pasted-image-20241107115602.png" style="width: 475px; max-width: 100%;" target="_self"><br>
21초
<br>
<br>기존 메인 진입 소요시간 case 2 (운영)<br>
<img alt="Pasted image 20241107115830.png" src="사진-및-문서/pasted-image-20241107115830.png" style="width: 475px; max-width: 100%;" target="_self"><br>
21초
<br>
<br>변경된 메인 진입 소요시간 case 1 (로컬)<br>
<img alt="Pasted image 20241107121044.png" src="사진-및-문서/pasted-image-20241107121044.png" style="width: 500px; max-width: 100%;" target="_self"><br>
0.201초
<br>
<br>변경된 메인 진입 소요시간 case 2 (로컬)<br>
<img alt="Pasted image 20241107121202.png" src="사진-및-문서/pasted-image-20241107121202.png" style="width: 500px; max-width: 100%;" target="_self"><br>
0.297초
<br>
<br>변경된 메인 진입 소요시간 case 3 (로컬)<br>
<img alt="Pasted image 20241107121939.png" src="사진-및-문서/pasted-image-20241107121939.png" style="width: 500px; max-width: 100%;" target="_self"><br>
0.232초
<br>
리로드 후 스크립트(상품 리스트)로드 시까지
<br>기존 투자하기 소요시간 case 1<br>
<img alt="Pasted image 20250227114750.png" src="사진-및-문서/pasted-image-20250227114750.png" target="_self"><br>
22.4초<br>
<img alt="Pasted image 20250227114826.png" src="사진-및-문서/pasted-image-20250227114826.png" target="_self">
<br>
<br>기존 투자하기 소요시간 case 2<br>
<img alt="Pasted image 20250227115004.png" src="사진-및-문서/pasted-image-20250227115004.png" target="_self"><br>
22.6초<br>
<img alt="Pasted image 20250227115015.png" src="사진-및-문서/pasted-image-20250227115015.png" target="_self">
<br>
<br>기존 투자하기 소요시간 case 3<br>
<img alt="Pasted image 20250227115158.png" src="사진-및-문서/pasted-image-20250227115158.png" target="_self"><br>
22.5초<br>
<img alt="Pasted image 20250227115148.png" src="사진-및-문서/pasted-image-20250227115148.png" target="_self">
<br>
<br>변경 투자하기 소요시간 case 1<br>
<img alt="Pasted image 20250227121009.png" src="사진-및-문서/pasted-image-20250227121009.png" style="width: 500px; max-width: 100%;" target="_self"><br>
0.373초
<br>
<br>변경 투자하기 소요시간 case 2<br>
<img alt="Pasted image 20250227121046.png" src="사진-및-문서/pasted-image-20250227121046.png" style="width: 500px; max-width: 100%;" target="_self"><br>
0.362초
<br>
<br>변경 투자하기 소요시간 case 3<br>
<img alt="Pasted image 20250227121942.png" src="사진-및-문서/pasted-image-20250227121942.png" style="width: 475px; max-width: 100%;" target="_self"><br>
0.360초
<br><img alt="Pasted image 20250227122010.png" src="사진-및-문서/pasted-image-20250227122010.png" target="_self"><br><img alt="Pasted image 20250227122736.png" src="사진-및-문서/pasted-image-20250227122736.png" target="_self"><br>
<br>aceat.js?advid=1954816599 - 에이스트레이더<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://cdn.nhnace.com/libs/aceat.js?advid=195481" target="_self">https://cdn.nhnace.com/libs/aceat.js?advid=195481</a>
<br>synchronizer.js - 네이버 관련 서버<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://ssl.pstatic.net/melona/libs/gfp-nac-module/synchronizer.js" target="_self">https://ssl.pstatic.net/melona/libs/gfp-nac-module/synchronizer.js</a>
<br>collect?en=page_view&amp;dr=localhost&amp;dl=http%... - 구글<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.google.com/ccm/collect" target="_self">https://www.google.com/ccm/collect</a>... - 구글
<br>869613409/?random=1740626824235&amp;cv=11&amp;f...<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.google.com/pagead/1p" target="_self">https://www.google.com/pagead/1p</a>...
<br>869613409/?random=1740626824235&amp;cv=11&amp;f... <br>869613409/?random=1110219531&amp;cv=11&amp;fst=... <br>
내부망 사용으로 인한 요청 실패, 중요 데이터 없음.
<br><img alt="output (14).png" src="사진-및-문서/output-(14).png" target="_self"><br>Main 페이지: 기존 21~23초 → 0.201~0.297초로 약 99% 속도 향상<br>
ProductList 페이지: 기존 22.4~22.6초 → 0.360~0.373초로 약 98% 속도 향상]]></description><link>issue_troubleshooting/⏰-script-로딩-지연-트러블-슈팅.html</link><guid isPermaLink="false">Issue_TroubleShooting/⏰ Script 로딩 지연 트러블 슈팅.md</guid><pubDate>Fri, 28 Feb 2025 09:04:36 GMT</pubDate><enclosure url="사진-및-문서/pasted-image-20241105110415.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="사진-및-문서/pasted-image-20241105110415.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🔒 투자하기 서비스 락(Lock)기법 개선안]]></title><description><![CDATA[<a class="tag" href="?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="?query=tag:Lock" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Lock</a> <a class="tag" href="?query=tag:DB" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#DB</a> <a class="tag" href="?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <a class="tag" href="?query=tag:동시성" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#동시성</a> <br> <a href=".?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href=".?query=tag:Lock" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Lock">#Lock</a> <a href=".?query=tag:DB" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#DB">#DB</a> <a href=".?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a> <a href=".?query=tag:동시성" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#동시성">#동시성</a><br>
<br>investView.html / 상품 선택 후 투자하기버튼 클릭
<br>custom.invest.js / kyc체크, 개인투자자 체크 -&gt; go-invest modal(investView.html)
<br>go-invest modal / 투자위험 동의체크, 유효성 체크 후 투자 실행 -&gt; InvestController
<br>InvestController / MP_INVEST investAction -&gt; investService.investAction
<br>investService.investAction / 투자신청기록, api상태체크 -&gt; SERVICE 프로젝트
<br>SERVICE 프로젝트 investmentsService.p2pCenterInvestmentRegister(투자신청기록)
<br>p2p(금결원) 투자신청기록 / 투자 유효성검사(시간 내 재투자, 금액체크) -&gt; p2p센터 투자잔액 조회(api)
<br>잔액조회 후 / 수익률,기간 업데이트 등등 .. 로직 처리 후 P2PCenter 투자신청 등록
<br>여기까지 정상 처리되면, async(비동기)로 자동기표처리
<br>
<br>
초기에는 동시에 치고들어오는 클라이언트가 굉장히 많았다. <br>
원활한 서비스를 제공과 데이터 정합성을 유지하기 위해 대기열 서비스가 아닌 락 기법을 사용. <br>
동시성 이슈를 대응해야할 곳. <br>모집금액과 동일 차주 투자 한도를 넘지 않게 상품의 동시성
<br>p2p투자한도와 예치금 한도를 넘지 않게 회원별 동시성<br>
이 두 가지의 동시성 문제를 해결해야한다. <br>
우리는 외부은행에 투자자,대출자 돈을 모두 맡겨두고 운영(신탁 운영)중이다.<br>
-&gt; 따라서, 외부 api를 굉장히 많이 사용한다.<br>
한도를 금결원 api를 통해 매번 체크 <br>
실제 돈이 빠져나가는 시점은, 모든 투자기록을 마친 후, 대출을 실행하는 시점에서 돈을 가져간다.<br>
-&gt; 만원만 있어도 여러 상품에 만원씩 여러번 투자가 가능하다. (문제 해결해야함)<br>
회원별 동시성 <br>
락을 잡아놓고(lock안에서의 서비스로직) api통신을 하는이유?<br>
동시성 이슈떄문 <br>
세마포어 뮤텍스 비관적락 등 여러 방법론이 있지만, 우리는 레디션으로 락을 구현하였다.<br>
-&gt; 그 이유는, k8s를 통해 여러 server를 띄워놓는 분산환경이기 때문. <br>
<br>비동기 작업 처리(예: 이메일 전송, 주문 처리, 로그 저장) → 대기열(Queue) 사용
<br>공유 데이터 동기화(예: 재고 감소, 은행 계좌 거래, 트랜잭션 처리) → 락(Lock) 사용
<br>분산 환경에서 높은 확장성이 필요할 경우 → 대기열이 유리
<br>데이터 정합성이 가장 중요한 경우 → 락이 유리
<br>
<br>분산환경에서 사용하기 용이함.
<br>우리의 서비스 프로젝트는 여러 서버로 이루어져있다.
<br>보통의 락기법은 하나의 로컬(서버)에서 구현이 이뤄지기 떄문에분산락기법 -&gt; 레디션 락기법을 사용하였다.
<br>왜냐? 우리는 쿠버네티스로 여러 서버(여러 서비스 서버)를 운영하기 때문이다.
<br>
<br>
만약의 락이 풀려버리면 데이터 정합성이 무너질 수 있다.<br>
-&gt; 락에 유효시간이 있기 떄문이다. 4초 <br>
투자시 순서를 반드시 보장하지 못한다. <br>왜 락이 풀리지?
lock으로 묶여있는 로직 안에 너무 많은 동작이 몰려있다.<br>
-&gt; 그때, 4초가 넘어 버리게 된다면, 락을 놓아버리고 동시성이 깨질 수 있는 가능성이 있다.
어쩨서?? <br>A, B에 대해 단일 투자자가 투자를 했을 때,<br>
A상품에 대한 투자를 완료처리하여 예치금 차감이 되지 않은 상태에서 락이 풀려버린다면?<br>
B상품에 대한 투자도 정상처리가 되어버린다. <br>-&gt; 큐 구조이긴 하나, 순차적으로 허가를 준다고 하여도 먼저 작업이 끝난 녀석부터 실행되기 때문에.<br>
<br>중앙기록관리기관(p2p)에서 해당 상품에 대한 단일 투자기록을 요구.<br>
즉, 하나라도 실패하면 실패한 투자건으로써 보낼수 밖에 없는 규정
<br>
<br>매 투자 건 별로 조회하는 개인별 투자한도를 redis로 관리하여, 투자건별 속도 개선
<br>
<br>상품을 미리 열어, 투자 금액 데이터를 쌓는 원리.
<br>해당 방법을 사용하면 데이터 정합성 및 경합을위한 락 사용 불필요
<br>주의 ! 투자 완료 후 실패 처리를 받을 가능성 존재<br>결론
현재 신탁 운영으로 인한 한도 데이터를 직접관리하지 못하는 문제와,<br>
보수적인 운영상의 방침으로 큰 구조 개선을 힘들어 보임
현재는 리펙토링을 통해 lock에 묶여있는 로직을 단순화 하는것에 만족해야겠음.]]></description><link>study/dev-seminar/🔒-투자하기-서비스-락(lock)기법-개선안.html</link><guid isPermaLink="false">study/Dev Seminar/🔒 투자하기 서비스 락(Lock)기법 개선안.md</guid><pubDate>Fri, 28 Feb 2025 09:01:27 GMT</pubDate></item><item><title><![CDATA[📔 DataBase]]></title><description><![CDATA[<a class="tag" href="?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="?query=tag:DB" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#DB</a> <a class="tag" href="?query=tag:DataBase" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#DataBase</a> <br> <a href=".?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href=".?query=tag:DB" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#DB">#DB</a> <a href=".?query=tag:DataBase" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#DataBase">#DataBase</a><br>
<br>간단히 설명하면 "여러 쿼리를 한번에 실행하는 것" 이다.
<br>SQL의 Function과 비슷해 보이지만 차이가 있다.<br>
function : 클라이언트에서 처리, 리턴값 필수, 리턴값은 한개만 반환 가능<br>
프로시저 : 서버로 보내서 처리, 리턴값 선택, 리컨값 여러개 가능
<br>속도면에서는 함수에 비해 프로시저가 더 빠르다.<br>
그렇기 때문에 프로시저같은 경우는 실행,처리를 할때 주로 사용하고, 함수는 간단한 계산이나 수치 결과를 나타낼 때 사용한다.<br>
<br>하나의 요청으로 여러 SQL문을 실행 할 수 있음
<br>네트워크 소요 시간을 줄일 수 있음(여러개의 쿼리를 처리하는 시점에서 네트워크 부하를 줄임)
<br>보수성이 뛰어나다
<br>개발 업무를 구분하여 개발할 수 있다.(DB관련 처리를 API처럼 만들어 사용가능)
<br>
<br>재사용성이 낮다(DB버전 별 구문/규칙과 호환성이 다르기 때문)
<br>처리 성능이 좋지 않다(MySQL스토어드 프로그램 처리 성능이 낮다)
<br><img alt="Pasted image 20240610171904.png" src="사진-및-문서/pasted-image-20240610171904.png" target="_self"><br>파라미터 선언은 프로시저명() 안에서 선언하고, SQL문과 변수는 BEGIN - END 안에서 작성한다.
<br>SELECT사용시 반드시, 조회한 컬럼의 값을 INTO로 변수 안에 넣어주어야 한다.
<br>프로시저안에서 사용하는 SQL문은 세미콜론(;)으로 문장 끝을 맺어주어야 한다.
<br>if, case, loop 문을 사용할 수 있다.
<br>프로시저내에서 다른 프로시저를 호출 할 수 있다.
<br>- 커넥션이란 어플리케이션과 데이터베이스 서버간의 통신 링크를 뜻한다. 애플리케이션이 쿼리를 실행하고, 데이터를 검색하고, 데이터베이스에서 트랜젝션을 수행 할 수 있는 세션을
설정하는데 사용된다.
말그대로 애플리케이션과 DB를 연결하는 통신링크이며, 이가 모여있는것을 커넥션 풀 이라고 한다.
매번 연결하고 끊고 하는것 보다 커넥션풀에 등록하는 것이 성능적인 향상을 기대할 수 있기 때문이다.
<br>
<br>테이블 간에 중복된 데이터를 허용하지 않는다는 기본 목표를 갖는다. <br>중복된 데이터를 허용하지 않음으로 써 무결성 을 유지할 수 있다.
<br>
<br>DB의 저장 용량 또한 줄일 수 있다.
<br>데이터 테이블을 분해하여 이상현상이 발생할 가능성을 줄이고, 확장/수정시 구조 변경을<br>
최소화 할 수 있다.
<br>
<br>
릴레이션의 분해로 인해 Join연산이 늘어날 수 있다. <br>
쿼리시 응답시간이 느려질 수 있다. 데이터의 중복속성을 최대한 제거하는 것 이기때문에, 속성이 하나의 테이블에 집약되므로<br>
데이터 용량이 최소화 되어 상황에따라 처리속도가 빨라질 수도 있고, 느려질 수도 있다.<br>
만약 조인이 만연하여 속도저하가 발생하게 된다면 반정규화를 통해 속도를 개선할 수 있다. <br>
<br>테이블의 컬럼이 원자값(하나의 값)을 갖도록 테이블을 분해하는 것이다.
<br>각 컬럼의 순서가 상관이 없어야한다.
<br>하나의 컬럼은 같은 종류의 타입을 가져야 한다.<br>
<img alt="Pasted image 20240531103441.png" src="사진-및-문서/pasted-image-20240531103441.png" target="_self"><br>
원자값을 갖도록 컬럼을 나눈다.<br>
<img alt="Pasted image 20240531103549.png" src="사진-및-문서/pasted-image-20240531103549.png" target="_self">
<br>
<br>제 1 정규화를 진행한 테이블에 대해 "완전 함수 종속"을 만족하도록 테이블을 분해하는 것이다.
<br>여기서 완전 함수 종속이란, 기본키의 부분집합이 결정자가 되어선 안된다는 것을 의미한다.<br>
즉, 부분적 종속을 없애는 것이다.
<br><img alt="Pasted image 20240531105228.png" src="사진-및-문서/pasted-image-20240531105228.png" target="_self"><br>
해당 테이블의 기본키는 (학생번호, 강좌이름)으로 복합키 이다.<br>
성적은 (학생번호, 강좌이름)인 기본키가 결정하지만,<br>
강의실은 기본키의 부분집합인 강좌이름이 결정하게 된다.<br>즉, 부분집합이 결정자가 되지 않도록 테이블을 분리시키는 것으로 완전 함수 종속을 만족시킬 수 있다.<br>
<img alt="Pasted image 20240531105241.png" src="사진-및-문서/pasted-image-20240531105241.png" target="_self"><br>
<br>제2 정규화를 진행한 테이블에 대해 "이행적 종속"을 없애도록 테이블을 분해하는 것이다.
<br>여기서 이행적 종속이란 A -&gt; B , B -&gt; C 가 성립할때, A -&gt; C 가 성립되는 것을 의미한다.<br>
<img alt="Pasted image 20240531104351.png" src="사진-및-문서/pasted-image-20240531104351.png" target="_self"><br>
다음의 경유 이행적 종속상태 로 말할 수 있다.
<br>그 경우 테이블을 분리하여 데이터 변경시에 다른 데이터까지 변경되는 상황을 막을 수 있다.<br>
<img alt="Pasted image 20240531104418.png" src="사진-및-문서/pasted-image-20240531104418.png" target="_self"><br>
<br>제3 정규화를 좀 더 강화한 것이라 생각하면 된다.
<br>BCNF정규화란 제3 정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록<br>
테이블을 분해하는 것을 말한다.
<br><img alt="Pasted image 20240531104751.png" src="사진-및-문서/pasted-image-20240531104751.png" target="_self"><br>
특수 수강 테이블에서 기본키는 (학생번호, 특강이름)이다. 그리고 기본키는 교수를 결정하고 있다.<br>
또한, 여기서 교수는 특강이름을 결정하고있다.<br>문제는 교수가 특강이름을 결정하는 결정자 이지만, 후보키가 아니다.<br>
그렇기 때문에 BCNF 정규화를 만족시키기 위해서는 테이블을 분해하여 아래와 같이 분리할 수 있다.<br><img alt="Pasted image 20240531104803.png" src="사진-및-문서/pasted-image-20240531104803.png" target="_self"><br>
<br>컬럼값의 중복을 제거하는것이다.
<br>
<br>중복을 제거하기 위해 분해할 수 있을만큼 최대한 분해하는 것이다.
<br> 그 이상 정규화를 진행하면 오히려 정규화의 단점이 더 커지기 때문이다.
<br>인덱스 : 단일데이터 단위인 도큐먼트(document)를 모아놓은 집합을 인덱스(index)라고 한다.<br>
색인 : 데이터를 Elasticsearch에 저장하는 행위<br>
샤드 : 인덱스는 기본적으로 샤드(shard)라는 단위로 분리되고, 각 노드에 분산되어 저장된다 (검색의 기본단위는 샤드이다.)<br>
<img alt="Pasted image 20240828104032.png" src="사진-및-문서/pasted-image-20240828104032.png" target="_self"><br>데이터를 범위나 카테고리로 나누어 관리하는 기법을 파티셔닝 이라고 한다.
<br>
<br>
인덱스를 생성할 때, 처음 생성된 샤드를 프라이머리 샤드, 복제본은 리플리카 라고 부른다. <br>
예를 들어 한 인덱스가 5개의 샤드로 구성되어있고, 클러스터가 4개의 노드로 구성되어있다고 가정하면,<br>
각각 5개의 프라이머리 샤드와 복제본, 총 10개의 샤드들이 전체 노드에 골고루 분산되어 저장된다.<br>
<img alt="Pasted image 20240828104728.png" src="사진-및-문서/pasted-image-20240828104728.png" target="_self"><br>
노드가 1개만 존재한다면 복제본은 생성되지 않는다. Elasticsearch는 아무리 작은 클러스터라도 최소 3개의 노드로 구성할 것을 권장하고 있다. <br>
이렇게 프라이머리 샤드와 리플리카를 통해 Elasticsearch는 운영 중에 노드가 유실되어도 데이터를 잃어버리지 않고, 데이터 가용성과 무결성을 보장하게 된다. <br>샤드는 여러 서버에 분산되어 병렬 및 병행으로 검색되므로, 인덱스가 같던 다르던 상관이 없다.
검색의 기본 단위는 샤드이기 때문이다. 따라서 인덱스를 나누는 것은 운영의 편의성을 고려할 때 선택하는 방법이다.
<br>전체색인을 할 경우 인덱스 1개가 7억건 이라면 색인이 모두 끝날때 까지 몇시간이 걸리게 된다.
그 와중에 데이터에 변경이 있게 된다면 전체 색인 후 일괄적용이 들어가게 될텐데, 대기시간이 길어질 수록 일괄적용 시간도 함께 늘어나게 된다.
결국 더 빠른 색인을 위해서는 하나의 인덱스를 여러개로 나누너 병행처리를 시키도록 해야한다. 다나와 에서는 상품DB특성상 카테고리군 별로 인덱스를 나누고 있다. 이때의 장점은 특정 카테고리만 검색할때 해당 인덱스만 검색하면 되므로, 검색 속도가 현저히 감소하게 된다.
<br>
<br>일반적인 시스템 로그와 같은 로그성 문서는 색인을 하고 나면 수정이 필요없는 정적 컨텐츠인 반면<br>
상품문서같은 경우 색인이 끝나도 계속 갱신되어야 하는 살아있는 동적 컨텐츠이다. 따라서 동적색인에 원할하고, 검색성능도 높은 설계를 요구한다.
<br>트렌젝션<br>
- 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위<br>트렌젝션매니저<br>
- Spring에서 제공하는 트렌젝션 관리 기능과 JPA를 연결하는 역할을 수행.<br>@Transactional<br>
- 클래스나 메서드에 삽입하면, AOP레벨(프록시를 사용하여)에서 트렌젝션매니저를 이용한 동작을 공통으로 적용.<br>앤티티매니저<br>
- 영속성 컨텍스트를 관리하는 인터페이스<br>
- 엔티티의 저장/수정/삭제/조회 작업을 수행<br>
- 스레드 세이프하지 않으므로 한트레젝션 내에서만 사용<br>
- 앤티티매니저펙토리는 스레드세이프하므로 공유 가능<br>영속성컨텍스트<br>
- JPA의 엔티티를 관리하는 1차 캐시 역할을 하는 메모리 공간<br>
- 엔티티와 DB데이터간의 상태 동기화를 책임<br>
- 1차캐싱 / 변경 감지 / 지연 로딩 의 특징을 갖는다<br>
- 지연로딩 : 관계된 엔티티를 실제로 필요할때만 가져오며, 변경점을 한번만 commit한다<br>스냅샷<br>
- DB스냅샷 :<br>
- 트렌젝션이 시작될때 생성된다.<br>
- 독립적인 데이터베이스 복사본으로, 원본데이터 변경과 무관하다.<br>
- 고급 격리 수준(REPEATABLE READ, SERIALIZABLE)에서 MVCC(Multi-Version Concurrency Control)를 구현할 때 사용한다.<br>
- 물리적인 복사본이 아닌, 논리적으로 매 쿼리마다 동적으로 가공이 되는 방식이다.<br>
- 앤티티매니저_스냅샷 :<br>
- 엔티티가 영속성 컨텍스트에 로드될 때 생성된다.<br>
- 엔티티의 초기 상태를 저장하여 변경 감지에 사용된다.]]></description><link>study/cs/📔-database.html</link><guid isPermaLink="false">study/CS/📔 DataBase.md</guid><pubDate>Fri, 28 Feb 2025 09:01:18 GMT</pubDate><enclosure url="사진-및-문서/pasted-image-20240610171904.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="사진-및-문서/pasted-image-20240610171904.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🏹 예치금 차액 비교 Spring Batch 리펙토링 부록]]></title><description><![CDATA[<a class="tag" href="?query=tag:프로젝트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로젝트</a> <a class="tag" href="?query=tag:개발" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#개발</a> <a class="tag" href="?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <a class="tag" href="?query=tag:Batch" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Batch</a> <a class="tag" href="?query=tag:Partitioning" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Partitioning</a> <a class="tag" href="?query=tag:Chunk" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Chunk</a> <br> <a href=".?query=tag:프로젝트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로젝트">#프로젝트</a> <a href=".?query=tag:개발" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#개발">#개발</a> <a href=".?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a> <a href=".?query=tag:Batch" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Batch">#Batch</a> <a href=".?query=tag:Partitioning" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Partitioning">#Partitioning</a> <a href=".?query=tag:Chunk" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Chunk">#Chunk</a><br>1 .GridSize: 4 ActiveConnections: 9/50 소요시간: 6 minutes 23.55<br>
2 .GridSize: 5 ActiveConnections: 11/50 소요시간: 4 minutes 55.57<br>
3 .GridSize: 6 ActiveConnections: 13/50 소요시간: 4 minutes 47.01<br>
4 .GridSize: 7 ActiveConnections: 15/50 소요시간: 3 minutes 47.76<br>
5 .GridSize: 8 ActiveConnections: 17/50 소요시간: 3 minutes 47.69<br>
6 .GridSize: 9 ActiveConnections: 19/50 소요시간: 3 minutes 59.85<br>
7 .GridSize: 10 ActiveConnections: 21/50 소요시간: 3 minutes 6.98<br>
8 .GridSize: 11 ActiveConnections: 23/50 소요시간: 3 minutes 0.52<br>
9 .GridSize: 12 ActiveConnections: 25/50 소요시간: 3 minutes 5.61<br>12월21일<br>
164컬럼<br>
10분 40.783<br>12월20일<br>
161컬럼<br>
10분 10.794<br>12월19일<br>
223컬럼<br>
14분 29.279초<br>12월18일<br>
181컬럼<br>
11분 09.660초<br>12월17일<br>
329컬럼<br>
19분 56.948초<br>
<br>12월14일<br>
220컬럼<br>
13분 28.209초<br>12월13일<br>
179컬럼<br>
10분 57.596초<br>12월12일<br>
236컬럼<br>
14분 30.033초<br>12월11일<br>
226컬럼<br>
14분 02.939초<br>12월21일<br>
startDate=2024-12-14 07:30:00:00&amp;endDate=2024-12-21 07:30:00<br>
388컬럼<br>
4분 43.53초<br>12월20일<br>
startDate=2024-12-13 07:30:00:00&amp;endDate=2024-12-20 07:30:00<br>
388컬럼<br>
4분 44.438초<br>12월19일<br>
startDate=2024-12-12 07:30:00:00&amp;endDate=2024-12-19 07:30:00<br>
387컬럼<br>
4분 41.215초<br>12월18일<br>
startDate=2024-12-11 07:30:00:00&amp;endDate=2024-12-18 07:30:00<br>
395컬럼<br>
4분 50.9초<br>12월17일<br>
startDate=2024-12-10 07:30:00:00&amp;endDate=2024-12-17 07:30:00<br>
407컬럼<br>
4분 55.686초<br>
<br>12월14일<br>
startDate=2024-12-07 07:30:00:00&amp;endDate=2024-12-14 07:30:00<br>
376컬럼<br>
4분 35.387초<br>12월13일<br>
startDate=2024-12-06 07:30:00:00&amp;endDate=2024-12-13 07:30:00<br>
384컬럼<br>
4분 43.642초<br>12월12일<br>
startDate=2024-12-05 07:30:00:00&amp;endDate=2024-12-12 07:30:00<br>
438컬럼<br>
4분 47.027초<br>12월11일<br>
startDate=2024-12-04 07:30:00:00&amp;endDate=2024-12-11 07:30:00<br>
437컬럼<br>
4분 54.308초<br>4일 7:30분-5일 7:30분
<br>5일 7:30분-6일 7:30분
<br>6일 7:30분-7일 7:30분
<br>7일 7:30분-8일 7:30분
<br>8일 7:30분-9일 7:30분
<br>9일 7:30분-10일 7:30분
<br>10일 7:30분-11일 7:30분
<br><img alt="output (9).png" src="사진-및-문서/output-(9).png" target="_self"><br>### 300테스트 1
## 범위 - 2016-09-28 ~ 2016-12-13
startDate=2016-09-28&amp;endDate=2016-12-13
## 컬럼 개수 - 289개
6분 22초 ### 300테스트 2
## 범위 - 2016-12-13 ~ 2017-01-16
startDate=2016-12-13&amp;endDate=2017-01-16
## 컬럼 개수 - 280개
5분 57초 ### 300테스트 3
## 범위 - 2017-01-11 ~ 2017-02-13
startDate=2017-01-11&amp;endDate=2017-02-13
## 컬럼 개수 - 286개
6분 23초 ### 300테스트 4
## 범위 - 2017-05-17 ~ 2017-06-01
startDate=2017-05-17&amp;endDate=2017-06-01
## 컬럼 개수 - 274개
5분 54초 ### 300테스트 5
## 범위 - 2017-11-07 ~ 2017-12-01
startDate=2017-11-07&amp;endDate=2017-12-01
## 컬럼 개수 - 292개
6분 32초 -------------------------------------------------- ### 1100테스트 1-1
## 범위 - 2018-02-11 ~ 2018-05-06
startDate=2018-02-11&amp;endDate=2018-05-06
## 컬럼 개수 - 1094개(예상)
22분 45초 ### 1100테스트 1-2
## 범위 - 2018-02-11 ~ 2018-05-06
startDate=2018-02-11&amp;endDate=2018-05-06
## 컬럼 개수 - 1094개(예상)
22분 34초
<br>
<br>현재 예치금 차액 배치의 서비스로직은, 각 파티션에서 실행되며,
<br>이렇게 실행된 코드는 parallelStream을 사용하여 내부적인 병렬처리를 진행한다.
<br>해당 로직의 특징은 cpu에 부하를 주는 계산식이 아닌, 단순 I/O (api호출 대기)의 소요시간이 크다.
<br>
<br>API 호출 작업 10,000건 처리
<br>각 호출 응답 시간 200ms
<br>
<br>기본 스레드 풀 크기: CPU 코어 수 - 1 (예: 7개의 코어)
<br>처리 시간 ≈ 작업&nbsp;개수/스레드&nbsp;수×응답&nbsp;시간\text{작업 개수} / \text{스레드 수} \times \text{응답 시간}작업&nbsp;개수/스레드&nbsp;수×응답&nbsp;시간
<br>≈10,000/7×200ms\approx 10,000 / 7 \times 200ms≈10,000/7×200ms
<br>≈286초\approx 286초≈286초
<br>
<br>스레드 풀 크기: 100
<br>처리 시간 ≈ 작업&nbsp;개수/스레드&nbsp;수×응답&nbsp;시간\text{작업 개수} / \text{스레드 수} \times \text{응답 시간}작업&nbsp;개수/스레드&nbsp;수×응답&nbsp;시간
<br>≈10,000/100×200ms\approx 10,000 / 100 \times 200ms≈10,000/100×200ms
<br>≈20초\approx 20초≈20초
<br>
<br>CPU 바운드 작업: <br>CPU를 많이 사용하는 작업(예: 복잡한 계산)이면, 코어 수 이상의 스레드를 실행할 경우 컨텍스트 스위칭(스레드 간 전환) 비용이 증가해 성능이 오히려 떨어질 수 있습니다.
<br>예: 7개의 코어로 100개의 CPU 작업 스레드를 처리하려 하면 병목이 발생. <br>I/O 바운드 작업(API 호출 포함): <br>네트워크 I/O 작업은 대기 시간이 길고, 대기 중에는 CPU를 거의 사용하지 않습니다.
<br>이 경우 스레드 수 &gt; 코어 수가 유리하며, 100개의 스레드를 실행해도 대부분의 스레드는 대기 상태에 있으므로 CPU 사용량이 낮습니다. <br>69961 ms<br>
70048 ms<br>
70396 ms<br>55180 ms<br>
55036 ms<br>
55285 ms<br>
55442 ms<br>71139 ms<br>
72220 ms<br>64473 ms<br>
65609 ms<br>미리 파티션 되어있는 데이터의 특성상 한번에 처리되는 양이 많지 않다.
<br>또한, stream().parallel()은 forkJoinPool에서 효율적으로 관리되며,
<br>데이터의 동기화 병목을 줄이고, 컨텍스트 전환 횟수를 줄여 더 효율적인 것으로 보임.
<br>사실 잘 모르겠음
<br>
<br>stream().parallel() 기능이 효율적이다.
<br>
<br>아마도 Where절이 추가되면서 reader의 속도가 크게 올라갓으며, 1번의 호출만을 하기 때문에 더 개선되었을것이다.
<br>chunk-size:20<br>
55969 ms<br>chunk-size:20<br>
54679 ms<br>
54416 ms<br>기존 : reader에서 넘어온녀석들의(옛날기준 날짜범위 내의 가장최신Point)차액 -&gt; 차액이있는녀석들의 (모든날짜 범위내의 최신 Point)의 차액<br>
현재 : reader에서 가져온녀석들의(모든날짜범위내의 최신 Point)의 차액<br>=&gt; 옛날기준 날짜범위 내의 가장최신포인트와 실시간 포인트는 다를 경우가 많음. 거기 내에<br>전날의 최신포인트 vs 현재 최신포인트(신한) -&gt; 여기엔 안걸리지만<br>
현재 최신포인트 vs 현재 최신포인트(신한) -&gt; 여기에는 걸리면 <br>
<br>로컬을 기준으로 잡아도, 운영 서버에서 어떠한 스레드 셋팅이 효과적일지 판단하기 힘듬.
<br>어떠한 방법을 사용해야 실제 운영 서버 반영 전, 테스트를 할 수 있을지?
<br>
<br>1차에서는 어제 범위 Point (서브쿼리도 메인 쿼리에서 .where()에 의해 이미 어제의 데이터로 필터링된 상태에서 작동)
<br>2차에서는 모든데이터 범위의 최신 Point <br>배치를 돌리는 현재날짜 0시 ~ 7시 사이에 입출금건이 있는 고객의 경우 1차에서 항상 걸릴 수 밖에 없음Point <br>1차에서 모두 검증하는 방법은 어떨지?]]></description><link>project/hello-batch/🏹-예치금-차액-비교-spring-batch-리펙토링-부록.html</link><guid isPermaLink="false">project/hello Batch/🏹 예치금 차액 비교 Spring Batch 리펙토링 부록.md</guid><pubDate>Fri, 28 Feb 2025 08:54:19 GMT</pubDate><enclosure url="사진-및-문서/output-(9).png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="사진-및-문서/output-(9).png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🍌 Elastic IP(탄력적 IP)란]]></title><description><![CDATA[<a class="tag" href="?query=tag:Tools" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Tools</a> <a class="tag" href="?query=tag:AWS" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#AWS</a> <a class="tag" href="?query=tag:Amazon" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Amazon</a> <a class="tag" href="?query=tag:Cloud" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Cloud</a> <a class="tag" href="?query=tag:EC2" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#EC2</a> <br> <a href=".?query=tag:Tools" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Tools">#Tools</a> <a href=".?query=tag:AWS" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#AWS">#AWS</a> <a href=".?query=tag:Amazon" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Amazon">#Amazon</a> <a href=".?query=tag:Cloud" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Cloud">#Cloud</a> <a href=".?query=tag:EC2" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#EC2">#EC2</a><br>
<br>EIP는 인터넷을 통해 접속할 수 있는 고정적인 IP주소를 할당하고, 인스턴스에 연결할 수 있는 서비스를 말한다.
<br>모든 인스턴스 또는 네트워크 인터페이스에 EIP 연결이 가능하다.
<br>EIP를 할당받고 삭제하기 전까지, 해당 EIP를 쭉 유지할 수 있다.
<br>정보
도메인과 IP주소를 연결할 떄, IP주소의 변동이 있어선 안되기 때문에, EIP를 사용한다.
<br>
<br>aws Ec2를 올리게 되면 ENI(Elastic network interface)가 함께 생성이된다. <br>ENI는 일종의 가상 랜카드 로써, MAC주소와 보안그룹에 연결되어있으며 IP도 갖고있다.<br>
여기서 ENI에 public IP를 달게 되면 외부에서 접속이 가능하게 되는것이다.
<br>하지만, EC2 인스턴스의 Public IP는 고정된 주소가 아니라 유동적인 IP이다.<br>만약 DNS에 인스턴스의 Public IP를 연결해놓았는데, 해당 IP주소가 변경된다면 문제가 발생할 수 있다.<br>
이러한 문제를 해결하고자 AWS에서 한 번 할당하면 바뀌지 않는 EIP를 제공하는 것이다.<br>주의
다만 AWS EIP(탄력적 IP)는 유료 서비스 임으로, 사용량에 따른 월 사용료를 지불해야 사용할 수 있다.<br>
free요금제 또한 마찬가지로 금액이 부과된다.]]></description><link>tools/aws/🍌-elastic-ip(탄력적-ip)란.html</link><guid isPermaLink="false">Tools/aws/🍌 Elastic IP(탄력적 IP)란.md</guid><pubDate>Thu, 27 Feb 2025 08:50:02 GMT</pubDate></item><item><title><![CDATA[🏫 강의]]></title><description><![CDATA[<a class="tag" href="?query=tag:강의" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#강의</a> <a class="tag" href="?query=tag:모음" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#모음</a> <a class="tag" href="?query=tag:lectur" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#lectur</a> <br> <a href=".?query=tag:강의" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#강의">#강의</a> <a href=".?query=tag:모음" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#모음">#모음</a> <a href=".?query=tag:lectur" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#lectur">#lectur</a><br>강의
강의를 수강하며, 정리한 내용 모음집 입니다.
<br>정보
inflearn - SpringCoreBasic.김영한 님의 강의 입니다.
<br> <br> <br> <br> <br>]]></description><link>lectur/🏫-강의.html</link><guid isPermaLink="false">lectur/🏫 강의.md</guid><pubDate>Wed, 26 Feb 2025 08:23:53 GMT</pubDate></item><item><title><![CDATA[⛈ Obsidian-AWS연동]]></title><description><![CDATA[<a class="tag" href="?query=tag:프로젝트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로젝트</a> <a class="tag" href="?query=tag:개발" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#개발</a> <a class="tag" href="?query=tag:Hosting" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Hosting</a> <a class="tag" href="?query=tag:Obsidian" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Obsidian</a> <a class="tag" href="?query=tag:CI/CD" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#CI/CD</a> <br> <a href=".?query=tag:프로젝트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로젝트">#프로젝트</a> <a href=".?query=tag:개발" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#개발">#개발</a> <a href=".?query=tag:Hosting" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Hosting">#Hosting</a> <a href=".?query=tag:Obsidian" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Obsidian">#Obsidian</a> <a href=".?query=tag:CI/CD" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#CI/CD">#CI/CD</a><br>추가예정.]]></description><link>project/note-ci_cd/⛈-obsidian-aws연동.html</link><guid isPermaLink="false">project/note CI_CD/⛈ Obsidian-AWS연동.md</guid><pubDate>Wed, 26 Feb 2025 08:20:17 GMT</pubDate></item><item><title><![CDATA[🥇 정보처리 기사 실기 SQL 문제]]></title><description><![CDATA[<a class="tag" href="?query=tag:정보처리기사" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정보처리기사</a> <a class="tag" href="?query=tag:실기" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#실기</a> <a class="tag" href="?query=tag:SQL" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SQL</a> <a class="tag" href="?query=tag:정리" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정리</a> <br> <a href=".?query=tag:정보처리기사" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정보처리기사">#정보처리기사</a> <a href=".?query=tag:실기" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#실기">#실기</a> <a href=".?query=tag:SQL" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SQL">#SQL</a> <a href=".?query=tag:정리" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정리">#정리</a><br>CREATE TABLE 부서 ( 부서코드 INT PRIMARY KEY, 부서명 VARCHAR(20)
); CREATE TABLE 직원 ( 직원코드 INT PRIMARY KEY, 부서코드 INT, 직원명 VARCHAR(20), FOREIGN KEY(부서코드) REFERENCES 부서(부서코드) ON DELETE CASCADE
); INSERT INTO 부서 VALUES(10, '영업부');
INSERT INTO 부서 VALUES(20, '기획부');
INSERT INTO 부서 VALUES(30, '개발부'); INSERT INTO 직원 VALUES(1001, 10, '이진수');
INSERT INTO 직원 VALUES(1002, 10, '곽명경');
INSERT INTO 직원 VALUES(1003, 20, '김건길');
INSERT INTO 직원 VALUES(1004, 20, '최민수');
INSERT INTO 직원 VALUES(1005, 20, '이용광');
INSERT INTO 직원 VALUES(1006, 30, '한성광');
INSERT INTO 직원 VALUES(1007, 30, '박미경');
<br>SELECT DISTINCT COUNT(부서코드) FROM 직원 WHERE 부서코드 = 20;
<br>결과: 3<br>해설 :<br>DISTINCT(중복 제거)는 부서코드가 아닌 COUNT(부서코드)에 적용되므로, 여전히 부서코드가 20인 컬럼의 수 '3'이 된다.
<br>DELETE FROM 부서 WHERE 부서코드 = 20;
SELECT DISTINCT COUNT(부서코드) FROM 직원;
<br>결과: 4<br>해설 :<br>부서코드가 20인 컬럼을 삭제한 후, 모든 직원테이블의 부서코드 개수를 센다. 이때 DISTINCT(중복 제거)는 COUNT에 적용되므로<br>
여전히 '4'이다.
<br>
<br>DEPT는 '학과'를 뜻한다
<br>가정: 전기과 학생 50명, 전자과 학생 100명, 전산과 학생 50명<br>SELECT DEPT FROM STUDENT;
<br>결과: 200<br>SELECT DISTINCT DEPT FROM STUDENT;
<br>결과: 3<br>해설 :<br>전기/전자/화학 3가지 종류로 이루어진 DEPT 속성의 중복을 제거하면 '3'이 남는다.
<br>SELECT COUNT(DISTINCT DEPT) FROM STUDENT WHERE DEPT = '전산과';
<br>결과: 1<br>해설 :<br>전산과인 학생들의 학과를 뽑는다. 이후 해당 학과의 중복을 제거하면 1개만 남게 된다.
<br>
<br>'H'제조사의 '단가' 보다 높은 '단가'를 가진 제품의 정보를 조회하는 SQL문이다.
<br>SELECT 제품명, 단가, 제조사
FROM 제품
WHERE 단가 &gt; ( ) (SELECT 단가 FROM 제품 WHERE 제조사 = 'H');
<br>답: ALL<br>해설 :<br>해당 쿼리는, where절의 하위 질의에 결과를 반영하여 본 질의의 조건에 추가하는 SQL이다.
<br>만약 서브쿼리에서 'H'제조사의 제품의 단다가 100/200/400 이 나왔다면,
<br>해당 단가들 보다 높은 단가를 찾기 위해서는 100/200/400을 모두 비교하여야 한다.
<br>따라서 ALL키워드가 들어간다면 모든 단가를 비교할 수 있다.
<br>서브쿼리 앞에 아무 키워드도 붙지 않는다면, 서브쿼리가 다중 행일때 오류를 발생시킨다.<br>
이때, ANY나 ALL 연산자를 사용하여 다중행을 비교할 수 있다.<br>ANY -&gt; 서브쿼리 결과 중 하나라도 참이면 해당 행은 참<br>
ALL -&gt; 서브쿼리 결과 중 모든 것에 참이어야 해당 행은 참<br>TABLE<br>SELECT COUNT(COL2)
FROM TABLE
WHERE COL1 IN (2, 3) OR COL2 IN (3, 5);
<br>결과: 3<br>해설 :<br>COL1 컬럼에 2나 3이 포함되었거나, COL2컬럼에 3이나 5가 포함된 컬럼 (4개)를 찾는다,
<br>
<br>여기서 NULL은 COUNT에 집계가 되지 않으므로 답은 '3'이다.
<br><img alt="Pasted image 20250225161448.png" src="사진-및-문서/pasted-image-20250225161448.png" target="_self"><br>결과 :<br>① TTL - ② 부장 - ③ 대리 - ④ 과장 - ⑤ 차장
<br>해설 :<br>해당 관계 대수식의 파이는 속성 리스트에 제시된 속성값만을 추출하여 새로운 릴레이션을 만드는 PROJECT연산이다
<br>따라서, TTL속성이 추출되어 속성명인 TTL부터 모든 속성값이 결과로 나타난다.<br>
= SELECT TTL FROM EMPLOYEE
<br>이 연산들은 관계형 데이터베이스의 데이터를 검색하고 변형하는 데 사용됩니다.<br>관계 대수에서 테이블을 하나의 집합(Set)으로 간주하고 수행하는 연산입니다.<br>(단, SQL문은 ISO/IEC 9075 표준을 기반으로 작성하시오.) <br>( 1 ) TABLE 학생 ( 2 ) 주소 VARCHAR(20);
<br>답 :<br>
1 -&gt; ALTER<br>
2 -&gt; ADD<br>해설 :<br>속성을 추가한다 -&gt; 테이블을 수정한다 -&gt; ALTER
<br>ALTER + ADD 속성 추가.
<br>
<br>3, 4학년의 학번, 이름을 조회한다.
<br>IN 예약어를 사용해야 한다.
<br>속성명 아래의 괄호는 속성의 자료형을 의미한다.
<br>정답 :<br>SELECT 학번, 이름 FROM 학생 WHERE 학년 IN (3, 4);
<br>해설 :<br>IN예약어는 WHERE절과 함께 쓰이며, WHERE 속성 IN (조건,조건,...) 방식으로 사용된다.
<br>해당 조건을 포함하고 있는 모든 속성이 선택되게 된다.
<br>student 테이블<br>정답 :<br>CREATE INDEX idx_name ON student(name);
<br>해설 :<br>인덱스 생성 문법 :<br>
CREATE INDEX 인덱스명 ON 테이블명(속성);
<br>(단, 아래의 실행 결과가 되도록 한다.)<br>
<br>
WHERE 조건절은 사용할 수 없다. <br>
GROUP BY는 반드시 포함한다. <br>
집계함수(Aggregation Function)를 적용한다. <br>
학과별튜플수 컬럼명을 출력에 Alias(AS)를 활용한다. <br>
문장 끝의 세미콜론(;)은 생략해도 무방하다. <br>
인용부호 사용이 필요한 경우 단일 따옴표(' ')를 사용한다.
정답 : <br>SELECT 학과, COUNT(*) AS 학과별튜플수
FROM 학생
GROUP BY 학과;
<br>&lt;처리 조건&gt;을 참고하여 적합한 SQL문을 작성하시오.<br>
<br>WHERE문은 사용하지 않는다.
<br>GROUP BY와 HAVING을 이용한다.
<br>집계함수(Aggregation Function)를 사용하여 명령문을 구성한다.
<br>최소점수, 최대점수는 별칭(Alias)을 위한 AS문을 이용한다.
<br>명령문 마지막의 세미콜론(;)은 생략 가능하다.
<br>인용 부호가 필요한 경우 작은따옴표(')를 사용한다.
<br>정답 :<br>SELECT 과목이름, MIN(점수) AS 최소점수, MAX(점수) AS 최대점수 FROM 성적 GROUP BY 과목이름 HAVING AVG(점수) &gt;= 90;
<br>해설 :<br>과목이름별로 여러 점수의 통계를 내는것 이기 때문에, GROUP BY 과목이름을 사용한다.
<br>이때, GROUP BY ~ HAVING 조건 을 사용하여, 해당 그릅화된 데이터 중 다음 조건을 만족하는 그룹만 포함한다.
<br>SELECT COUNT(*) CNT FROM A CROSS JOIN B WHERE A.NAME LIKE B.RULE;
<br>답 : 4<br>해설 :<br>SELECT COUNT(*) CNT 에서 CNT는 as CNT 가 생략된 형태이다.
<br>CROSS JOIN이란 카디션 프로덕트(곱)을 수행하는 조인방식으로써,<br>
A테이블의 모든 행과, B테이블의 모든 행의 모든 가능한 조합을 구한다.
<br>따라서, 저 중 a.name컬럼이 b.rule을 따르는(like 연산을 했을 때, 참인 결과는)<br>총 4개이다.<br>]]></description><link>study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-sql-문제.html</link><guid isPermaLink="false">study/정보처리기사/정보처리기사 실기/🥇 정보처리 기사 실기 SQL 문제.md</guid><pubDate>Wed, 26 Feb 2025 06:33:42 GMT</pubDate><enclosure url="사진-및-문서/pasted-image-20250225161448.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="사진-및-문서/pasted-image-20250225161448.png"&gt;&lt;/figure&gt;</content:encoded></item></channel></rss>