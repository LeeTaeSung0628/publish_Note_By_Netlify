<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[taesunglog]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib/media/favicon.png</url><title>taesunglog</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Tue, 04 Mar 2025 09:01:56 GMT</lastBuildDate><atom:link href="lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Tue, 04 Mar 2025 09:01:46 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[like 절 <em>OR</em> vs <em>IN</em> 추가예정]]></title><description><![CDATA[<br>]]></description><link>issue_troubleshooting/⚔-간단한-stckoverflow-원인분석(query).html</link><guid isPermaLink="false">Issue_TroubleShooting/⚔ 간단한 StckOverflow 원인분석(Query).md</guid><pubDate>Tue, 04 Mar 2025 09:01:24 GMT</pubDate></item><item><title><![CDATA[🔐 Lock이란 무엇인가. 헬로 서비스 이슈]]></title><description><![CDATA[<a class="tag" href="?query=tag:SQL" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SQL</a> <a class="tag" href="?query=tag:Lock" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Lock</a> <a class="tag" href="?query=tag:개선" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#개선</a> <a class="tag" href="?query=tag:이슈" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#이슈</a> <br> <a href=".?query=tag:SQL" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SQL">#SQL</a> <a href=".?query=tag:Lock" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Lock">#Lock</a> <a href=".?query=tag:개선" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#개선">#개선</a> <a href=".?query=tag:이슈" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#이슈">#이슈</a><br>
<br>
만약의 락이 풀려버리면 데이터 정합성이 무너질 수 있다.<br>
-&gt; 락에 유효시간이 있기 떄문이다. 4초 <br>
투자시 순서를 반드시 보장하지 못한다. <br>왜 락이 풀리지?
lock으로 묶여있는 로직 안에 너무 많은 동작이 몰려있다.<br>
-&gt; 그때, 4초가 넘어 버리게 된다면, 락을 놓아버리고 동시성이 깨질 수 있는 가능성이 있다.
어쩨서?? <br>A, B에 대해 단일 투자자가 투자를 했을 때,<br>
A상품에 대한 투자를 완료처리하여 예치금 차감이 되지 않은 상태에서 락이 풀려버린다면?<br>
B상품에 대한 투자도 정상처리가 되어버린다. <br>-&gt; 큐 구조이긴 하나, 순차적으로 허가를 준다고 하여도 먼저 작업이 끝난 녀석부터 실행되기 때문에.<br>
<br>중앙기록관리기관(p2p)에서 해당 상품에 대한 단일 투자기록을 요구.<br>
즉, 하나라도 실패하면 실패한 투자건으로써 보낼수 밖에 없는 규정
<br>
<br>매 투자 건 별로 조회하는 개인별 투자한도를 redis로 관리하여, 투자건별 속도 개선
<br>
<br>상품을 미리 열어, 투자 금액 데이터를 쌓는 원리.
<br>해당 방법을 사용하면 데이터 정합성 및 경합을위한 락 사용 불필요
<br>주의 ! 투자 완료 후 실패 처리를 받을 가능성 존재<br>결론
현재 신탁 운영으로 인한 한도 데이터를 직접관리하지 못하는 문제와,<br>
보수적인 운영상의 방침으로 큰 구조 개선을 힘들어 보임
현재는 리펙토링을 통해 lock에 묶여있는 로직을 단순화 하는것에 만족해야겠음.]]></description><link>issue_troubleshooting/🔐-lock이란-무엇인가.-헬로-서비스-이슈.html</link><guid isPermaLink="false">Issue_TroubleShooting/🔐 Lock이란 무엇인가. 헬로 서비스 이슈.md</guid><pubDate>Tue, 04 Mar 2025 08:39:45 GMT</pubDate></item><item><title><![CDATA[🏹 예치금 차액 비교 Spring Batch 리펙토링]]></title><description><![CDATA[<a class="tag" href="?query=tag:프로젝트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로젝트</a> <a class="tag" href="?query=tag:개발" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#개발</a> <a class="tag" href="?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <a class="tag" href="?query=tag:Batch" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Batch</a> <a class="tag" href="?query=tag:Partitioning" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Partitioning</a> <a class="tag" href="?query=tag:Chunk" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Chunk</a> <a class="tag" href="?query=tag:성능개선" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#성능개선</a> <br> <a href=".?query=tag:프로젝트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로젝트">#프로젝트</a> <a href=".?query=tag:개발" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#개발">#개발</a> <a href=".?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a> <a href=".?query=tag:Batch" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Batch">#Batch</a> <a href=".?query=tag:Partitioning" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Partitioning">#Partitioning</a> <a href=".?query=tag:Chunk" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Chunk">#Chunk</a> <a href=".?query=tag:성능개선" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#성능개선">#성능개선</a> <br>기존 예치금 차액비교 Batch의 Tasklet방식의 배치의 단점을 보완하는 chunk 방식의 배치를 구현하고,<br>
나아가 다른 기능의 Batch에도 효과적으로 빠르게 적용할 수 있는재사용성/유지보수성 높은 코드, 선례를 만들기 위함이다.<br>
<br>Chunk, Partioning방식을 Job을 추가 개발 (기존 balanceJob 유지)
<br>당분간 두 Job을 병행하면서 비교
<br>추가한 Job 기능에 문제없다면 기존 balanceJob 삭제
<br><img alt="회사 은행 서비스1111.png" src="사진-및-문서/회사-은행-서비스1111.png" target="_self"><br>
<img alt="Spring Batch Tasklet 예치금 잔액 비교 1.png" src="사진-및-문서/spring-batch-tasklet-예치금-잔액-비교-1.png" target="_self"><br>
<img alt="Spring Batch Tasklet 예치금 잔액 비교 잘못된 차액발생 인식 타임라인.png" src="사진-및-문서/spring-batch-tasklet-예치금-잔액-비교-잘못된-차액발생-인식-타임라인.png" target="_self"><br>
<br>평균 소요시간: 약 17.35분
<br>최대 소요시간: 22분
<br>최소 소요시간: 12분<br>
<img alt="output (1).png" src="사진-및-문서/output-(1).png" target="_self">
<br>
<br>처음 가져온 Point 배치 완료시 까지 계속 물고있다. -&gt; 한 트렌젝션의 범위가 넓다.
<br>정보 <br>병목이 있진 않으나, 한 배치서비스의 트렌젝션에서 외부 api의 값 변동을 반영하지 못함. <br>
<br>G5-Point 등은 처음 7시 시점에 묶여있다. 회원별로 실데이터를 건건이 api(신한)를 호출하여 비교한다. 때문에, 7시 이후에 수정된데이터를 실시간으로 반영하지 못한다.
<br>
<br>목적 : batch의 step 레벨에서의 스레드 분리 ( 병렬처리 )
<br>
<br>독립적인 ExecutionContext가 주어져 상태를 안전하게 관리할 수 있다.
<br>
<br>목적 : 각 step내의 트렌젝션 단위 분리
<br>Reader / Processor / writer 가 역할을 분담
<br>
<br>
Partition 생성: <br>Partition 1 : ID 1 ~ 25 / 대기열1 : ID 101 ~ 125 / 대기열2 : ID 201 ~ 225
<br>Partition 2 : ID 26 ~ 50 / 대기열 : ID 126 ~ 150 / 대기열2 : ID 226 ~ 250
<br>Partition 3 : ID 51 ~ 75 / 대기열 : ID 151 ~ 175 / 대기열2 : -
<br>Partition 4 : ID 76 ~ 100 / 대기열 : ID 176 ~ 200 / 대기열2 : - <br>
각 Partition에서 Chunk 처리: <br>Partition 1: <br>Chunk 1: ID 1 ~ 10 → 커밋
<br>Chunk 2: ID 11 ~ 20 → 커밋
<br>Chunk 3: ID 21 ~ 25 → 커밋 <br>Partition 2: <br>Chunk 1: ID 26 ~ 35 → 커밋
<br>Chunk 2: ID 36 ~ 45 → 커밋
<br>Chunk 3: ID 46 ~ 50 → 커밋 <br>나머지 Partition도 동일 방식으로 처리. <br>
병렬 실행: <br>스레드 풀 크기 = 4이므로 4개의 Partition이 동시에 실행됩니다.
<br>Partition 처리 순서는 스레드 풀에서 처리되는 순서에 따라 다를 수 있음. <br>
트랜잭션 관리: <br>각 Partition은 독립적인 트랜잭션을 가짐.
<br>각 Chunk가 커밋될 때마다 트랜잭션이 종료됨. <br>
<br>
Partition 생성: <br>Partition 1 : ID 1 ~ 25 / 대기열1 : ID 101 ~ 125 / 대기열2 : ID 201 ~ 225
<br>Partition 2 : ID 26 ~ 50 / 대기열 : ID 126 ~ 150 / 대기열2 : ID 226 ~ 250
<br>Partition 3 : ID 51 ~ 75 / 대기열 : ID 151 ~ 175 / 대기열2 : ID 251 ~ 275
<br>Partition 4 : ID 76 ~ 100 / 대기열 : ID 176 ~ 200 / 대기열2 : ID 276 ~ 300
<br>추가 스레드 풀 생성
<br>Partition 5 : ID 300 ~ 325 / 대기열 : ID 326 ~ 350 / 대기열2 : ID 351 ~ 375
<br>추가 스레드 풀 생성
<br>Partition 6 : ID 376 ~ 400 / 대기열 : ID 401 ~ 425 / 대기열2 : ID 426 ~ 450 모든 대기열 소모 및 최대 스레드 풀 도달 =&gt; 작업 중단 및 오류 <br>-&gt; 이로볼때, 쿼리작업보다 api호출작업의 소요시간이 길어보임<br>범위 - 2017-11-07 ~ 2017-12-01
startDate=2017-11-07&amp;endDate=2017-12-01 ## 컬럼 개수 - 292개 기존 병렬처리 : 1분 7초
기존로직 : 6분 32초 t:스레드 개수 / c:각 스레드별 청크 파티션 수 ###### SimpleAsyncTaskExecutor vs ThreadPoolTaskExecutor SimpleAsyncTaskExecutor
g4/c10 : 1분 41.586초
g5/c10 : 1분 30.037초
g5/c3 : 1분 28.997초
g5/c1 : 1분 29.931초
g8/c10 : 1분 36.019초
g10/c1 : 1분 24.529초 - ThreadPoolTaskExecutor
Th min/maxSize64, g64/c10 : 1분 42.848초
Th min/maxSize32, g32/c10 : 1분 26.551초 Th min/maxSize16, g16/c10 : 1분 46.753초 / 1분 33.779초 / 2분 25.759초
1분 11.668초 / 2분 5.773초 / 2분 39.553초 Th min/maxSize32, g8/c20 : 3분 25.743초 Th min/maxSize16, g4/c10 : 2분 29.207초 / 2분 8.004초
<br>
<br>Grid사이즈(파티셔닝 갯수) 만큼 스레드 풀 계속 생성
<br>파티셔닝 갯수가 많아졌을 때, 스레드 생성/소멸에 드는 오버헤드 증가
<br>
<br>최소 스레드풀 개수 / 최대 스레드풀 개수 / 대기열 큐 크기 / 유휴 시간 모두 설정가능
<br>파티셔닝 갯수가 많을 경우, 처리 성능에 맞는 스레드 풀에서 대기작업으로 처리하여 오버헤드 감소
<br>
<br>총 처리량 기준 1/n로 각 스레드에 할당시 충분히 감당한 양으로, 대기열을 사용할 필요가 없다.
<br>
<br>쿼리 호출 및 페이징 기법 직접 구현
<br>
<br>Native Query 형태로 호출하여 자동 페이징
<br>
<br>Spring Batch에서는 공식적으로 지원하지 않음
<br>자동 페이징
<br>Querydsl형태로 쿼리 호출 가능
<br>
<br>기존(헬로)의 Querydsl기반 JPAQuery를 그대로 사용 가능
<br>자동 페이징
<br>그 외 Querydsl의 장점 보유
<br>
<br>기존 PagingItemReader의 메서드를 오버라이딩 하여 사용하며,<br>
JPQL이 수행되던 부분에 코드를 수정하였다.
<br>@Bean @Scope(value = "step", proxyMode = ScopedProxyMode.TARGET_CLASS) public QuerydslPagingItemReader&lt;HfbatBankBalanceCheckDto&gt; balanceReader() { ExecutionContext jobContext = Objects.requireNonNull(StepSynchronizationManager.getContext()).getStepExecution().getJobExecution().getExecutionContext(); Date startDate = (Date) jobContext.get(START_DATE_KEY); Date endDate = (Date) jobContext.get(END_DATE_KEY); return new QuerydslPagingItemReader&lt;&gt;( entityManagerFactory, executionOrder, DEFAULT_CHUNK_SIZE, queryFactory -&gt; repository.newFindChangeBalanceMemberList( startDate, endDate )); }
<br>
<br>각 파티션 스레드 별 종료 시간이 크게 상이하다. 총 소요시간 기준 최대 약 20% 차이
<br>적용 한다면, 각 스레드 별로 even하게 작업을 수행하여 총 소요시간을 줄일 수 있을것이라 판단 <br>JOB private static AtomicLong executionOrder = new AtomicLong(0); ... new QuerydslPagingItemReader&lt;&gt;( entityManagerFactory, executionOrder, DEFAULT_CHUNK_SIZE, queryFactory -&gt; repository.newFindChangeBalanceMemberList( startDate, endDate ));
<br>job 레벨에서의 스레드 세이프한 전역 변수를 생성하였다.
<br>그 후, 각 파티션 별 리더에 인자값으로 넘긴다.
<br>long currentExecutionOrder = executionOrder.getAndIncrement(); long startIndex = (currentExecutionOrder) * getPageSize(); int totalRecords = stepContext.getInt("totalRecords"); if (startIndex &gt;= totalRecords) { initResults(); // 빈 결과로 초기화 tx.commit(); return; } int chunkSizeToRead = Math.min(getPageSize(), (int) (totalRecords - startIndex)); // 남은 데이터 크기만큼 읽기 // QueryDSL Query 생성 JPQLQuery&lt;T&gt; query = createQuery() .offset(startIndex) .limit(chunkSizeToRead);
<br>
<br>먼저 한 청크단위의 작업을 끝낸 파티션은 그 다음 작업을 즉시 할당받게 된다.
<br>즉, 총 처리시간 기준 가장 빨리끝난 파티션과 가장 늦게 끝난 파티션의 실행 시간 차이는 최대 한 청크사이즈를 처리하는 시간보다 크지 않게 된다.
<br>1차 비교 이후 차액이 발생한 녀석들의 List 를 한번 더 검증한 후, =&gt; 추후 변경 됨<br>
검증된 녀석들을 <br>List&lt;BalanceCheckResultDto&gt; realDiffList= new ArrayList&lt;&gt;();
<br>최종적인 차액 리스트에 넣는다.<br>writer는 각 프로세서의 리턴으로 받은 녀석들을 하나의 DTO List로 합쳐 메세징 처리를 하게 된다.<br>
<br>유지보수성이 좋다.
<br>환경셋팅에 리소스가 많이든다. <br>
<br>구현 레벨이 가장 쉽다
<br>DTO(데이터)가 많아질 경우, 큰 리소스를 차지한다.
<br>
<br>방법 2.보다는 리소스가 적지만, 문자열 처리 시간이 추가로 소모된다.
<br>
<br>높은 쓰기 성능을 갖고있다.
<br>동시성 문제 없이 다중 스레드에서 사용 가능하다.
<br>인덱스로 접근이 불가능하다.
<br>QueueManager클래스를 생성하며 공통으로 사용 가능하도록 하였고,<br>@Slf4j public class QueueManager&lt;T&gt; { protected final ConcurrentLinkedQueue&lt;T&gt; sharedQueue = new ConcurrentLinkedQueue&lt;&gt;(); // 데이터 추가 public void addItemToSharedQueue(T item) { if (item != null) { sharedQueue.add(item); } }
<br>이를 상속받아 특정 오브젝트를 넘길 수 있도록 하였다.<br>public class BalanceQueue extends QueueManager&lt;BalanceCheckResultDto&gt;{ public List&lt;BalanceCheckResultDto&gt; getDtoFromQueue() { return super.getItemsFromQueue(); } }
<br>이게 무슨소리인지? <br>보통의 Batch 서비스라면 I/O 작업에 부하가 걸려있겠지만, 현재 예치금 차액 배치는 processor 즉, 예치금 비교 연산에서 큰 리소스를 소모하고있다.
<br>이에 해당하는 시간 소모를 줄이기 위해 processor(서비스로직) 을 병렬처리 함으로 최종 처리시간 단축을 꾀할 수 있을지에 대한 고민이다.
<br>이후 설명하겠지만, 내부 병렬처리 로직은 청크의 트렌젝션을 무너뜨릴 가능성이 크므로 지양해야함. <br><img alt="Pasted image 20241206113120.png" src="사진-및-문서/pasted-image-20241206113120.png" target="_self"><br>소요시간 : 1분 9초
<br>-&gt; 기존 limit절을 이용한 로직보다 속도가 더빠르며,<br>
JpaPagingReader를 적용한다면 중복 select횟수를 줄여 더 빨라질 것으로 예상된다.<br>결론 : 둘 중 하나<br>#### 292 컬럼
## Processor 삭제(병렬처리)로직
#### grid-size:6 / chunk-size:20
54679 ms
54416 ms
## Processor 순차처리(writer만 병렬처리) 로직 #### grid-size:6 / chunk-size:20
60440 ms
62271 ms
#### grid-size:10 / chunk-size:20
58129 ms
56723 ms
#### grid-size:16 / chunk-size:20
58595 ms
56314 ms #### grid-size:32 / chunk-size:20
- SQLTransientConnectionException
- 스레드풀 점유갯수 초과
<br>하지만, 이후 청크 방식 Batch의 확장성과 유지보수성을 고려하여 리더,프로세서,라이터 방식으로 구현하기로 정했다.<br><img alt="Pasted image 20241217150339.png" src="사진-및-문서/pasted-image-20241217150339.png" target="_self"><br>리스너에 너무 많은 역할이 부여된 모습
<br><img alt="Pasted image 20241219145746.png" src="사진-및-문서/pasted-image-20241219145746.png" target="_self"><br>
<br>StepExecution-Level ExecutionContext <br>
각 Step에 고유한 ExecutionContext가 생성됩니다. <br>
Step 내의 Reader, Processor, Writer 등에서 공유됩니다. <br>
다른 Step과는 공유되지 않습니다. <br>
balanceWorkerStep 내에서는 Reader, Processor, Writer가 동일한 ExecutionContext를 공유합니다. <br>
balancePartitionStep과 balanceWorkerStep의 ExecutionContext는 서로 독립적입니다. <br>JobExecution-Level ExecutionContext <br>Job 전체에서 공유되며, 모든 Step이 동일한 ExecutionContext에 접근할 수 있습니다.
<br>JobExecutionContext는 Step 간 데이터 전달이 필요할 때 유용합니다. <br>JobExecutionListener 객체 생성<br>@Slf4j public class JobTimerExecutionListener implements JobExecutionListener { private final String jobName; private long startTime = System.currentTimeMillis(); public JobTimerExecutionListener(String jobName) { this.jobName = jobName; } @Override public void beforeJob(JobExecution var1) { startTime = System.currentTimeMillis(); } @Override public void afterJob(JobExecution var1) { long endTime = System.currentTimeMillis(); long elapsedTime = endTime - startTime; long minutes = (elapsedTime / 1000) / 60; // 밀리초를 분으로 변환 double seconds = (elapsedTime / 1000.0) % 60; // 남은 밀리초를 초로 변환 (소수점 포함) log.info("{}-completed: {} ms | {} minutes {} seconds", jobName, elapsedTime, minutes, seconds); } }
<br><img alt="output (9) 1.png" src="사진-및-문서/output-(9)-1.png" target="_self"><br><img alt="output (10).png" src="사진-및-문서/output-(10).png" target="_self"><br><img alt="do-messenger_screenshot_2024-12-23_14_40_21.png" src="사진-및-문서/do-messenger_screenshot_2024-12-23_14_40_21.png" target="_self"><br><img alt="Pasted image 20241224093159.png" src="사진-및-문서/pasted-image-20241224093159.png" target="_self"><br>
<img alt="Pasted image 20241224093207.png" src="사진-및-문서/pasted-image-20241224093207.png" target="_self"><br>
<img alt="Pasted image 20241224093225.png" src="사진-및-문서/pasted-image-20241224093225.png" target="_self"><br><a data-href="🚦 Spring Batch(스레드와 트렌젝션) 트러블슈팅" href="issue_troubleshooting/🚦-spring-batch(스레드와-트렌젝션)-트러블슈팅.html" class="internal-link" target="_self" rel="noopener nofollow">🚦 Spring Batch(스레드와 트렌젝션) 트러블슈팅</a><br>🙇‍♂<a data-href="🏹 예치금 차액 비교 Spring Batch 리펙토링 부록" href="project/hello-batch/🏹-예치금-차액-비교-spring-batch-리펙토링-부록.html" class="internal-link" target="_self" rel="noopener nofollow">🏹 예치금 차액 비교 Spring Batch 리펙토링 부록</a>]]></description><link>project/hello-batch/🏹-예치금-차액-비교-spring-batch-리펙토링.html</link><guid isPermaLink="false">project/hello Batch/🏹 예치금 차액 비교 Spring Batch 리펙토링.md</guid><pubDate>Tue, 04 Mar 2025 08:37:29 GMT</pubDate><enclosure url="사진-및-문서/회사-은행-서비스1111.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="사진-및-문서/회사-은행-서비스1111.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🚦 Spring Batch(스레드와 트렌젝션) 트러블슈팅]]></title><description><![CDATA[<a class="tag" href="?query=tag:트러블슈팅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#트러블슈팅</a> <a class="tag" href="?query=tag:EntityManager" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#EntityManager</a> <a class="tag" href="?query=tag:Transaction" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Transaction</a> <a class="tag" href="?query=tag:트렌젝션" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#트렌젝션</a> <br> <a href=".?query=tag:트러블슈팅" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#트러블슈팅">#트러블슈팅</a> <a href=".?query=tag:EntityManager" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#EntityManager">#EntityManager</a> <a href=".?query=tag:Transaction" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Transaction">#Transaction</a> <a href=".?query=tag:트렌젝션" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#트렌젝션">#트렌젝션</a><br>청크사이즈가 다름에도 처리속도가 똑같은 이유가 뭘까?<br>** Chunk 방식의 Batch에서 ChunkSize란, 한 트렌젝션 내에서 처리할 컬럼(DTO/모델)의 개수이다.<br>즉, ChunkSize가 작을수록 데이터 I/O작업 및 Overhead(데이터 읽기/쓰기, 트랜잭션 시작 및 종료 등)가 증가하여 총 실행시간이 길어져야한다.<br>청크 사이즈별 실행시간 측정 데이터
<br>grid-size:12 / chunk-size:30
-
3분 22.856초
3분 23.096초 grid-size:12 / chunk-size:20
-
3분 23.546초
3분 23.784초 grid-size:12 / chunk-size:10
-
3분 24.243초
3분 22.389초
3분 24.667초
3분 24.789초 grid-size:12 / chunk-size:5
-
3분 24.953초
3분 24.353초
<br>
<br>배치 서비스 로직의 일부
<br>dtoList.stream().parallel() .forEach(dto -&gt; {});
<br>스레드 확인
<br>} } IntStream.range(1, 10) .parallel() .forEach(i -&gt; System.out.println(Thread.currentThread().getName() + " - " + i)); }
} - 출력
ForkJoinPool.commonPool-worker-3 - 3
ForkJoinPool.commonPool-worker-1 - 1
ForkJoinPool.commonPool-worker-2 - 2
ForkJoinPool.commonPool-worker-0 - 4
... <br>
<br>별도의 셋팅이 없이 parallel() 구문을 사용하여 병렬 처리를 진행한다면,<br>
1.데이터를 작은 단위(Chunk)로 분할<br>
- 예를 들어, 1000개의 데이터를 4개의 스레드에서 처리한다고 하면, ForkJoinPool은 데이터를 여러 개의 Task로 나눈다.<br>
2.Worker Thread들이 분할된 작업을 병렬로 실행<br>
- 각 스레드는 자신이 맡은 작업을 처리하고, 남는 작업이 있다면 다른 스레드의 작업을 훔쳐(Work-Stealing) 가져와 실행한다.<br>
3.최종적으로 결과를 합쳐서 반환<br>
- 모든 작업이 완료되면 병렬 처리된 결과가 하나로 합쳐진다<br>
- ForkJoinPool이란?
Java에서 제공하는 병렬 작업을 최적화하는 스레드 풀로써,<br>
Work-Stealing 알고리즘을 사용하여 유휴스레드를 최소화하고 CPU 활용도를 극대화하는 기법이다. <br>해당 과정에서 ForkJoinPool은 작업을 여러 개의 워커 스레드(ForkJoinPool-worker-*)에서 실행하기 때문에 Spring의 ThreadLocal 기반 트랜잭션이 전파되지 않는다.<br>
<br>청크의 내부 서비스로직에서의 동작 효율을 위해 병렬처리를 사용했으나, ForkJoinPool기반의 정확한 동작원리를 충분히 고려하지 않아 발생한 이슈이다.
<br>해당 부분은 일반적인 forEach문으로 변경함으로써 이슈를 해결할 수 있었다.
<br>특히, 멀티스레드를 다룰 때에는 병렬처리를 함에 있어 주의를 필요로 함을 깨달았다.<br>반복 TEST 중.. 커넥션풀 Time Out 문제??<br><img alt="Pasted image 20241213102128.png" src="사진-및-문서/pasted-image-20241213102128.png" target="_self"><br>SHOW VARIABLES LIKE 'max_connections'; //최대 개수
SHOW STATUS LIKE 'Threads_connected'; //사용중인 개수
<br><img alt="Pasted image 20250304170347.png" src="사진-및-문서/pasted-image-20250304170347.png" target="_self"><br>
<img alt="Pasted image 20250304170412.png" src="사진-및-문서/pasted-image-20250304170412.png" target="_self"><br>
<img alt="Pasted image 20250304171240.png" src="사진-및-문서/pasted-image-20250304171240.png" target="_self"><br>운영 DB의 커넥션 pool은 충분한 상태로 보인다. <br>정보
처음 몇 번간은 정상실행 되지만, 반복 테스트 중 스레드 풀 점유 대기 타임아웃이 발생했다.
<br>배치를 완료한 이후에, 스레드 풀(히카리 풀)을 정상 반환하는지 확인.
<br><img alt="Pasted image 20241213102229.png" src="사진-및-문서/pasted-image-20241213102229.png" style="width: 750px; max-width: 100%;" target="_self"><br>Step이 마무리될때, 적어도 Job이 마무리 될때, entityManager를 클로즈 시키는것이 자명한데, 어째서 커넥션풀이 해제되지 않는가??<br><img alt="Pasted image 20241213143101.png" src="사진-및-문서/pasted-image-20241213143101.png" target="_self"><br>코드를 뜯어보자...
주의
엔티티 매니저는 클로즈 될 때, 트렌젝션이 살아있다면 그 트렌젝션이 종료될때까지 기다린다.
<img alt="Pasted image 20241213143217.png" src="사진-및-문서/pasted-image-20241213143217.png" target="_self"> <br>protected void doReadPage() { ... if (startIndex &gt;= totalRecords) { initResults(); // 빈 결과로 초기화 tx.commit(); return; } ...
<br><img alt="Pasted image 20241213103503.png" src="사진-및-문서/pasted-image-20241213103503.png" target="_self"><br>
<br>엔티티 메니저는 진짜 메니저가 아니다. 힘이 없다. 트렌젝션 메니저가 진짜 메니저다.
<br>그저 영속성 컨텍스트만 관리하는 녀석. 변경감지만 하는 녀석.]]></description><link>issue_troubleshooting/🚦-spring-batch(스레드와-트렌젝션)-트러블슈팅.html</link><guid isPermaLink="false">Issue_TroubleShooting/🚦 Spring Batch(스레드와 트렌젝션) 트러블슈팅.md</guid><pubDate>Tue, 04 Mar 2025 08:37:22 GMT</pubDate><enclosure url="사진-및-문서/pasted-image-20241213102128.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="사진-및-문서/pasted-image-20241213102128.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[⏰ Script 로딩 지연 이슈]]></title><description><![CDATA[<a class="tag" href="?query=tag:Script" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Script</a> <a class="tag" href="?query=tag:로딩지연" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#로딩지연</a> <a class="tag" href="?query=tag:성능개선" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#성능개선</a> <br> <a href=".?query=tag:Script" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Script">#Script</a> <a href=".?query=tag:로딩지연" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#로딩지연">#로딩지연</a> <a href=".?query=tag:성능개선" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#성능개선">#성능개선</a><br><img alt="Pasted image 20241105110415.png" src="사진-및-문서/pasted-image-20241105110415.png" style="width: 575px; max-width: 100%;" target="_self"><br>mainLayout은 Contents loading 후 Script를 호출하기 때문에, 특정 정적 오브젝트의 로딩이 완전히 마무리 될때 까지 실행되지 않음.<br>
=&gt; ex) 상품이 로딩되지 않은 상태로 최대 20초 가량을 대기 하게 됨<br>
<img alt="Pasted image 20250227140437.png" src="사진-및-문서/pasted-image-20250227140437.png" style="width: 600px; max-width: 100%;" target="_self">
<br><img alt="Pasted image 20250227140620.png" src="사진-및-문서/pasted-image-20250227140620.png" target="_self"><br>icon(아이콘)
<br>font(폰트)
<br> 현재 원인이 되는 외부자원(이미지/CSS)가 로딩되기 이전에 이벤트를 트리거 할 수 있다.<br>
이때, HTML DOM 트리가 준비 된 후(HTML 템플릿이 준비된 후)에 실행되기 때문에 modelAndView.addObject()로 전달한 데이터를 확정적으로 받아올 수 있다.<br>
<br>기존 메인 진입 소요시간 case 1 (로컬)<br>
<img alt="Pasted image 20241105110637.png" src="사진-및-문서/pasted-image-20241105110637.png" style="width: 500px; max-width: 100%;" target="_self"><br>
23초
<br>
<br>기존 메인 진입 소요시간 case 2 (로컬)<br>
<img alt="Pasted image 20241105110713.png" src="사진-및-문서/pasted-image-20241105110713.png" style="width: 500px; max-width: 100%;" target="_self"><br>
22초
<br>
<br>기존 메인 진입 소요시간 case 1 (운영)<br>
<img alt="Pasted image 20241107115602.png" src="사진-및-문서/pasted-image-20241107115602.png" style="width: 475px; max-width: 100%;" target="_self"><br>
21초
<br>
<br>기존 메인 진입 소요시간 case 2 (운영)<br>
<img alt="Pasted image 20241107115830.png" src="사진-및-문서/pasted-image-20241107115830.png" style="width: 475px; max-width: 100%;" target="_self"><br>
21초
<br>
<br>변경된 메인 진입 소요시간 case 1 (로컬)<br>
<img alt="Pasted image 20241107121044.png" src="사진-및-문서/pasted-image-20241107121044.png" style="width: 500px; max-width: 100%;" target="_self"><br>
0.201초
<br>
<br>변경된 메인 진입 소요시간 case 2 (로컬)<br>
<img alt="Pasted image 20241107121202.png" src="사진-및-문서/pasted-image-20241107121202.png" style="width: 500px; max-width: 100%;" target="_self"><br>
0.297초
<br>
<br>변경된 메인 진입 소요시간 case 3 (로컬)<br>
<img alt="Pasted image 20241107121939.png" src="사진-및-문서/pasted-image-20241107121939.png" style="width: 500px; max-width: 100%;" target="_self"><br>
0.232초
<br>
리로드 후 스크립트(상품 리스트)로드 시까지
<br>기존 투자하기 소요시간 case 1<br>
<img alt="Pasted image 20250227114750.png" src="사진-및-문서/pasted-image-20250227114750.png" target="_self"><br>
22.4초<br>
<img alt="Pasted image 20250227114826.png" src="사진-및-문서/pasted-image-20250227114826.png" target="_self">
<br>
<br>기존 투자하기 소요시간 case 2<br>
<img alt="Pasted image 20250227115004.png" src="사진-및-문서/pasted-image-20250227115004.png" target="_self"><br>
22.6초<br>
<img alt="Pasted image 20250227115015.png" src="사진-및-문서/pasted-image-20250227115015.png" target="_self">
<br>
<br>기존 투자하기 소요시간 case 3<br>
<img alt="Pasted image 20250227115158.png" src="사진-및-문서/pasted-image-20250227115158.png" target="_self"><br>
22.5초<br>
<img alt="Pasted image 20250227115148.png" src="사진-및-문서/pasted-image-20250227115148.png" target="_self">
<br>
<br>변경 투자하기 소요시간 case 1<br>
<img alt="Pasted image 20250227121009.png" src="사진-및-문서/pasted-image-20250227121009.png" style="width: 500px; max-width: 100%;" target="_self"><br>
0.373초
<br>
<br>변경 투자하기 소요시간 case 2<br>
<img alt="Pasted image 20250227121046.png" src="사진-및-문서/pasted-image-20250227121046.png" style="width: 500px; max-width: 100%;" target="_self"><br>
0.362초
<br>
<br>변경 투자하기 소요시간 case 3<br>
<img alt="Pasted image 20250227121942.png" src="사진-및-문서/pasted-image-20250227121942.png" style="width: 475px; max-width: 100%;" target="_self"><br>
0.360초
<br><img alt="Pasted image 20250227122010.png" src="사진-및-문서/pasted-image-20250227122010.png" target="_self"><br><img alt="Pasted image 20250227122736.png" src="사진-및-문서/pasted-image-20250227122736.png" target="_self"><br>
<br>aceat.js?advid=1954816599 - 에이스트레이더<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://cdn.nhnace.com/libs/aceat.js?advid=195481" target="_self">https://cdn.nhnace.com/libs/aceat.js?advid=195481</a>
<br>synchronizer.js - 네이버 관련 서버<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://ssl.pstatic.net/melona/libs/gfp-nac-module/synchronizer.js" target="_self">https://ssl.pstatic.net/melona/libs/gfp-nac-module/synchronizer.js</a>
<br>collect?en=page_view&amp;dr=localhost&amp;dl=http%... - 구글<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.google.com/ccm/collect" target="_self">https://www.google.com/ccm/collect</a>... - 구글
<br>869613409/?random=1740626824235&amp;cv=11&amp;f...<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.google.com/pagead/1p" target="_self">https://www.google.com/pagead/1p</a>...
<br>869613409/?random=1740626824235&amp;cv=11&amp;f... <br>869613409/?random=1110219531&amp;cv=11&amp;fst=... <br>
내부망 사용으로 인한 요청 실패, 중요 데이터 없음.
<br><img alt="output (14).png" src="사진-및-문서/output-(14).png" target="_self"><br>Main 페이지: 기존 21~23초 → 0.201~0.297초로 약 99% 속도 향상<br>
ProductList 페이지: 기존 22.4~22.6초 → 0.360~0.373초로 약 98% 속도 향상<br>
<br>정상 투자 확인<br>
<img alt="Pasted image 20250304121056.png" src="사진-및-문서/pasted-image-20250304121056.png" style="width: 475px; max-width: 100%;" target="_self"><br>
<img alt="Pasted image 20250304121009.png" src="사진-및-문서/pasted-image-20250304121009.png" style="width: 475px; max-width: 100%;" target="_self"><br>
<img alt="Pasted image 20250304121455.png" src="사진-및-문서/pasted-image-20250304121455.png" style="width: 475px; max-width: 100%;" target="_self"><br>
<img alt="Pasted image 20250304121338.png" src="사진-및-문서/pasted-image-20250304121338.png" style="width: 500px; max-width: 100%;" target="_self">]]></description><link>issue_troubleshooting/⏰-script-로딩-지연-이슈.html</link><guid isPermaLink="false">Issue_TroubleShooting/⏰ Script 로딩 지연 이슈.md</guid><pubDate>Tue, 04 Mar 2025 08:36:38 GMT</pubDate><enclosure url="사진-및-문서/pasted-image-20241105110415.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="사진-및-문서/pasted-image-20241105110415.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[📔 DataBase]]></title><description><![CDATA[<a class="tag" href="?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="?query=tag:DB" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#DB</a> <a class="tag" href="?query=tag:DataBase" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#DataBase</a> <br> <a href=".?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href=".?query=tag:DB" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#DB">#DB</a> <a href=".?query=tag:DataBase" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#DataBase">#DataBase</a><br>
<br>간단히 설명하면 "여러 쿼리를 한번에 실행하는 것" 이다.
<br>SQL의 Function과 비슷해 보이지만 차이가 있다.<br>
function : 클라이언트에서 처리, 리턴값 필수, 리턴값은 한개만 반환 가능<br>
프로시저 : 서버로 보내서 처리, 리턴값 선택, 리컨값 여러개 가능
<br>속도면에서는 함수에 비해 프로시저가 더 빠르다.<br>
그렇기 때문에 프로시저같은 경우는 실행,처리를 할때 주로 사용하고, 함수는 간단한 계산이나 수치 결과를 나타낼 때 사용한다.<br>
<br>하나의 요청으로 여러 SQL문을 실행 할 수 있음
<br>네트워크 소요 시간을 줄일 수 있음(여러개의 쿼리를 처리하는 시점에서 네트워크 부하를 줄임)
<br>보수성이 뛰어나다
<br>개발 업무를 구분하여 개발할 수 있다.(DB관련 처리를 API처럼 만들어 사용가능)
<br>
<br>재사용성이 낮다(DB버전 별 구문/규칙과 호환성이 다르기 때문)
<br>처리 성능이 좋지 않다(MySQL스토어드 프로그램 처리 성능이 낮다)
<br><img alt="Pasted image 20240610171904.png" src="사진-및-문서/pasted-image-20240610171904.png" target="_self"><br>파라미터 선언은 프로시저명() 안에서 선언하고, SQL문과 변수는 BEGIN - END 안에서 작성한다.
<br>SELECT사용시 반드시, 조회한 컬럼의 값을 INTO로 변수 안에 넣어주어야 한다.
<br>프로시저안에서 사용하는 SQL문은 세미콜론(;)으로 문장 끝을 맺어주어야 한다.
<br>if, case, loop 문을 사용할 수 있다.
<br>프로시저내에서 다른 프로시저를 호출 할 수 있다.
<br>- 커넥션이란 어플리케이션과 데이터베이스 서버간의 통신 링크를 뜻한다. 애플리케이션이 쿼리를 실행하고, 데이터를 검색하고, 데이터베이스에서 트랜젝션을 수행 할 수 있는 세션을
설정하는데 사용된다.
말그대로 애플리케이션과 DB를 연결하는 통신링크이며, 이가 모여있는것을 커넥션 풀 이라고 한다.
매번 연결하고 끊고 하는것 보다 커넥션풀에 등록하는 것이 성능적인 향상을 기대할 수 있기 때문이다.
<br>
<br>테이블 간에 중복된 데이터를 허용하지 않는다는 기본 목표를 갖는다. <br>중복된 데이터를 허용하지 않음으로 써 무결성 을 유지할 수 있다.
<br>
<br>DB의 저장 용량 또한 줄일 수 있다.
<br>데이터 테이블을 분해하여 이상현상이 발생할 가능성을 줄이고, 확장/수정시 구조 변경을<br>
최소화 할 수 있다.
<br>
<br>
릴레이션의 분해로 인해 Join연산이 늘어날 수 있다. <br>
쿼리시 응답시간이 느려질 수 있다. 데이터의 중복속성을 최대한 제거하는 것 이기때문에, 속성이 하나의 테이블에 집약되므로<br>
데이터 용량이 최소화 되어 상황에따라 처리속도가 빨라질 수도 있고, 느려질 수도 있다.<br>
만약 조인이 만연하여 속도저하가 발생하게 된다면 반정규화를 통해 속도를 개선할 수 있다. <br>
<br>테이블의 컬럼이 원자값(하나의 값)을 갖도록 테이블을 분해하는 것이다.
<br>각 컬럼의 순서가 상관이 없어야한다.
<br>하나의 컬럼은 같은 종류의 타입을 가져야 한다.<br>
<img alt="Pasted image 20240531103441.png" src="사진-및-문서/pasted-image-20240531103441.png" target="_self"><br>
원자값을 갖도록 컬럼을 나눈다.<br>
<img alt="Pasted image 20240531103549.png" src="사진-및-문서/pasted-image-20240531103549.png" target="_self">
<br>
<br>제 1 정규화를 진행한 테이블에 대해 "완전 함수 종속"을 만족하도록 테이블을 분해하는 것이다.
<br>여기서 완전 함수 종속이란, 기본키의 부분집합이 결정자가 되어선 안된다는 것을 의미한다.<br>
즉, 부분적 종속을 없애는 것이다.
<br><img alt="Pasted image 20240531105228.png" src="사진-및-문서/pasted-image-20240531105228.png" target="_self"><br>
해당 테이블의 기본키는 (학생번호, 강좌이름)으로 복합키 이다.<br>
성적은 (학생번호, 강좌이름)인 기본키가 결정하지만,<br>
강의실은 기본키의 부분집합인 강좌이름이 결정하게 된다.<br>즉, 부분집합이 결정자가 되지 않도록 테이블을 분리시키는 것으로 완전 함수 종속을 만족시킬 수 있다.<br>
<img alt="Pasted image 20240531105241.png" src="사진-및-문서/pasted-image-20240531105241.png" target="_self"><br>
<br>제2 정규화를 진행한 테이블에 대해 "이행적 종속"을 없애도록 테이블을 분해하는 것이다.
<br>여기서 이행적 종속이란 A -&gt; B , B -&gt; C 가 성립할때, A -&gt; C 가 성립되는 것을 의미한다.<br>
<img alt="Pasted image 20240531104351.png" src="사진-및-문서/pasted-image-20240531104351.png" target="_self"><br>
다음의 경유 이행적 종속상태 로 말할 수 있다.
<br>그 경우 테이블을 분리하여 데이터 변경시에 다른 데이터까지 변경되는 상황을 막을 수 있다.<br>
<img alt="Pasted image 20240531104418.png" src="사진-및-문서/pasted-image-20240531104418.png" target="_self"><br>
<br>제3 정규화를 좀 더 강화한 것이라 생각하면 된다.
<br>BCNF정규화란 제3 정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록<br>
테이블을 분해하는 것을 말한다.
<br><img alt="Pasted image 20240531104751.png" src="사진-및-문서/pasted-image-20240531104751.png" target="_self"><br>
특수 수강 테이블에서 기본키는 (학생번호, 특강이름)이다. 그리고 기본키는 교수를 결정하고 있다.<br>
또한, 여기서 교수는 특강이름을 결정하고있다.<br>문제는 교수가 특강이름을 결정하는 결정자 이지만, 후보키가 아니다.<br>
그렇기 때문에 BCNF 정규화를 만족시키기 위해서는 테이블을 분해하여 아래와 같이 분리할 수 있다.<br><img alt="Pasted image 20240531104803.png" src="사진-및-문서/pasted-image-20240531104803.png" target="_self"><br>
<br>컬럼값의 중복을 제거하는것이다.
<br>
<br>중복을 제거하기 위해 분해할 수 있을만큼 최대한 분해하는 것이다.
<br> 그 이상 정규화를 진행하면 오히려 정규화의 단점이 더 커지기 때문이다.
<br>인덱스 : 단일데이터 단위인 도큐먼트(document)를 모아놓은 집합을 인덱스(index)라고 한다.<br>
색인 : 데이터를 Elasticsearch에 저장하는 행위<br>
샤드 : 인덱스는 기본적으로 샤드(shard)라는 단위로 분리되고, 각 노드에 분산되어 저장된다 (검색의 기본단위는 샤드이다.)<br>
<img alt="Pasted image 20240828104032.png" src="사진-및-문서/pasted-image-20240828104032.png" target="_self"><br>데이터를 범위나 카테고리로 나누어 관리하는 기법을 파티셔닝 이라고 한다.
<br>
<br>
인덱스를 생성할 때, 처음 생성된 샤드를 프라이머리 샤드, 복제본은 리플리카 라고 부른다. <br>
예를 들어 한 인덱스가 5개의 샤드로 구성되어있고, 클러스터가 4개의 노드로 구성되어있다고 가정하면,<br>
각각 5개의 프라이머리 샤드와 복제본, 총 10개의 샤드들이 전체 노드에 골고루 분산되어 저장된다.<br>
<img alt="Pasted image 20240828104728.png" src="사진-및-문서/pasted-image-20240828104728.png" target="_self"><br>
노드가 1개만 존재한다면 복제본은 생성되지 않는다. Elasticsearch는 아무리 작은 클러스터라도 최소 3개의 노드로 구성할 것을 권장하고 있다. <br>
이렇게 프라이머리 샤드와 리플리카를 통해 Elasticsearch는 운영 중에 노드가 유실되어도 데이터를 잃어버리지 않고, 데이터 가용성과 무결성을 보장하게 된다. <br>샤드는 여러 서버에 분산되어 병렬 및 병행으로 검색되므로, 인덱스가 같던 다르던 상관이 없다.
검색의 기본 단위는 샤드이기 때문이다. 따라서 인덱스를 나누는 것은 운영의 편의성을 고려할 때 선택하는 방법이다.
<br>전체색인을 할 경우 인덱스 1개가 7억건 이라면 색인이 모두 끝날때 까지 몇시간이 걸리게 된다.
그 와중에 데이터에 변경이 있게 된다면 전체 색인 후 일괄적용이 들어가게 될텐데, 대기시간이 길어질 수록 일괄적용 시간도 함께 늘어나게 된다.
결국 더 빠른 색인을 위해서는 하나의 인덱스를 여러개로 나누너 병행처리를 시키도록 해야한다. 다나와 에서는 상품DB특성상 카테고리군 별로 인덱스를 나누고 있다. 이때의 장점은 특정 카테고리만 검색할때 해당 인덱스만 검색하면 되므로, 검색 속도가 현저히 감소하게 된다.
<br>
<br>일반적인 시스템 로그와 같은 로그성 문서는 색인을 하고 나면 수정이 필요없는 정적 컨텐츠인 반면<br>
상품문서같은 경우 색인이 끝나도 계속 갱신되어야 하는 살아있는 동적 컨텐츠이다. 따라서 동적색인에 원할하고, 검색성능도 높은 설계를 요구한다.
<br>트렌젝션<br>
- 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위<br>트렌젝션매니저<br>
- Spring에서 제공하는 트렌젝션 관리 기능과 JPA를 연결하는 역할을 수행.<br>@Transactional<br>
- 클래스나 메서드에 삽입하면, AOP레벨(프록시를 사용하여)에서 트렌젝션매니저를 이용한 동작을 공통으로 적용.<br>앤티티매니저<br>
- 영속성 컨텍스트를 관리하는 인터페이스<br>
- 엔티티의 저장/수정/삭제/조회 작업을 수행<br>
- 스레드 세이프하지 않으므로 한트레젝션 내에서만 사용<br>
- 앤티티매니저펙토리는 스레드세이프하므로 공유 가능<br>영속성컨텍스트<br>
- JPA의 엔티티를 관리하는 1차 캐시 역할을 하는 메모리 공간<br>
- 엔티티와 DB데이터간의 상태 동기화를 책임<br>
- 1차캐싱 / 변경 감지 / 지연 로딩 의 특징을 갖는다<br>
- 지연로딩 : 관계된 엔티티를 실제로 필요할때만 가져오며, 변경점을 한번만 commit한다<br>스냅샷<br>
- DB스냅샷 :<br>
- 트렌젝션이 시작될때 생성된다.<br>
- 독립적인 데이터베이스 복사본으로, 원본데이터 변경과 무관하다.<br>
- 고급 격리 수준(REPEATABLE READ, SERIALIZABLE)에서 MVCC(Multi-Version Concurrency Control)를 구현할 때 사용한다.<br>
- 물리적인 복사본이 아닌, 논리적으로 매 쿼리마다 동적으로 가공이 되는 방식이다.<br>
- 앤티티매니저_스냅샷 :<br>
- 엔티티가 영속성 컨텍스트에 로드될 때 생성된다.<br>
- 엔티티의 초기 상태를 저장하여 변경 감지에 사용된다.<br>세션1이 트렌젝션을 시작하고 데이터를 수정하는 동안 아직 커밋을 수행하지 않았는데,<br>
세션2에서 동시에 같은 데이터를 수정하게 되면 여러가지 문제가 발생한다.<br>이런문제를 방지하기 위해, 세션이 트렌젝션을 시작하고 데이터를 수정하는 동안에 커밋이나 롤백 전까지<br>
다른세션에서 해당 데이터를 수정할 수 없게 막아야 한다. 이런 문제를 해결하기 위해 DB에서는<br>
LOCK 락 이라는 개념을 제공한다.<br>락은 언제 사용하는가? : 트렌젝션 종료 시점까지 해당 데이터를 다른 곳에서 변경하지 못하도록 강제로 막아야 할 때 사용한다.
<br>일반적인 조회는 락을 사용하지 않는다.
<br>락 타임아웃(다른 세션이 데이터를 점유하고 있을때 대기시간이 초과된 경우)에는 익셉션이 발생하게 된다.
<br>동시성 제어(Concurrency Control)란,&nbsp;여러 사용자나 프로세스가 데이터를 공유할 때 발생할 수 있는 문제를 해결하기 위해, 데이터베이스 시스템이 트랜잭션을 순서대로 실행하는 것이 아니라, 트랜잭션이 동시에 실행될 수 있도록 허용하면서도 데이터의 일관성과 무결성을 유지할 수 있도록 하는 기술이며, 데이터베이스 시스템에서 매우 중요한 개념 중 하나이다.<br>
<br>여러 사용자가 DB에 접근하더라도&nbsp;데이터의 일관성을 보장하고 데이터의 무결성을 유지
<br>위를 만족하며 데이터베이스 시스템의 성능과 효율성을 유지하는 것
<br>분실된 갱신(Lost Update) <br>두개의 트랜잭션이 같은 데이터를 갱신하는 작업을 진행하게 되면서 하나의 작업이 진행되지 않는 경우 <br>모순성(Inconsistency) <br>두개의 트랜잭션이 같은 데이터를 동시에 갱신하게되어 사용자가 원하는 결과와 일치하지 않은 상태가 되는 경우 <br>연쇄복귀(Cascading Rollback) <br>두개의 트랜잭션이 같은 데이터를 갱신하는 작업을 진행하는 과정에서 하나의 트랜잭션이 실패하면 원자성에 의해 두 트랜잭션 모두 복귀하는 경우 <br>비완료 의존성(Uncommitted Dependency) <br>한개의 트랜잭션이 실패하였을때, 이 트랜재션이 회복하기전에 다른 트랜잭션이 실패한 수행 결과를 참조하는 경우 <br>
<br>Locking은 공유 자원에 대한 동시 액세스를 제어하는 전통적인 방법이다.
<br>단일 스레드 또는 단일 프로세스에서만 동작하며, 한 번에 하나의 스레드만 공유 자원에 액세스할 수 있다.
<br>신뢰성과 안전성이 높으며, 어떤 수준의 locking을 적용하느냐에 따라 교착 상태나 경쟁 조건과 같은 문제를 방지할 수 있다.
<br>하지만 동시성 처리 속도가 저하될 수 있고, 대기 시간이 발생할 수 있다.
<br>기본적으로 lock 연산과 unlock 연산을 사용한다.
<br>
<br>
공유 잠금 (shared lock/s-lock): 데이터를 읽을 때 사용하는 락 <br>공유잠금을 설정한 트랜잭션은 데이터 항목에 대해&nbsp;읽기 연산(read)만 가능하다. <br>T1에서 x에 대해 S-lock을 설정했다면, T1은 read(x) 연산만 가능하다. <br>하나의 데이터 항목에 대해&nbsp;여러 개의 공유잠금이(S-lock) 가능하다. <br>T1에서 x에 대해 S-lock을 설정한 경우, 동시에 T2에서도 x에 대해 S-lock을 설정할 수 있다. <br>다른 트랜잭션도 읽기 연산(read) 만을 실행할 수 있다. <br>T1에서 x에 대해 S-lock을 설정했다면, T2에서도 T1이 S-lock(x)을 실행하는 동안 read(x) 연산만 가능하다. <br>
배타 잠금 (exclusive lock/x-lock): 데이터를 변경할 때 사용하는 락 <br>배타잠금을 설정한 트랜잭션은 데이터 항목에 대해서&nbsp;읽기 연산(read)과 쓰기 연산(write) 모두 가능하다. <br>T1에서 x에 대해 S-lock을 설정했다면, T1은 read(x) 연산과 write(x) 연산 모두 가능하다. <br>하나의 데이터 항목에 대해서는&nbsp;하나의 배타잠금(X-lock)만 가능하다.
<br>동시에 여러 개의 배타잠금은 불가능하다. <br>T1에서 x에 대해 X-lock을 설정했다면, T1에서 unlock(x)를 하기 전까지 T2에서 x에 대해 X-lock을 설정할 수 없다. <br>다른 트랜잭션은 읽기 연산(read)와 쓰기 연산(write) 모두 불가능하다. <br>T1에서 x에 대해 X-lock을 설정했다면, T2에서는 T1에서 unlock(x)를 하기 전까지 read(x), write(x) 연산이 모두 불가능하다. <br>
추가) 교착상태 (deadlock) <br>모든 transaction이 대기 상태에 들어가 아무런 진행이 일어나지 않는 상태를 교착상태라고 한다. 교착상태에 빠지면 외부에서 강제로 트랜잭션을 중단하거나 잠금을 해제하지 않는 이상 무한정 대기 상태로 남게 된다. <br>
<br>
낙관적 락 (optimistic lock) <br>충돌이 발생할 가능성이 낮은 경우 사용되는 동시성 제어 기법이다.
<br>충돌이 발생하면 재시도 또는 병합을 통해 충돌을 해결한다.
<br>실제로 lock을 사용하지 않고&nbsp;version을 이용함으로서 정합성을 맞추는 방법이다. 데이터를 읽을 때 lock을 사용하지 않고, 업데이트 시&nbsp;내가 읽은 version이 맞는지 충돌 여부를 확인하여 처리한다.
<br>즉, 자원에 lock을 직접 걸어서 선점하지 않고, 동시성 문제가 실제로 발생하면 그때가서 처리하는 방식이다. <br>
비관적 락 (pessimistic lock) <br>충돌이 발생할 가능성이 높은 경우 사용되는 동시성 제어 기법이다.
<br>데이터를 읽거나 수정하기 전에 lock을 획득하여 다른 사용자의 액세스를 차단하고, lock을 가진 스레드만 접근하도록 제어한다.
<br>데이터에 대한 배타적인 액세스 권한을 보장하여 충돌을 방지한다.
<br>실제로 데이터에 lock을 걸어서 정합성을 맞추는 방법으로, 자원 요청에 따른 동시성 문제가 발생할 것이라고 예상하고 lock을 걸어버리는 방법이다.
<br>즉, 트랜젝션이 시작할 때 s-lock이나 x-lock을 실제로 걸고 시작한다. <br>
낙관적 락 vs. 비관적 락<br>
<img alt="Pasted image 20250228150552.png" src="사진-및-문서/pasted-image-20250228150552.png" target="_self"> <br>
분산락 (distributed lock) <br>여러 컴퓨터 또는 프로세스 간에 공유된 자원에 대한 동시 액세스를 제어하기 위해 사용된다.
<br>분산 시스템에서 동시성 문제를 해결하기 위해 사용되며,&nbsp;분산된 서버 또는 클러스터 간의 상호작용이 필요하다.
<br>주로&nbsp;데이터베이스나 메시지 큐 등의 분산 시스템에서 사용된다.
<br>대표적인 분산락 기법으로는 ZooKeeper, Redis 등이 있다.
<br>Redis는 RedLock이라는 알고리즘을 제안하며 3가지 특성을 보장해야한다고 한다. <br>오직 한 순간에 하나의 작업자만이 락(lock) 을 걸 수 있다.
<br>락 이후, 어떠한 문제로 인해 락을 풀지 못하고, 종료된 경우라도 다른 작업자가 락을 획득할 수 있어야합니다.
<br>Redis 노드가 작동하는한, 모든 작업자는 락을 걸고 해체할 수 있어야합니다. <br>분산 락을 구현하기 위해 lock에 대한 정보를 Redis에 저장하고 있어야한다. 그리고 분산환경에서 여러대의 서버들은 공통된 Redis를 바라보며, 자신이 공유 자원에 접근할 수 있는지 확인한다. <br>
스핀락 (spin lock) <br>자원에 대한 접근이 필요할 때 무한루프를 돌면서 반복적으로 확인하며, 다른 스레드가 lock을 해제할 때까지 대기한다.
<br>경쟁 상태 (2개 이상의 프로세스가 공유 자원을 동시에 읽거나 쓰는 상황)가 짧고 자원 점유 시간이 길지 않은 경우에 효과적이다.
<br>주로 멀티코어 시스템에서 사용되며, 락 획득을 위해 CPU를 계속 사용하므로 서버에 많은 부하를 주어 주의해야 한다.
<br>]]></description><link>study/cs/📔-database.html</link><guid isPermaLink="false">study/CS/📔 DataBase.md</guid><pubDate>Tue, 04 Mar 2025 08:36:00 GMT</pubDate><enclosure url="사진-및-문서/pasted-image-20240610171904.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="사진-및-문서/pasted-image-20240610171904.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🏠 taesung's Blog]]></title><description><![CDATA[<a class="tag" href="?query=tag:home" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#home</a> <a class="tag" href="?query=tag:index" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#index</a> <a class="tag" href="?query=tag:blog" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#blog</a> <a class="tag" href="?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <br> <a href=".?query=tag:home" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#home">#home</a> <a href=".?query=tag:index" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#index">#index</a> <a href=".?query=tag:blog" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#blog">#blog</a> <a href=".?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a><br><a data-tooltip-position="top" aria-label="https://github.com/LeeTaeSung0628" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/LeeTaeSung0628" target="_self"><span alt="Pasted image 20250220144552.png" src="Pasted image 20250220144552.png" class="internal-embed media-embed image-embed is-loaded" style="width: 220px; max-width: 100%;"></span></a><img alt="Pasted image 20250220144552.png" src="사진-및-문서/pasted-image-20250220144552.png" style="width: 220px; max-width: 100%;" target="_self"><br>
<a data-tooltip-position="top" aria-label="https://github.com/LeeTaeSung0628" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/LeeTaeSung0628" target="_self"><font color="#ffffff"></font></a>🔗git Hub 이동<br><a data-tooltip-position="top" aria-label="https://git.io/typing-svg" rel="noopener nofollow" class="external-link is-unresolved" href="https://git.io/typing-svg" target="_self"></a><img alt="Typing SVG" src="https://readme-typing-svg.demolab.com?font=Fira+Code&amp;pause=1000&amp;color=36A9F7&amp;random=false&amp;width=435&amp;lines=%EC%97%AC%EA%B8%B0%EB%8A%94+%EA%B3%B5%EB%B6%80%ED%95%98%EA%B3%A0%2C+%EA%B8%B0%EB%A1%9D%ED%95%98%EB%8A%94+%EA%B3%B3%EC%9E%85%EB%8B%88%EB%8B%A4" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br> <br> <br> <br> <br> <br> <br> <br> <br> <br>Soon <br>깃 레포에서도 블로그 주소로 이어질 수 있도록 Readme 설정하기. <br>리드미 또한 옵시디언에서 작업이 가능하다. <br>Netlify 셋팅 추가하기]]></description><link>index.html</link><guid isPermaLink="false">index.md</guid><pubDate>Tue, 04 Mar 2025 08:05:33 GMT</pubDate><enclosure url="사진-및-문서/pasted-image-20250220144552.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="사진-및-문서/pasted-image-20250220144552.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[📕 공부]]></title><description><![CDATA[<a class="tag" href="?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="?query=tag:모음" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#모음</a> <br> <a href=".?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href=".?query=tag:모음" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#모음">#모음</a><br>공부
보고 배운 지식 중 공유하고 싶은 정보를 모아둔 카테고리 입니다.
<br>
<br><a data-href="⏰ Script 로딩 지연 이슈" href="issue_troubleshooting/⏰-script-로딩-지연-이슈.html" class="internal-link" target="_self" rel="noopener nofollow">⏰ Script 로딩 지연 이슈</a>
<br><a data-href="🚦 Spring Batch(스레드와 트렌젝션) 트러블슈팅" href="issue_troubleshooting/🚦-spring-batch(스레드와-트렌젝션)-트러블슈팅.html" class="internal-link" target="_self" rel="noopener nofollow">🚦 Spring Batch(스레드와 트렌젝션) 트러블슈팅</a>⭐
<br><a data-href="🔐 Lock이란 무엇인가. 헬로 서비스 이슈" href="issue_troubleshooting/🔐-lock이란-무엇인가.-헬로-서비스-이슈.html" class="internal-link" target="_self" rel="noopener nofollow">🔐 Lock이란 무엇인가. 헬로 서비스 이슈</a>
<br><a data-href="⚔ 간단한 StckOverflow 원인분석(Query)" href="issue_troubleshooting/⚔-간단한-stckoverflow-원인분석(query).html" class="internal-link" target="_self" rel="noopener nofollow">⚔ 간단한 StckOverflow 원인분석(Query)</a>
<br>
<br><a data-href="☕ JAVA , OOP" href="study/cs/☕-java-,-oop.html" class="internal-link" target="_self" rel="noopener nofollow">☕ JAVA , OOP</a>
<br><a data-href="🍃 Spring" href="study/cs/🍃-spring.html" class="internal-link" target="_self" rel="noopener nofollow">🍃 Spring</a>
<br><a data-href="🎩 DevOps" href="study/cs/🎩-devops.html" class="internal-link" target="_self" rel="noopener nofollow">🎩 DevOps</a>
<br><a data-href="📔 DataBase" href="study/cs/📔-database.html" class="internal-link" target="_self" rel="noopener nofollow">📔 DataBase</a>
<br><a data-href="📭 Server" href="study/cs/📭-server.html" class="internal-link" target="_self" rel="noopener nofollow">📭 Server</a>
<br><a data-href="🐞 etc" href="study/cs/🐞-etc.html" class="internal-link" target="_self" rel="noopener nofollow">🐞 etc</a>
<br>
<br><a data-href="🤠 Coding Test 풀이 모음" href="study/coding-test/🤠-coding-test-풀이-모음.html" class="internal-link" target="_self" rel="noopener nofollow">🤠 Coding Test 풀이 모음</a>
<br><a data-href="👽 Algorithm" href="study/coding-test/👽-algorithm.html" class="internal-link" target="_self" rel="noopener nofollow">👽 Algorithm</a>
<br>
<br><a data-href="🔻 Redis 캐쉬 전략 - hello 서비스에 적용하여 성능개선 가능성" href="study/dev-seminar/🔻-redis-캐쉬-전략-hello-서비스에-적용하여-성능개선-가능성.html" class="internal-link" target="_self" rel="noopener nofollow">🔻 Redis 캐쉬 전략 - hello 서비스에 적용하여 성능개선 가능성</a>
<br><a data-href="🍂 JPA, Mybatis , Dead Lock" href="study/dev-seminar/🍂-jpa,-mybatis-,-dead-lock.html" class="internal-link" target="_self" rel="noopener nofollow">🍂 JPA, Mybatis , Dead Lock</a>
<br><a data-href="🔹 TDD에 대하여" href="study/dev-seminar/🔹-tdd에-대하여.html" class="internal-link" target="_self" rel="noopener nofollow">🔹 TDD에 대하여</a>
<br><a data-href="🪕 JPA 에 대한 고찰" href="study/dev-seminar/🪕-jpa-에-대한-고찰.html" class="internal-link" target="_self" rel="noopener nofollow">🪕 JPA 에 대한 고찰</a>
<br><a data-href="🔒 투자하기 서비스 락(Lock)기법 개선안" href="study/dev-seminar/🔒-투자하기-서비스-락(lock)기법-개선안.html" class="internal-link" target="_self" rel="noopener nofollow">🔒 투자하기 서비스 락(Lock)기법 개선안</a>
<br><a data-href="🥗 Spring Security_토큰-세션-쿠키-JWT 에 대하여" href="study/dev-seminar/🥗-spring-security_토큰-세션-쿠키-jwt-에-대하여.html" class="internal-link" target="_self" rel="noopener nofollow">🥗 Spring Security_토큰-세션-쿠키-JWT 에 대하여</a>
<br><a data-href="📔 DB 테이블 설계, 어떻게 하는게 옳은 방법인가" href="study/dev-seminar/📔-db-테이블-설계,-어떻게-하는게-옳은-방법인가.html" class="internal-link" target="_self" rel="noopener nofollow">📔 DB 테이블 설계, 어떻게 하는게 옳은 방법인가</a>
<br>
<br><a data-href="🥈 필기 1과목 - 소프트웨어 설계" href="study/정보처리기사/정보처리기사-필기/🥈-필기-1과목-소프트웨어-설계.html" class="internal-link" target="_self" rel="noopener nofollow">🥈 필기 1과목 - 소프트웨어 설계</a>
<br><a data-href="🥈 필기 2과목 - 소프트웨어 개발" href="study/정보처리기사/정보처리기사-필기/🥈-필기-2과목-소프트웨어-개발.html" class="internal-link" target="_self" rel="noopener nofollow">🥈 필기 2과목 - 소프트웨어 개발</a>
<br><a data-href="🥈 필기 3과목 - 데이터베이스 구축" href="study/정보처리기사/정보처리기사-필기/🥈-필기-3과목-데이터베이스-구축.html" class="internal-link" target="_self" rel="noopener nofollow">🥈 필기 3과목 - 데이터베이스 구축</a>
<br><a data-href="🥈 필기 4과목 - 프로그래밍 언어 활용" href="study/정보처리기사/정보처리기사-필기/🥈-필기-4과목-프로그래밍-언어-활용.html" class="internal-link" target="_self" rel="noopener nofollow">🥈 필기 4과목 - 프로그래밍 언어 활용</a>
<br><a data-href="🥈 필기 5과목 - 정보시스템 구축관리" href="study/정보처리기사/정보처리기사-필기/🥈-필기-5과목-정보시스템-구축관리.html" class="internal-link" target="_self" rel="noopener nofollow">🥈 필기 5과목 - 정보시스템 구축관리</a>
<br>
<br><a data-href="🥇 정보처리 기사 실기 키워드" href="study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-키워드.html" class="internal-link" target="_self" rel="noopener nofollow">🥇 정보처리 기사 실기 키워드</a>
<br><a data-href="🥇 정보처리 기사 실기 SQL 문제" href="study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-sql-문제.html" class="internal-link" target="_self" rel="noopener nofollow">🥇 정보처리 기사 실기 SQL 문제</a>]]></description><link>study/📕-공부.html</link><guid isPermaLink="false">study/📕 공부.md</guid><pubDate>Tue, 04 Mar 2025 08:05:20 GMT</pubDate></item><item><title><![CDATA[👩‍👧‍👦 marketing Analytics 공통모듈 제작기]]></title><description><![CDATA[<a class="tag" href="?query=tag:프로젝트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로젝트</a> <a class="tag" href="?query=tag:개발" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#개발</a> <a class="tag" href="?query=tag:DB" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#DB</a> <a class="tag" href="?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <a class="tag" href="?query=tag:AOP" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#AOP</a> <br> <a href=".?query=tag:프로젝트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로젝트">#프로젝트</a> <a href=".?query=tag:개발" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#개발">#개발</a> <a href=".?query=tag:DB" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#DB">#DB</a> <a href=".?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a> <a href=".?query=tag:AOP" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#AOP">#AOP</a> <br>
<br>기존 외부 유입 통계 로직의 단점 해결. <br>확장에 닫혀있음
<br>디테일한 행동 추적 불가능
<br>중복 접근자 처리로직의 부재 <br>Hello Service의 유입/동작 통계 모듈의 공통화 작업이다.
Spring AOP를 사용하여 구성하였다.
<br>
<br>통계 필요 페이지 내에서(프론트), 쿠키 데이터 페이지 별 최초 진입 확인?
<br>
<br>해당 진입시점부터 특정 동작에 대한 모든 타임라인 로그
<br>
<br>레디스 가용 메모리에 대한 한계값 산정. -&gt; 아직 적용 X
<br>
<br>URL + 함수명 조합
<br>=&gt; 메인 테이블<br>
=&gt; 백로직에서 쿠키 데이터 쌓기<br>=&gt; 디테일 테이블 - 타임라인으로 관리 단, 메인테이블에 존재하는 내셕들에 대해서<br>
=&gt; AOP에서 특정 서비스or메서드orURL로 지정하여 로그 쌀기<br>- 관심사(Aspect)를 분리하여, 각 서비스 메서드에 반복해서 구현하는 것이 아닌, 별도의 Aspect로 관리하여 핵심로직을 공통으로 적용하기 위함이다.
<br>
<br>난수 생성 후 물고있기☑ <br>IP로 추적 <br><img alt="Pasted image 20241224144309.png" src="사진-및-문서/pasted-image-20241224144309.png" target="_self"><br>쿠키가 필요한 페이지의 경로가 기본 path와 일치하는 경우(redirect url 이 SP_MARKETING_HIT_TEST1 의 하위 url일 경우)<br>
에는 명시적으로 표시할 필요가 없지만,<br>AOP에서 Front-end 단의 특정 동작 필터링 하기<br><img alt="Pasted image 20241226111559.png" src="사진-및-문서/pasted-image-20241226111559.png" target="_self"><br>
<br>장점: <br>코드가 간결하고 읽기 쉽다.
<br>Spring의 AOP 인프라를 사용하여 메서드 인터셉션을 쉽게 구현할 수 있다. <br>단점:
- 포인트컷 조건은 컴파일 시점에 고정된다.
- 복잡한 조건이나 동적으로 변경되는 조건을 처리하기 어렵다. -&gt; @Pointcut 등의 조건에 부합하는 Bean객체를 컴파일 시점에 찾아내어 프록시를 감싼다.
<br>
<br>동적 생성: <br>런타임에 프록시를 생성하여 포인트컷과 어드바이스를 동적으로 적용.
<br>StaticMethodMatcherPointcut 또는 DynamicMethodMatcherPointcut을 사용하여 런타임 조건 기반으로 메서드 매칭. <br>장점: <br>런타임 조건에 따라 동적으로 포인트컷 생성 가능.
<br>복잡한 조건과 동적 필터링을 처리하기 용이.
<br>Spring AOP가 아닌 순수 Java 프록시 방식도 지원. <br>단점: <br>코드가 복잡해지고 추가 구현이 필요.
<br>Spring AOP와 동일한 수준의 간결성을 제공하지 않음. <br>-&gt; 해당 프록시 객체를 적용하고 싶은 Bean객체에 매번 생성(등록)해주어야 함.<br>import org.springframework.aop.Pointcut;
import org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;
import org.springframework.aop.support.DefaultPointcutAdvisor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration; @Configuration
public class AopConfig { @Bean public Pointcut customPointcut() { return new CustomPointcut(); } @Bean public CustomAdvice customAdvice() { return new CustomAdvice(); } @Bean public DefaultPointcutAdvisor customAdvisor(Pointcut customPointcut, CustomAdvice customAdvice) { return new DefaultPointcutAdvisor(customPointcut, customAdvice); } @Bean public DefaultAdvisorAutoProxyCreator proxyCreator() { return new DefaultAdvisorAutoProxyCreator(); }
} <br>
<br>@Pointcut 방식과 동일한 동작: <br>Spring 컨테이너가 관리하는 모든 빈에 대해 조건을 평가하고 프록시를 자동 생성합니다. <br>프록시를 명시적으로 선언할 필요 없음: <br>ProxyFactory처럼 수동으로 프록시를 생성하지 않아도 됩니다. <br>유연성과 효율성 향상: <br>Spring AOP 인프라를 활용하므로, 관리가 용이하고 런타임 성능이 개선됩니다. <br>
<br>BeanPostProcessor: <br>DefaultAdvisorAutoProxyCreator는 Spring의 BeanPostProcessor를 구현한 클래스이다.
<br>Spring 컨테이너는 애플리케이션 컨텍스트에 등록된 모든 BeanPostProcessor를 자동으로 호출하여 빈의 초기화 전후 작업을 수행한다.
<br>이를 통해, Spring AOP는 빈 생성 단계에서 프록시를 생성하고 조건에 맞는 빈에 대해 어드바이저를 적용. <br>Advisor 탐색: <br>DefaultAdvisorAutoProxyCreator는 Spring 컨텍스트에 등록된 모든 Advisor를 자동으로 탐색한다.
<br>이는 DefaultAdvisorAutoProxyCreator가 BeanFactory를 통해 컨테이너의 모든 Advisor 타입 빈을 조회하기 때문.
<br>탐색된 Advisor를 사용하여 각 빈의 메서드와 포인트컷 조건을 매칭. <br>Advisor와 빈의 매칭: <br>빈이 생성될 때, DefaultAdvisorAutoProxyCreator는 해당 빈의 메서드가 어떤 Advisor의 포인트컷 조건에 부합하는지 평가.
<br>조건에 부합하면, 해당 빈을 프록시 객체로 감싸고, 어드바이스를 연결. <br>위 방법의 문제점? <br>
<br>이렇게 맵핑이 되어야 하나, 이를 동적으로 탐지하지 못한다.
<br>/* * EnableAspectJAutoProxy &gt; 프록시 적용시 인터페이스/클래스 여부 자동 판단 * 클래스에 인터페이스가 있으면 JDK 동적 프록시. * 인터페이스가 없으면 CGLIB 프록시. * */@Configuration @EnableAspectJAutoProxy public class AopConfig { @Bean public Pointcut customPointcut() { return new CustomPointcut(); } @Bean public CustomAdvice customAdvice() { return new CustomAdvice(); } @Bean public DefaultPointcutAdvisor customAdvisor(Pointcut customPointcut, CustomAdvice customAdvice) { return new DefaultPointcutAdvisor(customPointcut, customAdvice); } /* * @EnableAspectJAutoProxy를 사용해 등록했기 때문에 불필요. * */ // @Bean // public DefaultAdvisorAutoProxyCreator proxyCreator() { // return new DefaultAdvisorAutoProxyCreator(); // } }
<br>프록시(Proxy)는 대리자라는 뜻으로, 다른 객체에 대한 인터페이스 역할을 하는 객체를 말합니다. 프로그래밍에서 프록시는 실제 객체에 접근하기 전에 특정 작업(로깅, 보안, 트랜잭션 관리 등)을 수행하거나, 객체에 대한 접근을 제어하는 데 사용됩니다.<br>
<br>대리 객체: 프록시는 실제 객체에 대한 중간다리 역할을 합니다.
<br>동작 조정: 프록시는 요청을 가로채서 추가적인 작업을 수행하거나, 요청을 변형한 뒤 실제 객체에 전달할 수 있습니다.
<br>AOP와 연관: 프록시를 사용하면 코드를 변경하지 않고도 객체의 동작을 확장하거나 변경할 수 있습니다.
<br>Method Name: loanerLoginPage<br>
javax.servlet.http.HttpServletRequest<br>
org.springframework.web.bind.annotation.GetMapping <br><img alt="Pasted image 20241226152219.png" src="사진-및-문서/pasted-image-20241226152219.png" target="_self"><br><img alt="Pasted image 20241226171158.png" src="사진-및-문서/pasted-image-20241226171158.png" target="_self"><br>
<br>외부링크 최초진입. hitCode, hitUid 발급 및 DB저장
<br>
<br>외부링크 재진입. hitCode는 변경될 수 있으므로 "p"파라미터로 재발급<br>
=&gt; hitCode는 매번 재발급 / hitUid는 없을때만 발급
<br>
<br>일반사용자 이며, 아무동작 하지 않는다.
<br>
<br>외부링크 진입 후 동작. 없는 녀석 새로 발급 및 DB저장
<br>서비스 저장시 동시성 이슈가 발생할 수 있다?<br>@Override @Transactional public ResponseModel insertMarketingHitLog(String hitCode, String hitUid, String pageUrl, String pageType){ try { Optional&lt;HfMarketingHitLog&gt; existingLog = hfMarketingHitLogRepository.findByHitCodeAndHitUidAndPageUrlAndPageType(hitCode, hitUid, pageUrl, pageType); if (existingLog.isPresent()) { HfMarketingHitLog logToUpdate = existingLog.get(); logToUpdate.setUpdateDate(LocalDateTime.now()); hfMarketingHitLogRepository.save(logToUpdate); return new ResponseModel(ResponseModel.ResponseStatus.SUCCESS); } HfMarketingHitLog hfMarketingHitLog = HfMarketingHitLog.builder() .hitCode(hitCode) .hitUid(hitUid) .pageUrl(pageUrl) .pageType(pageType) .build(); hfMarketingHitLogRepository.save(hfMarketingHitLog); return new ResponseModel(ResponseModel.ResponseStatus.SUCCESS); } catch (Exception e) { return new ResponseModel(ResponseModel.ResponseStatus.FAILED, "데이터 처리 중 오류 발생"); } }
<br>
<br>여러 쓰레드(또는 트랜잭션)가 findByHitCodeAndHitUidAndPageUrlAndPageType 메서드를 호출하여 동일한 조건의 데이터를 동시에 조회할 수 있다.
<br>두 쓰레드가 모두 existingLog.isPresent() 조건에서 false를 확인한 후, 동시에 새로운 HfMarketingHitLog 객체를 생성하고 저장하려 하면 데이터 중복 문제가 발생할 수 있다.
<br>. Lock을 쓰면 되나, 이후 업데이트 로직 삭제(로그 테이블화) 변경으로 처리<br><img alt="Pasted image 20241230135801.png" src="사진-및-문서/pasted-image-20241230135801.png" target="_self"><br>1일의 유효기간을 갖는 uid를 발급하여, 인입코드 / Hit된 기능 주소 / 시간 을 저장한다.
<br>uid는 외부url로 접근시 발급
<br>page_url는 코드에 미리 등록 / hit_code는 모두(only 영문+숫자) 수용 가능
<br><img alt="Pasted image 20250102160213.png" src="사진-및-문서/pasted-image-20250102160213.png" target="_self"><br>
<img alt="Pasted image 20250102160223.png" src="사진-및-문서/pasted-image-20250102160223.png" target="_self"><br>
<br>enum객체에 정의된 메서드를 DB로 전환하여 pointcut에서 해당 클래스, 메서드를 가져와 조건으로 정의
<br>해당 조건에 부합하는 메서드를 프록시로 전환
<br>
<br>api호출을 통해 advice내의 동작은 런타임 환경에서 동적으로 변경이 가능한 것을 확인했다.
<br>
<br>런타입 위빙 방식이라고 하더라도, 변경은 불가능하다.
<br>컴파일 위빙 방식은 컴파일 단계에서 원본 클래스 바이트코드를 변경하여 직접 위빙을 하는 방식이고,<br>
런타임 위빙은 런타임단계에서 원본 클래스를 변경하지 않고 프록시 객체를 사용하여 교체하는 방식이다.
<br>=&gt; 해당하는 부분은 리빌드와 큰 차이가 없고, 각 class에 scope를 따로 적용해야했기 때문에 고려하지 않았다.<br>=&gt; 연관성 있는 모든 참조를 수동으로 재설정해야하기 때문에 매우 복잡해진다.<br>
<br>참조를 갱신하기 위해서는 Java리플렉션을 사용하여 강제로 참조를 갱신하거나, AspectJ의 런타임 위빙 방식을 활용해야 한다.
<br>따라서, 서버 Kill을 하는 것과 진배 없으며, 권장하지 않는 방법이다.
<br>이슈
내부통계기능(AOP)의 진입URL에서 네이버 아날리틱스(외부 통계 프로그램)가 작동하지 않는 이슈
<br>
<br>외부 유입통계 페이지의 인입 주소는 일반적인 메인 페이지가 아닌, Gate를 거쳐서(redirect) 동작하게 된다.
<br>이 때, 진입 referrer에 변동이 생기면서 집계가 되지 않는 오류가 발생한 것으로 보인다.
<br>
<br>해당 방법을 사용하여, View단을 추가하여 replace한다면, 처음 진입시 갖고 있는 referrer를 물고 갈수 있지 않을까?
<br>redirect대신 view단을 통해 진입하도록 만든 후, naver아날리틱스 스크립트를 추가한다.
<br>한계 : 외부 유입시 불필요한 페이지 방문이 생기게 되고, 유입과정의 시간이 증가한다. 또한, 해당 오류를 100% 해결할지 미지수
<br>
<br>해당 방법은 기존 naver아날리틱스를 사용하고 있는 로직을 그대로 사용하는 것이기 때문에 제일 확실하다.
<br>한계 : 외부유입자가 아닌, 모든 사용자에게 session및 uid체크가 들어가기 때문에 부하가 증가한다.(DB통신은 X)
<br>
<br>BEST🖐
<br>한계 : 네이버 아날리틱스의 내부로직 파악이 불가함
<br>
<br>현재 네이버의 내부 로직 파악이 불가하니, View를 추가하여 네이버 스크립트가 물고 가는지 먼저 TEST하도록 하기
<br>&lt;html xmlns:th="http://www/thymeleaf.org" th:replace="layout/mainLayout :: mainLayout('gate loan')"&gt; &lt;script th:inline="javascript"&gt; $(document).ready(function() { location.href = [[${urls.SP_LOAN}]]; }); &lt;/script&gt;
<br>mainLayout을 적용하여 해당 페이지에 default script를 적용시켰다.<br>
결과는 추후 모니터링 예정<br>Quote
sp/loan기준으로 레퍼러를 https://www-stg.hellofunding.co.kr/sp/loan/gtLoan?p=Z29vZ2xlMXN0 인입페이지 주소를 갖고있는것을 확인했다.
<br>2025-02-25 14:34:04 [hello-app-staging-7985c4d74f-47qnx] INFO com.hellofintech.hellofunding.common.interceptor.ServiceHandlerInterceptor[mergeIntoVisitCount:187] - referer = https://www-stg.hellofunding.co.kr/sp/loan/gtLoan?p=Z29vZ2xlMXN0
<br><img alt="Pasted image 20250226145129.png" src="사진-및-문서/pasted-image-20250226145129.png" target="_self"><br>확인 결과이미 sendRedirect 로직에서도 Header의 Referer를 물고있었다.<br>
어떠한 referrer를 기준으로 집계를 하는지 정확한 파악이 필요하다.
<br>[부록]<br>
<a data-href="👩‍👧‍👦 Analytics 공통모듈 ADMIN용 데이터 추출" href="project/hello-marketing/👩‍👧‍👦-analytics-공통모듈-admin용-데이터-추출.html" class="internal-link" target="_self" rel="noopener nofollow">👩‍👧‍👦 Analytics 공통모듈 ADMIN용 데이터 추출</a>]]></description><link>project/hello-marketing/👩‍👧‍👦-marketing-analytics-공통모듈-제작기.html</link><guid isPermaLink="false">project/hello marketing/👩‍👧‍👦 marketing Analytics 공통모듈 제작기.md</guid><pubDate>Tue, 04 Mar 2025 07:32:25 GMT</pubDate><enclosure url="사진-및-문서/pasted-image-20241224144309.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="사진-및-문서/pasted-image-20241224144309.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[💻 프로젝트]]></title><description><![CDATA[<a class="tag" href="?query=tag:프로젝트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로젝트</a> <a class="tag" href="?query=tag:모음" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#모음</a> <br> <a href=".?query=tag:프로젝트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로젝트">#프로젝트</a> <a href=".?query=tag:모음" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#모음">#모음</a><br>프로젝트
public하게 공개할 수 있는 프로젝트의 제작 과정입니다.
<br>
<br><a data-href="🏹 예치금 차액 비교 Spring Batch 리펙토링" href="project/hello-batch/🏹-예치금-차액-비교-spring-batch-리펙토링.html" class="internal-link" target="_self" rel="noopener nofollow">🏹 예치금 차액 비교 Spring Batch 리펙토링</a>⭐
<br><a data-href="🏹 예치금 차액 비교 Spring Batch 리펙토링 부록" href="project/hello-batch/🏹-예치금-차액-비교-spring-batch-리펙토링-부록.html" class="internal-link" target="_self" rel="noopener nofollow">🏹 예치금 차액 비교 Spring Batch 리펙토링 부록</a>
<br><a data-href="✏ Chunk_Partitioning Batch 구조 드로잉" href="project/hello-batch/✏-chunk_partitioning-batch-구조-드로잉.html" class="internal-link" target="_self" rel="noopener nofollow">✏ Chunk_Partitioning Batch 구조 드로잉</a>
<br>
<br><a data-href="👩‍👧‍👦 marketing Analytics 공통모듈 제작기" href="project/hello-marketing/👩‍👧‍👦-marketing-analytics-공통모듈-제작기.html" class="internal-link" target="_self" rel="noopener nofollow">👩‍👧‍👦 marketing Analytics 공통모듈 제작기</a>⭐
<br><a data-href="👩‍👧‍👦 Analytics 공통모듈 ADMIN용 데이터 추출" href="project/hello-marketing/👩‍👧‍👦-analytics-공통모듈-admin용-데이터-추출.html" class="internal-link" target="_self" rel="noopener nofollow">👩‍👧‍👦 Analytics 공통모듈 ADMIN용 데이터 추출</a>
<br>
<br><a data-href="👻 Obsidian 정적호스팅 CICD 과정" href="project/note-ci_cd/👻-obsidian-정적호스팅-cicd-과정.html" class="internal-link" target="_self" rel="noopener nofollow">👻 Obsidian 정적호스팅 CICD 과정</a>
<br><a data-href="⛈ Obsidian-AWS연동" href="project/note-ci_cd/⛈-obsidian-aws연동.html" class="internal-link" target="_self" rel="noopener nofollow">⛈ Obsidian-AWS연동</a>
<br>
<br><a data-href="📘 SpringBoot &amp; Docker + Reids 연동" href="tools/docker/📘-springboot-&amp;-docker-+-reids-연동.html" class="internal-link" target="_self" rel="noopener nofollow">📘 SpringBoot &amp; Docker + Reids 연동</a>
<br><a data-href="🌥 aws(EC2)셋팅부터 배포까지" href="tools/aws/🌥-aws(ec2)셋팅부터-배포까지.html" class="internal-link" target="_self" rel="noopener nofollow">🌥 aws(EC2)셋팅부터 배포까지</a>]]></description><link>project/💻-프로젝트.html</link><guid isPermaLink="false">project/💻 프로젝트.md</guid><pubDate>Tue, 04 Mar 2025 05:53:13 GMT</pubDate></item></channel></rss>