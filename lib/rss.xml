<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Category]]></title><description><![CDATA[Obsidian digital garden]]></description><link>https://lts.kr/</link><image><url>https://lts.kr/lib/media/favicon.png</url><title>Category</title><link>https://lts.kr/</link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Mon, 12 May 2025 09:04:07 GMT</lastBuildDate><atom:link href="https://lts.kr/lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Mon, 12 May 2025 09:04:05 GMT</pubDate><copyright><![CDATA[taesung's Blog]]></copyright><ttl>60</ttl><dc:creator>taesung's Blog</dc:creator><item><title><![CDATA[🏠 taesung's Blog]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:home" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#home</a> <a class="tag" href="https://lts.kr/?query=tag:index" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#index</a> <a class="tag" href="https://lts.kr/?query=tag:blog" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#blog</a> <a class="tag" href="https://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <br> <a href="https://lts.kr?query=tag:home" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#home">#home</a> <a href="https://lts.kr?query=tag:index" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#index">#index</a> <a href="https://lts.kr?query=tag:blog" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#blog">#blog</a> <a href="https://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a><br><a data-tooltip-position="top" aria-label="https://github.com/LeeTaeSung0628" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/LeeTaeSung0628" target="_self"><span alt="prof2.jpg" src="prof2.jpg" class="internal-embed media-embed image-embed is-loaded" style="width: 250px; max-width: 100%;"></span></a><img alt="prof2.jpg" src="https://lts.kr/사진-및-문서/prof2.jpg" style="width: 250px; max-width: 100%;" target="_self"><br><a data-tooltip-position="top" aria-label="https://git.io/typing-svg" rel="noopener nofollow" class="external-link is-unresolved" href="https://git.io/typing-svg" target="_self"></a><img alt="Typing SVG" src="https://readme-typing-svg.demolab.com?font=Fira+Code&amp;pause=1000&amp;color=36A9F7&amp;random=false&amp;width=435&amp;lines=%EC%97%AC%EA%B8%B0%EB%8A%94+%EA%B3%B5%EB%B6%80%ED%95%98%EA%B3%A0%2C+%EA%B8%B0%EB%A1%9D%ED%95%98%EB%8A%94+%EA%B3%B3%EC%9E%85%EB%8B%88%EB%8B%A4" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br>]]></description><link>https://lts.kr/🏠-taesung's-blog.html</link><guid isPermaLink="false">🏠 taesung's Blog.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Mon, 12 May 2025 09:03:45 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/prof2.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/prof2.jpg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🚞 Java 대용량 Excel 리펙토링]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:프로젝트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로젝트</a> <a class="tag" href="https://lts.kr/?query=tag:개발" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#개발</a> <a class="tag" href="https://lts.kr/?query=tag:JAVA" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#JAVA</a> <a class="tag" href="https://lts.kr/?query=tag:Excel" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Excel</a> <a class="tag" href="https://lts.kr/?query=tag:엑셀" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#엑셀</a> <a class="tag" href="https://lts.kr/?query=tag:성능개선" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#성능개선</a> <a class="tag" href="https://lts.kr/?query=tag:리펙토링" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#리펙토링</a> <br> <a href="https://lts.kr?query=tag:프로젝트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로젝트">#프로젝트</a> <a href="https://lts.kr?query=tag:개발" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#개발">#개발</a> <a href="https://lts.kr?query=tag:JAVA" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#JAVA">#JAVA</a> <a href="https://lts.kr?query=tag:Excel" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Excel">#Excel</a> <a href="https://lts.kr?query=tag:엑셀" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#엑셀">#엑셀</a> <a href="https://lts.kr?query=tag:성능개선" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#성능개선">#성능개선</a> <a href="https://lts.kr?query=tag:리펙토링" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#리펙토링">#리펙토링</a><br>
<br>기존 DataTables기반의 Excel export 기능의 성능 부진으로 인한 리펙토링
<br>클라이언트 → 서버사이드 로의 로직 변경
<br>DataTables 기반의 기존 처리
** DataTables란? HTML 테이블을 동적으로 처리하기 위한 jQuery 플러그인이다.
DataTables의 기능 중 Export 기능이 있는데, 클립보드 복사와 인쇄 등 의 기능도 지원한다.<br>
기존의 Excel출력 기능이 이 DataTables의 Export 기능으로 만들어져 있었다.
<br>
DataTables는 클라이언트 측에서 브라우저 메모리를 사용하여 엑셀 파일을 생성한다.
웹 HTML기반의 `DataTables Buttons`를 사용하여 데이터와 스타일을 엑셀 파일로 변환한다.<br>
<br>브라우저 메모리 한계 <br>브라우저는 서버보다 메모리와 CPU 성능이 낮다.
<br>대용량 데이터를 처리할 때 브라우저가 멈추거나 충돌할 가능성이 크다.
<br>DataTables는 전체 데이터를 메모리에 적재한 후 엑셀로 변환한다.
<br>Ajax로 부분 데이터를 불러오는 서버사이드 모드에서는 현재 페이지 데이터만 엑셀로 변환됩니다.
<br>모든 데이터를 한꺼번에 가져와 처리하면 처리 한계에 도달할 가능성이 더 커진다. <br>ex) 10만 개 이상의 행을 엑셀로 내보내면 브라우저의 메모리 한계를 초과하여 강제로 종료되는 경우가 많다.<br>
<br>파일 변환 속도 <br>JavaScript 기반으로 파일을 생성하는 데 시간이 많이 소요된다.
<br>데이터 변환과 파일 생성이 모두 싱글 스레드로 이루어져 병렬 처리의 이점을 활용하지 못한다. <br>
<br>스타일 커스터마이징의 복잡성 <br>엑셀 스타일을 커스터마이징하는 과정이 복잡하며, XML 직접 수정 방식은 성능 저하를 초래한다.
<br>파일의 구조와 스타일을 모두 제어하려면 JavaScript 메모리 부담이 더욱 커진다. <br>정리
소규모 데이터의 Export에는 간단한 설정으로 빠른 구현이 가능하나.<br>
10만개 이상의 대용량 데이터에서는 한계가 명확하다.
<br>... buttons: [ { extend: 'excel', name: 'Excel', text: 'Excel', filename: '엑셀출력_' + moment().format('YYYYMMDDhhmm'), title: '', action: serverSideButtonAction, customize: function(xlsx) { var sSh = xlsx.xl['styles.xml']; var lastXfIndex = $('cellXfs xf', sSh).length - 1; var sheet = xlsx.xl.worksheets['sheet1.xml']; // 스타일 적용 var n1 = '&lt;xf numFmtId="0" fontId="2" fillId="2" borderId="1" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyAlignment="1"&gt;' + '&lt;alignment horizontal="center"/&gt;&lt;/xf&gt;'; var n2 = '&lt;xf numFmtId="0" fontId="0" fillId="0" borderId="1" applyFont="0" applyFill="0" applyBorder="0" xfId="0" applyAlignment="0"&gt;' + '&lt;alignment horizontal="right"/&gt;&lt;/xf&gt;'; sSh.childNodes[0].childNodes[5].innerHTML += n1 + n2; var greyBoldCentered = lastXfIndex + 1; var value = lastXfIndex + 2; $('c', sheet).attr('s', value); $('row:first c', sheet).attr('s', greyBoldCentered); } }
] <br>
<br>서버의 자원 활용 <br>서버의 메모리와 CPU는 클라이언트보다 월등히 높아 대량 데이터 처리에 유리하다.
<br>서버가 Excel 파일을 직접 생성하여 브라우저에 전송하므로 클라이언트의 부담이 줄어든다. <br>
<br>대용량 데이터 처리 <br>수십만 건 이상의 데이터를 메모리 효율적으로 처리 가능
<br>Apache POI와 같은 라이브러리는 스트리밍 방식으로 데이터를 파일에 직접 기록하여 메모리 과부하를 방지한다.
<br>SXSSFWorkbook를 사용하여 매우 큰 데이터를 처리할 수 있습니다. <br>SXSSFWorkbook란?
Apache POI 라이브러리에서 제공하는 대용량 Excel 파일 생성용 클래스<br>
SXSSFWorkbook은 메모리 절약을 위해 디스크 기반 스트리밍 방식을 사용하여 메모리에 모든 데이터를 올리지 않고, 필요한 부분만 메모리에 유지한다.
<br>
<br>병렬 처리 <br>멀티스레딩을 통해 데이터 수집과 파일 생성을 병렬로 수행할 수 있다.
<br>서버 자원을 최대로 활용하여 성능을 극대화할 수 있다. <br>
<br>직접 파일 다운로드 <br>엑셀 파일을 서버에서 생성하고, URL을 통해 클라이언트가 다운로드 받도록 처리하여 브라우저 부담 최소화.
<br>응답을 스트리밍 방식으로 처리하여 중간에 데이터가 소실되지 않도록 보장한다. <br>
<br>엑셀 파일 처리 클래스
<br>엑셀파일 생성, 데이터 추가, 스타일 적용 등
<br>SXSSFWorkbook방식으로 스트리밍 처리 <br>대용량 처리에 적합
<br>일정 개수 이상의 row를 디스크로 flush
<br>OutOfMemory방지 <br>for (T t : data) { renderBody(t, rowNum, bodyStyle, totalStyle, accumStyle); if (rowNum % 10000 == 0 || rowNum == data.size()) { // 10,000건 마다 flush try { // 마지막 데이터의 경우, 남는 데이터 만큼만 flush, 아닌경우 10,000건씩 플러쉬 workbook.getSheet(sheetName).flushRows(rowNum == data.size() ? data.size() % 10000 : 10000); } catch (IOException e) { throw new BadRequestException(e.getMessage()); } } rowNum++; }
<br>Excel Sheet정보 파라미터로 받아서 초기화
<br>SimpleExcelMetaDataFactory를 이용하여 엑셀 메타데이터를 생성
<br>전체적인 엑셀 다운로드까지의 모든 단계를 포함하고 실제 랜더링해서 셀을 생성하는것
<br>
<br>싱글톤 객체로 생성
<br>엑셀로 출력할 DTO객체의 어노테이션을 파악해 메타데이터 정리
<br>SimpleExcelMetadata객체를 생성하기 위한 기본 틀 제공(헤더, 스타일, 필드 목록 등)
<br>CellStyleMap을 사용하여 각 필드의 스타일을 미리 캐싱 ( 스타일 중복 방지 )
<br>private void applyCellStyle(CellStyleMap cellStyleMap, ExcelColumnStyle fieldStyle, ExcelColumnStyle classDefaultStyle, String fieldName, CellPart part, Workbook workbook) { /* dto 의 field 값에 스타일이 설정되어 있는지 체크 */ boolean styleCheck = fieldStyle.excelCellStyleClass() != NullStyle.class; /* dto 의 field 에 스타일 존재 유무에 따라, ExcelCellKey 의 fieldName 지정 */ String fieldNameKey = styleCheck ? fieldName : "DEFAULT"; /* dto 의 field 에 스타일 존재 유무에 따라 스타일 설정 */ ExcelColumnStyle style = styleCheck ? fieldStyle : classDefaultStyle; ExcelCellKey excelCellKey = ExcelCellKey.of(fieldNameKey, part); /* 해당 키값과 같은 키값을 가진 데이터가 있는 경우 styleMap 에 추가하지 않음 */ if (!cellStyleMap.valueCheck(excelCellKey)) { cellStyleMap.put(decideAppliedStyle(style, workbook), excelCellKey, workbook); } }
<br>스타일, 정보등 dto 어노테이션 필드들을 읽어와서 파악하고, 가공하여 SimpleExcelFile에서 사용하기 쉽게 만드는 역할
<br>
<br>@DefaultExcelHeaderStyle: 엑셀 헤더에 기본 스타일 적용 <br>스타일: HeaderStyle.class <br>@DefaultExcelBodyStyle: 엑셀 데이터 행에 기본 스타일 적용 <br>스타일: BodyStyle.class <br>@DefaultExcelTotalRow: 합계 행에 기본 스타일 적용
<br>@DefaultExcelHeaderStyle(style = @ExcelColumnStyle(excelCellStyleClass = HeaderStyle.class)) @DefaultExcelBodyStyle(style = @ExcelColumnStyle(excelCellStyleClass = BodyStyle.class)) @DefaultExcelTotalRow(style = @ExcelColumnStyle(excelCellStyleClass = TotalRowStyle.class)) public class PgDepositListExcelDto { @ExcelColumn(headerName = "No") private String rowNum; @ExcelColumn(headerName = "회원번호") private String mbNo; @ExcelColumn(headerName = "아이디") private String mbId; @ExcelColumn( headerName = "금액", bodyStyle = @ExcelColumnStyle(excelCellStyleClass = AmountStyle.class), totalRowStyle = @ExcelColumnStyle(excelCellStyleClass = TotalAmountStyle.class) ) private long amt;
<br>실제 객체와 맵핑될 excelDTO객체
<br>SimpleExcelMetaDataFactory에서 @ExcelColumn 어노테이션이 붙은 필드를 수집하여 리스트에 저장<br>public SimpleExcelMetadata createSimpleExcelMetaData( Class&lt;?&gt; type, Workbook workbook, SheetType sheetType, boolean hasGroupHeader) { List&lt;Field&gt; fields = getExcelAnnotatedFields(type); List&lt;String&gt; headerNames = new ArrayList&lt;&gt;(); for (Field field : fields) { ExcelColumn excelColumn = field.getAnnotation(ExcelColumn.class); // 어노테이션 체크 String headerName = excelColumn.headerName(); headerNames.add(headerName); applyCellStyle(cellStyleMap, excelColumn.headerStyle(), null, field.getName(), HEADER, workbook); } return new SimpleExcelMetadata(headerNames, fields, cellStyleMap, groups);
} <br>
<br>엑셀로 출력할 기존 객체 → CustomExcelDto로 파싱 후 simpleExcelWrite로 엑셀 출력
<br>쿼리 데이터 조회시 페이징으로 메모리 관리
<br><img alt="Pasted image 20250512180307.png" src="https://lts.kr/사진-및-문서/pasted-image-20250512180307.png" target="_self">]]></description><link>https://lts.kr/project/🚞-java-대용량-excel-리펙토링.html</link><guid isPermaLink="false">project/🚞 Java 대용량 Excel 리펙토링.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Mon, 12 May 2025 09:03:13 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/pasted-image-20250512180307.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/pasted-image-20250512180307.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[💻 프로젝트]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:프로젝트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로젝트</a> <a class="tag" href="https://lts.kr/?query=tag:모음" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#모음</a> <br> <a href="https://lts.kr?query=tag:프로젝트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로젝트">#프로젝트</a> <a href="https://lts.kr?query=tag:모음" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#모음">#모음</a><br>프로젝트
public하게 공개할 수 있는 프로젝트의 제작 과정입니다.
<br>
<br><a data-href="🏹 예치금 차액 비교 Spring Batch 리펙토링" href="https://lts.kr/project/hello-batch/🏹-예치금-차액-비교-spring-batch-리펙토링.html" class="internal-link" target="_self" rel="noopener nofollow">🏹 예치금 차액 비교 Spring Batch 리펙토링</a>⭐
<br><a data-href="🏹 예치금 차액 비교 Spring Batch 리펙토링 부록" href="https://lts.kr/project/hello-batch/🏹-예치금-차액-비교-spring-batch-리펙토링-부록.html" class="internal-link" target="_self" rel="noopener nofollow">🏹 예치금 차액 비교 Spring Batch 리펙토링 부록</a>
<br><a data-href="✏ Chunk_Partitioning Batch 구조 드로잉" href="https://lts.kr/project/hello-batch/✏-chunk_partitioning-batch-구조-드로잉.html" class="internal-link" target="_self" rel="noopener nofollow">✏ Chunk_Partitioning Batch 구조 드로잉</a>
<br>
<br><a data-href="👩‍👧‍👦 marketing Analytics 공통모듈 제작기" href="https://lts.kr/project/hello-marketing/👩‍👧‍👦-marketing-analytics-공통모듈-제작기.html" class="internal-link" target="_self" rel="noopener nofollow">👩‍👧‍👦 marketing Analytics 공통모듈 제작기</a>⭐
<br><a data-href="👩‍👧‍👦 Analytics 공통모듈 ADMIN용 데이터 추출" href="https://lts.kr/project/hello-marketing/👩‍👧‍👦-analytics-공통모듈-admin용-데이터-추출.html" class="internal-link" target="_self" rel="noopener nofollow">👩‍👧‍👦 Analytics 공통모듈 ADMIN용 데이터 추출</a>
<br>
<br><a data-href="🚞 Java 대용량 Excel 리펙토링" href="https://lts.kr/project/🚞-java-대용량-excel-리펙토링.html" class="internal-link" target="_self" rel="noopener nofollow">🚞 Java 대용량 Excel 리펙토링</a>
<br>
<br><a data-href="✈MM_클라우드 마이그레이션" href="https://lts.kr/project/melometer-project/✈mm_클라우드-마이그레이션.html" class="internal-link" target="_self" rel="noopener nofollow">✈MM_클라우드 마이그레이션</a>
<br>
<br><a data-href="👻 Obsidian 정적호스팅 CICD 과정" href="https://lts.kr/project/note-ci_cd/👻-obsidian-정적호스팅-cicd-과정.html" class="internal-link" target="_self" rel="noopener nofollow">👻 Obsidian 정적호스팅 CICD 과정</a>
<br>
<br><a data-href="📘 SpringBoot &amp; Docker + Reids 연동" href="https://lts.kr/tools/docker/📘-springboot-&amp;-docker-+-reids-연동.html" class="internal-link" target="_self" rel="noopener nofollow">📘 SpringBoot &amp; Docker + Reids 연동</a>
<br><a data-href="🌥 aws(EC2)셋팅부터 배포까지" href="https://lts.kr/tools/aws/🌥-aws(ec2)셋팅부터-배포까지.html" class="internal-link" target="_self" rel="noopener nofollow">🌥 aws(EC2)셋팅부터 배포까지</a>]]></description><link>https://lts.kr/project/💻-프로젝트.html</link><guid isPermaLink="false">project/💻 프로젝트.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Thu, 08 May 2025 07:21:32 GMT</pubDate></item><item><title><![CDATA[🐹 MSA(Microservices Architecture)]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="https://lts.kr/?query=tag:구조" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#구조</a> <a class="tag" href="https://lts.kr/?query=tag:설계" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#설계</a> <a class="tag" href="https://lts.kr/?query=tag:MSA" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#MSA</a> <a class="tag" href="https://lts.kr/?query=tag:CloudNative" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#CloudNative</a> <br> <a href="https://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="https://lts.kr?query=tag:구조" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#구조">#구조</a> <a href="https://lts.kr?query=tag:설계" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#설계">#설계</a> <a href="https://lts.kr?query=tag:MSA" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#MSA">#MSA</a> <a href="https://lts.kr?query=tag:CloudNative" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#CloudNative">#CloudNative</a><br>
<br>msa는 대규모 애플리케이션을 독립적으로 배포 가능한 작은 서비스들의 집합으로 구성하는 소프트웨어 설계 접근 방식이다.
<br>각 서비스는 특정 비즈니스 기능을 담당하며, 자체 데이터 저장소를 보유하고(선택), 독립적으로 개발 및 배포가 가능하다.
<br>msa는 확장성, 유지보수성, 유연성 향상 등의 이점을 제공하지만 복잡한 운영과 통신 관리 등의 문제도 동반하고있다.
<br>모놀리식 아키텍처(Monolithic Architecture)
모든 기능이 단일 코드베이스에 포함되어 하나의 배포 단위로 운영되는 방식. <br>초기개발과 배포가 빠르고 간단하지만, 애플리케이션이 비대화 될 수록 다음과 같은 문제 발생 <br>확장성 제한: 전체 애플리케이션을 확장해야 하므로 자원 낭비가 발생할 수 있음
<br>배포 리스크 증가: 작은 변경도 전체 시스템의 재배포를 요구하여 위험이 증가
<br>유지보수 어려움: 코드베이스가 커지면 이해와 수정이 어려워짐 <br>MSA는 애플리케이션을 작은 서비스로 분리하여, 각 서비스가 독립적으로 개발, 배포, 확장 될 수 있도록 한다.
즉, 위의 모놀리식 아키텍처의 단점을 모두 보완하는 특징을 갖고 있다.<br>
<br>배포
<br>서비스별 개별 배포가 가능(배포시 전체 서비스의 중단이 없음)
<br>특정 서비스의 요구사항만을 반영하여, 빠르게 배포 가능
<br>확장
<br>특정 서비스에 대한 확장성(scale-out)이 유리하다.
<br>Cloud Native Architecture에 적합하다. <br>장애
<br>일부 장애가 전체 서비스로 확장될 가능성이 적다.(장애 격리가 쉽다)
<br>그 외
<br>새로운 기술을 적용하기 유연하다.(전체 서비스가 아닌 특정 서비스만 별도의 기술 또는 언어로 구현 가능)
<br>각각의 서비스에 대한 구조 파악 및 분석이 모놀리식 구조에 비해 쉽다.
<br>
<br>설계의 어려움
<br>MSA는 모놀리식에 비해 상대적으로 많이 복잡하다. 또한, 통신의 장애와 서버의 부하 등을 고려하여 transaction을 유지할지 결정해야 한다.
<br>성능
<br>서비스 간 호출 시 API를 사용하므로, 통신 비용이나 Latency에 대해 이슈가 존재.
<br>테스트/데이터 트랜잭션
<br>모놀리식에서는 단일 트랜잭션을 유지하면 됐지만 MSA에서는 비즈니스에 대한 DB를 가지고 있는 서비스도 각기 다르고, 서비스의 연결을 위해서는 통신이 포함되기 때문에 트랜잭션을 일관되게 유지하며 개발하는게 어렵다. <br>통합 테스트가 어렵다. 개발 환경과 실제 운영환경을 동일하게 가져가는 것의 어려움 <br>데이터 관리
<br>데이터가 여러 서비스에 분산되어 있어 관리하는데 어려움이 있다.
<br>그래서 msa가 무조건 좋은것인가? <br>설계방식에 대한 정답은 없다. 하지만, 많은 기업들이 MSA를 적용하여 글로벌 서비스를 성공적으로 확장시켰다는 것은 확실하다. <br>또한, Cloud 기반의 서비스에 매우적합한 방식이라는 것도 자명하다. 하지만, MSA를 무조건 적으로 적용하는 것 보다는 현재프로젝트의 규모, 통신 방식등을 적절하게 산정/예상하여 단점보다 장점이 커 보인다고 생각될 때 적용하는 것이 바람직 해 보인다. <br>
<br>MSA는 단순히 서비스를 여러 개로 나누는 것이 아니라, 개별 서비스가 독립적으로 개발, 배포, 운영될 수 있도록 설계하는 것이 핵심이다.
<br>그렇지 않으면 모놀리식 아키텍처와 다를 바 없다. 따라서, 적절한 설계 원칙을 적용하여 설계를 진행하여야 한다.
<br> SRP는 각 서비스가 하나의 명확한 역할을 수행해야 한다는 원칙이다. 이를 따르지 않으면 서비스가 점점 커지면서 결국 모놀리식 구조와 다름없어질 수 있음을 알아야 한다.<br>
<br>서비스 내부의 응집도는 높이고, 서비스 간의 결합도는 낮춰야 한다. 응집도가 높은 서비스는 유지보수가 용이하며, 변경 시 다른 기능에 영향을 최소화할 수 있다. 반면, 결합도가 높으면 서비스 간 변경 사항이 전파되면서 독립적인 배포가 어려워지고, 장애 전파의 위험도 커진다.
<br>
<br>각 서비스는 명확한 도메인 역할을 가져야 한다(DDD). 예를 들어, 주문 서비스는 주문 관련 로직만을 담당하고, 결제 서비스는 결제와 관련된 기능만을 처리해야 한다. 이를 통해 개발, 배포, 확장이 용이해지고, 운영 비용을 절감할 수 있다.
<br>서비스는 서로 독립적으로 운영될 수 있어야 한다. 특정 서비스가 다운되더라도 전체 시스템이 영향을 받지 않도록 설계하는 것이 중요하다.<br>
<br>서비스 간 통신은 동기 호출보다는 비동기 메시징 또는 이벤트 기반 방식을 활용하는 것이 좋다. 이를 통해 특정 서비스가 응답하지 않아도 전체 시스템이 멈추지 않도록 할 수 있다.
<br>
<br>서비스 간의 직접적인 의존성을 최소화해야 한다. 예를 들어, 한 서비스가 다른 서비스의 데이터베이스에 직접 접근하는 것은 피해야 하며, API나 이벤트 기반 방식으로 데이터를 교환해야 한다.
<br>MSA 환경에서는 특정 서비스에서 장애가 발생하더라도 다른 서비스로 확산되지 않도록 격리하는 것이 필수적이다.<br>
<br>서킷 브레이커는 특정 서비스가 응답하지 않을 때, 일정 횟수 이상 요청이 실패하면 추가 요청을 차단하는 패턴이다. 이를 통해 과부하를 방지하고, 장애가 확산되는 것을 막을 수 있다.
<br>
<br>서비스 장애 발생 시, 기본적인 대체 응답을 제공하는 폴백 전략을 사용하면 사용자 경험을 유지할 수 있다. 예를 들어, 추천 서비스가 장애가 발생하면 기본 인기 상품 목록을 반환하는 식.
<br>
<br>서비스의 상태를 지속적으로 모니터링하여 장애 발생을 사전에 감지하고 대응할 수 있도록 해야 한다.
<br>MSA에서는 수많은 서비스가 존재하므로 수작업으로 운영하기에는 한계가 있다. 따라서 <a data-href="CICD" href="https://lts.kr/짧은-키워드/cicd.html" class="internal-link" target="_self" rel="noopener nofollow">CICD</a> 파이프라인과 Kubernetes 기반의 자동화가 필수적이다.<br>
<br>코드 변경 사항을 빠르게 배포할 수 있도록 지속적인 통합 및 배포(CI/CD)를 구축해야 한다. 이를 통해 배포 속도를 높이고, 변경에 대한 위험을 줄일 수 있다.
<br>
<br>Kubernetes를 활용하면 서비스 배포, 확장, 롤백을 자동화할 수 있다. 이를 통해 인프라 관리의 복잡도를 줄이고, 서비스 안정성을 확보할 수 있다.
<br>MSA에서는 서비스가 분산되어 있기 때문에, 효과적인 모니터링과 로깅이 필수적이다.<br>
<br>서비스 간 요청 흐름을 추적하기 위해 분산 추적 시스템(OpenTelemetry, Jaeger)을 활용하여 성능 저하 원인을 빠르게 파악할 수 있다.
<br>
<br>각 서비스에서 발생하는 로그를 한곳에 수집하여 관리해야 한다. 중앙 집중식 로깅 시스템(ELK Stack, Grafana Loki)을 활용하면 장애 발생 시 원인을 빠르게 분석할 수 있다.
<br>
<br>서비스의 CPU, 메모리 사용량, 응답 시간 등을 지속적으로 모니터링하고, 이상 징후를 사전에 감지하여 대응할 수 있도록 해야 한다.
<br> <br>MSA를 설계할 때, 적절한 서비스 분해 전략을 선택하는 것 또한 매우 중요하다.
일반적인 분해 전략은 다음과 같다.<br>비즈니스 기능 기반 분해: 각 서비스가 특정 비즈니스 기능을 담당하도록 분해한다. 예를 들어, 주문 관리, 결제 처리, 사용자 인증 등을 각각의 서비스로 나눌 수 있다.
<br>
<br>하위 도메인 기반 분해: 도메인 주도 설계(DDD)를 활용하여 하위 도메인별로 서비스를 분리한다. 고객이 발생시키는 이벤트를 시작점으로 하여 Path를 발경하는 Event Storming 기법도 있다.
<br>
<br>트랜잭션 경계 기반 분해: 트랜잭션 경계를 기준으로 서비스를 분리하여 데이터 일관성을 유지한다.
<br>이러한 분해 전략을 통해 서비스 간의 결합도를 낮추고, 독립적인 개발과 배포가 가능하도록 설계할 수 있다.<br>주의점
MSA를 도입하며, 기능(도메인)의 경계를 명확히 하는것은 생각보다 쉽지 않다.<br>
특히 핵심 기능을 분리할 때 어려운 점이 있다. <br>핵심 기능은 다른 기능들과의 결합도가 높다
<br>핵심 기능일 수록 장기간의 유지보수로 인하여, 도메인간의 경계가 명확하지 않을 가능성이 높다 이러한 핵심 기능들은 사람의 눈으로만 판단하는데 어려움이 있기 떄문에, 다양한 정적 분석도구를 활용하면 좋다.
<br>다음은 MSA에서 유연성과 확장성을 확보하기 위한 주요 서비스 분리 원칙이다.
<br>
<br>분리 대상 서비스를 확정하고 나서는, 기존 모놀리식 코드를 재사용 할것인지, 재개발 할것인지를 고민해야한다.
<br>일반적으로 코드를 재사용하여 서비스를 구성하는 것이 효율적으로 보이지만 오히려 비효율을 초래할 가능성이 크다.
<br>오랜 기간 유지보수 된 코드의 문제점
<br>기술부채가 많이 쌓여있고, 기술 자체가 오래되었을 가능성이 큼
<br>수없이 변경된 요구사항으로, 비즈니스 도메인이 명확하게 반영되어있지 않을 가능성이 큼
<br>
<br>기능의 완전한 재작성의 장점
<br>요구사항을 다시 파악하여 해당 기능에 대한 비즈니스 도메인을 명확히 할 수 있음
<br>비즈니스에 대한 더놓은 이해를 바탕으로 아키텍처 재설계 가능
<br>기존의 기술부채 해결
<br>새로운 기술 스텍을 도입할 수 있음
<br>모놀리식으로 구현되어있는 코드 전체를 MSA로 전환하는 것은 아주 길고 비용이 많이 드는 일이다.
때문에, 작고 명확한 계획의 여러단계를 만들어 진행하는 것이 유리하다.<br>또한, 서비스를 분리할 때 서비스 범위를 너무 좁게 잡으면 각서비스는 응집도 높은 비즈니스 없이 CRUD만 수행하며 개수는 크게 증가하여 복잡도만 높아질 수 있다.<br>
<br>우선 서비스 단위를 크게 분리한 후, 이후에 설계에 대한 고민을 반복적으로 수행하며 분리작업을 점진적으로 진행하는 것이 가장 바람직 하다고 볼 수 있겠다.
<br> <br>마이크로서비스 아키텍처에서는 서비스 간 통신과 데이터 관리가 중요한 이슈이다.<br>
<br>동기 통신: <a data-href="RESTful API" href="https://lts.kr/짧은-키워드/restful-api.html" class="internal-link" target="_self" rel="noopener nofollow">RESTful API</a>, gRPC 등을 사용하여 실시간으로 요청과 응답을 주고받는 방식. 구현이 간단하지만, 서비스 간의 강한 결합을 초래할 수 있다.
<br>비동기 통신: 메시지 큐(Kafka, RabbitMQ 등)를 활용하여 비동기적으로 메시지를 전달하는 방식. 이는 서비스 간 결합도를 낮추고, 시스템의 확장성과 탄력성을 향상시킨다.
<br>
<br>데이터베이스 분리: 각 서비스는 자체 데이터베이스를 보유하여 데이터 독립성을 확보한다.
<br>데이터 일관성 유지: 분산 트랜잭션을 피하기 위해 SAGA 패턴, 이벤트 소싱 등을 활용하여 데이터 일관성을 유지한다.
<br>MSA는 단순히 시스템을 여러 개의 서비스로 나누는 것이 아니라, 서비스의 독립성, 장애 격리, 자동화, 모니터링 등의 원칙을 철저히 준수하는 것이 핵심이다. 이러한 원칙이 지켜지지 않으면, 시스템은 오히려 더 복잡해지고 운영 비용이 증가할 뿐 아니라 장애 대응도 어려워진다.<br>특히 단일 책임 원칙, 서비스 독립성, 장애 격리, 자동화, 모니터링은 MSA에서 반드시 적용해야 하는 필수 요소이다. 이 원칙들을 바탕으로 MSA를 설계하면 유연한 확장성, 높은 가용성, 효율적인 운영이 가능한 시스템을 구축할 수 있겠다.]]></description><link>https://lts.kr/study/cs/🐹-msa(microservices-architecture).html</link><guid isPermaLink="false">study/CS/🐹 MSA(Microservices Architecture).md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Thu, 08 May 2025 01:02:44 GMT</pubDate></item></channel></rss>