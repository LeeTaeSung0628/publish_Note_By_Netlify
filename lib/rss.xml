<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[blog]]></title><description><![CDATA[Obsidian digital garden]]></description><link>https://lts.kr/</link><image><url>https://lts.kr/lib/media/favicon.png</url><title>blog</title><link>https://lts.kr/</link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Fri, 02 May 2025 01:57:15 GMT</lastBuildDate><atom:link href="https://lts.kr/lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Fri, 02 May 2025 01:57:12 GMT</pubDate><copyright><![CDATA[taesung's Blog]]></copyright><ttl>60</ttl><dc:creator>taesung's Blog</dc:creator><item><title><![CDATA[🏠 taesung's Blog]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:home" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#home</a> <a class="tag" href="https://lts.kr/?query=tag:index" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#index</a> <a class="tag" href="https://lts.kr/?query=tag:blog" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#blog</a> <a class="tag" href="https://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <br> <a href="https://lts.kr?query=tag:home" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#home">#home</a> <a href="https://lts.kr?query=tag:index" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#index">#index</a> <a href="https://lts.kr?query=tag:blog" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#blog">#blog</a> <a href="https://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a><br><a data-tooltip-position="top" aria-label="https://github.com/LeeTaeSung0628" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/LeeTaeSung0628" target="_self"><span alt="prof2.jpg" src="prof2.jpg" class="internal-embed media-embed image-embed is-loaded" style="width: 250px; max-width: 100%;"></span></a><img alt="prof2.jpg" src="https://lts.kr/사진-및-문서/prof2.jpg" style="width: 250px; max-width: 100%;" target="_self"><br><a data-tooltip-position="top" aria-label="https://git.io/typing-svg" rel="noopener nofollow" class="external-link is-unresolved" href="https://git.io/typing-svg" target="_self"></a><img alt="Typing SVG" src="https://readme-typing-svg.demolab.com?font=Fira+Code&amp;pause=1000&amp;color=36A9F7&amp;random=false&amp;width=435&amp;lines=%EC%97%AC%EA%B8%B0%EB%8A%94+%EA%B3%B5%EB%B6%80%ED%95%98%EA%B3%A0%2C+%EA%B8%B0%EB%A1%9D%ED%95%98%EB%8A%94+%EA%B3%B3%EC%9E%85%EB%8B%88%EB%8B%A4" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<a data-href="🌩 Cloud-Native Architecture 분석" href="https://lts.kr/study/cs/🌩-cloud-native-architecture-분석.html" class="internal-link" target="_self" rel="noopener nofollow">🌩 Cloud-Native Architecture 분석</a><br>
<a data-href="🐹 MSA(Microservices Architecture)" href="https://lts.kr/study/cs/🐹-msa(microservices-architecture).html" class="internal-link" target="_self" rel="noopener nofollow">🐹 MSA(Microservices Architecture)</a>
<br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br>]]></description><link>https://lts.kr/🏠-taesung's-blog.html</link><guid isPermaLink="false">🏠 taesung's Blog.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Fri, 02 May 2025 01:56:54 GMT</pubDate><enclosure url="https://lts.kr/사진-및-문서/prof2.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://lts.kr/사진-및-문서/prof2.jpg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[📕 공부]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="https://lts.kr/?query=tag:모음" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#모음</a> <br> <a href="https://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="https://lts.kr?query=tag:모음" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#모음">#모음</a><br>공부
보고 배운 지식 중 공유하고 싶은 정보를 모아둔 카테고리 입니다.
<br>
<br><a data-href="🌩 Cloud-Native Architecture 분석" href="https://lts.kr/study/cs/🌩-cloud-native-architecture-분석.html" class="internal-link" target="_self" rel="noopener nofollow">🌩 Cloud-Native Architecture 분석</a> <br><a data-href="🐹 MSA(Microservices Architecture)" href="https://lts.kr/study/cs/🐹-msa(microservices-architecture).html" class="internal-link" target="_self" rel="noopener nofollow">🐹 MSA(Microservices Architecture)</a>
<br><a data-href="🐋 docker 란" href="https://lts.kr/tools/docker/🐋-docker-란.html" class="internal-link" target="_self" rel="noopener nofollow">🐋 docker 란</a>
<br><a data-href="🚢Kubernetes(k8s)란" href="https://lts.kr/tools/kubernetes/🚢kubernetes(k8s)란.html" class="internal-link" target="_self" rel="noopener nofollow">🚢Kubernetes(k8s)란</a>
<br><a data-href="👔 Jenkins란" href="https://lts.kr/tools/jenkins/👔-jenkins란.html" class="internal-link" target="_self" rel="noopener nofollow">👔 Jenkins란</a><br> <br><a data-href="🐡 Spring Security와 Filter" href="https://lts.kr/study/cs/🐡-spring-security와-filter.html" class="internal-link" target="_self" rel="noopener nofollow">🐡 Spring Security와 Filter</a>
<br><a data-href="🚨 RSA 암호화 방식의 이해와 적용 (feat.취약성점검)" href="https://lts.kr/issue_troubleshooting/🚨-rsa-암호화-방식의-이해와-적용-(feat.취약성점검).html" class="internal-link" target="_self" rel="noopener nofollow">🚨 RSA 암호화 방식의 이해와 적용 (feat.취약성점검)</a>
<br><a data-href="🍎 Redis로 Key관리하기" href="https://lts.kr/study/cs/🍎-redis로-key관리하기.html" class="internal-link" target="_self" rel="noopener nofollow">🍎 Redis로 Key관리하기</a>
<br><a data-href="🌋 OSIV와 영속성 컨텍스트" href="https://lts.kr/study/cs/🌋-osiv와-영속성-컨텍스트.html" class="internal-link" target="_self" rel="noopener nofollow">🌋 OSIV와 영속성 컨텍스트</a>
<br><a data-href="🐰 Java의 String과 SpringBuffer" href="https://lts.kr/study/cs/🐰-java의-string과-springbuffer.html" class="internal-link" target="_self" rel="noopener nofollow">🐰 Java의 String과 SpringBuffer</a>
<br><a data-href="🛬 JDK와 JRE, JVM" href="https://lts.kr/study/cs/🛬-jdk와-jre,-jvm.html" class="internal-link" target="_self" rel="noopener nofollow">🛬 JDK와 JRE, JVM</a>
<br><a data-href="🍊 Spring의 의존성 주입(DI)" href="https://lts.kr/study/cs/🍊-spring의-의존성-주입(di).html" class="internal-link" target="_self" rel="noopener nofollow">🍊 Spring의 의존성 주입(DI)</a>
<br><a data-href="🪕 JPA 관련 용어 정리" href="https://lts.kr/study/cs/🪕-jpa-관련-용어-정리.html" class="internal-link" target="_self" rel="noopener nofollow">🪕 JPA 관련 용어 정리</a>
<br>
<br><a data-href="☕ JAVA , OOP" href="https://lts.kr/study/cs/☕-java-,-oop.html" class="internal-link" target="_self" rel="noopener nofollow">☕ JAVA , OOP</a>
<br><a data-href="🍃 Spring" href="https://lts.kr/study/cs/🍃-spring.html" class="internal-link" target="_self" rel="noopener nofollow">🍃 Spring</a>
<br><a data-href="🎩 DevOps" href="https://lts.kr/study/cs/🎩-devops.html" class="internal-link" target="_self" rel="noopener nofollow">🎩 DevOps</a>
<br><a data-href="📔 DataBase" href="https://lts.kr/study/cs/📔-database.html" class="internal-link" target="_self" rel="noopener nofollow">📔 DataBase</a>
<br><a data-href="📭 Server" href="https://lts.kr/study/cs/📭-server.html" class="internal-link" target="_self" rel="noopener nofollow">📭 Server</a>
<br><a data-href="🐞 etc" href="https://lts.kr/study/cs/🐞-etc.html" class="internal-link" target="_self" rel="noopener nofollow">🐞 etc</a>
<br>
<br><a data-href="🤠 Coding Test 풀이 모음" href="https://lts.kr/study/coding-test/🤠-coding-test-풀이-모음.html" class="internal-link" target="_self" rel="noopener nofollow">🤠 Coding Test 풀이 모음</a>
<br><a data-href="👽 Algorithm" href="https://lts.kr/study/coding-test/👽-algorithm.html" class="internal-link" target="_self" rel="noopener nofollow">👽 Algorithm</a>
<br>
<br><a data-href="🔻 Redis 캐쉬 전략 - hello 서비스에 적용하여 성능개선 가능성" href="https://lts.kr/study/dev-seminar/🔻-redis-캐쉬-전략-hello-서비스에-적용하여-성능개선-가능성.html" class="internal-link" target="_self" rel="noopener nofollow">🔻 Redis 캐쉬 전략 - hello 서비스에 적용하여 성능개선 가능성</a>
<br><a data-href="🔐 상품 투자하기 서비스 Lock기법 개선안" href="https://lts.kr/issue_troubleshooting/🔐-상품-투자하기-서비스-lock기법-개선안.html" class="internal-link" target="_self" rel="noopener nofollow">🔐 상품 투자하기 서비스 Lock기법 개선안</a>
<br><a data-href="🔹 TDD에 대하여" href="https://lts.kr/study/dev-seminar/🔹-tdd에-대하여.html" class="internal-link" target="_self" rel="noopener nofollow">🔹 TDD에 대하여</a>
<br><a data-href="🍂 JPA, Mybatis , Dead Lock이슈" href="https://lts.kr/study/dev-seminar/🍂-jpa,-mybatis-,-dead-lock이슈.html" class="internal-link" target="_self" rel="noopener nofollow">🍂 JPA, Mybatis , Dead Lock이슈</a>
<br><a data-href="🥗 Spring Security_토큰-세션-쿠키-JWT 에 대하여" href="https://lts.kr/study/dev-seminar/🥗-spring-security_토큰-세션-쿠키-jwt-에-대하여.html" class="internal-link" target="_self" rel="noopener nofollow">🥗 Spring Security_토큰-세션-쿠키-JWT 에 대하여</a>
<br><a data-href="📔 DB 테이블 설계, 어떻게 하는게 옳은 방법인가" href="https://lts.kr/study/dev-seminar/📔-db-테이블-설계,-어떻게-하는게-옳은-방법인가.html" class="internal-link" target="_self" rel="noopener nofollow">📔 DB 테이블 설계, 어떻게 하는게 옳은 방법인가</a>]]></description><link>https://lts.kr/study/📕-공부.html</link><guid isPermaLink="false">study/📕 공부.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Fri, 02 May 2025 01:55:22 GMT</pubDate></item><item><title><![CDATA[🌩 Cloud-Native Architecture 분석]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="https://lts.kr/?query=tag:구조" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#구조</a> <a class="tag" href="https://lts.kr/?query=tag:설계" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#설계</a> <a class="tag" href="https://lts.kr/?query=tag:MSA" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#MSA</a> <a class="tag" href="https://lts.kr/?query=tag:CloudNative" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#CloudNative</a> <br> <a href="https://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="https://lts.kr?query=tag:구조" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#구조">#구조</a> <a href="https://lts.kr?query=tag:설계" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#설계">#설계</a> <a href="https://lts.kr?query=tag:MSA" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#MSA">#MSA</a> <a href="https://lts.kr?query=tag:CloudNative" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#CloudNative">#CloudNative</a><br>
<br>CNA는 클라우드 환경의 특성을 최대한 활용하여 애플리케이션을 설계하고 운영하는 접근 방식이다.
<br>이는 유연성, 확장성, 탄력성, 복원성 등의 장점을 극대화하여 빠르게 변화하는 비즈니스 요구에 대응할 수 있도록 하기 위함이다.
<br>
<br>클라우드(AWS, Azure 등..)의 보편화에 따라, 해당 환경(클라우드 시스템 환경)에 맞는 적절한 프로그램(애플리케이션)설계 기법이 필요해졌고, 그렇게 등장한 것이 클라우드 네이티브 아키텍처 CNA이다.
<br>우리 모두가 아는 ‘넷플릭스(NETFLIX)’의 사례를 보도록하자.<br> 넷플릭스는 2008년 매월 수천 편의 영상을, 수백만 명의 고객들에게 스트리밍 서비스로 제공하며, 데이터 량이 빠르게 늘어나고 있었다.<br>
이때, 넷플릭스는 자체적인 데이터 센터를 운영하고 있었는데 매일 급격하게 증가하는 볼륨을 감당하는데 무리가 있었고, 전체 서비스가 3일간 다운되는 큰 손실이 발생한 사례가 있다.<br>이후 넷플릭스는 사내 모든 컴퓨팅 인프라를 클라우드 환경으로 옮겨, 안정적인 스트리밍과 서비스 확장을 이뤄냈다.<br>꼭 매년 크게 성장하는 기업들 만이 클라우드 시스템에 유리한 것은 아니다.<br>
한가지 사례를 더 가정해보자.<br>평균적으로 매 시간 100만명의 유저가 서비스를 이용한다고 가정해보자.<br>
이때, 우리의 서버는 100만명을 수용할 수 있는 스펙이 되어야한다.<br>
하지만, 연말 연초 연휴에 서비스 사용자들이 크게 몰려 시간 당 1000만명 수준이 유지된다고 한다면 어떠한 선택을 해야할까?<br>일반적인 회사는 특정한 상황에 몰리는 사용자들을 위해 10배 이상의 서버를 증설할 여력이 없다.<br>
여기서 클라우드 컴퓨팅 시스템이 이러한 문제를 해결해 줄 수 있다.<br>
<br>클라우드는 온디맨드 셀프 서비스 (On-demand Self-Service) 를 지원한다.<br>
사용자는 필요한 자원을 요청하고 즉시 사용할 수 있다.<br>
때문에, 초기 인프라 구축 비용 없이 사용량만큼만 비용을 지불하여 하드웨어 운영 인건비를 절감할 수 있으며<br>
자본 기반 지출에서 → 운영 기반 지출로 지출 구조를 전환 할 수 있다.
주의점
하지만, 비용 예측의 어려움 또한 존재한다.<br>
사용량 기반 과금구조 이기 때문에, 과도한 사용시 요금이 폭주할 가능성이 있으며,<br>
리소스 낭비 및 Auto Scaling의 작동범위를 항상 주의하여 운영해야한다. <br>
<br>방금 기술했던 특징으로, 트래픽 증가시 손쉽게 리소스를 확장 가능하다.
<br>또한, 광범위한 네트워크 접근성으로 글로벌 서비스를 제공할 수 있다.
<br>
<br>DR(Disaster Recovery) 시스템을 손쉽게 구성할 수 있는 다양한 기능을 제공.
<br>스냅샷, 복제본 등 고가용성 및 복구 설계가 수월하다.
<br>
<br>클라우드 시스템들은 일정 수준 이상의 보안을 항상 유지해주기 때문에,<br>
하드웨어 보안에 필요한 노력을 줄일 수 있다.
<br>다음과 같은 기술들은 위에서 기술한 클라우드 시스템의 장점을 100%로 활용 가능하도록 도와준다.<br>
<br>상세한 설명 ▶▶ <a data-href="🐹 MSA(Microservices Architecture)" href="https://lts.kr/study/cs/🐹-msa(microservices-architecture).html" class="internal-link" target="_self" rel="noopener nofollow">🐹 MSA(Microservices Architecture)</a>
<br>애플리케이션은 API호출을 통해 세분화 되고, 느슨하게 결합된 구성 요소로 분해되어 관리된다.
<br>
<br>컨테이너 기술 ▶▶ <a data-href="🐋 docker 란" href="https://lts.kr/tools/docker/🐋-docker-란.html" class="internal-link" target="_self" rel="noopener nofollow">🐋 docker 란</a>
<br>CI/CD동안 모든 소프트웨어 어플리케이션과 모든 종속성은 컨테이너로써 관리되어<br>
환경 전반에 거린 솔루션의 이식성을 향상시킨다.
<br>
<br>오케스트레이션 기술 ▶▶ <a data-href="🚢Kubernetes(k8s)란" href="https://lts.kr/tools/kubernetes/🚢kubernetes(k8s)란.html" class="internal-link" target="_self" rel="noopener nofollow">🚢Kubernetes(k8s)란</a>
<br>컨테이너화된 어플리케이션을 실행하고 배포하고 확장하기 위한 클러스터를 관리하는 기술이다.
<br>많은 수의 컨테이너를 직접관리하지 않고 자동화 함으로 효율을 증대할 수 있다.
<br>
<br>개념 설명 ▶▶ <a data-href="CICD" href="https://lts.kr/짧은-키워드/cicd.html" class="internal-link" target="_self" rel="noopener nofollow">CICD</a>
<br>소프트웨어 릴리즈의 효율성을 높여준다.
<br>빈번하고 반복적인 릴리즈를 신속한 피드백과 함께 간소화하고 자동화 시킬 수 있다.
<br>
<br>클라우드 네이티브 아키텍천은 현대의 빠르게 변화하는 비즈니스 환경에서 유연하고 확장 가능한 시스템을 구축하는데, 필수적인 접근방식임은 틀림없다.
<br>이를 통해 기업은 빠른 서비스 출기, 안정적인 운영, 효율적인 리소스 활용등의 장점을 모두 취할 수 있다.]]></description><link>https://lts.kr/study/cs/🌩-cloud-native-architecture-분석.html</link><guid isPermaLink="false">study/CS/🌩 Cloud-Native Architecture 분석.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Fri, 02 May 2025 01:54:34 GMT</pubDate></item><item><title><![CDATA[🐹 MSA(Microservices Architecture)]]></title><description><![CDATA[<a class="tag" href="https://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="https://lts.kr/?query=tag:구조" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#구조</a> <a class="tag" href="https://lts.kr/?query=tag:설계" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#설계</a> <a class="tag" href="https://lts.kr/?query=tag:MSA" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#MSA</a> <a class="tag" href="https://lts.kr/?query=tag:CloudNative" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#CloudNative</a> <br> <a href="https://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="https://lts.kr?query=tag:구조" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#구조">#구조</a> <a href="https://lts.kr?query=tag:설계" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#설계">#설계</a> <a href="https://lts.kr?query=tag:MSA" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#MSA">#MSA</a> <a href="https://lts.kr?query=tag:CloudNative" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#CloudNative">#CloudNative</a><br>
<br>msa는 대규모 애플리케이션을 독립적으로 배포 가능한 작은 서비스들의 집합으로 구성하는 소프트웨어 설계 접근 방식이다.
<br>각 서비스는 특정 비즈니스 기능을 담당하며, 자체 데이터 저장소를 보유하고(선택), 독립적으로 개발 및 배포가 가능하다.
<br>msa는 확장성, 유지보수성, 유연성 향상 등의 이점을 제공하지만 복잡한 운영과 통신 관리 등의 문제도 동반하고있다.
<br>모놀리식 아키텍처(Monolithic Architecture)
모든 기능이 단일 코드베이스에 포함되어 하나의 배포 단위로 운영되는 방식. <br>초기개발과 배포가 빠르고 간단하지만, 애플리케이션이 비대화 될 수록 다음과 같은 문제 발생 <br>확장성 제한: 전체 애플리케이션을 확장해야 하므로 자원 낭비가 발생할 수 있음
<br>배포 리스크 증가: 작은 변경도 전체 시스템의 재배포를 요구하여 위험이 증가
<br>유지보수 어려움: 코드베이스가 커지면 이해와 수정이 어려워짐 <br>MSA는 애플리케이션을 작은 서비스로 분리하여, 각 서비스가 독립적으로 개발, 배포, 확장 될 수 있도록 한다.<br>
즉, 위의 모놀리식 아키텍처의 단점을 모두 보완하는 특징을 갖고 있다.<br>
<br>배포
<br>서비스별 개별 배포가 가능(배포시 전체 서비스의 중단이 없음)
<br>특정 서비스의 요구사항만을 반영하여, 빠르게 배포 가능
<br>&nbsp;<br>
2. 확장<br>특정 서비스에 대한 확장성(scale-out)이 유리하다.
<br>Cloud Native Architecture에 적합하다. <br>&nbsp;<br>장애
<br>일부 장애가 전체 서비스로 확장될 가능성이 적다.(장애 격리가 쉽다)
<br>&nbsp;<br>
4. 그 외<br>새로운 기술을 적용하기 유연하다.(전체 서비스가 아닌 특정 서비스만 별도의 기술 또는 언어로 구현 가능)
<br>각각의 서비스에 대한 구조 파악 및 분석이 모놀리식 구조에 비해 쉽다.
<br>
<br>설계의 어려움
<br>MSA는 모놀리식에 비해 상대적으로 많이 복잡하다. 또한, 통신의 장애와 서버의 부하 등을 고려하여 transaction을 유지할지 결정해야 한다.
<br>&nbsp;<br>
2. 성능<br>서비스 간 호출 시 API를 사용하므로, 통신 비용이나 Latency에 대해 이슈가 존재.
<br>&nbsp;<br>
3. 테스트/데이터 트랜잭션<br>모놀리식에서는 단일 트랜잭션을 유지하면 됐지만 MSA에서는 비즈니스에 대한 DB를 가지고 있는 서비스도 각기 다르고, 서비스의 연결을 위해서는 통신이 포함되기 때문에 트랜잭션을 일관되게 유지하며 개발하는게 어렵다. <br>통합 테스트가 어렵다. 개발 환경과 실제 운영환경을 동일하게 가져가는 것의 어려움 <br>&nbsp;<br>
4. 데이터 관리<br>데이터가 여러 서비스에 분산되어 있어 관리하는데 어려움이 있다.
<br>그래서 msa가 무조건 좋은것인가? <br>설계방식에 대한 정답은 없다. 하지만, 많은 기업들이 MSA를 적용하여 글로벌 서비스를 성공적으로 확장시켰다는 것은 확실하다. <br>또한, Cloud 기반의 서비스에 매우적합한 방식이라는 것도 자명하다. 하지만, MSA를 무조건 적으로 적용하는 것 보다는 현재프로젝트의 규모, 통신 방식등을 적절하게 산정/예상하여 단점보다 장점이 커 보인다고 생각될 때 적용하는 것이 바람직 해 보인다. <br>
<br>MSA는 단순히 서비스를 여러 개로 나누는 것이 아니라, 개별 서비스가 독립적으로 개발, 배포, 운영될 수 있도록 설계하는 것이 핵심이다.
<br>그렇지 않으면 모놀리식 아키텍처와 다를 바 없다. 따라서, 적절한 설계 원칙을 적용하여 설계를 진행하여야 한다.<br> SRP는 각 서비스가 하나의 명확한 역할을 수행해야 한다는 원칙이다. 이를 따르지 않으면 서비스가 점점 커지면서 결국 모놀리식 구조와 다름없어질 수 있음을 알아야 한다.<br>
<br>서비스 내부의 응집도는 높이고, 서비스 간의 결합도는 낮춰야 한다. 응집도가 높은 서비스는 유지보수가 용이하며, 변경 시 다른 기능에 영향을 최소화할 수 있다. 반면, 결합도가 높으면 서비스 간 변경 사항이 전파되면서 독립적인 배포가 어려워지고, 장애 전파의 위험도 커진다.
<br>
<br>각 서비스는 명확한 도메인 역할을 가져야 한다(DDD). 예를 들어, 주문 서비스는 주문 관련 로직만을 담당하고, 결제 서비스는 결제와 관련된 기능만을 처리해야 한다. 이를 통해 개발, 배포, 확장이 용이해지고, 운영 비용을 절감할 수 있다.<br>
<br>서비스는 서로 독립적으로 운영될 수 있어야 한다. 특정 서비스가 다운되더라도 전체 시스템이 영향을 받지 않도록 설계하는 것이 중요하다.<br>
<br>서비스 간 통신은 동기 호출보다는 비동기 메시징 또는 이벤트 기반 방식을 활용하는 것이 좋다. 이를 통해 특정 서비스가 응답하지 않아도 전체 시스템이 멈추지 않도록 할 수 있다.
<br>
<br>서비스 간의 직접적인 의존성을 최소화해야 한다. 예를 들어, 한 서비스가 다른 서비스의 데이터베이스에 직접 접근하는 것은 피해야 하며, API나 이벤트 기반 방식으로 데이터를 교환해야 한다.<br>
<br>MSA 환경에서는 특정 서비스에서 장애가 발생하더라도 다른 서비스로 확산되지 않도록 격리하는 것이 필수적이다.<br>
<br>서킷 브레이커는 특정 서비스가 응답하지 않을 때, 일정 횟수 이상 요청이 실패하면 추가 요청을 차단하는 패턴이다. 이를 통해 과부하를 방지하고, 장애가 확산되는 것을 막을 수 있다.
<br>
<br>서비스 장애 발생 시, 기본적인 대체 응답을 제공하는 폴백 전략을 사용하면 사용자 경험을 유지할 수 있다. 예를 들어, 추천 서비스가 장애가 발생하면 기본 인기 상품 목록을 반환하는 식.
<br>
<br>서비스의 상태를 지속적으로 모니터링하여 장애 발생을 사전에 감지하고 대응할 수 있도록 해야 한다.
<br>MSA에서는 수많은 서비스가 존재하므로 수작업으로 운영하기에는 한계가 있다. 따라서 <a data-href="CICD" href="https://lts.kr/짧은-키워드/cicd.html" class="internal-link" target="_self" rel="noopener nofollow">CICD</a> 파이프라인과 Kubernetes 기반의 자동화가 필수적이다.<br>
<br>코드 변경 사항을 빠르게 배포할 수 있도록 지속적인 통합 및 배포(CI/CD)를 구축해야 한다. 이를 통해 배포 속도를 높이고, 변경에 대한 위험을 줄일 수 있다.
<br>
<br>Kubernetes를 활용하면 서비스 배포, 확장, 롤백을 자동화할 수 있다. 이를 통해 인프라 관리의 복잡도를 줄이고, 서비스 안정성을 확보할 수 있다.
<br>MSA에서는 서비스가 분산되어 있기 때문에, 효과적인 모니터링과 로깅이 필수적이다.<br>
<br>서비스 간 요청 흐름을 추적하기 위해 분산 추적 시스템(OpenTelemetry, Jaeger)을 활용하여 성능 저하 원인을 빠르게 파악할 수 있다.
<br>
<br>각 서비스에서 발생하는 로그를 한곳에 수집하여 관리해야 한다. 중앙 집중식 로깅 시스템(ELK Stack, Grafana Loki)을 활용하면 장애 발생 시 원인을 빠르게 분석할 수 있다.
<br>
<br>서비스의 CPU, 메모리 사용량, 응답 시간 등을 지속적으로 모니터링하고, 이상 징후를 사전에 감지하여 대응할 수 있도록 해야 한다.
<br> <br>MSA를 설계할 때, 적절한 서비스 분해 전략을 선택하는 것 또한 매우 중요하다.<br>
일반적인 분해 전략은 다음과 같다.<br>비즈니스 기능 기반 분해: 각 서비스가 특정 비즈니스 기능을 담당하도록 분해한다. 예를 들어, 주문 관리, 결제 처리, 사용자 인증 등을 각각의 서비스로 나눌 수 있다.<br>
<br>하위 도메인 기반 분해: 도메인 주도 설계(DDD)를 활용하여 하위 도메인별로 서비스를 분리한다. 고객이 발생시키는 이벤트를 시작점으로 하여 Path를 발경하는 Event Storming 기법도 있다.<br>
<br>트랜잭션 경계 기반 분해: 트랜잭션 경계를 기준으로 서비스를 분리하여 데이터 일관성을 유지한다.
<br>이러한 분해 전략을 통해 서비스 간의 결합도를 낮추고, 독립적인 개발과 배포가 가능하도록 설계할 수 있다.<br>주의점
MSA를 도입하며, 기능(도메인)의 경계를 명확히 하는것은 생각보다 쉽지 않다.<br>
특히 핵심 기능을 분리할 때 어려운 점이 있다. <br>핵심 기능은 다른 기능들과의 결합도가 높다
<br>핵심 기능일 수록 장기간의 유지보수로 인하여, 도메인간의 경계가 명확하지 않을 가능성이 높다 이러한 핵심 기능들은 사람의 눈으로만 판단하는데 어려움이 있기 떄문에, 다양한 정적 분석도구를 활용하면 좋다.<br>
<br>다음은 MSA에서 유연성과 확장성을 확보하기 위한 주요 서비스 분리 원칙이다.<br>
<br>분리 대상 서비스를 확정하고 나서는, 기존 모놀리식 코드를 재사용 할것인지, 재개발 할것인지를 고민해야한다.
<br>일반적으로 코드를 재사용하여 서비스를 구성하는 것이 효율적으로 보이지만 오히려 비효율을 초래할 가능성이 크다.
<br>오랜 기간 유지보수 된 코드의 문제점<br>
- 기술부채가 많이 쌓여있고, 기술 자체가 오래되었을 가능성이 큼<br>
- 수없이 변경된 요구사항으로, 비즈니스 도메인이 명확하게 반영되어있지 않을 가능성이 큼<br>
<br>기능의 완전한 재작성의 장점<br>
- 요구사항을 다시 파악하여 해당 기능에 대한 비즈니스 도메인을 명확히 할 수 있음<br>
- 비즈니스에 대한 더놓은 이해를 바탕으로 아키텍처 재설계 가능<br>
- 기존의 기술부채 해결<br>
- 새로운 기술 스텍을 도입할 수 있음<br>
<br>모놀리식으로 구현되어있는 코드 전체를 MSA로 전환하는 것은 아주 길고 비용이 많이 드는 일이다.<br>
때문에, 작고 명확한 계획의 여러단계를 만들어 진행하는 것이 유리하다.<br>또한, 서비스를 분리할 때 서비스 범위를 너무 좁게 잡으면 각서비스는 응집도 높은 비즈니스 없이 CRUD만 수행하며 개수는 크게 증가하여 복잡도만 높아질 수 있다.<br>
<br>우선 서비스 단위를 크게 분리한 후, 이후에 설계에 대한 고민을 반복적으로 수행하며 분리작업을 점진적으로 진행하는 것이 가장 바람직 하다고 볼 수 있겠다.
<br> <br>마이크로서비스 아키텍처에서는 서비스 간 통신과 데이터 관리가 중요한 이슈이다.<br>
<br>동기 통신: <a data-href="RESTful API" href="https://lts.kr/짧은-키워드/restful-api.html" class="internal-link" target="_self" rel="noopener nofollow">RESTful API</a>, gRPC 등을 사용하여 실시간으로 요청과 응답을 주고받는 방식. 구현이 간단하지만, 서비스 간의 강한 결합을 초래할 수 있다.<br>
<br>비동기 통신: 메시지 큐(Kafka, RabbitMQ 등)를 활용하여 비동기적으로 메시지를 전달하는 방식. 이는 서비스 간 결합도를 낮추고, 시스템의 확장성과 탄력성을 향상시킨다.
<br>
<br>데이터베이스 분리: 각 서비스는 자체 데이터베이스를 보유하여 데이터 독립성을 확보한다.<br>
<br>데이터 일관성 유지: 분산 트랜잭션을 피하기 위해 SAGA 패턴, 이벤트 소싱 등을 활용하여 데이터 일관성을 유지한다.
<br>MSA는 단순히 시스템을 여러 개의 서비스로 나누는 것이 아니라, 서비스의 독립성, 장애 격리, 자동화, 모니터링 등의 원칙을 철저히 준수하는 것이 핵심이다. 이러한 원칙이 지켜지지 않으면, 시스템은 오히려 더 복잡해지고 운영 비용이 증가할 뿐 아니라 장애 대응도 어려워진다.<br>특히 단일 책임 원칙, 서비스 독립성, 장애 격리, 자동화, 모니터링은 MSA에서 반드시 적용해야 하는 필수 요소이다. 이 원칙들을 바탕으로 MSA를 설계하면 유연한 확장성, 높은 가용성, 효율적인 운영이 가능한 시스템을 구축할 수 있겠다.]]></description><link>https://lts.kr/study/cs/🐹-msa(microservices-architecture).html</link><guid isPermaLink="false">study/CS/🐹 MSA(Microservices Architecture).md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 30 Apr 2025 07:14:14 GMT</pubDate></item><item><title><![CDATA[정의]]></title><description><![CDATA[<br><br>
<br>CI/CD는 지속적 통합(Continuous Integration) 및 지속적 제공/배포(Continuous Delivery/Deployment) 를 의미하며, 소프트웨어 개발 라이프사이클을 간소화하고 가속화하는 것을 목표로 한다.
<br><br>
<br>코드 변경 사항을 공유 소스 코드 리포지토리에 자동으로 자주 통합하는 사례를 나타낸다. <br><br>
<br>코드 변경 사항의 통합, 테스트, 제공을 나타내는 프로세스로, 두 가지 부분으로 구성된다. 지속적 제공에는 자동 프로덕션 배포 기능이 없는 반면, 지속적 배포는 업데이트를 프로덕션 환경에 자동으로 릴리스된다.
<br><br><br><br><br><br>]]></description><link>https://lts.kr/짧은-키워드/cicd.html</link><guid isPermaLink="false">짧은 키워드/CICD.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 30 Apr 2025 06:50:46 GMT</pubDate></item><item><title><![CDATA[RESTful API]]></title><link>https://lts.kr/짧은-키워드/restful-api.html</link><guid isPermaLink="false">짧은 키워드/RESTful API.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 30 Apr 2025 06:15:43 GMT</pubDate></item></channel></rss>