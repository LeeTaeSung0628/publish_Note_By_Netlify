<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[blog]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://lts.kr/</link><image><url>http://lts.kr/lib/media/favicon.png</url><title>blog</title><link>http://lts.kr/</link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Wed, 12 Mar 2025 07:29:43 GMT</lastBuildDate><atom:link href="http://lts.kr/lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Wed, 12 Mar 2025 07:29:00 GMT</pubDate><copyright><![CDATA[taesung's Blog]]></copyright><ttl>60</ttl><dc:creator>taesung's Blog</dc:creator><item><title><![CDATA[🥇 정보처리 기사 실기 프로그래밍-포인터]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:정보처리기사" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정보처리기사</a> <a class="tag" href="http://lts.kr/?query=tag:실기" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#실기</a> <a class="tag" href="http://lts.kr/?query=tag:프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로그래밍</a> <a class="tag" href="http://lts.kr/?query=tag:정리" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정리</a> <a class="tag" href="http://lts.kr/?query=tag:포인터" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#포인터</a> <br> <a href="http://lts.kr?query=tag:정보처리기사" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정보처리기사">#정보처리기사</a> <a href="http://lts.kr?query=tag:실기" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#실기">#실기</a> <a href="http://lts.kr?query=tag:프로그래밍" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로그래밍">#프로그래밍</a> <a href="http://lts.kr?query=tag:정리" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정리">#정리</a> <a href="http://lts.kr?query=tag:포인터" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#포인터">#포인터</a><br>#include &lt;stdio.h&gt; int len(char* p);
int main( ) { char* p1 = "2022"; char* p2 = "202207"; int a = len(p1); int b = len(p2); printf("%d", a + b);
} int len(char* p) { int r = 0; while (*p != '\0') { p++; r++; } return r;
}
<br>int len(char* p); -&gt; len() 함수의 프로토타입 선언이다.
<br>p1과 p2는 문자형 포인터 변수로 각 문자가 저장된 주소의 주소로 초기화 된다.<br>
<img alt="Pasted image 20250312144444.png" src="http://lts.kr/사진-및-문서/pasted-image-20250312144444.png" target="_self"><br>
ex) p1에는 '2'가 저장되어있는 1000번째 주소가 삽입되어있으며,<br>
p1+1 은 '0' , p1+4 는 1004번째 주소로, '\0'이 들어가 있다.
<br>즉, 4 + 6 <br>#include &lt;stdio.h&gt; int main( ) { int a[4] = { 0, 2, 4, 8 }; int b[3]; int* p; int sum = 0; for (int i = 1; i &lt; 4; i++) { p = a + i; b[i - 1] = *p - a[i - 1]; sum = sum + b[i - 1] + a[i]; } printf("%d", sum); }
<br>p -&gt; 정수형 포인터 변수
<br>i = 1,2,3 반복문
<br>첫번째 반복 i = 1 `p = a + i` =&gt; a배열의 두번째 요소의 주소 저장 `b[0]` = (*p =&gt; p의 주소가 가리키는곳의 값)2 - 0 = 2 sum = 0 + 2 + 2 = 4
두번째 반복 i = 2 a배열의 세번째요소 4 `b[1]` = 4 - 2 = 2 sum = 4 + 2 + 4 = 10
세번째 반복 i = 3 a배열의 네번째요소 8의 주소 'b[2]' = 8 - 4 = 4 sum = 10 + 4 + 8 = 22 <br>포인터 변수로 선언된 p에 배열을 직접대입하는것은 주소값을 넣는것이다.
<br>포인터 변수를 사용할때 p*처럼 사용하면, 해당 주소값 내의 값을 의미한다.<br>
p에 직접 대입할 때 말고는 다 배열과 사칙연산이다.
<br>#include &lt;stdio.h&gt; int main() { int* array[3]; int a = 12, b = 24, c = 36; array[0] = &amp;a; array[1] = &amp;b; array[2] = &amp;c; printf("%d", *array[1] + **array + 1);
}
<br>정수형 포인터를 저장하는 배열 array [ , , ]
<br>array[0] = &amp;a;는 a의 시작 주소를 삽입하는 것이다.
<br>array[1] 은 &amp;b(b의 주소값)이고, *array[1] 은 그 주소가 지니고 있는 실제 값 24이다.
<br>**array + 1 =&gt; <br>array : 배열의 이름만 지정하면 배열의 첫 번째 요소의 주소인 &amp;array[0], 즉 array의 첫주소값
<br>*array : array의 첫주소값(array)이 가지는 실제 값 &amp;a 즉 int a의 주소값.
<br>**array : int a의 주소값의 실제 지니고 있는값 12이다. <br>즉, 24 + 12 + 1<br>#include &lt;stdio.h&gt; int main() { int ary[3]; int s = 0; *(ary + 0) = 1; ary[1] = *(ary + 0) + 2; ary[2] = *ary + 3; for (int i = 0; i &lt; 3; i++) s = s + ary[i]; printf("%d", s); }
<br>*(ary + 0) = 1; -&gt; arr의 첫 주소값의 실제값에 1 대입 / arr[1 , , ]
<br>ary[1] = *(ary + 0) + 2; -&gt; arr[1]에 1+2 대입 / arr[1 , 3 , ]
<br>ary[2] = *ary + 3; -&gt; arr[2]에 1+3 대입 / arr[1 , 3 , 4]
<br>1+3+4 = 8<br>#include &lt;stdio.h&gt; main() { char* p = "KOREA"; printf("%s\n", p); printf("%s\n", p + 3); printf("%c\n", *p); printf("%c\n", *(p + 3)); printf("%c\n", *p + 2); }
<br>문자열을 저장하는 경우 문자열의 끝을 의미하는 널 문자\0 가 추가로 저장되며,<br>
출력시 널 문자는 표시되 지 않는다.
<br>printf("%s", P) 의 %s는 널(\0) 문자가 나올 때까지 문자열을 출력한다.
<br>[K , O , R , E , A , \0]<br>P : 문자형 포인터 변수 p 의 시작주소값 -&gt; KOREA
<br>P + 3 : p의 시작주소값의 3번째 뒤의 주소 -&gt; E의 시작 주소값 -&gt; EA
<br>*P : p 의 시작주소값의 실제 값 -&gt; K
<br>*(P + 3) : P의 시작주소값의 3번째 뒤의 주소의 실제 값 -&gt; E
<br>*P + 2 : P의 시작 주소의 실제값 K(ASCII 코드 75) + 2 =&gt; 77 =&gt; M
<br>KOREA
EA
K
E
M]]></description><link>http://lts.kr/study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-프로그래밍-포인터.html</link><guid isPermaLink="false">study/정보처리기사/정보처리기사 실기/🥇 정보처리 기사 실기 프로그래밍-포인터.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 12 Mar 2025 07:13:28 GMT</pubDate><enclosure url="http://lts.kr/사진-및-문서/pasted-image-20250312144444.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="http://lts.kr/사진-및-문서/pasted-image-20250312144444.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[📕 공부]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="http://lts.kr/?query=tag:모음" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#모음</a> <br> <a href="http://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="http://lts.kr?query=tag:모음" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#모음">#모음</a><br>공부
보고 배운 지식 중 공유하고 싶은 정보를 모아둔 카테고리 입니다.
<br>
<br><a data-href="⏰ Script 로딩 지연 이슈" href="http://lts.kr/issue_troubleshooting/⏰-script-로딩-지연-이슈.html" class="internal-link" target="_self" rel="noopener nofollow">⏰ Script 로딩 지연 이슈</a>⭐
<br><a data-href="🔐 상품 투자하기 서비스 이슈 및 Lock기법 개선안" href="http://lts.kr/issue_troubleshooting/🔐-상품-투자하기-서비스-이슈-및-lock기법-개선안.html" class="internal-link" target="_self" rel="noopener nofollow">🔐 상품 투자하기 서비스 이슈 및 Lock기법 개선안</a>⭐
<br><a data-href="🚦 Spring Batch(스레드와 트렌젝션) 트러블슈팅" href="http://lts.kr/issue_troubleshooting/🚦-spring-batch(스레드와-트렌젝션)-트러블슈팅.html" class="internal-link" target="_self" rel="noopener nofollow">🚦 Spring Batch(스레드와 트렌젝션) 트러블슈팅</a>
<br><a data-href="⚔ StckOverflow 이슈와 QueryDSL" href="http://lts.kr/issue_troubleshooting/⚔-stckoverflow-이슈와-querydsl.html" class="internal-link" target="_self" rel="noopener nofollow">⚔ StckOverflow 이슈와 QueryDSL</a>
<br>
<br><a data-href="☕ JAVA , OOP" href="http://lts.kr/study/cs/☕-java-,-oop.html" class="internal-link" target="_self" rel="noopener nofollow">☕ JAVA , OOP</a>
<br><a data-href="🍃 Spring" href="http://lts.kr/study/cs/🍃-spring.html" class="internal-link" target="_self" rel="noopener nofollow">🍃 Spring</a>
<br><a data-href="🎩 DevOps" href="http://lts.kr/study/cs/🎩-devops.html" class="internal-link" target="_self" rel="noopener nofollow">🎩 DevOps</a>
<br><a data-href="📔 DataBase" href="http://lts.kr/study/cs/📔-database.html" class="internal-link" target="_self" rel="noopener nofollow">📔 DataBase</a>
<br><a data-href="📭 Server" href="http://lts.kr/study/cs/📭-server.html" class="internal-link" target="_self" rel="noopener nofollow">📭 Server</a>
<br><a data-href="🐞 etc" href="http://lts.kr/study/cs/🐞-etc.html" class="internal-link" target="_self" rel="noopener nofollow">🐞 etc</a>
<br>
<br><a data-href="🤠 Coding Test 풀이 모음" href="http://lts.kr/study/coding-test/🤠-coding-test-풀이-모음.html" class="internal-link" target="_self" rel="noopener nofollow">🤠 Coding Test 풀이 모음</a>
<br><a data-href="👽 Algorithm" href="http://lts.kr/study/coding-test/👽-algorithm.html" class="internal-link" target="_self" rel="noopener nofollow">👽 Algorithm</a>
<br>
<br><a data-href="🔻 Redis 캐쉬 전략 - hello 서비스에 적용하여 성능개선 가능성" href="http://lts.kr/study/dev-seminar/🔻-redis-캐쉬-전략-hello-서비스에-적용하여-성능개선-가능성.html" class="internal-link" target="_self" rel="noopener nofollow">🔻 Redis 캐쉬 전략 - hello 서비스에 적용하여 성능개선 가능성</a>
<br><a data-href="🍂 JPA, Mybatis , Dead Lock" href="http://lts.kr/study/dev-seminar/🍂-jpa,-mybatis-,-dead-lock.html" class="internal-link" target="_self" rel="noopener nofollow">🍂 JPA, Mybatis , Dead Lock</a>
<br><a data-href="🔹 TDD에 대하여" href="http://lts.kr/study/dev-seminar/🔹-tdd에-대하여.html" class="internal-link" target="_self" rel="noopener nofollow">🔹 TDD에 대하여</a>
<br><a data-href="🪕 JPA 에 대한 고찰" href="http://lts.kr/study/dev-seminar/🪕-jpa-에-대한-고찰.html" class="internal-link" target="_self" rel="noopener nofollow">🪕 JPA 에 대한 고찰</a>
<br><a data-href="🔐 상품 투자하기 서비스 이슈 및 Lock기법 개선안" href="http://lts.kr/issue_troubleshooting/🔐-상품-투자하기-서비스-이슈-및-lock기법-개선안.html" class="internal-link" target="_self" rel="noopener nofollow">🔐 상품 투자하기 서비스 이슈 및 Lock기법 개선안</a>
<br><a data-href="🥗 Spring Security_토큰-세션-쿠키-JWT 에 대하여" href="http://lts.kr/study/dev-seminar/🥗-spring-security_토큰-세션-쿠키-jwt-에-대하여.html" class="internal-link" target="_self" rel="noopener nofollow">🥗 Spring Security_토큰-세션-쿠키-JWT 에 대하여</a>
<br><a data-href="📔 DB 테이블 설계, 어떻게 하는게 옳은 방법인가" href="http://lts.kr/study/dev-seminar/📔-db-테이블-설계,-어떻게-하는게-옳은-방법인가.html" class="internal-link" target="_self" rel="noopener nofollow">📔 DB 테이블 설계, 어떻게 하는게 옳은 방법인가</a>]]></description><link>http://lts.kr/study/📕-공부.html</link><guid isPermaLink="false">study/📕 공부.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 12 Mar 2025 06:48:59 GMT</pubDate></item><item><title><![CDATA[🏫 강의 &amp; 자격증]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:강의" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#강의</a> <a class="tag" href="http://lts.kr/?query=tag:모음" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#모음</a> <a class="tag" href="http://lts.kr/?query=tag:lectur" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#lectur</a> <br> <a href="http://lts.kr?query=tag:강의" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#강의">#강의</a> <a href="http://lts.kr?query=tag:모음" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#모음">#모음</a> <a href="http://lts.kr?query=tag:lectur" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#lectur">#lectur</a><br>강의
강의를 수강하며, 정리한 내용 모음집 입니다.
<br>정보
inflearn - SpringCoreBasic.김영한 님의 강의 입니다.
<br> <br> <br> <br> <br>
<br><a data-href="🥈 필기 1과목 - 소프트웨어 설계" href="http://lts.kr/study/정보처리기사/정보처리기사-필기/🥈-필기-1과목-소프트웨어-설계.html" class="internal-link" target="_self" rel="noopener nofollow">🥈 필기 1과목 - 소프트웨어 설계</a>
<br><a data-href="🥈 필기 2과목 - 소프트웨어 개발" href="http://lts.kr/study/정보처리기사/정보처리기사-필기/🥈-필기-2과목-소프트웨어-개발.html" class="internal-link" target="_self" rel="noopener nofollow">🥈 필기 2과목 - 소프트웨어 개발</a>
<br><a data-href="🥈 필기 3과목 - 데이터베이스 구축" href="http://lts.kr/study/정보처리기사/정보처리기사-필기/🥈-필기-3과목-데이터베이스-구축.html" class="internal-link" target="_self" rel="noopener nofollow">🥈 필기 3과목 - 데이터베이스 구축</a>
<br><a data-href="🥈 필기 4과목 - 프로그래밍 언어 활용" href="http://lts.kr/study/정보처리기사/정보처리기사-필기/🥈-필기-4과목-프로그래밍-언어-활용.html" class="internal-link" target="_self" rel="noopener nofollow">🥈 필기 4과목 - 프로그래밍 언어 활용</a>
<br><a data-href="🥈 필기 5과목 - 정보시스템 구축관리" href="http://lts.kr/study/정보처리기사/정보처리기사-필기/🥈-필기-5과목-정보시스템-구축관리.html" class="internal-link" target="_self" rel="noopener nofollow">🥈 필기 5과목 - 정보시스템 구축관리</a>
<br>
<br><a data-href="🥇 정보처리 기사 실기 키워드" href="http://lts.kr/study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-키워드.html" class="internal-link" target="_self" rel="noopener nofollow">🥇 정보처리 기사 실기 키워드</a>
<br><a data-href="🥇 정보처리 기사 실기 SQL 문제" href="http://lts.kr/study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-sql-문제.html" class="internal-link" target="_self" rel="noopener nofollow">🥇 정보처리 기사 실기 SQL 문제</a>
<br><a data-href="🥇 정보처리 기사 실기 프로그래밍-제어문" href="http://lts.kr/study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-프로그래밍-제어문.html" class="internal-link" target="_self" rel="noopener nofollow">🥇 정보처리 기사 실기 프로그래밍-제어문</a>
<br><a data-href="🥇 정보처리 기사 실기 프로그래밍-포인터" href="http://lts.kr/study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-프로그래밍-포인터.html" class="internal-link" target="_self" rel="noopener nofollow">🥇 정보처리 기사 실기 프로그래밍-포인터</a>]]></description><link>http://lts.kr/lectur/🏫-강의-&amp;-자격증.html</link><guid isPermaLink="false">lectur/🏫 강의 &amp; 자격증.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 12 Mar 2025 06:45:28 GMT</pubDate></item><item><title><![CDATA[🏠 taesung's Blog]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:home" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#home</a> <a class="tag" href="http://lts.kr/?query=tag:index" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#index</a> <a class="tag" href="http://lts.kr/?query=tag:blog" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#blog</a> <a class="tag" href="http://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <br> <a href="http://lts.kr?query=tag:home" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#home">#home</a> <a href="http://lts.kr?query=tag:index" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#index">#index</a> <a href="http://lts.kr?query=tag:blog" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#blog">#blog</a> <a href="http://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a><br><a data-tooltip-position="top" aria-label="https://github.com/LeeTaeSung0628" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/LeeTaeSung0628" target="_self"><span alt="Pasted image 20250220144552.png" src="Pasted image 20250220144552.png" class="internal-embed media-embed image-embed is-loaded" style="width: 220px; max-width: 100%;"></span></a><img alt="Pasted image 20250220144552.png" src="http://lts.kr/사진-및-문서/pasted-image-20250220144552.png" style="width: 220px; max-width: 100%;" target="_self"><br>
<a data-tooltip-position="top" aria-label="https://github.com/LeeTaeSung0628" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/LeeTaeSung0628" target="_self"><font color="#ffffff"></font></a>🔗git Hub ▶ ...<br><a data-tooltip-position="top" aria-label="https://git.io/typing-svg" rel="noopener nofollow" class="external-link is-unresolved" href="https://git.io/typing-svg" target="_self"></a><img alt="Typing SVG" src="https://readme-typing-svg.demolab.com?font=Fira+Code&amp;pause=1000&amp;color=36A9F7&amp;random=false&amp;width=435&amp;lines=%EC%97%AC%EA%B8%B0%EB%8A%94+%EA%B3%B5%EB%B6%80%ED%95%98%EA%B3%A0%2C+%EA%B8%B0%EB%A1%9D%ED%95%98%EB%8A%94+%EA%B3%B3%EC%9E%85%EB%8B%88%EB%8B%A4" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br> <br> <br> <br> <br> <br> <br> <br> <br> <br>]]></description><link>http://lts.kr/🏠-taesung's-blog.html</link><guid isPermaLink="false">🏠 taesung's Blog.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 12 Mar 2025 06:45:24 GMT</pubDate><enclosure url="http://lts.kr/사진-및-문서/pasted-image-20250220144552.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="http://lts.kr/사진-및-문서/pasted-image-20250220144552.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🥇 정보처리 기사 실기 프로그래밍-제어문]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:정보처리기사" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정보처리기사</a> <a class="tag" href="http://lts.kr/?query=tag:실기" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#실기</a> <a class="tag" href="http://lts.kr/?query=tag:프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로그래밍</a> <a class="tag" href="http://lts.kr/?query=tag:정리" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정리</a> <br> <a href="http://lts.kr?query=tag:정보처리기사" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정보처리기사">#정보처리기사</a> <a href="http://lts.kr?query=tag:실기" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#실기">#실기</a> <a href="http://lts.kr?query=tag:프로그래밍" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로그래밍">#프로그래밍</a> <a href="http://lts.kr?query=tag:정리" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정리">#정리</a><br>#include &lt;stdio.h&gt;
main() { int s, el = 0; for (int i = 6; i &lt;= 30; i++) { s = 0; for (int j = 1; j &lt;= i / 2; j++) if (i % j == 0) s = s + j; if (s == i) el++; } printf("%d", el);
}
<br>j &lt;= i / 2; -&gt; 나머지가 몇이든 버린다.
<br>하나하나 분석하면, <br>6~30까지 자신의 약수(나누어 떨어지는 수)를 모두 더한다
<br>모두 더한 수와 자신이 같은지 판단하여 출력한다.
<br>6과 28이 해당한다.
<br>public class Test { public static void main(String[] args) { int r = 0; for (int i = 1; i &lt; 999; i++) { if (i % 3 == 0 &amp;&amp; i % 2 == 0) r = i; } System.out.print(r); } }
<br>1 ~ 998까지
<br>3으로 나누어 떨어지면서,
<br>2로도 나누어 떨어지는 녀석 즉, 2와 3의 공배수(6의 배수)
<br>일때, 가장 큰수(매번 초기화 하므로)를 구한다.
<br>public class Test { public static void main(String[] args) { int i = 3, k = 1; switch(i) { case 1: k++; case 2: k -= 3; case 3: k = 0; case 4: k += 3; case 5: k -= 10; default: k--; } System.out.print(k); }
}
<br>i가 3이므로 case3을 찾아간다.
<br>break문이 없으므로 그 밑으로 쭉 수행한다
<br>1234의 역순은 4321이다. 단 1230처럼 0으로 끝나는 정수는 고려하지 않는다.<br>#include &lt;stdio.h&gt; int main() { int number = 1234; int div = 10, result = 0; while (number "( 1 )" 0) { result = result * div; result = result + number "( 2 )" div; number = number "( 3 )" div; } printf("%d", result); }
<br>한자리수씩 커지면서 바꾸는거다.
<br>&gt; : 0보다 클때까지 반복한다.
<br>% : 나머지를 가져온다
<br>/ : 나누고, 나머지를 버린다.
<br>첫 사이클
0
4
123
<br>두 번쨰
40
43
12
<br>세 번째
430
432
1
<br>네 번째
4320
4321
0
<br>public class Test { public static void main(String[] args) { int w = 3, x = 4, y = 3, z = 5; if((w == 2 | w == y) &amp; !(y &gt; z) &amp; (1 == x ^ y != z)) { w = x + y; if(7 == x ^ y != w) System.out.println(w); else System.out.println(x); } else { w = y + z; if(7 == y ^ z != w) System.out.println(w); else System.out.println(z); } } }
<br>
&amp; , | -&gt; 비트 연산으로써, 2진법을 비트연산하면 된다. <br>
x ^ y 연산은 비트 XOR연산으로써,<br>
001 -&gt; y != z<br>
000 -&gt; 1 == x<br>
--- (같으면 0 / 다르면 1)<br>
001 -&gt; 4 가 된다. <br>a = 100 result = 0 for i in range(1,3): result = a &gt;&gt; i result = result + 1 print(result)
<br>i = 1,2 수행
<br>a &gt;&gt; i 는 오른쪽 시프트 연산자로써, a값을 오른쪽으로 i비트 움직인다는 뜻이다.
<br>파이썬에서 정수는 4Byte이므로, 8bit x 32개 로 계산하면 된다.
<br>0000 ... 0001100100 -&gt; 100 (4 + 32 + 64)<br>
시프트 연산을 한번 수행하면<br>
0000 ... 0000110010 -&gt; 50 (2 + 16 + 32)<br>
+1 을 하면 51 -&gt; 110011 <br>
한번 더 수행하면 100을 두칸 시프트 한다<br>
0000 ... 0000011001 -&gt; 25 (1 + 8 + 16)<br>
25+1 = 26 <br>파이썬의 print 기본적으로 파이썬의 print는 print(end='\n') 이 포함된 식이다. (줄바꿈 디펄트)<br>
즉 print("123", end=' ')로 표현하면 줄바꿈 대신 공백이 삽입된다.
<br>public class Test { public static void main(String[]args) { int a[] = new int[8]; int i = 0; int n = 10; while( "( 1 )" ) { a[i++] = "( 2 )"; n /= 2; } for(i = 7; i &gt;= 0; i--) System.out.print(a[i]); } }
<br>n /= 2;란 n = n / 2랑 동일한 문법이다.
<br>먼저, 10진수를 2진수로 변환하기 위해서는, 2로 계속해서 나누어, 나머지를 삽입하면된다.<br>10 / 2 = 5(0)
5 / 2 = 2(1)
2 / 2 = 1(0) (1)
10 -&gt; 1010 (8+2) 19 / 2 = 9(1)
9 / 2 = 4(1)
4 / 2 = 2(0)
2 / 2 = 1(0)
(1)
19 -&gt; 10011 (16+2+1)
<br>JAVA는 배열 선언시 초기화를 하지 않으면 0 이 삽입된다<br>
a[i++] = x 를 수행하면 i번째 자리에 값 삽입 후, i값을 증가시킨다.<br>첫번째 조건식에는 n &gt; 0을 넣는다.
<br>16일때, a[] 배열에는 11001 순서로 들어가게된다.
<br>n % 2(나머지가 계속 들어간다.)<br>
10 -&gt; 5 -&gt; 2 -&gt; 1 -&gt; 0(조건식에 부합) 실행 X<br>
0 1 0 1<br>
a = [0,1,0,1,0,0,0,0]
<br>를 역순으로 출력하면 1010 이 된다.<br>
출력은 00001010이 된다.
<br>]]></description><link>http://lts.kr/study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-프로그래밍-제어문.html</link><guid isPermaLink="false">study/정보처리기사/정보처리기사 실기/🥇 정보처리 기사 실기 프로그래밍-제어문.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 12 Mar 2025 05:37:59 GMT</pubDate></item><item><title><![CDATA[⏰ Script 로딩 지연 이슈]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:Script" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Script</a> <a class="tag" href="http://lts.kr/?query=tag:로딩지연" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#로딩지연</a> <a class="tag" href="http://lts.kr/?query=tag:성능개선" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#성능개선</a> <br> <a href="http://lts.kr?query=tag:Script" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Script">#Script</a> <a href="http://lts.kr?query=tag:로딩지연" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#로딩지연">#로딩지연</a> <a href="http://lts.kr?query=tag:성능개선" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#성능개선">#성능개선</a><br><img alt="Pasted image 20241105110415.png" src="http://lts.kr/사진-및-문서/pasted-image-20241105110415.png" style="width: 575px; max-width: 100%;" target="_self"><br>mainLayout은 Contents loading 후 Script를 호출하기 때문에, 특정 정적 오브젝트의 로딩이 완전히 마무리 될때 까지 실행되지 않음.<br>
=&gt; ex) 상품이 로딩되지 않은 상태로 최대 20초 가량을 대기 하게 됨<br>
<img alt="Pasted image 20250227140437.png" src="http://lts.kr/사진-및-문서/pasted-image-20250227140437.png" style="width: 600px; max-width: 100%;" target="_self">
<br><img alt="Pasted image 20250227140620.png" src="http://lts.kr/사진-및-문서/pasted-image-20250227140620.png" target="_self"><br>icon(아이콘)
<br>font(폰트)
<br> 현재 원인이 되는 외부자원(이미지/CSS)가 로딩되기 이전에 이벤트를 트리거 할 수 있다.<br>
이때, HTML DOM 트리가 준비 된 후(HTML 템플릿이 준비된 후)에 실행되기 때문에 modelAndView.addObject()로 전달한 데이터를 확정적으로 받아올 수 있다.<br>
<br>기존 메인 진입 소요시간 case 1 (로컬)<br>
<img alt="Pasted image 20241105110637.png" src="http://lts.kr/사진-및-문서/pasted-image-20241105110637.png" style="width: 500px; max-width: 100%;" target="_self"><br>
23초
<br>
<br>기존 메인 진입 소요시간 case 2 (로컬)<br>
<img alt="Pasted image 20241105110713.png" src="http://lts.kr/사진-및-문서/pasted-image-20241105110713.png" style="width: 500px; max-width: 100%;" target="_self"><br>
22초
<br>
<br>기존 메인 진입 소요시간 case 1 (운영)<br>
<img alt="Pasted image 20241107115602.png" src="http://lts.kr/사진-및-문서/pasted-image-20241107115602.png" style="width: 475px; max-width: 100%;" target="_self"><br>
21초
<br>
<br>기존 메인 진입 소요시간 case 2 (운영)<br>
<img alt="Pasted image 20241107115830.png" src="http://lts.kr/사진-및-문서/pasted-image-20241107115830.png" style="width: 475px; max-width: 100%;" target="_self"><br>
21초
<br>
<br>변경된 메인 진입 소요시간 case 1 (로컬)<br>
<img alt="Pasted image 20241107121044.png" src="http://lts.kr/사진-및-문서/pasted-image-20241107121044.png" style="width: 500px; max-width: 100%;" target="_self"><br>
0.201초
<br>
<br>변경된 메인 진입 소요시간 case 2 (로컬)<br>
<img alt="Pasted image 20241107121202.png" src="http://lts.kr/사진-및-문서/pasted-image-20241107121202.png" style="width: 500px; max-width: 100%;" target="_self"><br>
0.297초
<br>
<br>변경된 메인 진입 소요시간 case 3 (로컬)<br>
<img alt="Pasted image 20241107121939.png" src="http://lts.kr/사진-및-문서/pasted-image-20241107121939.png" style="width: 500px; max-width: 100%;" target="_self"><br>
0.232초
<br>
리로드 후 스크립트(상품 리스트)로드 시까지
<br>기존 투자하기 소요시간 case 1<br>
<img alt="Pasted image 20250227114750.png" src="http://lts.kr/사진-및-문서/pasted-image-20250227114750.png" target="_self"><br>
22.4초<br>
<img alt="Pasted image 20250227114826.png" src="http://lts.kr/사진-및-문서/pasted-image-20250227114826.png" target="_self">
<br>
<br>기존 투자하기 소요시간 case 2<br>
<img alt="Pasted image 20250227115004.png" src="http://lts.kr/사진-및-문서/pasted-image-20250227115004.png" target="_self"><br>
22.6초<br>
<img alt="Pasted image 20250227115015.png" src="http://lts.kr/사진-및-문서/pasted-image-20250227115015.png" target="_self">
<br>
<br>기존 투자하기 소요시간 case 3<br>
<img alt="Pasted image 20250227115158.png" src="http://lts.kr/사진-및-문서/pasted-image-20250227115158.png" target="_self"><br>
22.5초<br>
<img alt="Pasted image 20250227115148.png" src="http://lts.kr/사진-및-문서/pasted-image-20250227115148.png" target="_self">
<br>
<br>변경 투자하기 소요시간 case 1<br>
<img alt="Pasted image 20250227121009.png" src="http://lts.kr/사진-및-문서/pasted-image-20250227121009.png" style="width: 500px; max-width: 100%;" target="_self"><br>
0.373초
<br>
<br>변경 투자하기 소요시간 case 2<br>
<img alt="Pasted image 20250227121046.png" src="http://lts.kr/사진-및-문서/pasted-image-20250227121046.png" style="width: 500px; max-width: 100%;" target="_self"><br>
0.362초
<br>
<br>변경 투자하기 소요시간 case 3<br>
<img alt="Pasted image 20250227121942.png" src="http://lts.kr/사진-및-문서/pasted-image-20250227121942.png" style="width: 475px; max-width: 100%;" target="_self"><br>
0.360초
<br><img alt="Pasted image 20250227122010.png" src="http://lts.kr/사진-및-문서/pasted-image-20250227122010.png" target="_self"><br><img alt="Pasted image 20250227122736.png" src="http://lts.kr/사진-및-문서/pasted-image-20250227122736.png" target="_self"><br>
<br>aceat.js?advid=1954816599 - 에이스트레이더<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://cdn.nhnace.com/libs/aceat.js?advid=195481" target="_self">https://cdn.nhnace.com/libs/aceat.js?advid=195481</a>
<br>synchronizer.js - 네이버 관련 서버<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://ssl.pstatic.net/melona/libs/gfp-nac-module/synchronizer.js" target="_self">https://ssl.pstatic.net/melona/libs/gfp-nac-module/synchronizer.js</a>
<br>collect?en=page_view&amp;dr=localhost&amp;dl=http%... - 구글<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.google.com/ccm/collect" target="_self">https://www.google.com/ccm/collect</a>... - 구글
<br>869613409/?random=1740626824235&amp;cv=11&amp;f...<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.google.com/pagead/1p" target="_self">https://www.google.com/pagead/1p</a>...
<br>869613409/?random=1740626824235&amp;cv=11&amp;f... <br>869613409/?random=1110219531&amp;cv=11&amp;fst=... <br>
내부망 사용으로 인한 요청 실패, 중요 데이터 없음.
<br><img alt="output (14).png" src="http://lts.kr/사진-및-문서/output-(14).png" target="_self"><br>Main 페이지: 기존 21~23초 → 0.201~0.297초로 약 99% 속도 향상<br>
ProductList 페이지: 기존 22.4~22.6초 → 0.360~0.373초로 약 98% 속도 향상<br>
<br>정상 투자 확인<br>
<img alt="Pasted image 20250304121056.png" src="http://lts.kr/사진-및-문서/pasted-image-20250304121056.png" style="width: 475px; max-width: 100%;" target="_self"><br>
<img alt="Pasted image 20250304121009.png" src="http://lts.kr/사진-및-문서/pasted-image-20250304121009.png" style="width: 475px; max-width: 100%;" target="_self"><br>
<img alt="Pasted image 20250304121455.png" src="http://lts.kr/사진-및-문서/pasted-image-20250304121455.png" style="width: 475px; max-width: 100%;" target="_self"><br>
<img alt="Pasted image 20250304121338.png" src="http://lts.kr/사진-및-문서/pasted-image-20250304121338.png" style="width: 500px; max-width: 100%;" target="_self">]]></description><link>http://lts.kr/issue_troubleshooting/⏰-script-로딩-지연-이슈.html</link><guid isPermaLink="false">Issue_TroubleShooting/⏰ Script 로딩 지연 이슈.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 12 Mar 2025 00:38:57 GMT</pubDate><enclosure url="http://lts.kr/사진-및-문서/pasted-image-20241105110415.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="http://lts.kr/사진-및-문서/pasted-image-20241105110415.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🥇 정보처리 기사 실기 SQL 문제]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:정보처리기사" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정보처리기사</a> <a class="tag" href="http://lts.kr/?query=tag:실기" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#실기</a> <a class="tag" href="http://lts.kr/?query=tag:SQL" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SQL</a> <a class="tag" href="http://lts.kr/?query=tag:정리" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정리</a> <br> <a href="http://lts.kr?query=tag:정보처리기사" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정보처리기사">#정보처리기사</a> <a href="http://lts.kr?query=tag:실기" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#실기">#실기</a> <a href="http://lts.kr?query=tag:SQL" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SQL">#SQL</a> <a href="http://lts.kr?query=tag:정리" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정리">#정리</a><br>CREATE TABLE 부서 ( 부서코드 INT PRIMARY KEY, 부서명 VARCHAR(20)
); CREATE TABLE 직원 ( 직원코드 INT PRIMARY KEY, 부서코드 INT, 직원명 VARCHAR(20), FOREIGN KEY(부서코드) REFERENCES 부서(부서코드) ON DELETE CASCADE
); INSERT INTO 부서 VALUES(10, '영업부');
INSERT INTO 부서 VALUES(20, '기획부');
INSERT INTO 부서 VALUES(30, '개발부'); INSERT INTO 직원 VALUES(1001, 10, '이진수');
INSERT INTO 직원 VALUES(1002, 10, '곽명경');
INSERT INTO 직원 VALUES(1003, 20, '김건길');
INSERT INTO 직원 VALUES(1004, 20, '최민수');
INSERT INTO 직원 VALUES(1005, 20, '이용광');
INSERT INTO 직원 VALUES(1006, 30, '한성광');
INSERT INTO 직원 VALUES(1007, 30, '박미경');
<br>SELECT DISTINCT COUNT(부서코드) FROM 직원 WHERE 부서코드 = 20;
<br>결과: 3<br>해설 :<br>DISTINCT(중복 제거)는 부서코드가 아닌 COUNT(부서코드)에 적용되므로, 여전히 부서코드가 20인 컬럼의 수 '3'이 된다.
<br>DELETE FROM 부서 WHERE 부서코드 = 20;
SELECT DISTINCT COUNT(부서코드) FROM 직원;
<br>결과: 4<br>해설 :<br>부서코드가 20인 컬럼을 삭제한 후, 모든 직원테이블의 부서코드 개수를 센다. 이때 DISTINCT(중복 제거)는 COUNT에 적용되므로<br>
여전히 '4'이다.
<br>
<br>DEPT는 '학과'를 뜻한다
<br>가정: 전기과 학생 50명, 전자과 학생 100명, 전산과 학생 50명<br>SELECT DEPT FROM STUDENT;
<br>결과: 200<br>SELECT DISTINCT DEPT FROM STUDENT;
<br>결과: 3<br>해설 :<br>전기/전자/화학 3가지 종류로 이루어진 DEPT 속성의 중복을 제거하면 '3'이 남는다.
<br>SELECT COUNT(DISTINCT DEPT) FROM STUDENT WHERE DEPT = '전산과';
<br>결과: 1<br>해설 :<br>전산과인 학생들의 학과를 뽑는다. 이후 해당 학과의 중복을 제거하면 1개만 남게 된다.
<br>
<br>'H'제조사의 '단가' 보다 높은 '단가'를 가진 제품의 정보를 조회하는 SQL문이다.
<br>SELECT 제품명, 단가, 제조사
FROM 제품
WHERE 단가 &gt; ( ) (SELECT 단가 FROM 제품 WHERE 제조사 = 'H');
<br>답: ALL<br>해설 :<br>해당 쿼리는, where절의 하위 질의에 결과를 반영하여 본 질의의 조건에 추가하는 SQL이다.
<br>만약 서브쿼리에서 'H'제조사의 제품의 단다가 100/200/400 이 나왔다면,
<br>해당 단가들 보다 높은 단가를 찾기 위해서는 100/200/400을 모두 비교하여야 한다.
<br>따라서 ALL키워드가 들어간다면 모든 단가를 비교할 수 있다.
<br>서브쿼리 앞에 아무 키워드도 붙지 않는다면, 서브쿼리가 다중 행일때 오류를 발생시킨다.<br>
이때, ANY나 ALL 연산자를 사용하여 다중행을 비교할 수 있다.<br>ANY -&gt; 서브쿼리 결과 중 하나라도 참이면 해당 행은 참<br>
ALL -&gt; 서브쿼리 결과 중 모든 것에 참이어야 해당 행은 참<br>TABLE<br>SELECT COUNT(COL2)
FROM TABLE
WHERE COL1 IN (2, 3) OR COL2 IN (3, 5);
<br>결과: 3<br>해설 :<br>COL1 컬럼에 2나 3이 포함되었거나, COL2컬럼에 3이나 5가 포함된 컬럼 (4개)를 찾는다,
<br>
<br>여기서 NULL은 COUNT에 집계가 되지 않으므로 답은 '3'이다.
<br><img alt="Pasted image 20250225161448.png" src="http://lts.kr/사진-및-문서/pasted-image-20250225161448.png" target="_self"><br>결과 :<br>① TTL - ② 부장 - ③ 대리 - ④ 과장 - ⑤ 차장
<br>해설 :<br>해당 관계 대수식의 파이는 속성 리스트에 제시된 속성값만을 추출하여 새로운 릴레이션을 만드는 PROJECT연산이다
<br>따라서, TTL속성이 추출되어 속성명인 TTL부터 모든 속성값이 결과로 나타난다.<br>
= SELECT TTL FROM EMPLOYEE
<br>이 연산들은 관계형 데이터베이스의 데이터를 검색하고 변형하는 데 사용됩니다.<br>관계 대수에서 테이블을 하나의 집합(Set)으로 간주하고 수행하는 연산입니다.<br>(단, SQL문은 ISO/IEC 9075 표준을 기반으로 작성하시오.) <br>( 1 ) TABLE 학생 ( 2 ) 주소 VARCHAR(20);
<br>답 :<br>
1 -&gt; ALTER<br>
2 -&gt; ADD<br>해설 :<br>속성을 추가한다 -&gt; 테이블을 수정한다 -&gt; ALTER
<br>ALTER + ADD 속성 추가.
<br>
<br>3, 4학년의 학번, 이름을 조회한다.
<br>IN 예약어를 사용해야 한다.
<br>속성명 아래의 괄호는 속성의 자료형을 의미한다.
<br>정답 :<br>SELECT 학번, 이름 FROM 학생 WHERE 학년 IN (3, 4);
<br>해설 :<br>IN예약어는 WHERE절과 함께 쓰이며, WHERE 속성 IN (조건,조건,...) 방식으로 사용된다.
<br>해당 조건을 포함하고 있는 모든 속성이 선택되게 된다.
<br>student 테이블<br>정답 :<br>CREATE INDEX idx_name ON student(name);
<br>해설 :<br>인덱스 생성 문법 :<br>
CREATE INDEX 인덱스명 ON 테이블명(속성);
<br>(단, 아래의 실행 결과가 되도록 한다.)<br>
<br>
WHERE 조건절은 사용할 수 없다. <br>
GROUP BY는 반드시 포함한다. <br>
집계함수(Aggregation Function)를 적용한다. <br>
학과별튜플수 컬럼명을 출력에 Alias(AS)를 활용한다. <br>
문장 끝의 세미콜론(;)은 생략해도 무방하다. <br>
인용부호 사용이 필요한 경우 단일 따옴표(' ')를 사용한다.
정답 : <br>SELECT 학과, COUNT(*) AS 학과별튜플수
FROM 학생
GROUP BY 학과;
<br>&lt;처리 조건&gt;을 참고하여 적합한 SQL문을 작성하시오.<br>
<br>WHERE문은 사용하지 않는다.
<br>GROUP BY와 HAVING을 이용한다.
<br>집계함수(Aggregation Function)를 사용하여 명령문을 구성한다.
<br>최소점수, 최대점수는 별칭(Alias)을 위한 AS문을 이용한다.
<br>명령문 마지막의 세미콜론(;)은 생략 가능하다.
<br>인용 부호가 필요한 경우 작은따옴표(')를 사용한다.
<br>정답 :<br>SELECT 과목이름, MIN(점수) AS 최소점수, MAX(점수) AS 최대점수 FROM 성적 GROUP BY 과목이름 HAVING AVG(점수) &gt;= 90;
<br>해설 :<br>과목이름별로 여러 점수의 통계를 내는것 이기 때문에, GROUP BY 과목이름을 사용한다.
<br>이때, GROUP BY ~ HAVING 조건 을 사용하여, 해당 그릅화된 데이터 중 다음 조건을 만족하는 그룹만 포함한다.
<br>SELECT COUNT(*) CNT FROM A CROSS JOIN B WHERE A.NAME LIKE B.RULE;
<br>답 : 4<br>해설 :<br>SELECT COUNT(*) CNT 에서 CNT는 as CNT 가 생략된 형태이다.
<br>CROSS JOIN이란 카디션 프로덕트(곱)을 수행하는 조인방식으로써,<br>
A테이블의 모든 행과, B테이블의 모든 행의 모든 가능한 조합을 구한다.
<br>따라서, 저 중 a.name컬럼이 b.rule을 따르는(like 연산을 했을 때, 참인 결과는)<br>총 4개이다.<br>]]></description><link>http://lts.kr/study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-sql-문제.html</link><guid isPermaLink="false">study/정보처리기사/정보처리기사 실기/🥇 정보처리 기사 실기 SQL 문제.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Mon, 10 Mar 2025 02:50:34 GMT</pubDate><enclosure url="http://lts.kr/사진-및-문서/pasted-image-20250225161448.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="http://lts.kr/사진-및-문서/pasted-image-20250225161448.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[⚔ StckOverflow 이슈와 QueryDSL]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:Spring" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Spring</a> <a class="tag" href="http://lts.kr/?query=tag:StckOverflow" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#StckOverflow</a> <a class="tag" href="http://lts.kr/?query=tag:QueryDSL" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#QueryDSL</a> <a class="tag" href="http://lts.kr/?query=tag:JPA" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#JPA</a> <a class="tag" href="http://lts.kr/?query=tag:DB" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#DB</a> <br> <a href="http://lts.kr?query=tag:Spring" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Spring">#Spring</a> <a href="http://lts.kr?query=tag:StckOverflow" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#StckOverflow">#StckOverflow</a> <a href="http://lts.kr?query=tag:QueryDSL" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#QueryDSL">#QueryDSL</a> <a href="http://lts.kr?query=tag:JPA" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#JPA">#JPA</a> <a href="http://lts.kr?query=tag:DB" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#DB">#DB</a><br>
<br> <img alt="Pasted image 20250307172522.png" src="http://lts.kr/사진-및-문서/pasted-image-20250307172522.png" target="_self">
<br>
<br>
Hello에서는 특별한 상황이 아닌 이상, JPA - QueryDSL 방식으로 코드를 통일하고 있다.<br>
-&gt; QueryDSL: Type-Safe) 동적 SQL을 작성할 수 있도록 도와주는 Java 기반의 ORM(Query Builder)<br>
가독성이 뛰어나며, 컴파일 시점에 오류 검출 가능 <br>
BooleanExpression은 QueryDSL에서 제공하는 동적 쿼리 조합 기능이다.<br>
ex) <br>import com.querydsl.core.types.dsl.BooleanExpression;
import com.querydsl.jpa.impl.JPAQueryFactory;
import java.util.List; public List&lt;User&gt; findUsersByConditions(String name, Integer age) { QUser user = QUser.user; JPAQueryFactory queryFactory = new JPAQueryFactory(entityManager); BooleanExpression predicate = user.isNotNull(); // 기본 조건 (항상 참) if (name != null) { predicate = predicate.and(user.name.eq(name)); } if (age != null) { predicate = predicate.and(user.age.gt(age)); } return queryFactory.selectFrom(user) .where(predicate) .fetch();
} <br>새로운 BooleanExpression 객체를 반환한다.<br>
<br>함수형 조합 : 함수처럼 동적 쿼리 조합을 관리 할 수 있다.(여러 개의 조건을 동적으로 조합 가능)
<br>스레드 안정성 : 불변객체로 생성되므로, 여러 스레드에서 동시에 사용하더라도 안전하다.
<br>BooleanExpression expr1 = user.name.like("A%");
BooleanExpression expr2 = expr1.and(user.age.gt(20));
<br>BooleanExpression은 위에서 설명한 바와 같이, Immutable(불변)객체이다.<br>
이 때, 위와같이 and/or 연상을 호출하면, 기존 객체를 변경하는 것이 아닌, 새로운 객체를 만들어 낸다.<br>해당 연산은 연쇄적으로 새로운 객체를 생성하며, 깊이가 n이 되는 트리(Tree)구조가 형성된다.<br>
or() / and() 연산을 할 때마다 기존 객체를 참조하는 새로운 객체가 생성됨.<br>StckOverflow가 발생하게 되는 것이다.<br>import com.querydsl.core.BooleanBuilder;
import com.querydsl.core.types.dsl.BooleanExpression;
import java.util.List; public BooleanExpression buildPredicateEfficiently(List&lt;String&gt; patterns) { QUser user = QUser.user; BooleanBuilder builder = new BooleanBuilder(); // 동적 조건을 쌓는 도구 for (String pattern : patterns) { builder.or(user.name.like(pattern + "%")); // 재귀 호출 없이 추가 } return builder;
}
<br>BooleanBuilder는 객체를 생성할 때, 내부적으로 BooleanExpression을 List 형태로 관리하게 된다.
<br>따라서, 불필요한 재귀 호출 없이 메모리를 효율적으로 사용할 수 있다.
<br>List&lt;String&gt; names = List.of("A", "B", "C"); List&lt;User&gt; users = queryFactory .selectFrom(user) .where(user.name.in(names)) .fetch(); <br>리스트(Set, List, 배열) 데이터를 한 번에 비교
<br>B-tree 인덱스를 활용하여 더 효율적인 검색 가능
<br>대량 데이터를 비교할 때 성능이 더 좋음
<br>하지만!<br>WHERE IN절은 값의 일치(Equality Check, =)만을 지원하기 때문에, Like연산과 같은 패턴 매칭을 이용하기 위해선 BooleanBuilder를 사용해야한다.
<br>다중 컬럼 비교가 불가능하기 떄문에, 2개 이상의 컬럼을 비교하려면 BooleanBuilder를 사용해야한다.
<br>]]></description><link>http://lts.kr/issue_troubleshooting/⚔-stckoverflow-이슈와-querydsl.html</link><guid isPermaLink="false">Issue_TroubleShooting/⚔ StckOverflow 이슈와 QueryDSL.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Mon, 10 Mar 2025 02:49:35 GMT</pubDate><enclosure url="http://lts.kr/사진-및-문서/pasted-image-20250307172522.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="http://lts.kr/사진-및-문서/pasted-image-20250307172522.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[👻 Obsidian 정적호스팅 CICD 과정]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:프로젝트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로젝트</a> <a class="tag" href="http://lts.kr/?query=tag:개발" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#개발</a> <a class="tag" href="http://lts.kr/?query=tag:Hosting" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Hosting</a> <a class="tag" href="http://lts.kr/?query=tag:Obsidian" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Obsidian</a> <a class="tag" href="http://lts.kr/?query=tag:CI/CD" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#CI/CD</a> <br> <a href="http://lts.kr?query=tag:프로젝트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로젝트">#프로젝트</a> <a href="http://lts.kr?query=tag:개발" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#개발">#개발</a> <a href="http://lts.kr?query=tag:Hosting" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Hosting">#Hosting</a> <a href="http://lts.kr?query=tag:Obsidian" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Obsidian">#Obsidian</a> <a href="http://lts.kr?query=tag:CI/CD" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#CI/CD">#CI/CD</a><br> 먼저 옵시디언(Obsidian)에 대한 정보를 확인하고 싶다면.<br>정보!
현재 보고있는 해당 사이트는 Obsidian앱의 지속적인 통합(CI), 지속적인 배포(CD)를 구현한 사이트이다. <br>아주 기본적인 셋팅이므로, 이후 커스텀은 각자의 취향대로 진행하면 될 것이다.
<br>WAS가 아닌 WEB 정적 호스팅을 위한 셋팅이다. <br><img alt="Pasted image 20250218151731.png" src="http://lts.kr/사진-및-문서/pasted-image-20250218151731.png" target="_self"><br>
<img alt="Pasted image 20250218151806.png" src="http://lts.kr/사진-및-문서/pasted-image-20250218151806.png" target="_self"><br>이후 해당 위치에 Git을 생성해 줄 것이다.
<br><img alt="Pasted image 20250218152044.png" src="http://lts.kr/사진-및-문서/pasted-image-20250218152044.png" target="_self"><br>
<img alt="Pasted image 20250218152103.png" src="http://lts.kr/사진-및-문서/pasted-image-20250218152103.png" target="_self"><br>
<br>이전 생성한 옵시디언 폴더로 이동한다.
<br>&gt; cd C:\이하경로\obsidian\TEST
<br><img alt="Pasted image 20250218153131.png" src="http://lts.kr/사진-및-문서/pasted-image-20250218153131.png" target="_self"><br>깃 파일 생성<br>
해당 과정전 pc에 Git이 설치되어 있어야한다. (방법은 알아서)
<br>&gt; git init
<br><img alt="Pasted image 20250218153319.png" src="http://lts.kr/사진-및-문서/pasted-image-20250218153319.png" target="_self"><br>깃 레포에 연결
<br>&gt; git remote add origin https://github.com/LeeTaeSung0628/obsidian_Test.git
<br><img alt="Pasted image 20250218153445.png" src="http://lts.kr/사진-및-문서/pasted-image-20250218153445.png" target="_self"><br>옵시디언 레포에 올리기
<br>&gt; git add . &gt; git commit -m "initial commit" &gt; git push -u origin master
<br><img alt="Pasted image 20250218153543.png" src="http://lts.kr/사진-및-문서/pasted-image-20250218153543.png" target="_self"><img alt="Pasted image 20250218153553.png" src="http://lts.kr/사진-및-문서/pasted-image-20250218153553.png" style="width: 700px; max-width: 100%;" target="_self"><br>여기까지 따라왔다면, 옵시디언 파일을 git 레포지토리에 저장하는 것 까지 마칠 수 있다.<br><img alt="Pasted image 20250218151330.png" src="http://lts.kr/사진-및-문서/pasted-image-20250218151330.png" style="width: 1050px; max-width: 100%;" target="_self"><br>
옵시디언의 Git플러그인이다. 기본적인 커밋 푸시 및 셋팅이 가능하다.<br>기능은 제한적이기 때문에, GitDesktop이나, Cmd에서 직접 Git을 셋팅하는것을 추천한다.
<br>이후 셋팅이 완료되었을 때 배포 자동화를 위해 사용하면 편리하다.
<br><img alt="Pasted image 20250218153814.png" src="http://lts.kr/사진-및-문서/pasted-image-20250218153814.png" style="width: 775px; max-width: 100%;" target="_self"><img alt="Pasted image 20250218153858.png" src="http://lts.kr/사진-및-문서/pasted-image-20250218153858.png" target="_self"><br>이전에 생성한 깃 파일의 주소가 들어가면 된다.
<br>C:\Users\경로\obsidian\TEST\.git
<br><img alt="Pasted image 20250218154352.png" src="http://lts.kr/사진-및-문서/pasted-image-20250218154352.png" style="width: 875px; max-width: 100%;" target="_self"><br>또한 설정에서 오토 커밋/푸시/풀 설정을 통해 지속 적인 통합 셋팅이 가능하다.<br>
<img alt="Pasted image 20250218154433.png" src="http://lts.kr/사진-및-문서/pasted-image-20250218154433.png" style="width: 725px; max-width: 100%;" target="_self">
<br>주의
해당 디렉토리에 .gitignore 파일 및 세부적인 git셋팅은 자유롭게 진행하면 된다.<br>
옵시디언은 캐쉬파일로 인한 충돌이 잦기 때문에 상세히 설정하는 것을 추천한다.
<br><img alt="Pasted image 20250218154615.png" src="http://lts.kr/사진-및-문서/pasted-image-20250218154615.png" target="_self"><br>
<img alt="Pasted image 20250218154633.png" src="http://lts.kr/사진-및-문서/pasted-image-20250218154633.png" target="_self"><br>정상적으로 푸시 완료.<br>
<img alt="Pasted image 20250218154647.png" src="http://lts.kr/사진-및-문서/pasted-image-20250218154647.png" target="_self">
<br>
<br>해당 Git 레포는 옵시디언의 마크다운(md파일)자체를 저장하고 관리하는 레포다.
<br>정적 컨텐츠 호스팅을 위한 레포지토리를 추가적으로 생성하여 줄 것이다.
<br>
<br>여러 방법이 있지만, md파일을 기반으로 배포가능한 형태의 HTML파일을 생성해주는 플러그인을 사용할 것이다.<br>
<img alt="Pasted image 20250218155524.png" src="http://lts.kr/사진-및-문서/pasted-image-20250218155524.png" target="_self">
<br>다양한 옵션을 지원하지만, 오늘은 기본적인 기능만 설명하겠다.
<br>Control + P -&gt; export 를 검색
<br><img alt="Pasted image 20250218160328.png" src="http://lts.kr/사진-및-문서/pasted-image-20250218160328.png" target="_self"><br>
<img alt="Pasted image 20250218160359.png" src="http://lts.kr/사진-및-문서/pasted-image-20250218160359.png" target="_self"><br>폴더 생성 후 익스포트 한다.
<br>주의
이때 처음엔 index페이지를 생성하고, 추후 삭제하는 것을 추천(Netlify는 index가 필수)
<br><img alt="Pasted image 20250218160428.png" src="http://lts.kr/사진-및-문서/pasted-image-20250218160428.png" target="_self"><img alt="Pasted image 20250218160532.png" src="http://lts.kr/사진-및-문서/pasted-image-20250218160532.png" target="_self"><br>생성한 새 디렉토리에 정상적으로 생성된것을 볼 수 있다.
<br>
<br>배포용 HTML파일 레포지토리<br>
<img alt="Pasted image 20250218160956.png" src="http://lts.kr/사진-및-문서/pasted-image-20250218160956.png" target="_self">
<br>
<br>Netlify 정적 호스팅 서비스를 사용하여 Git 레포를 배포하겠다.
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.netlify.com/" target="_self">https://www.netlify.com/</a><br>
위 사이트로 접속하여 로그인 한 후, 깃 레포에 Netlify서비스를 적용한다.
1.깃허브를 선택한다.<br>
<img alt="Pasted image 20250218161424.png" src="http://lts.kr/사진-및-문서/pasted-image-20250218161424.png" style="width: 750px; max-width: 100%;" target="_self"><br>
2.배포용 옵시디언 레포를 선택한 후, SAVE를 누른다.<br>
<img alt="Pasted image 20250218161515.png" src="http://lts.kr/사진-및-문서/pasted-image-20250218161515.png" target="_self"><br>
3.site_name을 설정하고 Deploy를 누른다.<br>
<img alt="Pasted image 20250218161728.png" src="http://lts.kr/사진-및-문서/pasted-image-20250218161728.png" target="_self"><br>
정적웹사이트를 위한 셋팅으로 이외의 값은 공란으로 두어도 무방하다. <br>
그리고 기다리면...<br>
<img alt="Pasted image 20250218161824.png" src="http://lts.kr/사진-및-문서/pasted-image-20250218161824.png" target="_self"><br>
<img alt="Pasted image 20250218161847.png" src="http://lts.kr/사진-및-문서/pasted-image-20250218161847.png" target="_self"> <br>
<br>배포가 완료되고, 주소를 입력하여 확인이 가능하다.<br>
<img alt="Pasted image 20250218161937.png" src="http://lts.kr/사진-및-문서/pasted-image-20250218161937.png" target="_self">
<br>
<br>커뮤니티 플러그인
<br>인덱스페이지
<br>테마
<br>etc..
<br>
<br>본인의 경우에는 로컬 Obsidian에 민감정보를 포함하고 있으므로,<br>
정적 호스팅 전, public한 Vault 레포지토리를 거쳐 배포되도록 관리하고 있다.<br>
<img alt="Pasted image 20250218162355.png" src="http://lts.kr/사진-및-문서/pasted-image-20250218162355.png" style="width: 875px; max-width: 100%;" target="_self"> 좌 : 프라이빗 볼트 / 우 : 퍼블릭 볼트 <br>이렇게 사이트 배포가 완료되었다!<br>
<img alt="do-messenger_screenshot_2025-02-19_16_19_04.png" src="http://lts.kr/사진-및-문서/do-messenger_screenshot_2025-02-19_16_19_04.png" target="_self"><br>주의 <br>현재 Export HTML 1.8.01 버전 기준으로 export된 HTML css에 오류가 있다. <br>BRAT 플러그인을 사용하여 버전 업(베타) 하여 해결<br>
<img alt="Pasted image 20250219154331.png" src="http://lts.kr/사진-및-문서/pasted-image-20250219154331.png" target="_self"><br>
<img alt="Pasted image 20250219154315.png" src="http://lts.kr/사진-및-문서/pasted-image-20250219154315.png" target="_self">]]></description><link>http://lts.kr/project/note-ci_cd/👻-obsidian-정적호스팅-cicd-과정.html</link><guid isPermaLink="false">project/note CI_CD/👻 Obsidian 정적호스팅 CICD 과정.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Mon, 10 Mar 2025 02:32:40 GMT</pubDate><enclosure url="http://lts.kr/사진-및-문서/pasted-image-20250218151731.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="http://lts.kr/사진-및-문서/pasted-image-20250218151731.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🔐 상품 투자하기 서비스 이슈 및 Lock기법 개선안]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:SQL" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SQL</a> <a class="tag" href="http://lts.kr/?query=tag:Lock" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Lock</a> <a class="tag" href="http://lts.kr/?query=tag:개선" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#개선</a> <a class="tag" href="http://lts.kr/?query=tag:이슈" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#이슈</a> <a class="tag" href="http://lts.kr/?query=tag:세미나" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#세미나</a> <br> <a href="http://lts.kr?query=tag:SQL" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SQL">#SQL</a> <a href="http://lts.kr?query=tag:Lock" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Lock">#Lock</a> <a href="http://lts.kr?query=tag:개선" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#개선">#개선</a> <a href="http://lts.kr?query=tag:이슈" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#이슈">#이슈</a> <a href="http://lts.kr?query=tag:세미나" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#세미나">#세미나</a><br>
<br>투자자 투자실행 시 순서보장X <br>Lock해제와 정합성 이슈 <br>헬로의 투자 서비스는 다음과 같다.<br>특정 scf / 주택담보대출 상품에 대해 투자자를 모집한다.
<br>투자자들은 특정시간에 open되는 상품에 일괄적으로 투자신청을한다. <br>이때, 각 회원별로 "투자 신청 기록"을 진행한다.
<br>투자신청 기록이란, P2PCenter(금융결제원) API를 통해 유효성(투자기록 / 투자한도)을 조회하여 투자적합여부를 체크하고 기록하는것을 말한다. <br>회원별 검증 및 투자금 계산을 마치면 정상 투자가 진행된다.
<br>이때, 투자신청 기록 로직에서 Lock기법이 적용되어있다.<br>
<br>
Lock기법은 여러 요청이 같은 리소스에 접근하려 할 때, 한 번에 하나의 요청만을 처리하도록 막는 기법이다. <br>
데이터 정합성이 무엇보다 중요한 서비스에서 충돌을 방지하여 일관성을 효과적으로 유지하기 위함이다. <br>
헬로 서비스의 경우, 회원 idx로 lock을 유지하여 성능과 안정성 확보<br>
-상품별 한도 / 투자자 일별 투자상한 / 투자 금액 / 예치금 등 정합성이 무엇보다 우선시 되는 데이터들이 포함 <br>(JVM 레벨 Lock)<br>import org.springframework.stereotype.Service; @Service
public class SynchronizedLockService { private int counter = 0; public synchronized void increment() { counter++; System.out.println(Thread.currentThread().getName() + " - 현재 카운트: " + counter); }
} <br>JVM레벨에서 동작하므로, 분산환경에서는 동작 X, 성능 빠름
<br>(DB를 활용하여 Lock구현)<br>CREATE TABLE lock_table ( id INT PRIMARY KEY, locked BOOLEAN NOT NULL DEFAULT FALSE
);
<br> @Transactional public void doSomethingWithLock() { // 행 잠금 (SELECT FOR UPDATE) jdbcTemplate.queryForObject("SELECT * FROM lock_table WHERE id = 1 FOR UPDATE", (rs, rowNum) -&gt; rs.getInt("id")); System.out.println(Thread.currentThread().getName() + " - 데이터베이스 Lock 획득!"); try { Thread.sleep(5000); // 작업 수행 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + " - 작업 완료!"); }
<br>DB만으로 구현 가능, 트렌젝션 격리레벨에 따라 멀티인스턴스(분산환경)에서 정합성 보장 가능
<br>모든 요청이 DB lock을 기다리므로 속도 느림(lock이 해제될때 까지 대기), 데드락 가능성있음<br>
-&gt; 레디션 락은 블록킹하지 않고, Polling방식으로 재시도 가능.<br>
커넥션 pool 미 소유 및 TTL로 데드락 방지
<br>
<br>설계 방법에 따라, 강한 일관성 유지 가능하지만, 추가적인 설계/개발이 필요.
<br>높은 트래픽을 감당할 수 있음. (동시요청)
<br>수평적 확장에 용이(스케일 아웃)
<br>
<br>설계 방법에 따라, lock / 대기열 모두 일관성(데이터 정합성)을 유지할 수 있지만,<br>
lock 기법 사용시 추가적인 셋팅 없이 쉽게 일관성 및 실시간 처리를 구현할 수 있기에 채택되었다.
<br>
<br>동시성 이슈를 해결하고자.
<br>동시성 이슈란? <br>문맥에 따라 조금씩 차이는 있겠지만<br>
여기서는 '여러 스레드가 동시에 공유 자원에 접근할 때 발생하는 문제'<br>
로 정의하겠다. <br>동시성 이슈를 대응해야할 곳.<br>모집금액과, 상품 별 동일 차주 투자 한도를 넘지 않게 상품의 동시성 이슈
<br>p2p투자한도와 예치금 한도를 넘지 않게 회원별 동시성 이슈
<br>우리는 외부은행에 투자자,대출자 돈을 모두 맡겨두고 운영(신탁 운영)중이다.<br>한도를 금결원 api를 통해 매번 체크
<br>실제 돈이 빠져나가는 시점은, 모든 투자기록을 마친 후, 대출을 실행하는 시점에서 돈을 가져간다.<br>회원별 동시성
<br>세마포어 뮤텍스 비관적락 등 여러 방법론이 있지만, 우리는 redisson lock을 사용하였다.<br>k8s를 통해 여러 server를 띄워놓는 분산환경이기 때문.
<br>먼저, 헬로 투자하기 서비스는 redisson lock을 사용한다.<br>Lock testLock = redissonClient.getLock("affterProcessorLock-" + Idx);
testLock.tryLock(4, 4, TimeUnit.SECONDS);
// ...투자 로직
testLock.unlock();
<br>
<br>Redis기반의 분산 락 구현체이다.
<br>멀티 서버 환겨에서 동시성 문제를 해결하기 위해 사용된다.
<br>여러개의 애플리케이션 인스턴스가 동일한 공유자원에 접근할 때, 중복 처리나 데잍터 불일치 문제를 방지해준다.
<br>단일 서버 환경에서는 synchronized, 일반 Lock을 통해 임계 구역을 보호할 수 있다.<br>
하지만, 멀티서버(분산 시스템) 환경에서는 이런<br>
임계구역(Critical Section) : 여러 프로세스 또는 스레드가 공유 자원(Shared Resource) 에 접근하는 코드 영역
<br>
<br>분산 환경에서의 동시성 문제를 효과적으로 해결하기 위함
<br>싱글스레드 큐 방식의 Redis는 왜 순서를 보장하지 않는가?<br>Redis가 lock을 관리하는 과정 자체는 싱글 스레드 큐 방식이다.<br>
허나, Redisson Lock은 비동기 이벤트 기반의 락 처리 방식을 사용한다.
<br>즉, 락을 흭득하려는 프로세스는 우선순위가 없는 경쟁적락방식이다.
<br>정보
FIFO 방식의 "공정 락(Fair Lock)"또한 지원하여 원하는 바 사용 가능하다. <br>대기열 방식이라고 봐도 되겠다. <br>
<br>여러 클라이언트(서버 또는 스레드)가 동시에 같은 락을 요청할 수 있음.
<br>가장 먼저 Redis에 락을 설정한 클라이언트가 락을 획득(경쟁 방식).
<br>락을 획득한 클라이언트가 해제해야 다른 클라이언트가 락을 획득 가능.
<br>락이 만료되거나 자동 연장(Watchdog)되면서 동작.
<br>이러한 동작 방식 때문에, Starvation(기아 현상)이 야기되는 문제가 있다.<br>기아현상이란, 고부하 환경에서 락을 흭득하려는 클라이언트가 많으면, 후순위 요청이 계속해서 무시될 가능성이 생기긴다.<br>
즉, A투자자가 먼저 투자를 하였음에도 불구하고 그 다음에 실행한 투자자 B,C가 먼저 처리될 수 있다는것이다.<br>그리고 실제 운영 환경에서 해당 경우를 심심치 않게 찾아볼 수 있다.<br>최대 30초 이상 대기상태에서 기다린 인원이 있음.<br>
-&gt; 그러나 평균 속도는 대기열에 비해 굉장히 빠르다.(추가적인 대기열(FIFO 큐)이 없기 때문에 락 획득 속도가 빠름)
<br>해당 질문에 대한 답은,<br>
분산환경에서 고부하 api통신, I/O 작업을 수행하며 적절한 퍼포먼스를 유지하기 위한 타협점 이라고 볼 수 있다.<br>
<br>상품을 미리 열어, 투자 금액 데이터를 쌓는 원리.
<br>해당 방법을 사용하면 데이터 정합성 및 속도를 보장받을 수 있다.
<br>
<br>투자자 입장에서는 투자 완료 이후 취소 통보를 받을 수 있음. <br>투자자 개인 한도는 금융결제위원회에서 관리하며, 타 업체의 한도와 공유되어 중복투자로인한 취소 가능성
<br>상품 투자 한도 초과로 인한 취소가능성<br>
해당 경우에 재 투자를 받아야 할 경우도 생김 <br>
사내 정책의 문제 또한 존재하기 때문에, 모든 부분에서 완벽하기란 쉽지 않아 보인다.
<br>
<br>lock이 풀리는 이유?
<br>
<br>현재 설정으로, Redisson Lock은 4sec의 TTL을 갖는다.<br>
이때, 외부응답 지연으로 TTL을 초과해 버리게 된다면, lock을 해제함과 동시성이 깨질 수 있는 가능성이 있다.
<br>어쩨서??<br>A, B 상품에 대하여, 단일 투자자가 투자를 했을 때<br>
A상품에 대한 투자를 완료처리하여 ( 원래였으면 lock처리될 )예치금 차감이 되지 않은 상태에서 락이 풀려버린다면?<br>
B상품에 대한 투자도 정상처리가 되어버린다.
<br>
<br>매 투자 건 별로 조회하는 개인별 투자한도를 redis로 관리하여, 투자건별 속도 개선을 목표로함.<br>
한계 : 투자 건 별 TTL초과 확률을 줄일 수는 있으나, 외부에 의존적인 투자구조 상 100% 해결할 수는 없음
<br>(1번 이슈와 같은 해결 방법)<br>상품을 미리 열어, 투자 금액 데이터를 쌓는 원리.
<br>해당 방법을 사용하면 데이터 정합성 및 경합을위한 락 사용 불필요
<br>결론
현재 신탁 운영으로 인한 한도 데이터를 직접관리하지 못하는 문제와,<br>
보수적인 운영상의 방침으로 큰 구조 개선을 힘들어 보임
현재는 리펙토링을 통해 lock에 묶여있는 로직을 단순화 하는것에 만족해야겠음.]]></description><link>http://lts.kr/issue_troubleshooting/🔐-상품-투자하기-서비스-이슈-및-lock기법-개선안.html</link><guid isPermaLink="false">Issue_TroubleShooting/🔐 상품 투자하기 서비스 이슈 및 Lock기법 개선안.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Mon, 10 Mar 2025 01:55:57 GMT</pubDate></item><item><title><![CDATA[👩‍👧‍👦 marketing Analytics 공통모듈 제작기]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:프로젝트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로젝트</a> <a class="tag" href="http://lts.kr/?query=tag:개발" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#개발</a> <a class="tag" href="http://lts.kr/?query=tag:DB" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#DB</a> <a class="tag" href="http://lts.kr/?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <a class="tag" href="http://lts.kr/?query=tag:AOP" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#AOP</a> <br> <a href="http://lts.kr?query=tag:프로젝트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로젝트">#프로젝트</a> <a href="http://lts.kr?query=tag:개발" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#개발">#개발</a> <a href="http://lts.kr?query=tag:DB" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#DB">#DB</a> <a href="http://lts.kr?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a> <a href="http://lts.kr?query=tag:AOP" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#AOP">#AOP</a> <br>개요 <br>Hello Service의 유입/동작 통계 모듈의 공통화 작업이다.
<br>Spring AOP를 사용하여 구성하였다. <br>
<br>통계 필요 페이지 내에서(front &gt; back)
<br>
<br>쿠키 데이터 페이지 별 최초 진입 확인?\
<br>
<br>기존 외부 유입 통계 로직의 단점 해결. <br>확장에 닫혀있음
<br>디테일한 행동 추적 불가능
<br>중복 접근자 처리로직의 부재 <br>
<br>해당 진입시점부터 특정 동작에 대한 모든 타임라인 로그
<br>
<br>레디스 가용 메모리에 대한 한계값 산정. -&gt; 아직 적용 X
<br>
<br>URL + 함수명 조합
<br>=&gt; 메인 테이블<br>
=&gt; 백로직에서 쿠키 데이터 쌓기<br>=&gt; 디테일 테이블 - 타임라인으로 관리 단, 메인테이블에 존재하는 내셕들에 대해서<br>
=&gt; AOP에서 특정 서비스or메서드orURL로 지정하여 로그 쌀기<br>- 관심사(Aspect)를 분리하여, 각 서비스 메서드에 반복해서 구현하는 것이 아닌, 별도의 Aspect로 관리하여 핵심로직을 공통으로 적용하기 위함이다.
<br>
<br>난수 생성 후 물고있기☑ <br>IP로 추적 <br><img alt="Pasted image 20241224144309.png" src="http://lts.kr/사진-및-문서/pasted-image-20241224144309.png" target="_self"><br>쿠키가 필요한 페이지의 경로가 기본 path와 일치하는 경우(redirect url 이 SP_MARKETING_HIT_TEST1 의 하위 url일 경우)<br>
에는 명시적으로 표시할 필요가 없지만,<br>AOP에서 Front-end 단의 특정 동작 필터링 하기<br>기존<br>
<img alt="Pasted image 20241226111559.png" src="http://lts.kr/사진-및-문서/pasted-image-20241226111559.png" target="_self"><br>
DB<br>
<img alt="Pasted image 20250102160223.png" src="http://lts.kr/사진-및-문서/pasted-image-20250102160223.png" target="_self"><br>
<br>장점: <br>코드가 간결하고 읽기 쉽다.
<br>Spring의 AOP 인프라를 사용하여 메서드 인터셉션을 쉽게 구현할 수 있다. <br>단점:
- 포인트컷 조건은 컴파일 시점에 고정된다.
- 복잡한 조건이나 동적으로 변경되는 조건을 처리하기 어렵다. -&gt; @Pointcut 등의 조건에 부합하는 Bean객체를 컴파일 시점에 찾아내어 프록시를 감싼다.
<br>
<br>동적 생성: <br>런타임에 프록시를 생성하여 포인트컷과 어드바이스를 동적으로 적용.
<br>StaticMethodMatcherPointcut 또는 DynamicMethodMatcherPointcut을 사용하여 런타임 조건 기반으로 메서드 매칭. <br>장점: <br>런타임 조건에 따라 동적으로 포인트컷 생성 가능.
<br>복잡한 조건과 동적 필터링을 처리하기 용이.
<br>Spring AOP가 아닌 순수 Java 프록시 방식도 지원. <br>단점: <br>코드가 복잡해지고 추가 구현이 필요.
<br>Spring AOP와 동일한 수준의 간결성을 제공하지 않음. <br>-&gt; 해당 프록시 객체를 적용하고 싶은 Bean객체에 매번 생성(등록)해주어야 함.<br>import org.springframework.aop.Pointcut;
import org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;
import org.springframework.aop.support.DefaultPointcutAdvisor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration; @Configuration
public class AopConfig { @Bean public Pointcut customPointcut() { return new CustomPointcut(); } @Bean public CustomAdvice customAdvice() { return new CustomAdvice(); } @Bean public DefaultPointcutAdvisor customAdvisor(Pointcut customPointcut, CustomAdvice customAdvice) { return new DefaultPointcutAdvisor(customPointcut, customAdvice); } @Bean public DefaultAdvisorAutoProxyCreator proxyCreator() { return new DefaultAdvisorAutoProxyCreator(); }
} <br>
<br>@Pointcut 방식과 동일한 동작: <br>Spring 컨테이너가 관리하는 모든 빈에 대해 조건을 평가하고 프록시를 자동 생성합니다. <br>프록시를 명시적으로 선언할 필요 없음: <br>ProxyFactory처럼 수동으로 프록시를 생성하지 않아도 됩니다. <br>유연성과 효율성 향상: <br>Spring AOP 인프라를 활용하므로, 관리가 용이하고 런타임 성능이 개선됩니다. <br>
<br>BeanPostProcessor: <br>DefaultAdvisorAutoProxyCreator는 Spring의 BeanPostProcessor를 구현한 클래스이다.
<br>Spring 컨테이너는 애플리케이션 컨텍스트에 등록된 모든 BeanPostProcessor를 자동으로 호출하여 빈의 초기화 전후 작업을 수행한다.
<br>이를 통해, Spring AOP는 빈 생성 단계에서 프록시를 생성하고 조건에 맞는 빈에 대해 어드바이저를 적용. <br>Advisor 탐색: <br>DefaultAdvisorAutoProxyCreator는 Spring 컨텍스트에 등록된 모든 Advisor를 자동으로 탐색한다.
<br>이는 DefaultAdvisorAutoProxyCreator가 BeanFactory를 통해 컨테이너의 모든 Advisor 타입 빈을 조회하기 때문.
<br>탐색된 Advisor를 사용하여 각 빈의 메서드와 포인트컷 조건을 매칭. <br>Advisor와 빈의 매칭: <br>빈이 생성될 때, DefaultAdvisorAutoProxyCreator는 해당 빈의 메서드가 어떤 Advisor의 포인트컷 조건에 부합하는지 평가.
<br>조건에 부합하면, 해당 빈을 프록시 객체로 감싸고, 어드바이스를 연결. <br>위 방법의 문제점? <br>
<br>이렇게 맵핑이 되어야 하나, 이를 동적으로 탐지하지 못한다.
<br>/* * EnableAspectJAutoProxy &gt; 프록시 적용시 인터페이스/클래스 여부 자동 판단 * 클래스에 인터페이스가 있으면 JDK 동적 프록시. * 인터페이스가 없으면 CGLIB 프록시. * */@Configuration @EnableAspectJAutoProxy public class AopConfig { @Bean public Pointcut customPointcut() { return new CustomPointcut(); } @Bean public CustomAdvice customAdvice() { return new CustomAdvice(); } @Bean public DefaultPointcutAdvisor customAdvisor(Pointcut customPointcut, CustomAdvice customAdvice) { return new DefaultPointcutAdvisor(customPointcut, customAdvice); } /* * @EnableAspectJAutoProxy를 사용해 등록했기 때문에 불필요. * */ // @Bean // public DefaultAdvisorAutoProxyCreator proxyCreator() { // return new DefaultAdvisorAutoProxyCreator(); // } }
<br>프록시(Proxy)는 대리자라는 뜻으로, 다른 객체에 대한 인터페이스 역할을 하는 객체를 말합니다. 프로그래밍에서 프록시는 실제 객체에 접근하기 전에 특정 작업(로깅, 보안, 트랜잭션 관리 등)을 수행하거나, 객체에 대한 접근을 제어하는 데 사용됩니다.<br>
<br>대리 객체: 프록시는 실제 객체에 대한 중간다리 역할을 합니다.
<br>동작 조정: 프록시는 요청을 가로채서 추가적인 작업을 수행하거나, 요청을 변형한 뒤 실제 객체에 전달할 수 있습니다.
<br>AOP와 연관: 프록시를 사용하면 코드를 변경하지 않고도 객체의 동작을 확장하거나 변경할 수 있습니다.
<br>Method Name: loanerLoginPage<br>
javax.servlet.http.HttpServletRequest<br>
org.springframework.web.bind.annotation.GetMapping <br><img alt="Pasted image 20241226152219.png" src="http://lts.kr/사진-및-문서/pasted-image-20241226152219.png" target="_self"><br><img alt="Pasted image 20241226171158.png" src="http://lts.kr/사진-및-문서/pasted-image-20241226171158.png" target="_self"><br>
<br>외부링크 최초진입. hitCode, hitUid 발급 및 DB저장
<br>
<br>외부링크 재진입. hitCode는 변경될 수 있으므로 "p"파라미터로 재발급<br>
=&gt; hitCode는 매번 재발급 / hitUid는 없을때만 발급
<br>
<br>일반사용자 이며, 아무동작 하지 않는다.
<br>
<br>외부링크 진입 후 동작. 없는 녀석 새로 발급 및 DB저장
<br>서비스 저장시 동시성 이슈가 발생할 수 있다?<br>@Override @Transactional public ResponseModel insertMarketingHitLog(String hitCode, String hitUid, String pageUrl, String pageType){ try { Optional&lt;HfMarketingHitLog&gt; existingLog = hfMarketingHitLogRepository.findByHitCodeAndHitUidAndPageUrlAndPageType(hitCode, hitUid, pageUrl, pageType); if (existingLog.isPresent()) { HfMarketingHitLog logToUpdate = existingLog.get(); logToUpdate.setUpdateDate(LocalDateTime.now()); hfMarketingHitLogRepository.save(logToUpdate); return new ResponseModel(ResponseModel.ResponseStatus.SUCCESS); } HfMarketingHitLog hfMarketingHitLog = HfMarketingHitLog.builder() .hitCode(hitCode) .hitUid(hitUid) .pageUrl(pageUrl) .pageType(pageType) .build(); hfMarketingHitLogRepository.save(hfMarketingHitLog); return new ResponseModel(ResponseModel.ResponseStatus.SUCCESS); } catch (Exception e) { return new ResponseModel(ResponseModel.ResponseStatus.FAILED, "데이터 처리 중 오류 발생"); } }
<br>
<br>여러 쓰레드(또는 트랜잭션)가 findByHitCodeAndHitUidAndPageUrlAndPageType 메서드를 호출하여 동일한 조건의 데이터를 동시에 조회할 수 있다.
<br>두 쓰레드가 모두 existingLog.isPresent() 조건에서 false를 확인한 후, 동시에 새로운 HfMarketingHitLog 객체를 생성하고 저장하려 하면 데이터 중복 문제가 발생할 수 있다.
<br>. Lock을 쓰면 되나, 이후 업데이트 로직 삭제(로그 테이블화) 변경으로 처리<br><img alt="Pasted image 20241230135801.png" src="http://lts.kr/사진-및-문서/pasted-image-20241230135801.png" target="_self"><br>1일의 유효기간을 갖는 uid를 발급하여, 인입코드 / Hit된 기능 주소 / 시간 을 저장한다.
<br>uid는 외부url로 접근시 발급
<br>page_url는 코드에 미리 등록 / hit_code는 모두(only 영문+숫자) 수용 가능
<br><img alt="Pasted image 20250102160213.png" src="http://lts.kr/사진-및-문서/pasted-image-20250102160213.png" target="_self"><br>
<img alt="Pasted image 20250102160223.png" src="http://lts.kr/사진-및-문서/pasted-image-20250102160223.png" target="_self"><br>
<br>enum객체에 정의된 메서드를 DB로 전환하여 pointcut에서 해당 클래스, 메서드를 가져와 조건으로 정의
<br>해당 조건에 부합하는 메서드를 프록시로 전환
<br>
<br>api호출을 통해 advice내의 동작은 런타임 환경에서 동적으로 변경이 가능한 것을 확인했다.
<br>
<br>런타입 위빙 방식이라고 하더라도, 변경은 불가능하다.
<br>컴파일 위빙 방식은 컴파일 단계에서 원본 클래스 바이트코드를 변경하여 직접 위빙을 하는 방식이고,<br>
런타임 위빙은 런타임단계에서 원본 클래스를 변경하지 않고 프록시 객체를 사용하여 교체하는 방식이다.
<br>=&gt; 해당하는 부분은 리빌드와 큰 차이가 없고, 각 class에 scope를 따로 적용해야했기 때문에 고려하지 않았다.<br>=&gt; 연관성 있는 모든 참조를 수동으로 재설정해야하기 때문에 매우 복잡해진다.<br>
<br>참조를 갱신하기 위해서는 Java리플렉션을 사용하여 강제로 참조를 갱신하거나, AspectJ의 런타임 위빙 방식을 활용해야 한다.
<br>따라서, 서버 Kill을 하는 것과 진배 없으며, 권장하지 않는 방법이다.
<br>이슈
내부통계기능(AOP)의 진입URL에서 네이버 아날리틱스(외부 통계 프로그램)가 작동하지 않는 이슈
<br>
<br>외부 유입통계 페이지의 인입 주소는 일반적인 메인 페이지가 아닌, Gate를 거쳐서(redirect) 동작하게 된다.
<br>이 때, 진입 referrer에 변동이 생기면서 집계가 되지 않는 오류가 발생한 것으로 보인다.
<br>
<br>해당 방법을 사용하여, View단을 추가하여 replace한다면, 처음 진입시 갖고 있는 referrer를 물고 갈수 있지 않을까?
<br>redirect대신 view단을 통해 진입하도록 만든 후, naver아날리틱스 스크립트를 추가한다.
<br>한계 : 외부 유입시 불필요한 페이지 방문이 생기게 되고, 유입과정의 시간이 증가한다. 또한, 해당 오류를 100% 해결할지 미지수
<br>
<br>해당 방법은 기존 naver아날리틱스를 사용하고 있는 로직을 그대로 사용하는 것이기 때문에 제일 확실하다.
<br>한계 : 외부유입자가 아닌, 모든 사용자에게 session및 uid체크가 들어가기 때문에 부하가 증가한다.(DB통신은 X)
<br>
<br>BEST🖐
<br>한계 : 네이버 아날리틱스의 내부로직 파악이 불가함
<br>
<br>현재 네이버의 내부 로직 파악이 불가하니, View를 추가하여 네이버 스크립트가 물고 가는지 먼저 TEST하도록 하기
<br>&lt;html xmlns:th="http://www/thymeleaf.org" th:replace="layout/mainLayout :: mainLayout('gate loan')"&gt; &lt;script th:inline="javascript"&gt; $(document).ready(function() { location.href = [[${urls.SP_LOAN}]]; }); &lt;/script&gt;
<br>mainLayout을 적용하여 해당 페이지에 default script를 적용시켰다.<br>
결과는 추후 모니터링 예정<br>Quote
sp/loan기준으로 레퍼러를 https://www-stg.hellofunding.co.kr/sp/loan/gtLoan?p=Z29vZ2xlMXN0 인입페이지 주소를 갖고있는것을 확인했다.
<br>2025-02-25 14:34:04 [hello-app-staging-7985c4d74f-47qnx] INFO com.hellofintech.hellofunding.common.interceptor.ServiceHandlerInterceptor[mergeIntoVisitCount:187] - referer = https://www-stg.hellofunding.co.kr/sp/loan/gtLoan?p=Z29vZ2xlMXN0
<br><img alt="Pasted image 20250226145129.png" src="http://lts.kr/사진-및-문서/pasted-image-20250226145129.png" target="_self"><br>확인 결과이미 sendRedirect 로직에서도 Header의 Referer를 물고있었다.<br>
어떠한 referrer를 기준으로 집계를 하는지 정확한 파악이 필요하다.
<br>]]></description><link>http://lts.kr/project/hello-marketing/👩‍👧‍👦-marketing-analytics-공통모듈-제작기.html</link><guid isPermaLink="false">project/hello marketing/👩‍👧‍👦 marketing Analytics 공통모듈 제작기.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Mon, 10 Mar 2025 00:48:37 GMT</pubDate><enclosure url="http://lts.kr/사진-및-문서/pasted-image-20241224144309.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="http://lts.kr/사진-및-문서/pasted-image-20241224144309.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🪓 도구]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:Tools" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Tools</a> <a class="tag" href="http://lts.kr/?query=tag:모음" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#모음</a> <a class="tag" href="http://lts.kr/?query=tag:도구" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#도구</a> <br> <a href="http://lts.kr?query=tag:Tools" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Tools">#Tools</a> <a href="http://lts.kr?query=tag:모음" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#모음">#모음</a> <a href="http://lts.kr?query=tag:도구" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#도구">#도구</a><br>툴 모음
제가 사용하고 있는 편리/유용한 TOOL을 소개하고 설명하는 곳 입니다.
<br>
<br><a data-href="🍊 aws EC2란" href="http://lts.kr/tools/aws/🍊-aws-ec2란.html" class="internal-link" target="_self" rel="noopener nofollow">🍊 aws EC2란</a>
<br><a data-href="🌥 aws(EC2)셋팅부터 배포까지" href="http://lts.kr/tools/aws/🌥-aws(ec2)셋팅부터-배포까지.html" class="internal-link" target="_self" rel="noopener nofollow">🌥 aws(EC2)셋팅부터 배포까지</a>
<br><a data-href="🍌 Elastic IP(탄력적 IP)란" href="http://lts.kr/tools/aws/🍌-elastic-ip(탄력적-ip)란.html" class="internal-link" target="_self" rel="noopener nofollow">🍌 Elastic IP(탄력적 IP)란</a>
<br>
<br><a data-href="🐋 docker" href="http://lts.kr/tools/docker/🐋-docker.html" class="internal-link" target="_self" rel="noopener nofollow">🐋 docker</a>
<br><a data-href="📘 SpringBoot &amp; Docker + Reids 연동" href="http://lts.kr/tools/docker/📘-springboot-&amp;-docker-+-reids-연동.html" class="internal-link" target="_self" rel="noopener nofollow">📘 SpringBoot &amp; Docker + Reids 연동</a>
<br>
<br><a data-href="🎵 Obsidian" href="http://lts.kr/tools/🎵-obsidian.html" class="internal-link" target="_self" rel="noopener nofollow">🎵 Obsidian</a>
<br><a data-href="👻 Obsidian 정적호스팅 CICD 과정" href="http://lts.kr/project/note-ci_cd/👻-obsidian-정적호스팅-cicd-과정.html" class="internal-link" target="_self" rel="noopener nofollow">👻 Obsidian 정적호스팅 CICD 과정</a>
<br><a data-href="⛈ Obsidian-AWS연동" href="http://lts.kr/project/note-ci_cd/⛈-obsidian-aws연동.html" class="internal-link" target="_self" rel="noopener nofollow">⛈ Obsidian-AWS연동</a>
<br>
<br>🩹추가예정!!]]></description><link>http://lts.kr/tools/🪓-도구.html</link><guid isPermaLink="false">Tools/🪓 도구.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Fri, 07 Mar 2025 08:32:13 GMT</pubDate></item><item><title><![CDATA[🏹 예치금 차액 비교 Spring Batch 리펙토링 부록]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:프로젝트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로젝트</a> <a class="tag" href="http://lts.kr/?query=tag:개발" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#개발</a> <a class="tag" href="http://lts.kr/?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <a class="tag" href="http://lts.kr/?query=tag:Batch" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Batch</a> <a class="tag" href="http://lts.kr/?query=tag:Partitioning" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Partitioning</a> <a class="tag" href="http://lts.kr/?query=tag:Chunk" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Chunk</a> <br> <a href="http://lts.kr?query=tag:프로젝트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로젝트">#프로젝트</a> <a href="http://lts.kr?query=tag:개발" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#개발">#개발</a> <a href="http://lts.kr?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a> <a href="http://lts.kr?query=tag:Batch" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Batch">#Batch</a> <a href="http://lts.kr?query=tag:Partitioning" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Partitioning">#Partitioning</a> <a href="http://lts.kr?query=tag:Chunk" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Chunk">#Chunk</a><br><img alt="output (9).png" src="http://lts.kr/사진-및-문서/output-(9).png" target="_self"><br>
<br>현재 예치금 차액 배치의 서비스로직은, 각 파티션에서 실행되며,
<br>이렇게 실행된 코드는 parallelStream을 사용하여 내부적인 병렬처리를 진행한다.
<br>해당 로직의 특징은 cpu에 부하를 주는 계산식이 아닌, 단순 I/O (api호출 대기)의 소요시간이 크다.
<br>
<br>API 호출 작업 10,000건 처리
<br>각 호출 응답 시간 200ms
<br>
<br>기본 스레드 풀 크기: CPU 코어 수 - 1 (예: 7개의 코어)
<br>처리 시간 ≈ 작업&nbsp;개수/스레드&nbsp;수×응답&nbsp;시간\text{작업 개수} / \text{스레드 수} \times \text{응답 시간}작업&nbsp;개수/스레드&nbsp;수×응답&nbsp;시간
<br>≈10,000/7×200ms\approx 10,000 / 7 \times 200ms≈10,000/7×200ms
<br>≈286초\approx 286초≈286초
<br>
<br>스레드 풀 크기: 100
<br>처리 시간 ≈ 작업&nbsp;개수/스레드&nbsp;수×응답&nbsp;시간\text{작업 개수} / \text{스레드 수} \times \text{응답 시간}작업&nbsp;개수/스레드&nbsp;수×응답&nbsp;시간
<br>≈10,000/100×200ms\approx 10,000 / 100 \times 200ms≈10,000/100×200ms
<br>≈20초\approx 20초≈20초
<br>
<br>CPU 바운드 작업: <br>CPU를 많이 사용하는 작업(예: 복잡한 계산)이면, 코어 수 이상의 스레드를 실행할 경우 컨텍스트 스위칭(스레드 간 전환) 비용이 증가해 성능이 오히려 떨어질 수 있습니다.
<br>예: 7개의 코어로 100개의 CPU 작업 스레드를 처리하려 하면 병목이 발생. <br>I/O 바운드 작업(API 호출 포함): <br>네트워크 I/O 작업은 대기 시간이 길고, 대기 중에는 CPU를 거의 사용하지 않습니다.
<br>이 경우 스레드 수 &gt; 코어 수가 유리하며, 100개의 스레드를 실행해도 대부분의 스레드는 대기 상태에 있으므로 CPU 사용량이 낮습니다. <br>69961 ms<br>
70048 ms<br>
70396 ms<br>55180 ms<br>
55036 ms<br>
55285 ms<br>
55442 ms<br>71139 ms<br>
72220 ms<br>64473 ms<br>
65609 ms<br>미리 파티션 되어있는 데이터의 특성상 한번에 처리되는 양이 많지 않다.
<br>또한, stream().parallel()은 forkJoinPool에서 효율적으로 관리되며,
<br>데이터의 동기화 병목을 줄이고, 컨텍스트 전환 횟수를 줄여 더 효율적인 것으로 보임.
<br>
<br>stream().parallel() 기능이 효율적이다.
<br>
<br>아마도 Where절이 추가되면서 reader의 속도가 크게 올라갓으며, 1번의 호출만을 하기 때문에 더 개선되었을것이다.
<br>chunk-size:20<br>
55969 ms<br>chunk-size:20<br>
54679 ms<br>
54416 ms<br>기존 : reader에서 넘어온녀석들의(옛날기준 날짜범위 내의 가장최신Point)차액 -&gt; 차액이있는녀석들의 (모든날짜 범위내의 최신 Point)의 차액<br>
현재 : reader에서 가져온녀석들의(모든날짜범위내의 최신 Point)의 차액<br>=&gt; 옛날기준 날짜범위 내의 가장최신포인트와 실시간 포인트는 다를 경우가 많음. 거기 내에<br>전날의 최신포인트 vs 현재 최신포인트(신한) -&gt; 여기엔 안걸리지만<br>
현재 최신포인트 vs 현재 최신포인트(신한) -&gt; 여기에는 걸린다.<br>이게 무슨소리인지? <br>보통의 Batch 서비스라면 I/O 작업에 부하가 걸려있겠지만, 현재 예치금 차액 배치는 processor 즉, 예치금 비교 연산에서 큰 리소스를 소모하고있다.
<br>이에 해당하는 시간 소모를 줄이기 위해 processor(서비스로직) 을 병렬처리 함으로 최종 처리시간 단축을 꾀할 수 있을지에 대한 고민이다.
<br>이후 설명하겠지만, 내부 병렬처리 로직은 청크의 트렌젝션을 무너뜨릴 가능성이 크므로 지양해야함. <br><img alt="Pasted image 20241206113120.png" src="http://lts.kr/사진-및-문서/pasted-image-20241206113120.png" target="_self"><br>소요시간 : 1분 9초
<br>-&gt; 기존 limit절을 이용한 로직보다 속도가 더빠르며,<br>
JpaPagingReader를 적용한다면 중복 select횟수를 줄여 더 빨라질 것으로 예상된다.<br>결론 : 둘 중 하나<br>#### 292 컬럼
## Processor 삭제(병렬처리)로직
#### grid-size:6 / chunk-size:20
54679 ms
54416 ms
## Processor 순차처리(writer만 병렬처리) 로직 #### grid-size:6 / chunk-size:20
60440 ms
62271 ms
#### grid-size:10 / chunk-size:20
58129 ms
56723 ms
#### grid-size:16 / chunk-size:20
58595 ms
56314 ms #### grid-size:32 / chunk-size:20
- SQLTransientConnectionException
- 스레드풀 점유갯수 초과
<br>하지만, 이후 청크 방식 Batch의 확장성과 유지보수성을 고려하여 리더,프로세서,라이터 방식으로 구현하기로 정했다.]]></description><link>http://lts.kr/project/hello-batch/🏹-예치금-차액-비교-spring-batch-리펙토링-부록.html</link><guid isPermaLink="false">project/hello Batch/🏹 예치금 차액 비교 Spring Batch 리펙토링 부록.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Thu, 06 Mar 2025 08:17:00 GMT</pubDate><enclosure url="http://lts.kr/사진-및-문서/output-(9).png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="http://lts.kr/사진-및-문서/output-(9).png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🏹 예치금 차액 비교 Spring Batch 리펙토링]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:프로젝트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로젝트</a> <a class="tag" href="http://lts.kr/?query=tag:개발" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#개발</a> <a class="tag" href="http://lts.kr/?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <a class="tag" href="http://lts.kr/?query=tag:Batch" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Batch</a> <a class="tag" href="http://lts.kr/?query=tag:Partitioning" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Partitioning</a> <a class="tag" href="http://lts.kr/?query=tag:Chunk" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Chunk</a> <a class="tag" href="http://lts.kr/?query=tag:성능개선" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#성능개선</a> <br> <a href="http://lts.kr?query=tag:프로젝트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로젝트">#프로젝트</a> <a href="http://lts.kr?query=tag:개발" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#개발">#개발</a> <a href="http://lts.kr?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a> <a href="http://lts.kr?query=tag:Batch" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Batch">#Batch</a> <a href="http://lts.kr?query=tag:Partitioning" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Partitioning">#Partitioning</a> <a href="http://lts.kr?query=tag:Chunk" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Chunk">#Chunk</a> <a href="http://lts.kr?query=tag:성능개선" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#성능개선">#성능개선</a> <br>기존 예치금 차액비교 Batch의 Tasklet방식의 배치의 단점을 보완하는 chunk 방식의 배치를 구현하고,<br>
나아가 다른 기능의 Batch에도 효과적으로 빠르게 적용할 수 있는재사용성/유지보수성 높은 코드, 선례를 만들기 위함이다.<br>
<br>Chunk, Partioning방식을 Job을 추가 개발 (기존 balanceJob 유지)
<br>당분간 두 Job을 병행하면서 비교
<br>추가한 Job 기능에 문제없다면 기존 balanceJob 삭제
<br><img alt="회사 은행 서비스1111.png" src="http://lts.kr/사진-및-문서/회사-은행-서비스1111.png" target="_self"><br>
<img alt="Spring Batch Tasklet 예치금 잔액 비교 1.png" src="http://lts.kr/사진-및-문서/spring-batch-tasklet-예치금-잔액-비교-1.png" target="_self"><br>
<img alt="Spring Batch Tasklet 예치금 잔액 비교 잘못된 차액발생 인식 타임라인.png" src="http://lts.kr/사진-및-문서/spring-batch-tasklet-예치금-잔액-비교-잘못된-차액발생-인식-타임라인.png" target="_self"><br>
<br>평균 소요시간: 약 17.35분
<br>최대 소요시간: 22분
<br>최소 소요시간: 12분<br>
<img alt="output (1).png" src="http://lts.kr/사진-및-문서/output-(1).png" target="_self">
<br>
<br>처음 가져온 Point 배치 완료시 까지 계속 물고있다. -&gt; 한 트렌젝션의 범위가 넓다.
<br>정보 <br>병목이 있진 않으나, 한 배치서비스의 트렌젝션에서 외부 api의 값 변동을 반영하지 못함. <br>
<br>G5-Point 등은 처음 7시 시점에 묶여있다. 회원별로 실데이터를 건건이 api(신한)를 호출하여 비교한다. 때문에, 7시 이후에 수정된데이터를 실시간으로 반영하지 못한다.
<br>
<br>목적 : batch의 step 레벨에서의 스레드 분리 ( 병렬처리 )
<br>
<br>독립적인 ExecutionContext가 주어져 상태를 안전하게 관리할 수 있다.
<br>
<br>목적 : 각 step내의 트렌젝션 단위 분리
<br>Reader / Processor / writer 가 역할을 분담
<br>
<br>
Partition 생성: <br>Partition 1 : ID 1 ~ 25 / 대기열1 : ID 101 ~ 125 / 대기열2 : ID 201 ~ 225
<br>Partition 2 : ID 26 ~ 50 / 대기열 : ID 126 ~ 150 / 대기열2 : ID 226 ~ 250
<br>Partition 3 : ID 51 ~ 75 / 대기열 : ID 151 ~ 175 / 대기열2 : -
<br>Partition 4 : ID 76 ~ 100 / 대기열 : ID 176 ~ 200 / 대기열2 : - <br>
각 Partition에서 Chunk 처리: <br>Partition 1: <br>Chunk 1: ID 1 ~ 10 → 커밋
<br>Chunk 2: ID 11 ~ 20 → 커밋
<br>Chunk 3: ID 21 ~ 25 → 커밋 <br>Partition 2: <br>Chunk 1: ID 26 ~ 35 → 커밋
<br>Chunk 2: ID 36 ~ 45 → 커밋
<br>Chunk 3: ID 46 ~ 50 → 커밋 <br>나머지 Partition도 동일 방식으로 처리. <br>
병렬 실행: <br>스레드 풀 크기 = 4이므로 4개의 Partition이 동시에 실행됩니다.
<br>Partition 처리 순서는 스레드 풀에서 처리되는 순서에 따라 다를 수 있음. <br>
트랜잭션 관리: <br>각 Partition은 독립적인 트랜잭션을 가짐.
<br>각 Chunk가 커밋될 때마다 트랜잭션이 종료됨. <br>
<br>
Partition 생성: <br>Partition 1 : ID 1 ~ 25 / 대기열1 : ID 101 ~ 125 / 대기열2 : ID 201 ~ 225
<br>Partition 2 : ID 26 ~ 50 / 대기열 : ID 126 ~ 150 / 대기열2 : ID 226 ~ 250
<br>Partition 3 : ID 51 ~ 75 / 대기열 : ID 151 ~ 175 / 대기열2 : ID 251 ~ 275
<br>Partition 4 : ID 76 ~ 100 / 대기열 : ID 176 ~ 200 / 대기열2 : ID 276 ~ 300
<br>추가 스레드 풀 생성
<br>Partition 5 : ID 300 ~ 325 / 대기열 : ID 326 ~ 350 / 대기열2 : ID 351 ~ 375
<br>추가 스레드 풀 생성
<br>Partition 6 : ID 376 ~ 400 / 대기열 : ID 401 ~ 425 / 대기열2 : ID 426 ~ 450 모든 대기열 소모 및 최대 스레드 풀 도달 =&gt; 작업 중단 및 오류 <br>-&gt; 이로볼때, 쿼리작업보다 api호출작업의 소요시간이 길어보임<br>범위 - 2017-11-07 ~ 2017-12-01
startDate=2017-11-07&amp;endDate=2017-12-01 ## 컬럼 개수 - 292개 기존 병렬처리 : 1분 7초
기존로직 : 6분 32초 t:스레드 개수 / c:각 스레드별 청크 파티션 수 ###### SimpleAsyncTaskExecutor vs ThreadPoolTaskExecutor SimpleAsyncTaskExecutor
g4/c10 : 1분 41.586초
g5/c10 : 1분 30.037초
g5/c3 : 1분 28.997초
g5/c1 : 1분 29.931초
g8/c10 : 1분 36.019초
g10/c1 : 1분 24.529초 - ThreadPoolTaskExecutor
Th min/maxSize64, g64/c10 : 1분 42.848초
Th min/maxSize32, g32/c10 : 1분 26.551초 Th min/maxSize16, g16/c10 : 1분 46.753초 / 1분 33.779초 / 2분 25.759초
1분 11.668초 / 2분 5.773초 / 2분 39.553초 Th min/maxSize32, g8/c20 : 3분 25.743초 Th min/maxSize16, g4/c10 : 2분 29.207초 / 2분 8.004초
<br>
<br>Grid사이즈(파티셔닝 갯수) 만큼 스레드 풀 계속 생성
<br>파티셔닝 갯수가 많아졌을 때, 스레드 생성/소멸에 드는 오버헤드 증가
<br>
<br>최소 스레드풀 개수 / 최대 스레드풀 개수 / 대기열 큐 크기 / 유휴 시간 모두 설정가능
<br>파티셔닝 갯수가 많을 경우, 처리 성능에 맞는 스레드 풀에서 대기작업으로 처리하여 오버헤드 감소
<br>
<br>총 처리량 기준 1/n로 각 스레드에 할당시 충분히 감당한 양으로, 대기열을 사용할 필요가 없다.
<br>
<br>쿼리 호출 및 페이징 기법 직접 구현
<br>
<br>Native Query 형태로 호출하여 자동 페이징
<br>
<br>Spring Batch에서는 공식적으로 지원하지 않음
<br>자동 페이징
<br>Querydsl형태로 쿼리 호출 가능
<br>
<br>기존(헬로)의 Querydsl기반 JPAQuery를 그대로 사용 가능
<br>자동 페이징
<br>그 외 Querydsl의 장점 보유
<br>
<br>기존 PagingItemReader의 메서드를 오버라이딩 하여 사용하며,<br>
JPQL이 수행되던 부분에 코드를 수정하였다.
<br>@Bean @Scope(value = "step", proxyMode = ScopedProxyMode.TARGET_CLASS) public QuerydslPagingItemReader&lt;HfbatBankBalanceCheckDto&gt; balanceReader() { ExecutionContext jobContext = Objects.requireNonNull(StepSynchronizationManager.getContext()).getStepExecution().getJobExecution().getExecutionContext(); Date startDate = (Date) jobContext.get(START_DATE_KEY); Date endDate = (Date) jobContext.get(END_DATE_KEY); return new QuerydslPagingItemReader&lt;&gt;( entityManagerFactory, executionOrder, DEFAULT_CHUNK_SIZE, queryFactory -&gt; repository.newFindChangeBalanceMemberList( startDate, endDate )); }
<br>
<br>각 파티션 스레드 별 종료 시간이 크게 상이하다. 총 소요시간 기준 최대 약 20% 차이
<br>적용 한다면, 각 스레드 별로 even하게 작업을 수행하여 총 소요시간을 줄일 수 있을것이라 판단 <br>JOB private static AtomicLong executionOrder = new AtomicLong(0); ... new QuerydslPagingItemReader&lt;&gt;( entityManagerFactory, executionOrder, DEFAULT_CHUNK_SIZE, queryFactory -&gt; repository.newFindChangeBalanceMemberList( startDate, endDate ));
<br>job 레벨에서의 스레드 세이프한 전역 변수를 생성하였다.
<br>그 후, 각 파티션 별 리더에 인자값으로 넘긴다.
<br>long currentExecutionOrder = executionOrder.getAndIncrement(); long startIndex = (currentExecutionOrder) * getPageSize(); int totalRecords = stepContext.getInt("totalRecords"); if (startIndex &gt;= totalRecords) { initResults(); // 빈 결과로 초기화 tx.commit(); return; } int chunkSizeToRead = Math.min(getPageSize(), (int) (totalRecords - startIndex)); // 남은 데이터 크기만큼 읽기 // QueryDSL Query 생성 JPQLQuery&lt;T&gt; query = createQuery() .offset(startIndex) .limit(chunkSizeToRead);
<br>
<br>먼저 한 청크단위의 작업을 끝낸 파티션은 그 다음 작업을 즉시 할당받게 된다.
<br>즉, 총 처리시간 기준 가장 빨리끝난 파티션과 가장 늦게 끝난 파티션의 실행 시간 차이는 최대 한 청크사이즈를 처리하는 시간보다 크지 않게 된다.
<br>1차 비교 이후 차액이 발생한 녀석들의 List 를 한번 더 검증한 후, =&gt; 추후 변경 됨<br>
검증된 녀석들을 <br>List&lt;BalanceCheckResultDto&gt; realDiffList= new ArrayList&lt;&gt;();
<br>최종적인 차액 리스트에 넣는다.<br>writer는 각 프로세서의 리턴으로 받은 녀석들을 하나의 DTO List로 합쳐 메세징 처리를 하게 된다.<br>
<br>유지보수성이 좋다.
<br>환경셋팅에 리소스가 많이든다. <br>
<br>구현 레벨이 가장 쉽다
<br>DTO(데이터)가 많아질 경우, 큰 리소스를 차지한다.
<br>
<br>방법 2.보다는 리소스가 적지만, 문자열 처리 시간이 추가로 소모된다.
<br>
<br>높은 쓰기 성능을 갖고있다.
<br>동시성 문제 없이 다중 스레드에서 사용 가능하다.
<br>인덱스로 접근이 불가능하다.
<br>QueueManager클래스를 생성하며 공통으로 사용 가능하도록 하였고,<br>@Slf4j public class QueueManager&lt;T&gt; { protected final ConcurrentLinkedQueue&lt;T&gt; sharedQueue = new ConcurrentLinkedQueue&lt;&gt;(); // 데이터 추가 public void addItemToSharedQueue(T item) { if (item != null) { sharedQueue.add(item); } }
<br>이를 상속받아 특정 오브젝트를 넘길 수 있도록 하였다.<br>public class BalanceQueue extends QueueManager&lt;BalanceCheckResultDto&gt;{ public List&lt;BalanceCheckResultDto&gt; getDtoFromQueue() { return super.getItemsFromQueue(); } }
<br><img alt="Pasted image 20241217150339.png" src="http://lts.kr/사진-및-문서/pasted-image-20241217150339.png" target="_self"><br>리스너에 너무 많은 역할이 부여된 모습
<br><img alt="Pasted image 20241219145746.png" src="http://lts.kr/사진-및-문서/pasted-image-20241219145746.png" target="_self"><br>
<br>StepExecution-Level ExecutionContext <br>
각 Step에 고유한 ExecutionContext가 생성됩니다. <br>
Step 내의 Reader, Processor, Writer 등에서 공유됩니다. <br>
다른 Step과는 공유되지 않습니다. <br>
balanceWorkerStep 내에서는 Reader, Processor, Writer가 동일한 ExecutionContext를 공유합니다. <br>
balancePartitionStep과 balanceWorkerStep의 ExecutionContext는 서로 독립적입니다. <br>JobExecution-Level ExecutionContext <br>Job 전체에서 공유되며, 모든 Step이 동일한 ExecutionContext에 접근할 수 있습니다.
<br>JobExecutionContext는 Step 간 데이터 전달이 필요할 때 유용합니다. <br>JobExecutionListener 객체 생성<br>@Slf4j public class JobTimerExecutionListener implements JobExecutionListener { private final String jobName; private long startTime = System.currentTimeMillis(); public JobTimerExecutionListener(String jobName) { this.jobName = jobName; } @Override public void beforeJob(JobExecution var1) { startTime = System.currentTimeMillis(); } @Override public void afterJob(JobExecution var1) { long endTime = System.currentTimeMillis(); long elapsedTime = endTime - startTime; long minutes = (elapsedTime / 1000) / 60; // 밀리초를 분으로 변환 double seconds = (elapsedTime / 1000.0) % 60; // 남은 밀리초를 초로 변환 (소수점 포함) log.info("{}-completed: {} ms | {} minutes {} seconds", jobName, elapsedTime, minutes, seconds); } }
<br><img alt="output (9) 1.png" src="http://lts.kr/사진-및-문서/output-(9)-1.png" target="_self"><br><img alt="output (10).png" src="http://lts.kr/사진-및-문서/output-(10).png" target="_self"><br><img alt="do-messenger_screenshot_2024-12-23_14_40_21.png" src="http://lts.kr/사진-및-문서/do-messenger_screenshot_2024-12-23_14_40_21.png" target="_self"><br><img alt="Pasted image 20241224093159.png" src="http://lts.kr/사진-및-문서/pasted-image-20241224093159.png" target="_self"><br>
<img alt="Pasted image 20241224093207.png" src="http://lts.kr/사진-및-문서/pasted-image-20241224093207.png" target="_self"><br>
<img alt="Pasted image 20241224093225.png" src="http://lts.kr/사진-및-문서/pasted-image-20241224093225.png" target="_self"><br>]]></description><link>http://lts.kr/project/hello-batch/🏹-예치금-차액-비교-spring-batch-리펙토링.html</link><guid isPermaLink="false">project/hello Batch/🏹 예치금 차액 비교 Spring Batch 리펙토링.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Thu, 06 Mar 2025 08:15:51 GMT</pubDate><enclosure url="http://lts.kr/사진-및-문서/회사-은행-서비스1111.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="http://lts.kr/사진-및-문서/회사-은행-서비스1111.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[💻 프로젝트]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:프로젝트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로젝트</a> <a class="tag" href="http://lts.kr/?query=tag:모음" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#모음</a> <br> <a href="http://lts.kr?query=tag:프로젝트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로젝트">#프로젝트</a> <a href="http://lts.kr?query=tag:모음" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#모음">#모음</a><br>프로젝트
public하게 공개할 수 있는 프로젝트의 제작 과정입니다.
<br>
<br><a data-href="🏹 예치금 차액 비교 Spring Batch 리펙토링" href="http://lts.kr/project/hello-batch/🏹-예치금-차액-비교-spring-batch-리펙토링.html" class="internal-link" target="_self" rel="noopener nofollow">🏹 예치금 차액 비교 Spring Batch 리펙토링</a>⭐
<br><a data-href="🏹 예치금 차액 비교 Spring Batch 리펙토링 부록" href="http://lts.kr/project/hello-batch/🏹-예치금-차액-비교-spring-batch-리펙토링-부록.html" class="internal-link" target="_self" rel="noopener nofollow">🏹 예치금 차액 비교 Spring Batch 리펙토링 부록</a>
<br><a data-href="✏ Chunk_Partitioning Batch 구조 드로잉" href="http://lts.kr/project/hello-batch/✏-chunk_partitioning-batch-구조-드로잉.html" class="internal-link" target="_self" rel="noopener nofollow">✏ Chunk_Partitioning Batch 구조 드로잉</a>
<br>
<br><a data-href="👩‍👧‍👦 marketing Analytics 공통모듈 제작기" href="http://lts.kr/project/hello-marketing/👩‍👧‍👦-marketing-analytics-공통모듈-제작기.html" class="internal-link" target="_self" rel="noopener nofollow">👩‍👧‍👦 marketing Analytics 공통모듈 제작기</a>⭐
<br><a data-href="👩‍👧‍👦 Analytics 공통모듈 ADMIN용 데이터 추출" href="http://lts.kr/project/hello-marketing/👩‍👧‍👦-analytics-공통모듈-admin용-데이터-추출.html" class="internal-link" target="_self" rel="noopener nofollow">👩‍👧‍👦 Analytics 공통모듈 ADMIN용 데이터 추출</a>
<br>
<br><a data-href="👻 Obsidian 정적호스팅 CICD 과정" href="http://lts.kr/project/note-ci_cd/👻-obsidian-정적호스팅-cicd-과정.html" class="internal-link" target="_self" rel="noopener nofollow">👻 Obsidian 정적호스팅 CICD 과정</a>
<br><a data-href="⛈ Obsidian-AWS연동" href="http://lts.kr/project/note-ci_cd/⛈-obsidian-aws연동.html" class="internal-link" target="_self" rel="noopener nofollow">⛈ Obsidian-AWS연동</a>
<br>
<br><a data-href="📘 SpringBoot &amp; Docker + Reids 연동" href="http://lts.kr/tools/docker/📘-springboot-&amp;-docker-+-reids-연동.html" class="internal-link" target="_self" rel="noopener nofollow">📘 SpringBoot &amp; Docker + Reids 연동</a>
<br><a data-href="🌥 aws(EC2)셋팅부터 배포까지" href="http://lts.kr/tools/aws/🌥-aws(ec2)셋팅부터-배포까지.html" class="internal-link" target="_self" rel="noopener nofollow">🌥 aws(EC2)셋팅부터 배포까지</a>]]></description><link>http://lts.kr/project/💻-프로젝트.html</link><guid isPermaLink="false">project/💻 프로젝트.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Thu, 06 Mar 2025 06:05:28 GMT</pubDate></item><item><title><![CDATA[2. 스프링 핵심 원리 이해]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:SpringCoreBasic" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SpringCoreBasic</a> <a class="tag" href="http://lts.kr/?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <a class="tag" href="http://lts.kr/?query=tag:lectur" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#lectur</a> <a class="tag" href="http://lts.kr/?query=tag:강의" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#강의</a> <br> <a href="http://lts.kr?query=tag:SpringCoreBasic" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SpringCoreBasic">#SpringCoreBasic</a> <a href="http://lts.kr?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a> <a href="http://lts.kr?query=tag:lectur" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#lectur">#lectur</a> <a href="http://lts.kr?query=tag:강의" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#강의">#강의</a><br>스타터 사이트 : <a rel="noopener nofollow" class="external-link is-unresolved" href="https://start.spring.io/" target="_self">https://start.spring.io/</a><br>
<img alt="Pasted image 20250305173344.png" src="http://lts.kr/사진-및-문서/pasted-image-20250305173344.png" style="width: 625px; max-width: 100%;" target="_self"><br>
별도의 의존관계는 추가하지 않음<br><img alt="Pasted image 20250305175924.png" src="http://lts.kr/사진-및-문서/pasted-image-20250305175924.png" target="_self">]]></description><link>http://lts.kr/lectur/2.-스프링-핵심-원리-이해.html</link><guid isPermaLink="false">lectur/2. 스프링 핵심 원리 이해.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 05 Mar 2025 08:59:31 GMT</pubDate><enclosure url="http://lts.kr/사진-및-문서/pasted-image-20250305173344.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="http://lts.kr/사진-및-문서/pasted-image-20250305173344.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[1. 객체 지향 설계와 스프링]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:SpringCoreBasic" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SpringCoreBasic</a> <a class="tag" href="http://lts.kr/?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <a class="tag" href="http://lts.kr/?query=tag:lectur" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#lectur</a> <a class="tag" href="http://lts.kr/?query=tag:강의" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#강의</a> <br> <a href="http://lts.kr?query=tag:SpringCoreBasic" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SpringCoreBasic">#SpringCoreBasic</a> <a href="http://lts.kr?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a> <a href="http://lts.kr?query=tag:lectur" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#lectur">#lectur</a> <a href="http://lts.kr?query=tag:강의" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#강의">#강의</a><br>스프링이 제공하는 핵심 가치와 원리를 제대로 파악하고 사용한다.<br>객체 지향 프로그래밍
<br>단순 레퍼런스 문서 설명이 아닌, 이유와 핵심원리
<br>스프링의 본질에 대해 깊은 이해 -&gt; 객체지향 설계의 본질을 이해
<br>2000년대 초반<br>
EJB(enterprise java Beans) -&gt; spring / JAP 를 짬뽕해놓은 기술이 탄생<br>Java진영에서 표준으로 개발한 기술
<br>컨테이너 기술
<br>설정에 의한 트렌젝션 기술
<br>분산 기술
<br>엔티티 빈 : ORM기술 중 하나
<br>가격이 매우 비쌌음 수천만원 짜리 Server도 존재했었음
<br>단점 <br>어렵고
<br>복잡하고
<br>느리다
<br>POJO - 오래된 방식의 자바 오브젝트, 그냥 이걸로 돌아가자는 말이 나올 정도였다.<br>두 명의 사람이 EJB에 환멸을 느끼고, 오픈소스를 만든다.<br>
<br>EJB 컨테이너의 대체
<br>단순함의 승리
<br>현재 사실상의 표준 기술
<br>
<br>EJB의 엔티티빈 기술을 대체
<br>JPA 새로운 표준 정의
<br> EJB 엔티티 빈 -&gt; 하이버네이트 -&gt; JPA(같은 사람이 거의 하이버네이트와 비슷하게 만든 JAVA표준)<br>JPA - 표준 인터페이스<br>
하이버네이트 - 80% 이상의 점유율을 차지하는 JAP 구현체<br>
<br>2002 로드 존슨 책 출간
<br>EJB의 문제점 지적
<br>EJB없이 고품질의 확장 가능한 애플리케이션을 개발할 수 있음을 보여줌
<br>30,000라인 이상의 기반 기술을 예제코드로 선보임
<br>BeanFactory, applicationContext, POJO, DI, IoC(제어의 역전)
<br>책 출간 이후 '유겐 휠러', '얀 카로프'가 로드 존슨에게 오픈소스 프로젝트를 제안하여<br>
만들어진 것이 SPRING( EBJ 겨울을 넘어 새로운 시작이라는 뜻 )<br>1.0 - xml<br>
2.0 - xml 편의기능<br>
3.0 - 자바 코드로 설정<br>
4.0 - 자바8<br>
boot 1.0 - 기존 스프링의 복잡한 셋팅/설정을 개선<br>
5.0 / boot 2.0 - 리엑티브 프로그래밍 지원<br>
...<br>예전 스프링은 설정이 절반이다 라고 할 정도로 설정이 힘들었다.
<br>필수<br>스프링 프레임워크
<br>스프링 부트
<br>선택<br>스프링 데이터 - noSQL, RDB 등 CRUD를 편리하게 도와줌
<br>스프링 세션
<br>스프링 시큐리티
<br>스프링 레스트 독스 - API문서화, 테스트를 편리하게 도와줌
<br>스프링 배치 - 배치 처리 특화 기술
<br>스프링 클라우드 - 클라우드..
<br>
<br>핵심기술 - 스프링 DI 컨테이너 / AOP / 이벤트
<br>웹 기술 - 스프링 MVC / 스프링 Web Flux
<br>데이터 - 트렌젝션 / JDBC / ORM / xml
<br>기술통합 - 캐시, 이메일, 원격, 스케줄링
<br>테스트 - 스프링기반 테스트
<br>언어 - 코틀린, 그루비
<br>
<br>
스프링을 편리하게 사용할 수 있도록 지원, 최근에는 스텐다드로 사용 <br>
단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성<br>
-Tomcat같은 웹 서버를 내장하여 별도의 웹 서버 설치 불필요 <br>
손쉬운 빌드 구성을 위한 starter 종속성 제공 <br>
스프링과 3rd parth 라이브러리 자동 구성 <br>메이저 외부 라이브러리 버전 자동 체크/다운 <br>
메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공 <br>
관례에 의한 간결한 설정 <br>문맥에 따라 다르게 사용된다.<br>스프링 DI 컨테이너 기술
<br>스프링 프레임워크
<br>스프링 부트, 프레임워크 등 모두 포함한 생태계
<br>
<br>자바 언어 기반의 프레임워크
<br>자바 언어의 가장 큰 특징 - 객체 지향 언어
<br>스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크
<br>스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크⭐
<br>
<br>
컴퓨터 프로그래밍을 명령어의 목록으로 보는 시각에서 벗어나, 여러개의 독립된 단위,<br>
즉, 객체 들의 모임으로 파악하고자 하는것이다. <br>
각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있다.(협력) <br>
객체지향 프로그래밍은 유연하고 변경용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다. <br>
<br>레고 블럭 조립하듯,
<br>컴퓨터 부품 갈아 끼우듯,
<br>컴포넌트를 쉽고 유연하게 변경하면서 개발할 수 있는 방법.<br>
=&gt; 다형성
<br>
<br>자동차의 역할 (인터페이스)
<br>자동차 구현 K3, 모델3, 아반떼 등 (class, 구현체)
<br>운전자는 역할(인터페이스)만을 따르면 모든 자동차를 이용할 수 있다.<br>
즉, 클라이언트에 영향을 주지 않고 새로운 기능을 구현할 수 있다.<br>유연하고, 변경에 용이한 것!!<br>ex) 정렬 알고리즘, 할인 정책 등등<br>
<br>클라이언트는 대상의 역할(인타페이스)만 알면 된다.
<br>클라이언트는 구현 대상의 내부구조를 몰라도 된다.
<br>클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않는다.
<br>클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않는다.
<br>
<br>오버라이딩은 자바의 기본 문법
<br>오버라이딩 된 메서드가 실행
<br>다형성으로 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경 가능
<br>물론, 클래스 상속 관계도 다형성/오버라이딩 적용가능(권장안함)
<br>
<br>인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.
<br>다형성의 본질을 이해하려면 협력이라는 객체사이의 관계에서 시작해야함.
<br>클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.
<br>확장 가능한 설계
<br>
<br>역할(인터페이스) 자체가 변하면, 클라이언트, 서버 모두에 큰 변경이 발생한다.
<br>
<br>다형성이 가장 중요하다!
<br>스프링은 다형성을 극대화해서 이용할 수 있게 도와준다.
<br>스프링에서 이야기하는 IoC, DI는 다형성을 활용해서 역할과 구현을 편리하게 다룰 수있도록 지원한다.
<br>스프링을 사용하면 마치 레고 블럭 조립하듯 구현을 편리하게 변경할 수 있다.
<br>
<br>클린코드로 유명한 로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙을 정리한것.
<br>SRP: 단일 책임 원칙(single responsibility principle)
<br>OCP: 개방-폐쇄 원칙 (Open/closed principle)
<br>LSP: 리스코프 치환 원칙 (Liskov substitution principle)
<br>ISP: 인터페이스 분리 원칙 (Interface segregation principle)
<br>DIP: 의존관계 역전 원칙 (Dependency inversion principle)
<br>
<br>한 클래스는 하나의 책임만 가져야 한다.
<br>중요한 기준은 변경이다.
<br>변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른것.
<br>UI변경, 객체의 생성과 사용을 분리
<br>
<br>확장에는 열려있으나, 변경에는 닫혀있어야 한다.
<br>다형성을 잘 활용하여야 한다.
<br>인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현
<br>역할과 구현의 분리
<br>	- MemberService 클라이언트가 구현 클래스를 직접 선택 MemberRepository m = new MemoryMemberRepository(); //기존 코드 //DIP 위반 MemberRepository m = new JdbcMemberRepository(); //변경 코드 //DIP 위반
<br>구현 객체를 변경하려면 클라이언트 코드를 변경해야 한다.
<br>분명 다형성을 사용했지만 OCP 원칙을 지킬 수 없다. -&gt; 클라이언트가 기존코드를 변경해야한다.<br>
-&gt; 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다 : 스프링 컨테이너 / DI, IoC <br>
<br>프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다
<br>하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것
<br>다형성을 지원하기 위 한 원칙, 인터페이스를 구현한 구현체는 믿고 사용하려면, 이 원칙이 필요하다.
<br>단순히 컴파일에 성공하는 것을 넘어서는 이야기
<br>ex) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP 위반<br>
<br>특정 클라이언트를 위한 인터페이스 여러 개가, 범용 인터페이스 하나보다 낫다
<br>자동차 인터페이스 -&gt; 운전 인터페이스, 정비 인터페이스로 분리
<br>사용자 클라이언트 -&gt; 운전자 클라이언트, 정비사 클라이언트로 분리
<br>분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음
<br>인터페이스가 명확해지고, 대체 가능성이 높아진다.
<br>
<br>프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.”
<br>구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻
<br>역할(Role)에 의존하게 해야 한다는 것과 같다.
<br>구현체에 의존하게 되면 변 경이 아주 어려워진다
<br>
그런데 OCP에서 설명한 MemberService는 인터페이스에 의존하지만, 구현 클래스도 동시에 의존한다.
<br>MemberService 클라이언트가 구현 클래스를 직접 선택<br>MemberRepository m = new MemoryMemberRepository(); //DIP 위반
<br>그럼 인터페이스만 사용하면 구현체가 없는데 어떻게 위반을 안해?<br>
<br>다형성 만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다.
<br>다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.
<br>다형성 만으로는 OCP, DIP를 지킬 수 없다.
<br>뭔가 더 필요하다.
<br>
<br>
스프링은 다음 기술로 다형성 + OCP, DIP를 가능하게 지원<br>
DI(Dependency Injection): 의존관계, 의존성 주입<br>
DI 컨테이너 제공 <br>
클라이언트 코드의 변경 없이 기능 확장 <br>
쉽게 부품을 교체하듯이 개발 <br>
<br>순수하게 자바로 OCP, DIP 원칙들을 지키면서 개발을 해보면, 결국 스프링 프레임워크를 만들게 된다.<br>
(더 정확히는 DI 컨테이너)
<br>
<br>하지만 인터페이스를 도입하면 추상화라는 비용이 발생한다.
<br>기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용하고,<br>
향후 꼭 필요할 때 리팩터 링해서 인터페이스를 도입하는 것도 방법이다]]></description><link>http://lts.kr/lectur/1.-객체-지향-설계와-스프링.html</link><guid isPermaLink="false">lectur/1. 객체 지향 설계와 스프링.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 05 Mar 2025 08:28:42 GMT</pubDate></item><item><title><![CDATA[🚦 Spring Batch(스레드와 트렌젝션) 트러블슈팅]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:트러블슈팅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#트러블슈팅</a> <a class="tag" href="http://lts.kr/?query=tag:EntityManager" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#EntityManager</a> <a class="tag" href="http://lts.kr/?query=tag:Transaction" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Transaction</a> <a class="tag" href="http://lts.kr/?query=tag:트렌젝션" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#트렌젝션</a> <br> <a href="http://lts.kr?query=tag:트러블슈팅" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#트러블슈팅">#트러블슈팅</a> <a href="http://lts.kr?query=tag:EntityManager" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#EntityManager">#EntityManager</a> <a href="http://lts.kr?query=tag:Transaction" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Transaction">#Transaction</a> <a href="http://lts.kr?query=tag:트렌젝션" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#트렌젝션">#트렌젝션</a><br>청크사이즈가 다름에도 처리속도가 똑같은 이유가 뭘까?<br>** Chunk 방식의 Batch에서 ChunkSize란, 한 트렌젝션 내에서 처리할 컬럼(DTO/모델)의 개수이다.<br>즉, ChunkSize가 작을수록 데이터 I/O작업 및 Overhead(데이터 읽기/쓰기, 트랜잭션 시작 및 종료 등)가 증가하여 총 실행시간이 길어져야한다.<br>청크 사이즈별 실행시간 측정 데이터
<br>grid-size:12 / chunk-size:30
-
3분 22.856초
3분 23.096초 grid-size:12 / chunk-size:20
-
3분 23.546초
3분 23.784초 grid-size:12 / chunk-size:10
-
3분 24.243초
3분 22.389초
3분 24.667초
3분 24.789초 grid-size:12 / chunk-size:5
-
3분 24.953초
3분 24.353초
<br>
<br>배치 서비스 로직의 일부
<br>dtoList.stream().parallel() .forEach(dto -&gt; {});
<br>스레드 확인
<br>} } IntStream.range(1, 10) .parallel() .forEach(i -&gt; System.out.println(Thread.currentThread().getName() + " - " + i)); }
} - 출력
ForkJoinPool.commonPool-worker-3 - 3
ForkJoinPool.commonPool-worker-1 - 1
ForkJoinPool.commonPool-worker-2 - 2
ForkJoinPool.commonPool-worker-0 - 4
... <br>
<br>별도의 셋팅이 없이 parallel() 구문을 사용하여 병렬 처리를 진행한다면,<br>
1.데이터를 작은 단위(Chunk)로 분할<br>
- 예를 들어, 1000개의 데이터를 4개의 스레드에서 처리한다고 하면, ForkJoinPool은 데이터를 여러 개의 Task로 나눈다.<br>
2.Worker Thread들이 분할된 작업을 병렬로 실행<br>
- 각 스레드는 자신이 맡은 작업을 처리하고, 남는 작업이 있다면 다른 스레드의 작업을 훔쳐(Work-Stealing) 가져와 실행한다.<br>
3.최종적으로 결과를 합쳐서 반환<br>
- 모든 작업이 완료되면 병렬 처리된 결과가 하나로 합쳐진다<br>
- ForkJoinPool이란?
Java에서 제공하는 병렬 작업을 최적화하는 스레드 풀로써,<br>
Work-Stealing 알고리즘을 사용하여 유휴스레드를 최소화하고 CPU 활용도를 극대화하는 기법이다. <br>해당 과정에서 ForkJoinPool은 작업을 여러 개의 워커 스레드(ForkJoinPool-worker-*)에서 실행하기 때문에 Spring의 ThreadLocal 기반 트랜잭션이 전파되지 않는다.<br>
<br>청크의 내부 서비스로직에서의 동작 효율을 위해 병렬처리를 사용했으나, ForkJoinPool기반의 정확한 동작원리를 충분히 고려하지 않아 발생한 이슈이다.
<br>해당 부분은 일반적인 forEach문으로 변경함으로써 이슈를 해결할 수 있었다.
<br>특히, 멀티스레드를 다룰 때에는 병렬처리를 함에 있어 주의를 필요로 함을 깨달았다.<br>반복 TEST 중.. 커넥션풀 Time Out 문제??<br><img alt="Pasted image 20241213102128.png" src="http://lts.kr/사진-및-문서/pasted-image-20241213102128.png" target="_self"><br>SHOW VARIABLES LIKE 'max_connections'; //최대 개수
SHOW STATUS LIKE 'Threads_connected'; //사용중인 개수
<br><img alt="Pasted image 20250304170347.png" src="http://lts.kr/사진-및-문서/pasted-image-20250304170347.png" target="_self"><br>
<img alt="Pasted image 20250304170412.png" src="http://lts.kr/사진-및-문서/pasted-image-20250304170412.png" target="_self"><br>
<img alt="Pasted image 20250304171240.png" src="http://lts.kr/사진-및-문서/pasted-image-20250304171240.png" target="_self"><br>운영 DB의 커넥션 pool은 충분한 상태로 보인다. <br>정보
처음 몇 번간은 정상실행 되지만, 반복 테스트 중 스레드 풀 점유 대기 타임아웃이 발생했다.
<br>배치를 완료한 이후에, 스레드 풀(히카리 풀)을 정상 반환하는지 확인.
<br><img alt="Pasted image 20241213102229.png" src="http://lts.kr/사진-및-문서/pasted-image-20241213102229.png" style="width: 750px; max-width: 100%;" target="_self"><br>Step이 마무리될때, 적어도 Job이 마무리 될때, entityManager를 클로즈 시키는것이 자명한데, 어째서 커넥션풀이 해제되지 않는가??<br><img alt="Pasted image 20241213143101.png" src="http://lts.kr/사진-및-문서/pasted-image-20241213143101.png" target="_self"><br>코드를 뜯어보자...
주의
엔티티 매니저는 클로즈 될 때, 트렌젝션이 살아있다면 그 트렌젝션이 종료될때까지 기다린다.
<img alt="Pasted image 20241213143217.png" src="http://lts.kr/사진-및-문서/pasted-image-20241213143217.png" target="_self"> <br>protected void doReadPage() { ... if (startIndex &gt;= totalRecords) { initResults(); // 빈 결과로 초기화 tx.commit(); return; } ...
<br><img alt="Pasted image 20241213103503.png" src="http://lts.kr/사진-및-문서/pasted-image-20241213103503.png" target="_self"><br>
<br>엔티티 메니저는 진짜 메니저가 아니다. 힘이 없다. 트렌젝션 메니저가 진짜 메니저다.
<br>그저 영속성 컨텍스트만 관리하는 녀석. 변경감지만 하는 녀석.]]></description><link>http://lts.kr/issue_troubleshooting/🚦-spring-batch(스레드와-트렌젝션)-트러블슈팅.html</link><guid isPermaLink="false">Issue_TroubleShooting/🚦 Spring Batch(스레드와 트렌젝션) 트러블슈팅.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Tue, 04 Mar 2025 08:37:22 GMT</pubDate><enclosure url="http://lts.kr/사진-및-문서/pasted-image-20241213102128.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="http://lts.kr/사진-및-문서/pasted-image-20241213102128.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[📔 DataBase]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="http://lts.kr/?query=tag:DB" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#DB</a> <a class="tag" href="http://lts.kr/?query=tag:DataBase" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#DataBase</a> <br> <a href="http://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="http://lts.kr?query=tag:DB" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#DB">#DB</a> <a href="http://lts.kr?query=tag:DataBase" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#DataBase">#DataBase</a><br>
<br>간단히 설명하면 "여러 쿼리를 한번에 실행하는 것" 이다.
<br>SQL의 Function과 비슷해 보이지만 차이가 있다.<br>
function : 클라이언트에서 처리, 리턴값 필수, 리턴값은 한개만 반환 가능<br>
프로시저 : 서버로 보내서 처리, 리턴값 선택, 리컨값 여러개 가능
<br>속도면에서는 함수에 비해 프로시저가 더 빠르다.<br>
그렇기 때문에 프로시저같은 경우는 실행,처리를 할때 주로 사용하고, 함수는 간단한 계산이나 수치 결과를 나타낼 때 사용한다.<br>
<br>하나의 요청으로 여러 SQL문을 실행 할 수 있음
<br>네트워크 소요 시간을 줄일 수 있음(여러개의 쿼리를 처리하는 시점에서 네트워크 부하를 줄임)
<br>보수성이 뛰어나다
<br>개발 업무를 구분하여 개발할 수 있다.(DB관련 처리를 API처럼 만들어 사용가능)
<br>
<br>재사용성이 낮다(DB버전 별 구문/규칙과 호환성이 다르기 때문)
<br>처리 성능이 좋지 않다(MySQL스토어드 프로그램 처리 성능이 낮다)
<br><img alt="Pasted image 20240610171904.png" src="http://lts.kr/사진-및-문서/pasted-image-20240610171904.png" target="_self"><br>파라미터 선언은 프로시저명() 안에서 선언하고, SQL문과 변수는 BEGIN - END 안에서 작성한다.
<br>SELECT사용시 반드시, 조회한 컬럼의 값을 INTO로 변수 안에 넣어주어야 한다.
<br>프로시저안에서 사용하는 SQL문은 세미콜론(;)으로 문장 끝을 맺어주어야 한다.
<br>if, case, loop 문을 사용할 수 있다.
<br>프로시저내에서 다른 프로시저를 호출 할 수 있다.
<br>- 커넥션이란 어플리케이션과 데이터베이스 서버간의 통신 링크를 뜻한다. 애플리케이션이 쿼리를 실행하고, 데이터를 검색하고, 데이터베이스에서 트랜젝션을 수행 할 수 있는 세션을
설정하는데 사용된다.
말그대로 애플리케이션과 DB를 연결하는 통신링크이며, 이가 모여있는것을 커넥션 풀 이라고 한다.
매번 연결하고 끊고 하는것 보다 커넥션풀에 등록하는 것이 성능적인 향상을 기대할 수 있기 때문이다.
<br>
<br>테이블 간에 중복된 데이터를 허용하지 않는다는 기본 목표를 갖는다. <br>중복된 데이터를 허용하지 않음으로 써 무결성 을 유지할 수 있다.
<br>
<br>DB의 저장 용량 또한 줄일 수 있다.
<br>데이터 테이블을 분해하여 이상현상이 발생할 가능성을 줄이고, 확장/수정시 구조 변경을<br>
최소화 할 수 있다.
<br>
<br>
릴레이션의 분해로 인해 Join연산이 늘어날 수 있다. <br>
쿼리시 응답시간이 느려질 수 있다. 데이터의 중복속성을 최대한 제거하는 것 이기때문에, 속성이 하나의 테이블에 집약되므로<br>
데이터 용량이 최소화 되어 상황에따라 처리속도가 빨라질 수도 있고, 느려질 수도 있다.<br>
만약 조인이 만연하여 속도저하가 발생하게 된다면 반정규화를 통해 속도를 개선할 수 있다. <br>
<br>테이블의 컬럼이 원자값(하나의 값)을 갖도록 테이블을 분해하는 것이다.
<br>각 컬럼의 순서가 상관이 없어야한다.
<br>하나의 컬럼은 같은 종류의 타입을 가져야 한다.<br>
<img alt="Pasted image 20240531103441.png" src="http://lts.kr/사진-및-문서/pasted-image-20240531103441.png" target="_self"><br>
원자값을 갖도록 컬럼을 나눈다.<br>
<img alt="Pasted image 20240531103549.png" src="http://lts.kr/사진-및-문서/pasted-image-20240531103549.png" target="_self">
<br>
<br>제 1 정규화를 진행한 테이블에 대해 "완전 함수 종속"을 만족하도록 테이블을 분해하는 것이다.
<br>여기서 완전 함수 종속이란, 기본키의 부분집합이 결정자가 되어선 안된다는 것을 의미한다.<br>
즉, 부분적 종속을 없애는 것이다.
<br><img alt="Pasted image 20240531105228.png" src="http://lts.kr/사진-및-문서/pasted-image-20240531105228.png" target="_self"><br>
해당 테이블의 기본키는 (학생번호, 강좌이름)으로 복합키 이다.<br>
성적은 (학생번호, 강좌이름)인 기본키가 결정하지만,<br>
강의실은 기본키의 부분집합인 강좌이름이 결정하게 된다.<br>즉, 부분집합이 결정자가 되지 않도록 테이블을 분리시키는 것으로 완전 함수 종속을 만족시킬 수 있다.<br>
<img alt="Pasted image 20240531105241.png" src="http://lts.kr/사진-및-문서/pasted-image-20240531105241.png" target="_self"><br>
<br>제2 정규화를 진행한 테이블에 대해 "이행적 종속"을 없애도록 테이블을 분해하는 것이다.
<br>여기서 이행적 종속이란 A -&gt; B , B -&gt; C 가 성립할때, A -&gt; C 가 성립되는 것을 의미한다.<br>
<img alt="Pasted image 20240531104351.png" src="http://lts.kr/사진-및-문서/pasted-image-20240531104351.png" target="_self"><br>
다음의 경유 이행적 종속상태 로 말할 수 있다.
<br>그 경우 테이블을 분리하여 데이터 변경시에 다른 데이터까지 변경되는 상황을 막을 수 있다.<br>
<img alt="Pasted image 20240531104418.png" src="http://lts.kr/사진-및-문서/pasted-image-20240531104418.png" target="_self"><br>
<br>제3 정규화를 좀 더 강화한 것이라 생각하면 된다.
<br>BCNF정규화란 제3 정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록<br>
테이블을 분해하는 것을 말한다.
<br><img alt="Pasted image 20240531104751.png" src="http://lts.kr/사진-및-문서/pasted-image-20240531104751.png" target="_self"><br>
특수 수강 테이블에서 기본키는 (학생번호, 특강이름)이다. 그리고 기본키는 교수를 결정하고 있다.<br>
또한, 여기서 교수는 특강이름을 결정하고있다.<br>문제는 교수가 특강이름을 결정하는 결정자 이지만, 후보키가 아니다.<br>
그렇기 때문에 BCNF 정규화를 만족시키기 위해서는 테이블을 분해하여 아래와 같이 분리할 수 있다.<br><img alt="Pasted image 20240531104803.png" src="http://lts.kr/사진-및-문서/pasted-image-20240531104803.png" target="_self"><br>
<br>컬럼값의 중복을 제거하는것이다.
<br>
<br>중복을 제거하기 위해 분해할 수 있을만큼 최대한 분해하는 것이다.
<br> 그 이상 정규화를 진행하면 오히려 정규화의 단점이 더 커지기 때문이다.
<br>인덱스 : 단일데이터 단위인 도큐먼트(document)를 모아놓은 집합을 인덱스(index)라고 한다.<br>
색인 : 데이터를 Elasticsearch에 저장하는 행위<br>
샤드 : 인덱스는 기본적으로 샤드(shard)라는 단위로 분리되고, 각 노드에 분산되어 저장된다 (검색의 기본단위는 샤드이다.)<br>
<img alt="Pasted image 20240828104032.png" src="http://lts.kr/사진-및-문서/pasted-image-20240828104032.png" target="_self"><br>데이터를 범위나 카테고리로 나누어 관리하는 기법을 파티셔닝 이라고 한다.
<br>
<br>
인덱스를 생성할 때, 처음 생성된 샤드를 프라이머리 샤드, 복제본은 리플리카 라고 부른다. <br>
예를 들어 한 인덱스가 5개의 샤드로 구성되어있고, 클러스터가 4개의 노드로 구성되어있다고 가정하면,<br>
각각 5개의 프라이머리 샤드와 복제본, 총 10개의 샤드들이 전체 노드에 골고루 분산되어 저장된다.<br>
<img alt="Pasted image 20240828104728.png" src="http://lts.kr/사진-및-문서/pasted-image-20240828104728.png" target="_self"><br>
노드가 1개만 존재한다면 복제본은 생성되지 않는다. Elasticsearch는 아무리 작은 클러스터라도 최소 3개의 노드로 구성할 것을 권장하고 있다. <br>
이렇게 프라이머리 샤드와 리플리카를 통해 Elasticsearch는 운영 중에 노드가 유실되어도 데이터를 잃어버리지 않고, 데이터 가용성과 무결성을 보장하게 된다. <br>샤드는 여러 서버에 분산되어 병렬 및 병행으로 검색되므로, 인덱스가 같던 다르던 상관이 없다.
검색의 기본 단위는 샤드이기 때문이다. 따라서 인덱스를 나누는 것은 운영의 편의성을 고려할 때 선택하는 방법이다.
<br>전체색인을 할 경우 인덱스 1개가 7억건 이라면 색인이 모두 끝날때 까지 몇시간이 걸리게 된다.
그 와중에 데이터에 변경이 있게 된다면 전체 색인 후 일괄적용이 들어가게 될텐데, 대기시간이 길어질 수록 일괄적용 시간도 함께 늘어나게 된다.
결국 더 빠른 색인을 위해서는 하나의 인덱스를 여러개로 나누너 병행처리를 시키도록 해야한다. 다나와 에서는 상품DB특성상 카테고리군 별로 인덱스를 나누고 있다. 이때의 장점은 특정 카테고리만 검색할때 해당 인덱스만 검색하면 되므로, 검색 속도가 현저히 감소하게 된다.
<br>
<br>일반적인 시스템 로그와 같은 로그성 문서는 색인을 하고 나면 수정이 필요없는 정적 컨텐츠인 반면<br>
상품문서같은 경우 색인이 끝나도 계속 갱신되어야 하는 살아있는 동적 컨텐츠이다. 따라서 동적색인에 원할하고, 검색성능도 높은 설계를 요구한다.
<br>트렌젝션<br>
- 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위<br>트렌젝션매니저<br>
- Spring에서 제공하는 트렌젝션 관리 기능과 JPA를 연결하는 역할을 수행.<br>@Transactional<br>
- 클래스나 메서드에 삽입하면, AOP레벨(프록시를 사용하여)에서 트렌젝션매니저를 이용한 동작을 공통으로 적용.<br>앤티티매니저<br>
- 영속성 컨텍스트를 관리하는 인터페이스<br>
- 엔티티의 저장/수정/삭제/조회 작업을 수행<br>
- 스레드 세이프하지 않으므로 한트레젝션 내에서만 사용<br>
- 앤티티매니저펙토리는 스레드세이프하므로 공유 가능<br>영속성컨텍스트<br>
- JPA의 엔티티를 관리하는 1차 캐시 역할을 하는 메모리 공간<br>
- 엔티티와 DB데이터간의 상태 동기화를 책임<br>
- 1차캐싱 / 변경 감지 / 지연 로딩 의 특징을 갖는다<br>
- 지연로딩 : 관계된 엔티티를 실제로 필요할때만 가져오며, 변경점을 한번만 commit한다<br>스냅샷<br>
- DB스냅샷 :<br>
- 트렌젝션이 시작될때 생성된다.<br>
- 독립적인 데이터베이스 복사본으로, 원본데이터 변경과 무관하다.<br>
- 고급 격리 수준(REPEATABLE READ, SERIALIZABLE)에서 MVCC(Multi-Version Concurrency Control)를 구현할 때 사용한다.<br>
- 물리적인 복사본이 아닌, 논리적으로 매 쿼리마다 동적으로 가공이 되는 방식이다.<br>
- 앤티티매니저_스냅샷 :<br>
- 엔티티가 영속성 컨텍스트에 로드될 때 생성된다.<br>
- 엔티티의 초기 상태를 저장하여 변경 감지에 사용된다.<br>세션1이 트렌젝션을 시작하고 데이터를 수정하는 동안 아직 커밋을 수행하지 않았는데,<br>
세션2에서 동시에 같은 데이터를 수정하게 되면 여러가지 문제가 발생한다.<br>이런문제를 방지하기 위해, 세션이 트렌젝션을 시작하고 데이터를 수정하는 동안에 커밋이나 롤백 전까지<br>
다른세션에서 해당 데이터를 수정할 수 없게 막아야 한다. 이런 문제를 해결하기 위해 DB에서는<br>
LOCK 락 이라는 개념을 제공한다.<br>락은 언제 사용하는가? : 트렌젝션 종료 시점까지 해당 데이터를 다른 곳에서 변경하지 못하도록 강제로 막아야 할 때 사용한다.
<br>일반적인 조회는 락을 사용하지 않는다.
<br>락 타임아웃(다른 세션이 데이터를 점유하고 있을때 대기시간이 초과된 경우)에는 익셉션이 발생하게 된다.
<br>동시성 제어(Concurrency Control)란,&nbsp;여러 사용자나 프로세스가 데이터를 공유할 때 발생할 수 있는 문제를 해결하기 위해, 데이터베이스 시스템이 트랜잭션을 순서대로 실행하는 것이 아니라, 트랜잭션이 동시에 실행될 수 있도록 허용하면서도 데이터의 일관성과 무결성을 유지할 수 있도록 하는 기술이며, 데이터베이스 시스템에서 매우 중요한 개념 중 하나이다.<br>
<br>여러 사용자가 DB에 접근하더라도&nbsp;데이터의 일관성을 보장하고 데이터의 무결성을 유지
<br>위를 만족하며 데이터베이스 시스템의 성능과 효율성을 유지하는 것
<br>분실된 갱신(Lost Update) <br>두개의 트랜잭션이 같은 데이터를 갱신하는 작업을 진행하게 되면서 하나의 작업이 진행되지 않는 경우 <br>모순성(Inconsistency) <br>두개의 트랜잭션이 같은 데이터를 동시에 갱신하게되어 사용자가 원하는 결과와 일치하지 않은 상태가 되는 경우 <br>연쇄복귀(Cascading Rollback) <br>두개의 트랜잭션이 같은 데이터를 갱신하는 작업을 진행하는 과정에서 하나의 트랜잭션이 실패하면 원자성에 의해 두 트랜잭션 모두 복귀하는 경우 <br>비완료 의존성(Uncommitted Dependency) <br>한개의 트랜잭션이 실패하였을때, 이 트랜재션이 회복하기전에 다른 트랜잭션이 실패한 수행 결과를 참조하는 경우 <br>
<br>Locking은 공유 자원에 대한 동시 액세스를 제어하는 전통적인 방법이다.
<br>단일 스레드 또는 단일 프로세스에서만 동작하며, 한 번에 하나의 스레드만 공유 자원에 액세스할 수 있다.
<br>신뢰성과 안전성이 높으며, 어떤 수준의 locking을 적용하느냐에 따라 교착 상태나 경쟁 조건과 같은 문제를 방지할 수 있다.
<br>하지만 동시성 처리 속도가 저하될 수 있고, 대기 시간이 발생할 수 있다.
<br>기본적으로 lock 연산과 unlock 연산을 사용한다.
<br>
<br>
공유 잠금 (shared lock/s-lock): 데이터를 읽을 때 사용하는 락 <br>공유잠금을 설정한 트랜잭션은 데이터 항목에 대해&nbsp;읽기 연산(read)만 가능하다. <br>T1에서 x에 대해 S-lock을 설정했다면, T1은 read(x) 연산만 가능하다. <br>하나의 데이터 항목에 대해&nbsp;여러 개의 공유잠금이(S-lock) 가능하다. <br>T1에서 x에 대해 S-lock을 설정한 경우, 동시에 T2에서도 x에 대해 S-lock을 설정할 수 있다. <br>다른 트랜잭션도 읽기 연산(read) 만을 실행할 수 있다. <br>T1에서 x에 대해 S-lock을 설정했다면, T2에서도 T1이 S-lock(x)을 실행하는 동안 read(x) 연산만 가능하다. <br>
배타 잠금 (exclusive lock/x-lock): 데이터를 변경할 때 사용하는 락 <br>배타잠금을 설정한 트랜잭션은 데이터 항목에 대해서&nbsp;읽기 연산(read)과 쓰기 연산(write) 모두 가능하다. <br>T1에서 x에 대해 S-lock을 설정했다면, T1은 read(x) 연산과 write(x) 연산 모두 가능하다. <br>하나의 데이터 항목에 대해서는&nbsp;하나의 배타잠금(X-lock)만 가능하다.
<br>동시에 여러 개의 배타잠금은 불가능하다. <br>T1에서 x에 대해 X-lock을 설정했다면, T1에서 unlock(x)를 하기 전까지 T2에서 x에 대해 X-lock을 설정할 수 없다. <br>다른 트랜잭션은 읽기 연산(read)와 쓰기 연산(write) 모두 불가능하다. <br>T1에서 x에 대해 X-lock을 설정했다면, T2에서는 T1에서 unlock(x)를 하기 전까지 read(x), write(x) 연산이 모두 불가능하다. <br>
추가) 교착상태 (deadlock) <br>모든 transaction이 대기 상태에 들어가 아무런 진행이 일어나지 않는 상태를 교착상태라고 한다. 교착상태에 빠지면 외부에서 강제로 트랜잭션을 중단하거나 잠금을 해제하지 않는 이상 무한정 대기 상태로 남게 된다. <br>
<br>
낙관적 락 (optimistic lock) <br>충돌이 발생할 가능성이 낮은 경우 사용되는 동시성 제어 기법이다.
<br>충돌이 발생하면 재시도 또는 병합을 통해 충돌을 해결한다.
<br>실제로 lock을 사용하지 않고&nbsp;version을 이용함으로서 정합성을 맞추는 방법이다. 데이터를 읽을 때 lock을 사용하지 않고, 업데이트 시&nbsp;내가 읽은 version이 맞는지 충돌 여부를 확인하여 처리한다.
<br>즉, 자원에 lock을 직접 걸어서 선점하지 않고, 동시성 문제가 실제로 발생하면 그때가서 처리하는 방식이다. <br>
비관적 락 (pessimistic lock) <br>충돌이 발생할 가능성이 높은 경우 사용되는 동시성 제어 기법이다.
<br>데이터를 읽거나 수정하기 전에 lock을 획득하여 다른 사용자의 액세스를 차단하고, lock을 가진 스레드만 접근하도록 제어한다.
<br>데이터에 대한 배타적인 액세스 권한을 보장하여 충돌을 방지한다.
<br>실제로 데이터에 lock을 걸어서 정합성을 맞추는 방법으로, 자원 요청에 따른 동시성 문제가 발생할 것이라고 예상하고 lock을 걸어버리는 방법이다.
<br>즉, 트랜젝션이 시작할 때 s-lock이나 x-lock을 실제로 걸고 시작한다. <br>
낙관적 락 vs. 비관적 락<br>
<img alt="Pasted image 20250228150552.png" src="http://lts.kr/사진-및-문서/pasted-image-20250228150552.png" target="_self"> <br>
분산락 (distributed lock) <br>여러 컴퓨터 또는 프로세스 간에 공유된 자원에 대한 동시 액세스를 제어하기 위해 사용된다.
<br>분산 시스템에서 동시성 문제를 해결하기 위해 사용되며,&nbsp;분산된 서버 또는 클러스터 간의 상호작용이 필요하다.
<br>주로&nbsp;데이터베이스나 메시지 큐 등의 분산 시스템에서 사용된다.
<br>대표적인 분산락 기법으로는 ZooKeeper, Redis 등이 있다.
<br>Redis는 RedLock이라는 알고리즘을 제안하며 3가지 특성을 보장해야한다고 한다. <br>오직 한 순간에 하나의 작업자만이 락(lock) 을 걸 수 있다.
<br>락 이후, 어떠한 문제로 인해 락을 풀지 못하고, 종료된 경우라도 다른 작업자가 락을 획득할 수 있어야합니다.
<br>Redis 노드가 작동하는한, 모든 작업자는 락을 걸고 해체할 수 있어야합니다. <br>분산 락을 구현하기 위해 lock에 대한 정보를 Redis에 저장하고 있어야한다. 그리고 분산환경에서 여러대의 서버들은 공통된 Redis를 바라보며, 자신이 공유 자원에 접근할 수 있는지 확인한다. <br>
스핀락 (spin lock) <br>자원에 대한 접근이 필요할 때 무한루프를 돌면서 반복적으로 확인하며, 다른 스레드가 lock을 해제할 때까지 대기한다.
<br>경쟁 상태 (2개 이상의 프로세스가 공유 자원을 동시에 읽거나 쓰는 상황)가 짧고 자원 점유 시간이 길지 않은 경우에 효과적이다.
<br>주로 멀티코어 시스템에서 사용되며, 락 획득을 위해 CPU를 계속 사용하므로 서버에 많은 부하를 주어 주의해야 한다.
<br>]]></description><link>http://lts.kr/study/cs/📔-database.html</link><guid isPermaLink="false">study/CS/📔 DataBase.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Tue, 04 Mar 2025 08:36:00 GMT</pubDate><enclosure url="http://lts.kr/사진-및-문서/pasted-image-20240610171904.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="http://lts.kr/사진-및-문서/pasted-image-20240610171904.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[👩‍👧‍👦 Analytics 공통모듈 ADMIN용 데이터 추출]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:프로젝트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로젝트</a> <a class="tag" href="http://lts.kr/?query=tag:개발" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#개발</a> <a class="tag" href="http://lts.kr/?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <a class="tag" href="http://lts.kr/?query=tag:AOP" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#AOP</a> <br> <a href="http://lts.kr?query=tag:프로젝트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로젝트">#프로젝트</a> <a href="http://lts.kr?query=tag:개발" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#개발">#개발</a> <a href="http://lts.kr?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a> <a href="http://lts.kr?query=tag:AOP" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#AOP">#AOP</a><br>hf_marketing_code<br>hf_marketing_target<br>hf_marketing_hit_log<br><img alt="Pasted image 20250102181842.png" src="http://lts.kr/사진-및-문서/pasted-image-20250102181842.png" target="_self"><br>=&gt; 해당형태로 컬럼을 고정시키고, 동적으로 유입 수 를 출력한다.<br>-&gt; 그 후 페이지에 뿌려주기<br>Date: 01-02
Ad Type: 구글광고
Total Inflow: 4
Total Hit: 27
Detail Information: Page Name: 대출하기 페이지 Hit: 9 Page Name: 한도조회 버튼 Hit: 12 Page Name: 이용안내 페이지 Hit: 6]]></description><link>http://lts.kr/project/hello-marketing/👩‍👧‍👦-analytics-공통모듈-admin용-데이터-추출.html</link><guid isPermaLink="false">project/hello marketing/👩‍👧‍👦 Analytics 공통모듈 ADMIN용 데이터 추출.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Fri, 28 Feb 2025 09:10:43 GMT</pubDate><enclosure url="http://lts.kr/사진-및-문서/pasted-image-20250102181842.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="http://lts.kr/사진-및-문서/pasted-image-20250102181842.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🍌 Elastic IP(탄력적 IP)란]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:Tools" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Tools</a> <a class="tag" href="http://lts.kr/?query=tag:AWS" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#AWS</a> <a class="tag" href="http://lts.kr/?query=tag:Amazon" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Amazon</a> <a class="tag" href="http://lts.kr/?query=tag:Cloud" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Cloud</a> <a class="tag" href="http://lts.kr/?query=tag:EC2" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#EC2</a> <br> <a href="http://lts.kr?query=tag:Tools" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Tools">#Tools</a> <a href="http://lts.kr?query=tag:AWS" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#AWS">#AWS</a> <a href="http://lts.kr?query=tag:Amazon" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Amazon">#Amazon</a> <a href="http://lts.kr?query=tag:Cloud" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Cloud">#Cloud</a> <a href="http://lts.kr?query=tag:EC2" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#EC2">#EC2</a><br>
<br>EIP는 인터넷을 통해 접속할 수 있는 고정적인 IP주소를 할당하고, 인스턴스에 연결할 수 있는 서비스를 말한다.
<br>모든 인스턴스 또는 네트워크 인터페이스에 EIP 연결이 가능하다.
<br>EIP를 할당받고 삭제하기 전까지, 해당 EIP를 쭉 유지할 수 있다.
<br>정보
도메인과 IP주소를 연결할 떄, IP주소의 변동이 있어선 안되기 때문에, EIP를 사용한다.
<br>
<br>aws Ec2를 올리게 되면 ENI(Elastic network interface)가 함께 생성이된다. <br>ENI는 일종의 가상 랜카드 로써, MAC주소와 보안그룹에 연결되어있으며 IP도 갖고있다.<br>
여기서 ENI에 public IP를 달게 되면 외부에서 접속이 가능하게 되는것이다.
<br>하지만, EC2 인스턴스의 Public IP는 고정된 주소가 아니라 유동적인 IP이다.<br>만약 DNS에 인스턴스의 Public IP를 연결해놓았는데, 해당 IP주소가 변경된다면 문제가 발생할 수 있다.<br>
이러한 문제를 해결하고자 AWS에서 한 번 할당하면 바뀌지 않는 EIP를 제공하는 것이다.<br>주의
다만 AWS EIP(탄력적 IP)는 유료 서비스 임으로, 사용량에 따른 월 사용료를 지불해야 사용할 수 있다.<br>
free요금제 또한 마찬가지로 금액이 부과된다.]]></description><link>http://lts.kr/tools/aws/🍌-elastic-ip(탄력적-ip)란.html</link><guid isPermaLink="false">Tools/aws/🍌 Elastic IP(탄력적 IP)란.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Thu, 27 Feb 2025 08:50:02 GMT</pubDate></item><item><title><![CDATA[⛈ Obsidian-AWS연동]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:프로젝트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로젝트</a> <a class="tag" href="http://lts.kr/?query=tag:개발" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#개발</a> <a class="tag" href="http://lts.kr/?query=tag:Hosting" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Hosting</a> <a class="tag" href="http://lts.kr/?query=tag:Obsidian" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Obsidian</a> <a class="tag" href="http://lts.kr/?query=tag:CI/CD" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#CI/CD</a> <br> <a href="http://lts.kr?query=tag:프로젝트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로젝트">#프로젝트</a> <a href="http://lts.kr?query=tag:개발" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#개발">#개발</a> <a href="http://lts.kr?query=tag:Hosting" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Hosting">#Hosting</a> <a href="http://lts.kr?query=tag:Obsidian" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Obsidian">#Obsidian</a> <a href="http://lts.kr?query=tag:CI/CD" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#CI/CD">#CI/CD</a><br>추가예정.]]></description><link>http://lts.kr/project/note-ci_cd/⛈-obsidian-aws연동.html</link><guid isPermaLink="false">project/note CI_CD/⛈ Obsidian-AWS연동.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 26 Feb 2025 08:20:17 GMT</pubDate></item><item><title><![CDATA[🌥 aws(EC2)셋팅부터 배포까지]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:Tools" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Tools</a> <a class="tag" href="http://lts.kr/?query=tag:AWS" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#AWS</a> <a class="tag" href="http://lts.kr/?query=tag:Amazon" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Amazon</a> <a class="tag" href="http://lts.kr/?query=tag:Cloud" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Cloud</a> <a class="tag" href="http://lts.kr/?query=tag:Docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Docker</a> <a class="tag" href="http://lts.kr/?query=tag:Redis" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Redis</a> <a class="tag" href="http://lts.kr/?query=tag:EC2" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#EC2</a> <br> <a href="http://lts.kr?query=tag:Tools" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Tools">#Tools</a> <a href="http://lts.kr?query=tag:AWS" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#AWS">#AWS</a> <a href="http://lts.kr?query=tag:Amazon" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Amazon">#Amazon</a> <a href="http://lts.kr?query=tag:Cloud" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Cloud">#Cloud</a> <a href="http://lts.kr?query=tag:Docker" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Docker">#Docker</a> <a href="http://lts.kr?query=tag:Redis" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Redis">#Redis</a> <a href="http://lts.kr?query=tag:EC2" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#EC2">#EC2</a><br><img alt="Pasted image 20250221112429.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221112429.png" target="_self"><br>
<br>AWS가 제공하는&nbsp;'클라우드 컴퓨팅 서비스'&nbsp;이다.
<br>예전의 쓴 더 자세한 글.<br>- Amazon Elastic Compute Cloud으로써 AWS에서 제공하는 클라우드 컴퓨팅 서비스이다. 즉, 독립괸 컴퓨터를 임대해주는 aws의
<br>오늘은 EC2에서 인스턴스를 생성하고, docker를 통해 Spring boot 프로젝트를 띄워보겠다.<br>
천천히 따라가 보자.<br>먼저&nbsp; 프로젝트가 설치된 경로에서 ' mvn install '명령어를 사용하여 jar 파일을 생성한다<br><img alt="Pasted image 20250221114856.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114856.png" target="_self"><br>
<img alt="Pasted image 20250221114901.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114901.png" target="_self"><br>docker build -t [이미지 이름]:[태그] [dockerfile이 저장된 경로]
<br><img alt="Pasted image 20250221114932.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114932.png" target="_self"><br><img alt="Pasted image 20250221114945.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114945.png" target="_self"><br><img alt="Pasted image 20250221114951.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114951.png" target="_self"><br>이제 docker는 준비가 끝났다...<br>자세한 설명은 생략한다. 검색해 보시길<br><img alt="Pasted image 20250221114959.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114959.png" target="_self"><br>4.번의 주소를 사용해서 접속한다.<br>
이때!,&nbsp;.pem&nbsp;파일이 저장 되어있는 경로에서 진행한다<br><img alt="Pasted image 20250221115004.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221115004.png" target="_self"><br>접속완료.<br><img alt="Pasted image 20250221115010.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221115010.png" target="_self"><br>먼저, aws 무료 버전 인스턴스를 생성하고자 한다.<br>aws 사이트에 접속하여 개인계정을 생성한다. (aws 프리티어 서비스를 이용하면 1년 무료로 사용가능 함)
<br>sudo docker pull [image이름]:[태그]
<br><img alt="Pasted image 20250221115019.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221115019.png" target="_self"><br>sudo docker images
<br>명령어를 통해 생성된것을 확인할 수 있다.<br><img alt="Pasted image 20250221115024.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221115024.png" target="_self"><br>1.2의 과정에서 ' --platform linux/amd64 ' 태그를 추가해 주고, 태그에 -linux를 붙였다.<br><img alt="Pasted image 20250221115030.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221115030.png" target="_self"><br><img alt="Pasted image 20250221115035.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221115035.png" target="_self"><br>잘 따라왔다면 EC2 환경에서 docker를 통해 받은 jar파일이 잘 실행되는 것을 볼 수 있다.<br>내가 만든 포트는 8000번이며 IP주소는 AWS의 인스턴스에서 찾아볼 수있다.<br>퍼블릭 IP주소 를 통해 접속을 확인해보기 전에..<br><img alt="Pasted image 20250221115040.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221115040.png" target="_self"><br>해당 인스턴스의 보안그룹을 확인하고, 내가 설정한 포트(:8000)에 대한 접근을 허가해주어야한다.<br>
보안그룹 확인 후,<br><img alt="Pasted image 20250221115046.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221115046.png" target="_self"><br>네트워크 및 보안 -&gt; 해당 보안그룹 -&gt;&nbsp; 인바운드 규칙 편집 ( 인바운드란, 외부에서 해당 인스턴스로 접근하는 것)<br><img alt="Pasted image 20250221115052.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221115052.png" target="_self"><br>8000번 포트 추가<br><img alt="Pasted image 20250221115058.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221115058.png" target="_self"><br>이렇게 과정을 마치면...<br>http://[인스턴스의 퍼블릭 IP주소]:[포트번호]
<br> 로 접속이 가능하다!<br>
<img alt="Pasted image 20250221115102.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221115102.png" target="_self"><br>다음의 대략정인 과정을 통해 진행될 것이다.<br>1. Docker를 통해 Redis 다운받기<br>2. Redis config 파일 생성/수정 및 docker file 생성하기<br>3. 2에서 생성한 conf 파일과 dockerfile로 docker image 생성하기<br>4. 생성한 image 를 docker hub에 올리기<br>5. EC2에서 redis image와 spring(jar)image 내려받기<br>6. 내려받은 image를 container로 실행하고, EC2 포트 열기<br>EC2셋팅법과 docker 및 redis를 셋팅하는 방법은 이전 글에서 찾아볼 수 있다.<br>spring + docker 셋팅<br>로컬에 도커가 셋팅되어있다고 가정하고,&nbsp; redis를 최신으로 내려받는다.<br>docker pull redis
<br><img alt="Pasted image 20250221115117.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221115117.png" target="_self"><br>docker desktop을 통해 확인할 수 있고,&nbsp;<br>docker images
<br>명령어를 통해서 확인 할 수 있다.<br><img alt="Pasted image 20250221115122.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221115122.png" target="_self"><br>1.에서 redis를 내려받았다면 해당하는 디렉토리에 redis.conf 파일이 생성된다.<br>
생성되지 않았을경우 text파일 형식으로 생성해도 문제없다.<br>생성된 conf파일을 다음과 같이 수정하였다.<br># 연결 가능한 네트위크(0.0.0.0 = Anywhere)
bind 0.0.0.0 # 연결 포트
port 6379 # Master 노드의 기본 사용자 비밀번호
requirepass 사용할비밀번호입력 # 최대 사용 메모리 용량(지정하지 않으면 시스템 전체 용량)
maxmemory 2gb # 설정된 최대 사용 메모리 용량을 초과했을때 처리 방식
# - noeviction : 쓰기 동작에 대해 error 반환 (Default)
# - volatile-lru : expire 가 설정된 key 들중에서 LRU algorithm 에 의해서 선택된 key 제거
# - allkeys-lru : 모든 key 들 중 LRU algorithm에 의해서 선택된 key 제거
# - volatile-random : expire 가 설정된 key 들 중 임의의 key 제거
# - allkeys-random : 모든 key 들 중 임의의 key 제거
# - volatile-ttl : expire time(TTL)이 가장 적게 남은 key 제거 (minor TTL)
maxmemory-policy volatile-ttl # == RDB 관련 설정 ==
# 저장할 RDB 파일명
dbfilename backup.rdb
# 15분 안에 최소 1개 이상의 key가 변경 되었을 때
save 900 1
# 5분 안에 최소 10개 이상의 key가 변경 되었을 때
save 300 10
# 60초 안에 최소 10000개 이상의 key가 변경 되었을 때
save 60 10000
# RDB 저장 실패 시 write 명령 차단 여부
stop-writes-on-bgsave-error no # == AOF 관련 설정 ==
# AOF 사용 여부
appendonly yes
# 저장할 AOF 파일명
appendfilename appendonly.aof
# 디스크와 동기화 처리 방식
# - always : AOF 값을 추가할 때마다 fsync를 호출해서 디스크에 쓰기
# - everysec : 매초마다 fsync를 호출해서 디스크에 쓰기
# - no : OS가 실제 sync를 할 때까지 따로 설정하지 않음
appendfsync everysec # == Replication 관련 설정테스트 ==
# Slave Redis 설정
#임시주석slaveof 127.0.0.1 6380
<br>docker file도 생성하여 준다.<br>FROM redis:latest
COPY redis.conf /저장디렉토리/redis.conf
CMD [ "redis-server", "/저장디렉토리/redis.conf" ]
EXPOSE 6379
<br><img alt="Pasted image 20250221115129.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221115129.png" target="_self"><br>docker build --platform linux/amd64 -t 이미지이름:태그 디렉토리
----
docker build --platform linux/amd64 -t springredis:linux .
<br>dockerfile이 있는 디렉토리에서 해당 명령어를 실행한다.<br>* --platform linux/amd64 태그는 본인의 ec2환경이 리눅스64 환경이기 때문에 추가했다.<br><img alt="Pasted image 20250221115132.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221115132.png" target="_self"><br>docker push xotjd794613/springredis:linux
------
docker push 계정명/이미지이름:태그
<br><img alt="Pasted image 20250221115136.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221115136.png" target="_self"><br><img alt="Pasted image 20250221115140.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221115140.png" target="_self"><br>업로드까지 완료했다.<br>이전에 만들어두었던 Spring(jar)이미지&nbsp;와 방금 push한 redis이미지를 받는다<br>docker pull xotjd794613/funfun:0.0.1-linux
docker pull xotjd794613/springredis:linux
--
docker pull 계정명/이미지이름:태그
<br>docker images
<br>명령어로 확인 할 수 있다.<br><img alt="Pasted image 20250221115146.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221115146.png" target="_self"><br>이미지를 컨테이너로 실행하자.<br>Spring 이미지 실행<br>sudo docker run -d -p 8000:8080 xotjd794613/funfun:0.0.1-linux
------
sudo docker run -d -p 포트 계정명/이미지명:태그
<br>redis 이미지 실행<br>docker run --name springredis -p 6379:6379 -v /home/ec2-user/redis:/data -d xotjd794613/springredis:linux --appendonly yes ---------- docker run --name 컨테이너이름 -p 포트 -v 데이터저장할디렉토리:/data -d 계정명/이미지명:태그 --appendonly yes
<br>'docker ps -a' 명령어로 실행중인 모든 컨테이너를 확인 할 수 있다.<br><img alt="Pasted image 20250221115151.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221115151.png" target="_self"><br>http://ec2주소:포트번호로 접속시 정상적으로 spring기반 페이지와 redis가 연결된 것을 확인할 수 있다.<br><img alt="Pasted image 20250221115157.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221115157.png" target="_self"><br>오류
만약,&nbsp;해당주소로 접속시 접속이 안되거나, redis가 정상적으로 실행되지 않는경우
<br>
<br><img alt="Pasted image 20250221115201.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221115201.png" target="_self">
<br><img alt="Pasted image 20250221115214.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221115214.png" target="_self"><br>2.1 ec2 redis 컨테이너 포트 확인<br>docker ps -a
<br>로 redis 컨테이너 ID 확인<br><img alt="Pasted image 20250221115220.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221115220.png" target="_self"><br>docker inspect 컨테이너ID
<br>명령어로 IP 확인<br><img alt="Pasted image 20250221115224.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221115224.png" target="_self"><br><img alt="Pasted image 20250221115228.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221115228.png" target="_self"><br>spring 프로젝트에 ip 정보 추가<br>
<img alt="Pasted image 20250221115232.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221115232.png" target="_self"><br>]]></description><link>http://lts.kr/tools/aws/🌥-aws(ec2)셋팅부터-배포까지.html</link><guid isPermaLink="false">Tools/aws/🌥 aws(EC2)셋팅부터 배포까지.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Mon, 24 Feb 2025 01:37:57 GMT</pubDate><enclosure url="http://lts.kr/사진-및-문서/pasted-image-20250221112429.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="http://lts.kr/사진-및-문서/pasted-image-20250221112429.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🍊 aws EC2란]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:Tools" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Tools</a> <a class="tag" href="http://lts.kr/?query=tag:AWS" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#AWS</a> <a class="tag" href="http://lts.kr/?query=tag:Amazon" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Amazon</a> <a class="tag" href="http://lts.kr/?query=tag:Cloud" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Cloud</a> <a class="tag" href="http://lts.kr/?query=tag:EC2" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#EC2</a> <br> <a href="http://lts.kr?query=tag:Tools" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Tools">#Tools</a> <a href="http://lts.kr?query=tag:AWS" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#AWS">#AWS</a> <a href="http://lts.kr?query=tag:Amazon" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Amazon">#Amazon</a> <a href="http://lts.kr?query=tag:Cloud" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Cloud">#Cloud</a> <a href="http://lts.kr?query=tag:EC2" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#EC2">#EC2</a><br><img alt="Pasted image 20250221114152.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114152.png" target="_self"><br>
AWS의 EC2는 무엇이며, 왜 사용하는가? 에 대해 알아보겠다.<br>
<br>
Amazon Elastic Compute Cloud으로써 AWS에서 제공하는 클라우드 컴퓨팅 서비스이다.<br>
즉, 독립괸 컴퓨터를 임대해주는 aws의 대표적인 서비스상품 이다. <br>
클라우드 컴퓨팅 서비스로 컴퓨팅 요구사항의 변화에 따라 컴퓨팅 파워를 조정할 수 있다. <br>
실제로 사용한 용량 만큼만 지불하여, 서비스 요금을 미리 선입금 할 필요가 없다. <br>
Linux / Window 중 OS선택이 자유롭다. <br>
머신러닝, 웹서버, 게임서버 등 다양한 용도에 최적화된 서버를 쉽게 구성 가능하다. <br>
여러 aws서비스와 유기적인 연동이 가능하다. <br>
<br>
인스턴스란 aws클라우드에서 사용하는&nbsp;가상컴퓨터&nbsp;이다. <br>
cpu, 메모리, 그래픽카드 등 연산을 위한 하드웨어 부분을 담당한다. <br>
aws는 각 사용 사례에 맞게 최적화된 다양한 인스턴스 유형을 제공한다. <br>-&nbsp;한정된 요금으로&nbsp;유형(사용목적)을 정하고,&nbsp;사이즈를 골라, 각 인스턴스별 사용 목적에 따라 최적화 시킨다.<br>
<img alt="Pasted image 20250221114208.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114208.png" target="_self"><br>
<br>
인스턴스가 연산(cpu, 메모리 등) 처리를 담당한다면, EBS는&nbsp;데이터를 저장하는&nbsp;역할을 한다. <br>
즉, 클라우드에서 사용하는 가상 HDD이다. <br>
손쉽게 사용량을 많게, 혹은 적게 확장할 수 있으며, 빌린 부분에 대한 부분만 저렴하게 비용을 지불 할 수 있다. <br>
총 5가지 타입을 제공하는데, 다음과 같다.<br>
<img alt="Pasted image 20250221114220.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114220.png" target="_self"> <br>
<br>
AMI는 인스턴스를 실행하기 위한 정보를 모은 단위이다. <br>
EC2를 실행하기 위해서, cpu프로세서 타입, 저장공간 용량, 32/64비트, OS정보, 설치된 소프트웨어 정보 등 <br>세팅정보(템플릿)을 저장한 단위 이다.<br>
즉, 서버에 필요한 운영체제와 다양한 소프트웨어로 구성된 탬플릿 <br>
AMI를 사용하여&nbsp;현재 상태의 EC2셋팅(템플릿)을 복제하여 다른 계정이나, 다른 리전에 전달이 가능하다. <br>
<br>위의 이유들로 생각할 수 있는&nbsp;장점들!
<br>. 클라우드에서 확장 가능한 컴퓨팅 용량을 제공하기 때문에, 하드웨어에 대한 투자를 앞당길 필요가 없기 때문에,<br>신속하게 개발하고 배포 할 수 있다!<br>. 컴퓨팅 요구가 변화했을 때,&nbsp;용량을 빠르게 확장/축소&nbsp;할 수 있다. 즉, 비용을 아낄 수 있다.<br>. 일반적인 실패 시나리오를 방지하고, 장애 복구 능력이 뛰어난 도구를 제공한다.<br>. 이렇게 유연한 구조/사이즈 변경이 가능한 호스팅 서비스와 더불어, 안정적인 환경을 제공하며,<br>본안성이 매우 높은 네트워킹 기능을 제공한다.<br>]]></description><link>http://lts.kr/tools/aws/🍊-aws-ec2란.html</link><guid isPermaLink="false">Tools/aws/🍊 aws EC2란.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Mon, 24 Feb 2025 01:37:49 GMT</pubDate><enclosure url="http://lts.kr/사진-및-문서/pasted-image-20250221114152.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="http://lts.kr/사진-및-문서/pasted-image-20250221114152.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🥗 Spring Security_토큰-세션-쿠키-JWT 에 대하여]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="http://lts.kr/?query=tag:Java" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Java</a> <a class="tag" href="http://lts.kr/?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <a class="tag" href="http://lts.kr/?query=tag:Security" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Security</a> <a class="tag" href="http://lts.kr/?query=tag:Tokken" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Tokken</a> <a class="tag" href="http://lts.kr/?query=tag:Session" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Session</a> <a class="tag" href="http://lts.kr/?query=tag:Cookie" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Cookie</a> <br> <a href="http://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="http://lts.kr?query=tag:Java" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Java">#Java</a> <a href="http://lts.kr?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a> <a href="http://lts.kr?query=tag:Security" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Security">#Security</a> <a href="http://lts.kr?query=tag:Tokken" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Tokken">#Tokken</a> <a href="http://lts.kr?query=tag:Session" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Session">#Session</a> <a href="http://lts.kr?query=tag:Cookie" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Cookie">#Cookie</a><br>
<br>Spring Security는 Spring 기반 애플리케이션에서 인증(Authentication)과 권한 부여(Authorization)를 제공하는 강력한 보안 프레임워크입니다.
<br>다양한 보안 요구사항(예: HTTP 인증, OAuth2, JWT 등)을 처리할 수 있도록 확장 가능합니다.
<br>
<br>
인증(Authentication): <br>사용자가 애플리케이션에 접근하기 전에 신원을 확인.
<br>일반적으로 사용자 이름과 비밀번호를 기반으로 인증. <br>
권한 부여(Authorization): <br>인증된 사용자가 애플리케이션의 특정 리소스나 작업에 접근할 수 있는지 확인. <br>
보안 필터: <br>요청과 응답을 처리하기 위한 필터 체인을 제공.
<br>요청이 필터 체인을 통과하면 보안 정책이 적용됨. <br>
확장성: <br>OAuth2, JWT, LDAP 등 다양한 인증 방식과 통합 가능. <br>
<br>토큰(Token)은 인증 정보를 포함하는 문자열로, 클라이언트와 서버 간 인증 및 권한 부여를 간편화합니다.
<br>사용자가 인증을 완료하면 서버가 토큰을 발급하고, 클라이언트는 이후 요청에 토큰을 포함하여 인증을 유지합니다.
<br>
<br>
무상태성: <br>토큰은 상태 정보를 포함하므로 서버가 세션을 유지할 필요 없음.
<br>클라이언트가 모든 요청에 토큰을 포함하여 서버로 전송. <br>
토큰 종류: <br>Bearer Token: 요청 헤더에 포함되어 인증.
<br>Refresh Token: Access Token이 만료되었을 때 재발급에 사용. <br>
<br>세션(Session)은 사용자가 서버에 접속한 동안 유지되는 상태 정보입니다.
<br>서버는 클라이언트의 각 요청을 식별하기 위해 세션 ID를 생성하고, 이를 클라이언트에 제공.
<br>
<br>사용자가 로그인하면 서버가 고유한 세션 ID를 생성.
<br>세션 ID는 클라이언트의 쿠키에 저장.
<br>이후 요청에서 클라이언트는 세션 ID를 포함하여 서버로 전송.
<br>서버는 세션 저장소(Session Store)에 저장된 정보를 기반으로 클라이언트를 식별.
<br>
<br>상태 유지: <br>서버는 클라이언트별로 상태 정보를 유지. <br>확장성 문제: <br>서버가 클라이언트별로 상태를 저장하므로 대규모 확장성이 떨어질 수 있음. <br>
<br>쿠키(Cookie)는 클라이언트 브라우저에 저장되는 데이터 조각으로, 서버와 클라이언트 간 정보를 유지하기 위해 사용.
<br>
<br>서버가 응답에 쿠키를 설정하면 클라이언트는 쿠키를 저장.
<br>클라이언트는 이후 요청에 저장된 쿠키를 자동으로 서버에 포함.
<br>서버는 쿠키를 기반으로 요청을 처리.
<br>
<br>키-값 쌍: <br>쿠키는 key=value 형태로 저장. <br>보안 옵션: <br>HttpOnly: 자바스크립트를 통해 접근 불가.
<br>Secure: HTTPS 요청에서만 전송. <br>유효 기간: <br>쿠키는 만료 시간이 지나면 자동 삭제. <br>
<br>JWT는 JSON 형식으로 인코딩된 토큰으로, 클라이언트와 서버 간 인증 정보를 안전하게 전달하기 위해 사용.
<br>무상태 인증 방식에서 많이 사용됨.
<br>JWT는 세 부분으로 구성:<br>Header: <br>토큰 타입(JWT)과 알고리즘(HMAC, RSA 등) 정보를 포함.
<br>예: {"alg": "HS256", "typ": "JWT"} <br>Payload: <br>토큰에 포함된 클레임(Claim) 정보를 포함.
<br>예: {"sub": "user123", "role": "admin"} <br>Signature: <br>Header와 Payload를 비밀키로 서명하여 생성.
<br>예: HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret) <br>
<br>사용자가 로그인하면 서버가 JWT를 생성하여 클라이언트에 전달.
<br>클라이언트는 이후 요청에서 JWT를 Authorization 헤더에 포함.
<br>서버는 JWT를 검증하여 사용자를 인증.
<br>
<br>자체 포함(Self-contained): <br>JWT는 인증 정보와 사용자 정보를 모두 포함. <br>무상태성: <br>서버는 JWT를 저장하지 않으므로 확장성이 뛰어남. <br>보안: <br>서명(Signature)을 통해 변조를 방지.
<br>그러나 암호화되지 않은 Payload는 누구나 읽을 수 있음. <br>
<br>상태 정보 저장 없음: <br>서버는 클라이언트의 상태 정보를 유지하지 않습니다.
<br>즉, 서버는 이전 요청에 대한 정보를 기억하지 않고, 요청마다 필요한 인증 정보를 다시 받아야 합니다. <br>클라이언트 책임: <br>인증 정보(예: JWT 토큰)는 클라이언트가 관리합니다.
<br>클라이언트는 매 요청마다 서버에 인증 정보를 제공해야 합니다. <br>확장성: <br>서버 간 상태 동기화가 필요 없으므로 수평 확장이 용이합니다.
<br>로드 밸런싱을 사용하는 다중 서버 환경에서 적합. <br>
<br>
Spring Security: <br>인증과 권한 부여를 처리하는 보안 프레임워크.
<br>세션, 쿠키, 토큰(JWT 포함)과 통합 가능. <br>
Token: <br>인증 정보를 포함한 문자열.
<br>서버-클라이언트 간 무상태 인증을 위해 사용. <br>
Session: <br>서버가 클라이언트별 상태 정보를 유지.
<br>확장성이 낮지만 단순한 구조. <br>
Cookie: <br>클라이언트에 저장되는 작은 데이터 조각.
<br>세션 ID 또는 JWT 저장에 사용. <br>
JWT: <br>JSON 형식의 자체 포함 토큰.
<br>무상태 인증 및 높은 확장성을 제공.]]></description><link>http://lts.kr/study/dev-seminar/🥗-spring-security_토큰-세션-쿠키-jwt-에-대하여.html</link><guid isPermaLink="false">study/Dev Seminar/🥗 Spring Security_토큰-세션-쿠키-JWT 에 대하여.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Fri, 21 Feb 2025 08:51:48 GMT</pubDate></item><item><title><![CDATA[📘 SpringBoot &amp; Docker + Reids 연동]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:Tools" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Tools</a> <a class="tag" href="http://lts.kr/?query=tag:도커" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#도커</a> <a class="tag" href="http://lts.kr/?query=tag:Docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Docker</a> <a class="tag" href="http://lts.kr/?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <a class="tag" href="http://lts.kr/?query=tag:Boot" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Boot</a> <a class="tag" href="http://lts.kr/?query=tag:Redis" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Redis</a> <br> <a href="http://lts.kr?query=tag:Tools" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Tools">#Tools</a> <a href="http://lts.kr?query=tag:도커" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#도커">#도커</a> <a href="http://lts.kr?query=tag:Docker" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Docker">#Docker</a> <a href="http://lts.kr?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a> <a href="http://lts.kr?query=tag:Boot" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Boot">#Boot</a> <a href="http://lts.kr?query=tag:Redis" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Redis">#Redis</a> <br><img alt="Pasted image 20250221114306.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114306.png" target="_self"><br>먼저 도커에 대한 간단한 이전 글!<br>aws의 설명에 의하면 Docker란 <br>애플리케이션을 신속하게 구축, 테스트 및 배포할 수 있는 소프트웨어 플랫폼이다. <br>소프트웨어를 컨테이너 라는 표준화된 유닛으로 패키징하여 관리한다. <br><a data-tooltip-position="top" aria-label="https://docs.docker.com/desktop/install/mac-install/" rel="noopener nofollow" class="external-link is-unresolved" href="https://docs.docker.com/desktop/install/mac-install/" target="_self">도커 다운로드 링크</a><br>각 기기에 맞는 docker 버전을 다운로드 받는다.<br>
<img alt="Pasted image 20250221114324.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114324.png" target="_self"><br>다운로드 받은 후 명령어를 입력하여 docker의 현재 버전을 볼 수 있다.<br>※ 터미널에 'docker' 를 입력하게 되면 다양한 명령어들을 확인할 수 있다.<br>
<img alt="Pasted image 20250221114327.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114327.png" target="_self"><br>제대로 다운로드 받았다면 docker에 기본적으로 만들어져있는 이미지들을 확인 할수 있다. 밑에 사진은 도커 데스트톱 이라는 앱이다.<br><img alt="Pasted image 20250221114334.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114334.png" target="_self"><br>터미널에서도 확인할 수 있다.<br><img alt="Pasted image 20250221114339.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114339.png" target="_self"><br>이제&nbsp;도커 파일&nbsp;을 이용하여&nbsp;도커 이미지를 생성한 후, 이미지를 빌드하여&nbsp;컨테이너를 생성해 줄것이다.<br>여기서 여러 용어들이 나오는데...<br>용어들에 대한 설명이다<br><img alt="Pasted image 20250221114345.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114345.png" target="_self"><br><img alt="Pasted image 20250221114353.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114353.png" target="_self"><br>Dockerfile을 생성하기에 앞서, .jar 파일을 생성해야한다.<br>gradle 이나 maven 을 사용하여 프로젝트를 빌드 할것이다.<br>여기서는 Maven 을 사용한다.<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://maven.apache.org/download.cgi" target="_self">https://maven.apache.org/download.cgi</a><br>홈페이지에서 직접 다운받아도 되고, brew를 사용해 각자 다운받으면 된다.<br>이후에, 프로젝트의 루트 디렉토리에서 'mvn install' 명령어를 사용하여 프로젝트를 빌드 할 수 있다.<br><img alt="Pasted image 20250221114400.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114400.png" target="_self"><br>빌드를 마치면, 프로젝트 내에&nbsp;target이 생성 됨을 볼 수 있다.<br><img alt="Pasted image 20250221114406.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114406.png" target="_self"><br>그 후, 루트 디렉토리에 'Dockerfile' 을 생성하여 준다.<br><img alt="Pasted image 20250221114411.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114411.png" target="_self"><br><img alt="Pasted image 20250221114423.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114423.png" target="_self"><br>Dockerfile 생성시 사용되는 명령어들은 다음과 같다.<br><img alt="Pasted image 20250221114428.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114428.png" target="_self"><br>나는 기본적인 옵션만 넣어서 test 하였다.<br>FROM 태그에 나의 java(jdk)버전을 확인하여 baseimage를 지정하고<br>
( dockerRpository에서 다양한 이미지를 가져다 사용할 수 있으므로 찾아보세요)<br>ADD 태그에 maven을 통해 생성된 .jar파일과 경로를 입력한다<br>이외에 태그는 자유롭게 작성해 줄 수 있다.<br>프롬프트에 <br>docker build -t ${"도커파일 명"} ${"디렉토리"} <br>형식으로 사용할 수 있다.<br><img alt="Pasted image 20250221114434.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114434.png" target="_self"><br><img alt="Pasted image 20250221114439.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114439.png" target="_self"><br>해당 단계를 마치면 이미지가 생성된 것을 확인할 수 있다.<br>프롬프트에 <br>docker run -p ${사용할 포트번호} ${이미지 명}
<br>을 사용한다.<br>본인은 8000번 포트를 직접 사용하여 8080포트인 도커 컨테이너에 접근할 것이다.<br><img alt="Pasted image 20250221114443.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114443.png" target="_self"><br>짜잔!&nbsp; &nbsp;정상적으로 동작한다.<br>
<img alt="Pasted image 20250221114501.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114501.png" target="_self"><br>
<img alt="Pasted image 20250221114448.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114448.png" target="_self"><br>docker는 다운받아져 있는걸로 알고..&nbsp;<br>'docker pull redis:latest' 명령어를 사용하여 최신버전의 redis를 받아온다.<br><img alt="Pasted image 20250221114522.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114522.png" target="_self"><br>그 다음, <br>docker network create redis-network --driver bridge
<br>명령어를 사용하여 네트워크를 생성해 준다.<br>※ docker network : 컨테이너간의 통신 및 데이터 공유를 위한 가상 네트워크<br><img alt="Pasted image 20250221114527.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114527.png" target="_self"><br>이제, 'sudo vim redis.conf' 명령어를 사용하여 redis.conf 파일을 수정하여 설정을 잡아준다.<br><img alt="Pasted image 20250221114531.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114531.png" target="_self"><br>docker run \ -d \ --name redis \ -p 6379:6379 \ --network redis-network \ -v ~/${데이터를 저장할 파일 경로} /redis.conf:/etc/redis/redis.conf \ -v redis_data:/data \
redis:latest redis-server /etc/redis/redis.conf
<br><img alt="Pasted image 20250221114535.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114535.png" target="_self"><br>포트번호와, 방금 설정한 네트워크, 데이터 저장 경로를 잡아준다.<br>이렇게 설정을 마쳤으면 redis 이미지가 생성되었음을 확인할 수 있다.<br><img alt="Pasted image 20250221114539.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114539.png" target="_self"><br>최종적으로 생성된 이미지로 컨테이너를 만들어 준다.<br><img alt="Pasted image 20250221114543.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114543.png" target="_self"><br>docker run --name myredis \ -p 6379:6379 \ --network redis-network \ -v /Users/lts/Desktop/docker/redis:/data \ -d redis:latest redis-server \ --appendonly yes
<br><img alt="Pasted image 20250221114600.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114600.png" target="_self"><br>컨테이너까지 생성완료!<br>docker exec -it myredis redis-cli --raw
<br>명령어를 사용하여 컨테이너 실행<br><img alt="Pasted image 20250221114605.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114605.png" target="_self"><br>프롬프트를 보면 정상적으로 접속됨을 확인할 수 있다.<br>※ 해당 프로젝트는 Maven 을 사용한 프로젝트이다.<br>spring.cache.type=redis
spring.redis.host=localhost
spring.redis.port=6379
<br><img alt="Pasted image 20250221114610.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114610.png" target="_self"><br><img alt="Pasted image 20250221114616.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114616.png" target="_self"><br>import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.serializer.StringRedisSerializer; @Configuration
public class RedisConfig { @Value("${spring.redis.host}") private String host; @Value("${spring.redis.port}") private int port; @Bean public LettuceConnectionFactory redisConnectionFactory() { return new LettuceConnectionFactory(host, port); } @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate() { RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.setValueSerializer(new StringRedisSerializer()); redisTemplate.setConnectionFactory(redisConnectionFactory()); return redisTemplate; } @Bean public StringRedisTemplate stringRedisTemplate() { final StringRedisTemplate stringRedisTemplate = new StringRedisTemplate(); stringRedisTemplate.setKeySerializer(new StringRedisSerializer()); stringRedisTemplate.setValueSerializer(new StringRedisSerializer()); stringRedisTemplate.setConnectionFactory(redisConnectionFactory()); return stringRedisTemplate; }
}
<br><img alt="Pasted image 20250221114621.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114621.png" target="_self"><br>import lombok.AllArgsConstructor; import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.Id;
import org.springframework.data.redis.core.RedisHash;
import org.springframework.data.redis.core.index.Indexed; import java.time.LocalDateTime; @Getter
@RedisHash(value = "resultHistory", timeToLive = 3600) // Redis Repository 사용을 위한
@AllArgsConstructor
@NoArgsConstructor
public class ResultHistory { @Id private String id; @Indexed // 필드 값으로 데이터를 찾을 수 있도록 설정 (findByAccessToken) private String ip; private String originalText; private String translatedText; @Indexed private LocalDateTime createDateTime; @Builder public ResultHistory(String ip, String originalText, String translatedText, LocalDateTime createDateTime) { this.ip = ip; this.originalText = originalText; this.translatedText = translatedText; this.createDateTime = createDateTime; }
}
<br><img alt="Pasted image 20250221114628.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114628.png" target="_self"><br>import com.teamTS.funfun.model.ResultHistory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository; import java.util.List;
import java.util.Optional; @Repository
public interface ResultRedisRepository extends JpaRepository&lt;ResultHistory, String&gt; { Optional&lt;List&lt;ResultHistory&gt;&gt; findByIpOrderByCreateDateTimeAsc(String ip);
}
<br><img alt="Pasted image 20250221114633.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114633.png" target="_self"><br> @GetMapping("/hello") public String HelloWorld(Model model) { redisConnectionTest(); List&lt;TestModel&gt; tm = testRepository.getTestData(); model.addAttribute("data", tm.get(0).getTitle()); return "home/homeView"; } void redisConnectionTest() { final String key = "a"; final String data = "1"; final ValueOperations&lt;String, String&gt; valueOperations = redisTemplate.opsForValue(); valueOperations.set(key, data); final String s = valueOperations.get(key); } }
<br><img alt="Pasted image 20250221114638.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114638.png" target="_self"><br>Error starting ApplicationContext. To display the condition evaluation report re-run your application with 'debug' enabled.
<br>원인은 기존 MapperRepository와 Redis용 JpaRepository에서<br>@Repository
<br>해당 어노테이션을 사용하여 충돌한듯 하다.<br>
이럴때는<br>spring.main.allow-bean-definition-overriding=true
<br>한 줄을 추가하여 준다.<br><img alt="Pasted image 20250221114644.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114644.png" target="_self"><br>성공적인 실행.<br><img alt="Pasted image 20250221114648.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114648.png" target="_self"><br>&nbsp;이후 ' keys * ' 명령어를 사용하여 데이터가 정상적으로 추가된 것을 확인할 수 있다.<br>]]></description><link>http://lts.kr/tools/docker/📘-springboot-&amp;-docker-+-reids-연동.html</link><guid isPermaLink="false">Tools/docker/📘 SpringBoot &amp; Docker + Reids 연동.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Fri, 21 Feb 2025 04:50:17 GMT</pubDate><enclosure url="http://lts.kr/사진-및-문서/pasted-image-20250221114306.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="http://lts.kr/사진-및-문서/pasted-image-20250221114306.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🐋 docker]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:Tools" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Tools</a> <a class="tag" href="http://lts.kr/?query=tag:도커" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#도커</a> <a class="tag" href="http://lts.kr/?query=tag:Docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Docker</a> <br> <a href="http://lts.kr?query=tag:Tools" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Tools">#Tools</a> <a href="http://lts.kr?query=tag:도커" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#도커">#도커</a> <a href="http://lts.kr?query=tag:Docker" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Docker">#Docker</a><br><img alt="Pasted image 20250221114743.png" src="http://lts.kr/사진-및-문서/pasted-image-20250221114743.png" target="_self"><br>...aws의 설명에 의하면<br>
<br>애플리케이션을 신속하게 구축, 테스트 및 배포할 수 있는 소프트웨어 플랫폼이다.
<br>소프트웨어를&nbsp;컨테이너&nbsp;라는 표준화된 유닛으로 패키징하여 관리한다.<br>
2-1. 컨테이너에는 라이브러리, 시스템 도구, 코드, 런타임 등 소프트웨어를 실행하는 데 필요한 모든것이 포함되어 있다.
<br>Docker는 AWS와 협업하여 다양한 규모에서 안정적이고 저렴하게 애플리케이션을 구축, 제공할 수 있게 한다.
<br>
<br>코드, 런타임, 시스템도구 등등등 소프트웨어를 실행하는 데 필요한 모든 것을 포함하는 독립 실행형 실행 가능 패키지 이다.
<br>다른컨테이너나 호스트 시스템을 방해하지 않고, Docker runtime을 사용하여 모든 호스트에서 실행할 수 있는 소프트웨어의 격리된 단위로 설계되어있다.
<br>
<br>별도의 하드웨어 에뮬레이션 없이 리눅스 커널을 공유해 컨테이너를 실행한다.
<br>
<br>하드웨어 에뮬레이션이 없어서 매우 빠르다. 또한 하나의 머신에서 프로세스만큼 많이 실행하는 것이 가능하다.
<br>
<br>컨테이너는 호스트의 환경이 아닌 독자적인 실행환경을 갖고 있다.
<br>이 환경은 파일(Dockerfile)들로 구성되며, 공유될 수 있다.
<br>
<br>모든 이미지에는 계층이 있으며, 현재의 이미지가 적절하지 않은 경우 이전 버전으로 롤백이 가능하다.
<br>CI/CD를 수행하는 데 도움을 준다.
<br>
<br>
서버를 처음 설정할때, OS, 라이브러리, 컴파일러 등 많은 설정이 필요하고, 버전으 변경되고 업데이트 될 때 마다 다시 재설정이 필요하다. <br>
하지만, 이러한 설정 등을 도커 컨테이너 위에서 진행한다면, 호스트 OS에 아무런 영향을 주지 않는다.<br>
즉, 로컬 환경의 간섭 없이 독립적으로 구동된다! <br>
또한 다른 서버로 이사를 가는 상황에서 이미지만을 가져와 새로운 서버에 컨테이너를 만들어 쉽게 동일한 환경을 구성할 수 있다. <br>
<br>마이크로 서비스 구조로, 애플리케이션이 독립적인 구성 요소로 구축되어 각 애플리케이션 프로세스가 서비스로 실행된다.
<br>
<br>도커는 각 환경마다 쓸 수 있는 자원이 고정적으로 정해져 있지 않기 때문에, 유동적으로 자원을 할당하여 기존의 가상화 방식보다 훨씬 자원적, 성능적으로 뛰어나다
<br>]]></description><link>http://lts.kr/tools/docker/🐋-docker.html</link><guid isPermaLink="false">Tools/docker/🐋 docker.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Fri, 21 Feb 2025 03:23:57 GMT</pubDate><enclosure url="http://lts.kr/사진-및-문서/pasted-image-20250221114743.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="http://lts.kr/사진-및-문서/pasted-image-20250221114743.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[👽 Algorithm]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="http://lts.kr/?query=tag:Coding" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Coding</a> <a class="tag" href="http://lts.kr/?query=tag:Test" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Test</a> <a class="tag" href="http://lts.kr/?query=tag:알고리즘" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#알고리즘</a> <br> <a href="http://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="http://lts.kr?query=tag:Coding" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Coding">#Coding</a> <a href="http://lts.kr?query=tag:Test" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Test">#Test</a> <a href="http://lts.kr?query=tag:알고리즘" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#알고리즘">#알고리즘</a><br>Algorithm
알고리즘 유형 별 풀이 입니다.
<br>]]></description><link>http://lts.kr/study/coding-test/👽-algorithm.html</link><guid isPermaLink="false">study/Coding Test/👽 Algorithm.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Fri, 21 Feb 2025 03:13:13 GMT</pubDate></item><item><title><![CDATA[🤠 Coding Test 풀이 모음]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="http://lts.kr/?query=tag:Coding" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Coding</a> <a class="tag" href="http://lts.kr/?query=tag:Test" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Test</a> <a class="tag" href="http://lts.kr/?query=tag:모음" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#모음</a> <br> <a href="http://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="http://lts.kr?query=tag:Coding" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Coding">#Coding</a> <a href="http://lts.kr?query=tag:Test" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Test">#Test</a> <a href="http://lts.kr?query=tag:모음" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#모음">#모음</a><br>Coding Test
코딩 테스트 문제 풀이 입니다.
<br>
<br> <br>
<br>]]></description><link>http://lts.kr/study/coding-test/🤠-coding-test-풀이-모음.html</link><guid isPermaLink="false">study/Coding Test/🤠 Coding Test 풀이 모음.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Thu, 20 Feb 2025 06:14:07 GMT</pubDate></item><item><title><![CDATA[🥇 정보처리 기사 실기 키워드]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:정보처리기사" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정보처리기사</a> <a class="tag" href="http://lts.kr/?query=tag:실기" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#실기</a> <a class="tag" href="http://lts.kr/?query=tag:키워드" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#키워드</a> <a class="tag" href="http://lts.kr/?query=tag:정리" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정리</a> <br> <a href="http://lts.kr?query=tag:정보처리기사" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정보처리기사">#정보처리기사</a> <a href="http://lts.kr?query=tag:실기" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#실기">#실기</a> <a href="http://lts.kr?query=tag:키워드" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#키워드">#키워드</a> <a href="http://lts.kr?query=tag:정리" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정리">#정리</a><br>
<br>시제품을 끊임없이 제작하며 사이클을 반복하는 개발 방법론
<br>워터폴과 대조적이며, 소프트웨어 개발을 넘어 기업 경영 전반에서 사용되고 있다.
<br>고객의 변화하는 요구사항과 환경 변화에 능동적인 소프트웨어 개발 방법론
<br>
<br>소프트웨어 공학에서 리펙토링(Refactoring)을 하는 목적에 대해 간략히 서술하시오.
<br>
리펙토링의 목적은 프로그램을 쉽게 이해하고 수정하여 빠르게 개발할 수 있도록 하기 위함이다.
<br>
<br>( 1 ) 요구사항은 시스템이 무엇을 하는지, 어떤 기능을 하는지 등 사용자가 시스템을 통해 제공받기를 원하는 기능이나 시스템이 반드시 수행해야하는 기능을 의미한다.
<br>( 2 ) 요구사항은 품질이나 제약사항과 관련된 요구사항으로, 시스템의 장비 구성, 성능, 인터페이스, 테스트, 보안 등의 요구사항을 말한다.
<br>
<br>UML에 관한 다음 괄호에 공통으로 들어갈 알맞은 용어는?
<br>( ) 다이어그램은 UML다이어그램중 객체(Object)들을 ( )로 추상화하여 표현하는 다이어그램으로, 대표적인 구조적 다이어그램이다.
<br>( )는 각각의 객체들이 갖는 속성과 메소드를 표현한 것으로 3개의 구획으로 나눠 이름, 속성, 메서드를 표기한다.
<br>
<br>UML은 시스템 분석, 설계, 구현 등 시스템 개발 과정에서 시스템 개발자와 고객 또는 개발자 상호 간의 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어로 사물, ( 1 ), 다이어그램 으로 이루어져있다.
<br>( 1 )는 사물과 사물사이의 연관성을 표현하는 것으로 연관, 집합, 포함, 일반화 등 다양한 형태의 ( 1 )가 존재한다.
<br>( 2 )는 UML에 표현되는 사물의 하나로, 객체가 갖는 속성과 동작을 표현한다. 일반적으로 직사각형으로 표현하며, 직사각형 안에 이름, 속성, 동작을 표기한다.
<br>( 3 )는 ( 2 )와 같은 UML에 표현되는 사물의 하나로, ( 2 )나 컴포넌트의 동작을 모아놓은 것이며, 외부적으로 가시화되는 행동을 표현한다. 단독으로 사용되는 경우는 없으며, ( 3 )구현을 위한 ( 2 )또는 컴포넌트와 함께 사용된다.
<br>
<br>관계(Relationship)는 사물과 사물 사이의 연관성을 표현하는 것이다.
<br>1 - 하나의 사물이 다른 사물에 포함되어 있는 관계로, 전체와 부분으로 구분되어지며, 서로 독립적이다.
<br>2 - 상위 모듈이 하위 모듈보다 더 일반적인 개념을 가지고 있으며, 하위 모듈이 상위 모듈보다 더 구체적인 개념을 가진다.
<br>
[보기]<br>
-Association(연관 관계) : 객체간의 기본적인 관계를 나타낸다.<br>
-Dependency(의존 관계) : 한 객체가 다른 객체에 의존하거나 영향을 받는다.<br>
-Aggregation(집합 관계) : 부분과 전체의 관계를 나타내며, 부분이 독립적으로 존재할 수 있는 경우를 말한다.<br>
-Realization(실체화 관계) : 인터페이스와 이를 구현하는 클래스 간의 관계<br>
-Composition(합성 관계) : 집합관계의 특수한 형태로, 부분이 전체와 생명 주기를 공유하며 독립적으로 존재할 수 없는 경우<br>
-Generalization(일반화 관계) : 상위 클래스와 하위 클래스 간의 관계로, 상속을 통해 일반적인 특성을 공유한다.
<br>
<br>UML을 이용한 다이어그램 중 다음 그림에 해당하는 다이어그램을 쓰시오.
<br>[ ] &lt;&lt;import&gt;&gt; [Security]
Order ----------------&gt; +(Credentials) / ( ) +(MDSCrupt)
<br>
<br>LOC기법에 의하여 예측된 총 라인 수가 30,000라인, 개발에 참여할 프로그래머가 5명, 프로그래머들의 평균 생산성이 월간 300라인일 때 개발에 소요되는 기간을 계산식과 함께 쓰시오.
<br>
<br>데이터베이스 스키마(Schema)에 대해 간략히 서술하시오.
<br>
스키마는 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 것이다.
<br>
<br>DB 설계에 대한 설명. 괄호를 채우시오
<br>( 1 ) : 논리적 구조로 표현된 데이터를 디스크 등의 저장장치에 저장할 수 있는 데이터로 변환하는 과정으로, 파일의 저장 구조 및 엑세스 경로를 결정하며, 테이블 정의서 및 명세서가 산출된다.
<br>( 2 ) : 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정으로, 개념 스키마 모델링과 트렌젝션 모델링을 수행하며, 요구 조건 명세를 E-R 다이어그램으로 작성한다.
<br>( 3 ) : 현실의 자료를 특정 DBMS가 지원하는 자료구조로 변환하는 과정으로, 트렌젝션의 인터페이스를 설계하고, 정규화를 통해 스키마를 평가 및 정제한다.
<br>
<br>다음은 데이터베이스 구축까지의 과정을 나열한 것이다. 순서대로 괄호를 채우시오. 요구분석 → ( ) → ( ) → ( ) → 구현 <br>
<br>데이터 모델이 구성 요소에 대한 다음 설명에서 괄호(1, 2)에 들어갈 용어를 쓰시오
<br>( 1 )은 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세서로서 데이터베이스를 조작하는 기본 도구에 해당된다.
<br>( 2 )는 논리적으로 표현된 객체 타입들 간의 관계로서 데이터의 구성 및 정적 성질을 표현한다.
<br>제약조건은 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건을 의미한다.
<br><img alt="do-messenger_screenshot_2025-02-10_15_04_45.png" src="http://lts.kr/사진-및-문서/do-messenger_screenshot_2025-02-10_15_04_45.png" target="_self"><br>
-다음 E-R다이어그램을 참고하여 괄호(1~5)의 설명에 적합한 요소를 찾아 기호로 표시<br>( 1 ) : 관계 집합을 의미한다.
<br>( 2 ) : 관계 집합과 속성을 연결한다.
<br>( 3 ) : 개체 집합을 의미하며, 키로 사용되는 항목에는 밑줄을 표시한다.
<br>( 4 ) : 관계 집합의 속성을 의미한다.
<br>( 5 ) : 개체 집합과 집합을 연결한다.
<br>
1 → ㄴ<br>
2 → ㄷ<br>
3 → ㄱ<br>
4 → ㄹ<br>
5 → ㅁ
<br>-키(Key)에 대한 다음 설명에서 괄호(1, 2)에 들어갈 용어를 쓰시오.<br>키는 데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 기준이 되는 속성을 말한다.
<br>슈퍼키는 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키로, 릴레이션을 구성하는 모든 튜플에 대해 ( 1 )을 만족한다.
<br>후보키(Candidate Key)는 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해 사용되는 속성들의 부분집합으로, ( 1 )과 ( 2 )을 만족하는 특징이 있다.
<br>
<br>
관계대수란 관계형 데이터베이스에서 원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절차적인 언어이다. 관계 대수에 사용되는 연산은 다음과 같다. <br>
합집합(UNION)은 두 릴레이션에 존재하는 튜플의 합집합을 구하되, 결과로 생성된 릴레이션에서 중복되는 튜플은 제되는 연산으로, 기호는 ( 1 )이다. <br>
차집합(DIFFERENCCE)은 두 릴레이션에 존재하는 튜플의 차집합을 구하는 연산으로, 사용하는 기호는 ( 2 )이다. <br>
교차곱(CARTESIAN PRODUCT)은 두 릴레이션에 있는 튜플들의 순서쌍을 구하는 연산으로, 사용하는 기호는 ( 3 )이다. <br>
프로젝트(PROJECT)는 주어진 릴레이션에서 송성 리스트(Attribute List)에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 연산으로, 사용하는 기호는 ( 4 )이다. <br>
조인(JOIN)은 공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산으로, 사용하는 기호는 ( 5 )이다. <br>
1 → U<br>
2 → ㅡ<br>
3 → x<br>
4 → ㅠ<br>
5 → |&gt;&lt;|
<br>
<br>릴레이션 A, B가 있을 때, 릴레이션 B의조건에 맞는 것들만 릴레이션 A에서 분리하여 프로젝션을 하는 연산은?
<br>
<br>( )은 관계 데이터의 연산을 표현하는 방법으로, 관계 데이터 모델의 제안자인 코드(E. F. Codd)가 수학의 술어 해석(Predicate Calculus)에 기반을 두고 관계 데이터베이스를 위해 제안했다.
<br>원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성을 지니며, 원하는 정보를 정의할 때 계산 수식을 사용한다.
<br>튜플 해석식을 사용하는 튜플 ( )과 도메인 해석식을 사용하는 도메인 ( )으로 구분된다.
<br>
<br>데이터의 중복으로 인해 테이블 조작 시 문제가 발생하는 현상을 이상(Anomaly)이라고 한다. 이상 중 삭제 이상(Deletion Anomaly)에 대해 간략히 서술하시오.
<br>
테이블에서 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는 현상.
<br>
<br>데이터베이스의 이상(Anomaly)의 종류 3가지를 쓰시오.
<br>
삽입 이상(Insertion Anomaly)<br>
삭제 이상(Deletion Anomaly)<br>
갱신 이상(Update Anomaly)
<br><img alt="do-messenger_screenshot_2025-02-10_17_10_58.png" src="http://lts.kr/사진-및-문서/do-messenger_screenshot_2025-02-10_17_10_58.png" target="_self"><br>테이블 &lt;R&gt;에서 성적은 기본키인 {학생, 학과}에 대해 ( 1 ) Functional Dependency이다.
<br>테이블 &lt;R&gt;에서 학년은 기본키인 {학생, 학과} 중 학생만으로 식별이 가능하므로 기본키에 대해 ( 2 ) Functional Dependency이다.
<br>임이의 테이블에 속성 A, B, C가 있을 떄, A → B이고 B → C일 때 A → C인 관계는 ( 3 )Functional Dependency이다.
<br> <br>Full
<br>Partial
<br>Transitive <br>
<br>데이터베이스에서 비(반)정규화(Denormalization)의 개념을 서술하시오.
<br>
비정규화는 정규화된 데이터 모델을 통합, 중복, 분리 하는 과정으로, 의도적으로 정규화 원칙을 위배하는 행위이다.
<br>
<br>데이터베이스의 상태 변화를 일으키는 트렌젝션(Transaction)의 특성
<br> <br>원자성 : <br>트렌젝션의 연산은 데이터베이스에 모두 반영되도록 완료(Commit)되든지 아니면 전혀 반영되지 않도록 복구(Rollback)되어야 한다. <br>일관성 : <br>트렌젝션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다. <br>독립성 : <br>둘 이상의 트렌젝션이 동시에 병행 실행되는 경우 어느 하나의 트렌젝션 실행중에 다른 트렌젝션의 연산이 끼어들 수 없다. <br>지속성 <br>성공적으로 완료된 트렌젝션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다. <br>
<br>파일의 구조는 파일을 구성하는 레코드들이 보조기억장치에 편성되는 방식을 의미하는 것으로, 크게 순차, ( ), 해싱으로 구분한다.
<br>( ) 파일 구조는 &lt;값, 주소&gt; 쌍으로 구성되는 데이터 구조를 활용하여 데이터에 접근하는 방식으로, 자기 디스크서 주로 활용된다.
<br>
<br>비상 상황이 발생한 경우 비상사태 또는 업무중단 시점부터 업무가 복구되어 다시 정상 가동 될 때까지의 시간을 의미한다.
<br>
<br>접근통제는 데이터가 저장된 객체와 이를 사용하려는 주체 사이의 정보 흐름을 제한하는 것이다. 이러한 접근통제에 관한 기술 중 ( )는 데이터에 접근하는 사용자의 신원에 따라 접근 권한을 부여하여 제어하는 방식으로, 데이터의 소유자가 접근통제 권한을 지정하고 제어한다.
<br>객체를 생성한 사용자가 생성된 객체에 대한 모든 권한을 부여받고, 부여된 권한을 다른 사용자에게 허가할 수도 있다.
<br>
<br>DBMS는 데이터베이스에 치명적인 손실이 발생했을 때 이를 복구하기 위해 데이터베이스의 처리내용이나 이용 상황 등 상태 변화를 시간의 흐름에 따라 기록한 로그를 생성한다.
<br>( 1 ) : 데이터베이스가 비정상적으로 종료되었을 때, 디스크에 저장된 로그를 분석하여 트렌젝션의 시작(start)과 완료(commit)에 대한 기록이 있는 트렌젝션들의 작업을 재작업 한다. 즉, 로그를 이용하여 해당 데이터 항목에 대해 이전 값을 이후값으로 변경하는 연산이다.
<br>( 2 ) : 데이터베이스가 비정상적으로 종료되었을 때, 디스크에 저장된 로그를 분석하여 트렌젝션의 시작을 나타는 'start'는 있지만 완료를 나타내는 'commit' 기록이 없는 트렌젝션들이 작업한 내용들을 모두 취소한다. 즉 로그를 이용하여 해당 데이터 항목에 대해 이후 값을 이전 값으로 변경한다.
<br>
<br>웹 페이지의 기본 형식인 HTML의 문법이 각 웹 브라우저에서 상호 호환적이지 못한다는 문제와 SGML의 복잡함을 해결하기 위하여 개발된 ( )은 다른 특수한 목적을 갖는 마크업 언어이다.
<br>원활한 데이터의 연계를 위해 송.수신 시스템 간에 전송되는 데이터가 동일한 구조로 구성될 수 있도록 형태를 정의는 역할을 수행하며, 다음과 같은 특징이 있다.
<br>
<br>텍스트 데이터 형식으로 유니코드를 사용하여 전 세계 언어를 지원한다.
<br>
<br>대다수의 웹 브라우저가 해석을 위한 번역기(Parser)를 내장하고 있다.
<br>
<br>XML문서의 문자들은 마크업과 내용으로 구분된다.
<br>일반적으로 마크업은 &lt;로 시작하여 &gt;로 끝나는 태그(Tag)를 의미하고, 그 외의 문자열은 내용에 해당한다.
<br>
<br>마크업과 내용으로 이루어지는 하나의 요소를 의미한다.
<br>
<br>통합 구현과 관련하여 다음 설명의 괄호에 공통으로 들어갈 알맞은 용어는?
<br>( )는 HTTP, HTTPS, SMTP 등을 사용하여 xml 기반의 메시지를 네트워크상에서 교환하는 프로토콜이다.
<br>( ) envelope, 헤더, 바디 등이 추가된 xml 문서이다.
<br>( )는 복잡하고 무거운 구조로 구성되어 있어, ( )보다는 RESTful 프로토콜을 이용하기도 한다.
<br>
<br>웹 서비스와 관련된 다음 설명에 해당되는 용어는?
<br>웹 서비스와 관련된 서식이나 프로토콜 등을 표준적인 방법으로 기술하고 게시하기 위한 언어.
<br>XML로 작성되며 UDDI의 기초가 된다. SOAP, XML 스키마와 결합하여 인터넷에서 웹 서비스를 제공하기 위해 사용되며, 클라이언트는 이것을 통해 서버에서 어떠한 조작이 가능한지를 파악할 수 있다.
<br>
<br>다음 럼바우 데이터 모델링에 대한 설명에서 각 지문(1~3)에 해당하는 모델링을 매칭시키기
<br>ㄱ. 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링<br>
ex) 자료흐름도(DFD)<br>ㄴ. 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링<br>
ex) 상태 변화도(STD), 사건 추적도<br>ㄷ. 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 표시하는 모델링<br>
ex) ER 다이어그램(ERD)<br>
1 → Function(기능)<br>
2 → Dynamic(동적)<br>
3 → Information(객체) <br>
<br>자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다는 객체지향 설계 원칙 중 하나다.
<br>예를 들어 프린터, 펙스, 복사 기능을 가진 복합기의 경우 3가지 기능을 모두 가지 범용 인터페이스보다는, 프린터 인터페이스, 팩스 인터페이스, 복사 인터페이스로 분리함으로써 하나의 기능 변경으로 인해 다른기능이 영향을 받지 않도록 해야한다.
<br>
<br>결합도(Coupling)의 종류 중 단순 처리 대상인 데이터만 전달되는 것이 아니라, 어떻게 처리해야 하는지를 결정하는 제어 요소가 전달되는 경우의 결합도를 영문으로 쓰면?
<br>
<br>( 1 )는 모듈간의 인터페이스로, 데이터,지역변수 등을 직접 참조하거나 수정할 때의 결합도다.
<br>( 2 )는 모듈간의 인터페이스로, 배열이나 레코드 등의 자료구조가 전달될 때의 결합도다.
<br>( 3 )는 모듈간의 인터페이스로, 파라미터가 아닌 모듈 밖에 선언된 전역 변수를 사용하여 전역 변수를 갱신하는 방식으로 상호작용하는 때의 결합도다.
<br>
1 → 내용 결합도<br>
2 → 스탬프 결합도<br>
3 → 공통 결합도
<br>
<br>내부의 요소들이 기능적으로 연관성은 없으나, 순차적으로 실행될 때의 응집도 <br>서로 다른 기능을 수행하지만 동일한 입력과 출력을 사용할 때의 응집도 <br>하나의 기능에 밀접하게 관련되어 있거나 연관되어 있을 때의 응집도 <br>
1 → 절차적 응집도<br>
2 → 교환적 응집도<br>
3 → 기능적 응집도
<br>
<br>모듈간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합이다.
<br>복수의 프로세스를 수행하며 이뤄지는 프로세스 간 통신까지 구현이 가능하다.
<br>대표적인 메소드에는 공뮤 메모리(Shared Memory), 소켓, 세마포어, 파이프와 네임드 파이프, 메세지 큐잉이 있다.
<br>
<br>( )패턴은 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴이다.
<br>상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당한다.
<br>다른 이름으로는 가상 생성자(Virtual Constructor) 패턴 이라고도 한다.
<br>
<br>( 1 )패턴은 구현부에서 추상층을 분리하여, 서로가 독립적으로 확장할 수 있도록 구성한 패턴으로, 기능과 구현을 두 개의 별도 클래스로 구현한다는 특징이 있다.
<br>( 2 )패턴은 한 객체의 상태가 변화하면 객체의 상속된 다른 객체들에게 변화된 상태를 전달하는 패턴으로, 일대다의 의존성을 정의한다. 주로 시스템 간에 이벤트를 생성.발행(Publish)하고, 이를 수신(Subscribe)해야할 떄 이용된다.
<br>
1 → Bridge 패턴<br>
2 → Observer 패턴
<br>
<br>디자인 패턴은 모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예젤를 의미한다. <br>그 중 ( )패턴은 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴으로, Interpreter, Observer, Command 등이 그 예에 해당한다.
<br>
<br>기업 내 각종 어플리케이션 및 플랫폼 간의 정보 전달, 연계, 통합 등 상호 연동이 가능하게 해주는 솔루션.
<br>Point-to-Point, Hub&amp;Spoke, Message Bus, Hybrid 등의 다양한 방식으로 구축이 가능한 모듈 연계 방법.
<br><img alt="do-messenger_screenshot_2025-02-11_13_47_16.png" src="http://lts.kr/사진-및-문서/do-messenger_screenshot_2025-02-11_13_47_16.png" style="width: 900px; max-width: 100%;" target="_self"><br>EAI(Enterprise Application Integration)는 기업 내 비즈니스 간 통합 및 연계성을 증대시켜 효율성 및 각 시스템 간의 확정성(Determinacy)을 높여 준다. EAI의 구축 유형은 위와 같다.
<br>
1 → Point-to-Point<br>
2 → Hub &amp; Spoke
<br>
<br>네트워크 트래픽에 대해 IP(Internet Protocol) 계층에서 IP패킷 단위의 데이터 변조 및 은닉 기능을 제공하는 네트워크 계층에서의 보안 통신 규약을 쓰시오.
<br>
<br>Kent Beck과 Erich Gamma 등이 개발한 자바 프로그래밍 언어용 유닛 테스트 프레임워크.
<br>xUnit계열의 한 종류이다. 같은 테스트 코드를 여러 번 작성하지 않게 도와주며, 테스트마다 예상 결과를 기억 할 필요가 없는 자동화된 해법을 제공한다.
<br>
<br>사용자 인터페이스 UI(User Interface)의 설계 원칙
<br>
직관성 : 누구나 쉽게 이해하고 사용할 수 있어야 한다<br>
유효성 : 사용자의 목적을 정확하고 완벽하게 달성해야 한다<br>
학습성 : 누구나 쉽게 배우고 익힐 수 있어야 한다<br>
유연성 : 사용자의 요구사항을 최대한 수용하고 실수를 최소화해야 한다
<br>
<br>애플리케이션 테스트에서 사용되는 살충제 패러독스(Pesticide Paradox)의 개념을 간략히 설명
<br> <br>살충제 패러독스는 동일한 테스트 케이스로 동일한 테스트를 반복하면 더 이상 결함이 발견되지 않는 현상을 의미한다. <br>
<br>테스트에 대한 다음 설명에서 각 (1~3)에 해당되는 커버리지(기준)을 찾으시오.
<br>최소 한번은 모든 문장이 수행되도록 구성하는 검증 기준
<br>조건식이 참 / 거짓일 때 수행되도록 구성하는 검증 기준
<br>2번과 달리 조건식에 상관없이 개별 조건이 참 / 거짓일 때 수행되도록 구성하는 검증기준
<br>
1 → 구문(문장) 커버리지<br>
2 → 결정(분기) 커버리지<br>
3 → 조건 커버리지
<br>
<br>소프트웨아가 수행할 특정 기능을 알기 위해서 각 기능이 완전히 작동되는 것을 입증하는 테스트.
<br>동치 클래스 분해 및 경계값 분석을 이용하는 테스트 기법이다.
<br><img alt="do-messenger_screenshot_2025-02-11_15_32_34.png" src="http://lts.kr/사진-및-문서/do-messenger_screenshot_2025-02-11_15_32_34.png" target="_self"><br>다음 중 블랙박스 테스트에 속하는 녀석들은?
<br>
경계값 분석(Boundary Value Analysis)<br>
입력값의 경계 부분(최소, 최대값 등)에서 오류가 발생할 가능성이 높다는 점을 이용하여 테스트하는 기법<br>
동등(동치) 분할(Equivalence Partitioning)<br>
입력값을 유사한 동작을 하는 그룹으로 나누고 각 그룹에서 대표값을 선택해 테스트하는 기법<br>
원인-결과 그래프(Cause-Effect Graph)<br>
그래프를 활용하여 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한 다음 효용성이 높은 테스트 케이스를 선정하여 검사하는 기법
<br>
<br>테스트 기법 중 다음과 같이 평가 점수표를 미리 정해 놓은 후 각 영역에 해당하는 입력 값을 넣고, 예상되는 출력값이 나오는지 실제 값과 비교하는 명세 기밥 테스트 기법을 쓰시오.
<br><img alt="do-messenger_screenshot_2025-02-11_16_31_10.png" src="http://lts.kr/사진-및-문서/do-messenger_screenshot_2025-02-11_16_31_10.png" style="width: 1025px; max-width: 100%;" target="_self"><br>개발 단계에 따른 애플리케이션 테스트에 대한 다음 V-모델에서 (1~4)에 들어갈 알맞은 테스트를 작성하시오.
<br>
1 → 단위 테스트(Unit Test)<br>
- 코딩 직후 소프트웨어 설계의 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 수행하는 테스트<br>
2 → 통합 테스트(Integration Test)<br>
- 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트<br>
3 → 시스템 테스트(System Test)<br>
4 → 인수 테스트(Acceptance Test)
<br>
<br>인수 테스트는 개발한 소프트웨어가 사용자의 요구사항을 충족하는지에 중점을 두고 테스트한다.
<br>( 1 ) : 선정된 최종 사용자가 여러 명의 사용자 앞에서 행하는 테스트 기법으로, 실제 업무를 가지고 사용자가 직접 테스트한다.
<br>( 2 ) : 개발자의 장소에서 사용자가 개발자 앞에서 행하는 테스트 기법으로, 테스트는 통제된 환경에서 행해지며, 오류와 사용상의 문제점을 사용자와 개발자가 함께 확인하면서 기록한다.
<br>
1 → 베타 테스트(Beta Test)<br>
2 → 알파 테스트(Alpha Test)
<br>
<br>통합 테스트 기법 중, 두 방법에 대한 설명이다.
<br>상향식 통합 테스트는 미완성이거나 문제가 있는 상위 모듈을 대체할 수 있는 테스트 드라이버가 있다.
<br>하향식 통합 테스트는 미완성이거나 문제가 있는 하위 모듈을 대체할 수 있는 테스트 ( )가 있어야 한다.
<br>
<br>통합 테스트로 인해 변경된 모듈이나 컴포넌트에 새로운 오류가 있는지 확인하는 테스트.
<br>이미 테스트된 프로그램의 테스팅을 반복하는 것이다.
<br>수정한 모듈이나 컴포넌트가 다른 부분에 영향을 미치는지, 오류가 생기지 않았는지 테스트하여 새로운 오류가 발생하지 않음을 보증하기 위해 반복 테스트한다.
<br>
<br>특정한 몇몇 테스트 케이스의 입력 값들에 대해서만 기대하는 결과를 제공하는 오라클로, 전수 테스트가 불가능한 경우 사용하고, 경계값 및 구간별 예상값 결과 작성시 사용하는 오라클은?
<br>
<br>애플리케이션 성능 측정의 지표에 대한 다음 설명을 채우십시오<br>
( 1 ) - 일정 시간 내에 애플리케이션이 처리하는 일의 양을 의미한다.<br>
( 2 ) - 애플리케이션에 요청을 던달한 시간부터 응답이 도착할 때까지 걸린 시간을 의미한다.<br>
( 3 ) - 애플리케이션에 작업을 의뢰한 시간부터 처리가 완료될 떄까지 걸린 시간을 의미한다.<br>
자원 활용률 - 애플리케이션이 의뢰한 작업을 처리하는 동안의 CPU, 메모리, 네트워크 등의 자원 사용률을 의미.
<br>
1 → 처리량(Throughput)<br>
2 → 응답 시간(Response Time)<br>
3 → 경과 시간(Turn Around Time)
<br>
<br>각각 소스코드 품질 분석에 대한 정의를 작성하세요.
<br>
<br>소스 코드의 코딩 스타일, 코드에 설정된 코딩 표준, 코드의 복잡도, 코드에 존재하는 메모리 누수 현상, 스레드 결함 등을 발견하기 위해 사용하는 분석 도구이다.
<br>
<br>작성한 소스 코드를 실행하지 않고, 코딩 표준이나 코딩 스타일, 결함 등을 확인하는 코드 분석 도구.
<br>
<br>소스 코드를 직접 실행하여 프로그램의 동작이나 반응을 추적하고 보고하는 분석 도구로, 프로그램 모니터링 기능이나 스냅샷 생성 기능을 포함하고 있다.
<br>
<br>데이터를 제어하는 DCL의 하나인 GRANT의 기능에 대해 간략히 서술하시오.
<br>
GRANT는 데이터베이스 관리자가 데이터베이스 사용자에게 권한을 부여하는 데 사용하는 명령어 이다.
<br>
<br>데이터를 제어하는 DCL의 하나인 ROLLBACK에 대해 간략히 서술하시오.
<br>
ROLLBACK은 트렌젝션이 실패한 경우 작업을 취소하고 이전 상태로 되돌리기 위한 명령어이다.
<br>
<br>데이터베이스 보안에서 가용성(Availability)에 대해 간략히 서술하시오.
<br>
가용성은 인가받은 사용자는 시스템
<br>
<br>보안 위협의 하나인 SQL Injection에 대해 간략히 서술하시오.
<br>
SQL Injection은 웹 응용 프로그램에 SQL 구문을 삽입하여 내부 DB서버의 데이터를 유출 및 변조하고 관리자 인증을 우회하는 공격 기법이다.
<br>
<br>
다음은 암호화 알고리즘에 대한 설명이다. 괄호를 채우시오. <br>
암호화 알고리즘은 패스워드, 주민번호, 은행계좌와 같은 중요 정보를 보호하기 위해 평문을 암호화된 문장으 만드는 절차 또는 방법을 말한다. <br>
스위스의 라이(Lai)와 메시(Messey)는 1990년 PES를 발표하고, 이후 이를 개선한 IPES를 발표하였다. IPES는 128비트의 Key를 사용하여 64비트 블록을 암호화하는 알고리즘이며 현재는 ( 1 )라고 불린다. <br>
( 2 )은 국가 안전 보장국(NSA)에서 개발한 암호화 알고리즘으로, 클리퍼 칩(Clipper Chip)이라는 IC 칩에 내장되어 있다. 80비트의 Key를 사용하여 64비트 블록을 암호화하며, 주로 전화기와 같은 음성 통신 장비에 삽입되어 음성 데이터르르 암호화 한다. <br>
1 → IDEA(Internetional Data Encryption Algorithm)<br>
2 → Skipjack
<br>
<br>무선랜 보안에 사용된 WEP 방식을 보완한 데이터 보안 프로토콜로, 임시 키 무결성 프로토콜이라도 한다.
<br>WEP의 취약성을 보완하기 위해 암호 알고리즘의 입력 키 길이를 128비트로 늘리고 패킷당 키할당, 키값 재설정 등 키 관리 방식을 개선하였다.
<br>
<br>1974년 IBM이 개발하고, 1975년 NBS에 의해 미국의 국가 표준으로 발표된 암호화 알고리즘
<br>블록 크기는 64비트, 키 길이는 56비트이며, 16회의 라운드를 수행한다.
<br>컴퓨터 기술이 발달함에 따라 해독이 쉬워지면서 미국의 국가 표준이 2001년 AES로 대체되었다.
<br>
<br>2001년 미국 표준 기술 연구소(NIST)에서 발표한 대칭키 암호화 알고리즘이다.
<br>DES의 한계를 느낀 NIST에서 공모한 후 발표하였다.
<br>블록 크기는 128비트이며, 키 길이에 따라 128, 192, 256으로 분류된다.
<br>
<br>1991년 R.ricest가 MD4를 개서한 암호화 알고리즘으로, 각각의 512비트짜리 입력 메세지 블록에 대해 차례동작한다.
<br>각 512비트 입력 메시지 블록을 처리하고 나면 128비트 스테이트(stat)의 값이 변하는 암호화 알고리즘이다.
<br>
<br>( ) 스푸핑은 로컬 네트워크(LAN)에서 사용하는 ( )프로토콜의 취약점을 이용한 공격 기법으로, 자신의 물리적 주소(MAC)를 변조하여 다른 PC에게 도달해야 하는 데이터 패킷을 가로채거나 방해한다.
<br>
<br>아래의 패킷 로그와 같이, 공격자가 패킷의 출발지 주소(Address) 또는 포트를 임의로 변경하여 송신측 IP주소 또는 포트를 동일하게 함으로써, 송신 IP주소가 자신이므로 자신에게 응답을 수행하게 된다.
<br>자신에 대해 무한히 응답하는 패킷을 계속 전송하여 컴퓨터의 실행 속도를 느리게 하거나 동작을 마비 시켜 서비스 거부 상태에 빠지도록 하는 네워크 공격 유형은?
<br>
<br>( 1 )은 컴퓨터 보안에 있어서, 인간 상호 작용의 깊은 신뢰를 바탕으로 사람들을 속여 정상 보안 절차를 깨트리기 위한 비기술적 시스템 침입 수단을 의미한다.
<br>( 2 )는 특정 목적을 가지고 데이터를 수집하였으나, 이후 활용되지 않고 저장만 되어있는 대량의 데이터를 의미한다. 미래에 사용될 가능성을 고려하여 저장 공간에서 삭제되지 않고 보관되어 있으나, 이는 저장 공간의 낭비뿐만 아니라 보안 위험을 초래할 수도 있다.
<br>
1 → 사회 공학(Social Engineering)<br>
2 → 다크 데이터(Dark Data)
<br>
<br>( )은 ‘세션을 가로채다’라는 의미로, 정상적인 연결을 RST패킷을 통해 종료시킨 후 재연결 시 희생자가 아닌 공격자에게 연결하는 공격 기법이다.
<br>TCP ( )은 공격자가 TCP 3-Way-Handshake과정에 끼어듦으로써 서버와 상호 간의 동기화된 시퀀스 번호를 갖고 인가되지 않은 시스템의 기능을 이용하거나 중요한 정보에 접근할 수 있게 된다.
<br>
<br>목표 조직이 자주 방문하는 웹 사이트를 사전에 감염시켜, 목표 조직의 일원이 웹 사이트에 방문했을 때 악성 코드에 감연되게 한다.
<br>이후에는 감염된 PC를 기반으로 조직의 중요 시스템에 접근하거나 불능으로 만드는 등의 영향력을 행사하는 웹 기반 공격이다.
<br>
<br>AAA서버는 사용자의 컴퓨터 자원 접근 처리와 서비스 제공에 있어서의 다음 3가지 기능을 제공하는 서버이다.
<br>접근하는 사용자의 신원을 검증하는 기능
<br>신원이 검증된 사용자에게 특정된 권한과 서비스를 허용하는 기능
<br>사용자가 어떤 종류의 서비스를 이용했고, 얼마만큼의 자원을 사용했는지 기록 및 보관하는 기능
<br>
1 → Authentication - 검증<br>
2 → Authorization - 권한 부여<br>
3 → Accounting - 기록
<br>
<br>다양한 장비에서 발생하는 로그 및 보안 이벤트를 통합하여 관리하는 보안 소룰션으로, 방화벽, IDS, IPS, 웹 방화벽, VPN 등에서 발생한 로그 및 보안 이벤트를 통합하여 관리함으로써 비용 및 자원을 절약할 수 있는 특징이 있다.
<br>보안 솔루션 간의 상호 연동을 통해 종합적인 보안 관리 체계를 수립할 수 있다.
<br>
<br>헝가리안 표기법(Hungarian Notation)에 대해 간략히 서술.
<br>
헝가리안 표기법은 변수명 작성시 변수의 자료형을 알 수 있도록 자료형을 의미하는 문자를 포함하여 작성하는 방법.<br>
ex) bool bIsTrue / int nCnt
<br>
<br>스니핑(Sniffing)은 사전적 의미로 ‘코를 킁킁 거리다, 냄새를 맡다’이다. 네트워크 보안에서 스니핑에 대한 개념을 간략히 작성.
<br>
스니핑은 네트워크의 중간에서 남의 패킷 정보를 도청하는 해킹 유형의 하나로 수동적 공격에 해당한다.
<br>
<br>C++에서 생성자에 대해 간략히 서술하시오.
<br>
생성자는 객체 변수 생성에 사용되는 메소드로, 객체 변수를 생성하면서 초기화를 수행한다.
<br>
<br>1960년대 AT&amp;T 벨(Bell) 연구소가 MIT, GM사와 함께 공동 개발한 운영체제 이다.
<br>시분할 시스템(Time Sharing System)을 위해 설계된 대화식 운영체제 이다.
<br>대부분 c언어로 작성되어 있어 이식성이 높으며, 장치/프로세스 간의 호환성이 높다.
<br>트리 구조의 파일 시스템을 갖는다.
<br><img alt="do-messenger_screenshot_2025-02-12_14_04_58.png" src="http://lts.kr/사진-및-문서/do-messenger_screenshot_2025-02-12_14_04_58.png" target="_self"><br>
1 → 준비(Ready)<br>
2 → 실행(Run)<br>
3 → 대기(Wait)
<br>
<br>HRN 비선점형 스케줄링 우선순위를 구하는 계삭식을 쓰시오.
<br>
<br>
( 1 )는 준비상태 큐에서 기다리고 있는 프로세스들 중에서 실행시간이 가장 짧은 프로세스에게 먼저 CPU를 할당하는 기법이다. 가장 적은 평균 대기 시간을 제공하는 최적 알고리즘이지만, 실행 시간이 긴 프로세스는 실행 시간이 짧은 프로세스에게 할당 순위가 밀려 무한 연기 상태가 발생 될 수 있다. <br>
( 2 )은 시분할 시스템을 위해 고안된 방식으로, 준비상태 큐에 먼저 들어온 프로세스가 먼저 CPU를 할당받지만 각 프로세스는 시간 할당량 동안만 실행한 후 실행이 완료되지 않으면 다음 프로세스에게 CPU를 넘겨고 준비상태 큐의 가장 뒤로 배치된다. 할당되는 시간이 작을 경우 문맥 교환 및 오버헤드가 자주 발생되어 요청된 작업을 신속히 처리할 수 없다. <br>
( 3 )는 현재 실행중인 프로세스의 남은 시간과 준비상태 큐에 새로 도착한 프로세스의 실행시간을 비교하 가장 짧은 실행 시간을 요구하는 프로세스에게 CPU를 할당하는 기법으로, 시분할 시스템에 유용하다. 준비상태 큐에 있는 각 프로세스의 실행 시간을 추적하여 보유하고 있어야 하므로 오버헤드가 증가한다. <br>
1 → SJF(Shortest Job First)<br>
2 → RR(Round Robin)<br>
3 → SRT(Shortest Remaining Time)
<br>
<br>리눅스 또는 유닉스에서 a.txt 파일에 대해 다음 처리 조건과 같이 권한을 부여하고자 한다.
<br>사용자에게 읽기,쓰기,실행 권한을 부여한다.
<br>그룹에게 읽기,실행 권한을 부여한다.
<br>기타 사용자에게 실행 권한을 부여한다.
<br>한 줄로 작성하고, 8진법 숫자를 이용한 명령문을 이용한다.
<br>
<br>192.168.1.0/24 네트워크를 FLSM 방식으로 3개의 Subnet으로 나누는 방법
<br>즉, 64개씩 호스트를 할당하면,<br>
<br>여분의 서브넷 = 192.168.1.192/26
<br>
<br>서브넷팅(Subnetting)에 대한 설명
<br>현재 IP주소가 192.168.1.132이고, 서브넷 마스크가 255.255.255.192 일 때, 네트워크 주소와 사용가능 호스트 개수는?
<br>
<br>A Class - 0~127 / 기본 서브넷 - 255.0.0.0 (/8)
<br>B Class - 128~191 / 기본 서브넷 - 255.255.0.0 (/16)
<br>C Class - 192~223 / 기본 서브넷 - 255.255.255.0 (/24)
<br>D Class - 224~239 / 기본 서브넷 - 멀티캐스트 전용 (서브넷 X)
<br>이 때, 네트워크 개수는 2^2(추가된 1의 개수) = 4개<br>호스트개수는 256 / 4(네트워크 개수) = 64개<br>즉, 이를 표로 나타내면 →<br>여기서 192.168.1.13 는 3번째 네트워크 주소에 속하므로,<br>
네트워크 주소는 192.168.1.128 이며, 사용 가능 호스트 주소는 네트워크와 브로드캐스트 주소를 뺀 64-2 <br>
<br>OSI 7 Layer에 대한 설명
<br>
물리적으로 연결된 두 개의 인접한 개방 시스템들 간에 신뢰성 있고 효율적인 정보 전송을 할 수 있도록 연결 설정, 데이터 전송, 오류 제어 등의 기능을 수행한다. <br>
개방 시스템들 간의 네트워크 연결을 관리하며, 경로 제어, 패킷 교환, 트래픽 제어 등의 기능을 수행한다. <br>
서로 다른 데이터 표현 형태를 갖는 시스템 간의 상호 접속을 위해 필요한 계층으로, 코드변환, 데이터 암호화, 데이터 압축, 구문 검색 등의 기능을 수행한다. <br>
다양한 전송매체를 통해 비트 스트림을 전송. 전송에 필요한 두 장치 간의 실제 접속과 절단 등 기계적, 전기적, 기능적, 절차적 특성에 대한 규칙을 정의한다. <br>
1 → 데이터 링크 계층(Data Link Layer)<br>
2 → 네트워크 계층(Network Layer)<br>
3 → 표현 계층(Presentation Layer)
<br>
<br>심리학자 톰 마릴은 컴퓨터가 메시지를 전달하고, 메시지가 제대로 도착했는지 확인하며, 도착하지 않았을 경우 메시지를 재전송하는 일련의 방법을 ‘기술적 은어’를 뜻하는 ( )이라는 용어로 정의하였다.
<br>
<br>프로토콜은 서로다른 기기들 간의 데이터 교환을 원활하게 수행할 수 있도록 표준화 시켜놓은 통신 규약이다. 프로토콜의 기본요소 3가지를 쓰시오.
<br>
구문(Syntex)<br>
의미(Semantics)<br>
시간(Timing)
<br>
<br>( 1 ) : 연결형 통신에서 주로 사용되는 방식으로, 출발지와 목적지의 전송 경로를 미리 연결하여 논리적으로 고정한 후 통신하는 방식
<br>( 2 ) : 비연결형 통신에서 주로 사용되는 방식으로, 사전에 접속 절차를 수행하지 않고 헤더에 출발지에서 목적지까지의 경로 지정을 위한 충분한 정보를 붙여서 개별적으로 전달하는 방식
<br>
1 → 가상 회선(Virtual Circuit)<br>
2 → 데이터그램(Datagram)
<br>
<br>인터넷 환경에서의 호스트 상호 간 통신에서 연결된 네트워크 접속 장치의 물리적 주소인 MAC 주소를 이용하여 IP주소를 찾는 인터넷 계층의 프로토콜로, 역순 주소 결정 프로토콜이라 불린다.
<br>
RARP(Reverse Address Resolution protocol)
<br>
<br>( )는 한 번의 로그인으로 개인이 가입한 모든 사이트를 이용할 수 있게 해주는 시스템을 말한다.
<br>개인의 경우, 사이트에 접속하기 위하여 아이디와 패스워드는 물론 이름, 전화번호 등 개인정보를 각 사이트마다 일일이 기록해야 하던 것이 한 번의 작업으로 끝나므로 불편함이 해소되며, 기업에서는 회원에 대한 통합관리가 가능해 마케딩을 극대화시킬 수 있다는 장점이 있다.
<br>
SSO(Single Sign On)
<br>
<br>재난 및 군사 현장과 같이 별도의 고정된 유선망을 구축할 수 없는 장소에서 모바일 호스트만을 이용하여 구성한 네트워크.
<br>망을 구성한 후 단기간 사용되는 경우나 유선망을 구성하기 어려운 경우에 적합하다.
<br>멀티 홉 라우팅 기능을 지원한다.
<br>
애드 훅 네트워크(Ad-hoc Network)
<br>
<br>우리말로 번역하면 '네트워크 주소 변환'이라는 의미의 영문 3글자 약자이다.
<br>1개의 정식 IP 주소에 다량의 가상 사설 IP 주소를 할당 및 연결하는 방식이다.
<br>1개의 IP 주소를 사용해서 외부에 접속할 수 있는 노드는 어느 시점에서 1개만으로 제한되는 문제가 있으나, 이 때에는 IP 마스커레이드(Masquerade)를 이용하면 된다.
<br>
NAT(Network Address Translation)
<br>
<br>
정의<br>
웹상에 존재하는 데이터를 개별 URI로 식별하고, 각 URI에 링크 정보를 부여함으로써 상호 연결된 웹을 지향하는 모형이다.<br>
링크 기능이 강조된 시맨틱웹의 모형에 속한다고 볼 수 있으며, 팀 버너스 리의 W3C를 중심으로 발전하고있다. <br>
주요 기능 <br>공개된 데이터를 이용하면 내가 원하는 데이터가 이미 존재하는지, 어디에 존재하는지 알 수 있다.
<br>URI로 구별되는 데이터 리소스의 자유로운 접근 및 이용이 가능하므로 큰 노력 없이 데이터의 매쉬업이 가능하다.
<br>내가 만든 데이터가 아니라도 URI를 이용하여 링크만 해주면 이용할 수 있다. <br>
4대 원칙 <br>통합 자원 식별자(URI)를 사용한다,
<br>URI는 HTTP 프로토콜을 통해 접근할 수 있어야 한다.
<br>RDF나 스파클 같은 표준을 사용한다,
<br>풍부한 링크 정보가 있어야 한다. <br>
Linked Data와 Open Data를 결합한 용어이다. <br>
LOD(개방형 링크드 데이터)
<br>
<br>경로 제어 프로토콜은 크게 자율 시스템 내부의 라우팅에 사용되는 (①) 와 <br>자율 시스템 간의 라우팅에 사용되는 (②) 로 구분할 수 있다.
<br>설명 <br>(①) 는 소규모 동종 자율 시스템에서 효율적인 RIP와 대규모 자유 시스템에서 많이 사용되는 (③) 로 나누어진다.
<br>(③) 는 링크 상태(Link State)를 실시간으로 반영하여 최단 경로로 라우팅을 지원하는 특징이 있다.
<br>(④) 는 (②) 의 단점을 보완하여 만들어진 라우팅 프로토콜로, 처음 연결될 때는 전체 라우팅 테이블을 교환하고, 이후에는 변환된 정보만을 교환한다. <br>
<br>BGP
<br>AS
<br>HOP
<br>OSPF
<br>NAT
<br>ISP
<br>EGP
<br>IGP
<br> <br>IGP
<br>EGP
<br>OSPF
<br>BGP <br>
<br>P2P 네트워크를 이용하여 온라인 금융 거래 정보를 온라인 네트워크 참여자(Peer)의 디지털 장비에 분산 저장하는 기술은?
<br>
블록체인(Blockchain)
<br>
<br>정보 자산을 안전하게 보호하기 위한 보호 절차와 대책으로, 정보보호 관리 체계라고 한다.
<br>조직에 맞는 정보보호 정책을 수립하고, 위험에 상시 대응하는 여러 보안 대책을 통합 관리한다.
<br>공공 부문과 민간 기업 부문에서 이것을 평가하고 인증하는 사업을 한국인터넷진흥원(KISA)에서 운영중이다.
<br>
<br>( 1 )은 칩 설계 회사인 ARM에서 개발한 기술로, 하나의 프로세서 내에 일반 애플리케이션을 처리하는 일반 구역과, 보안이 필요한 애플리케이션을 처리하는 보안 구역으로 분할하여 관리하는 하드웨어 기반의 보안기술이다.
<br>( 2 )은 네티즌들이 사이트에 접속할 때 주소를 잘못 입력하거나 철자를 빠뜨리는 실수를 이용하기 위해 이와 유사한 유명 도메인을 미리 등록하는 것으로 URL하이재킹이라고도 한다. <br>
<br>Pharming
<br>Typosquatting
<br>Ransomware
<br>Tvishing
<br>Hacktivism
<br>CSRF
<br>Trustzone
<br>Watering Hole
<br>APT
<br>Smurfing
<br> <br>Trustzone
<br>Typosquatting <br>
<br>RAID(Redundant Array of Independent Disks)란 여러개의 하드디스크를 조합하여 성능 향상과 데이터 보호기능을 제공하는 기술이다.
<br> <br>RAID 0: 성능 최우선, 데이터 보호 없음.
<br>RAID 1: 데이터 안정성 높음, 저장 용량 절반 사용.
<br>RAID 5: 성능과 안정성 균형, 최소 3개 디스크 필요.
<br>RAID 6: RAID 5보다 높은 안정성, 최소 4개 디스크 필요.
<br>RAID 10: RAID 0과 RAID 1의 조합, 고성능과 고안정성 제공. <br>
<br>오픈 소스 기반 분산 컴퓨팅 플랫폼 이다.
<br>분산 저장된 데이터들은 클러스터 환경에서 병렬 처리된다.
<br>일반 PC급 컴퓨터들로 가상화된 대형 스토리지를 형성하고 그 안에 보관된 거대한 데이터 세트를 병렬로 처리할 수 있도록 개발되었다.
<br>더그 커팅과 마이크 캐퍼렐라가 개발했으며, 구글의 맵리듀스(MapReduce) 엔진을 사용하고 있다.
<br>
<br>데이터 마이닝(Data Mining)의 개념을 간략히 서술하시오.
<br>
데이터 마이닝은 대량의 데이터를 분석하여 데이터에 내재된 변수 사이의 상호관계를 규명하여 일정한 패턴을 찾아내는 기법이다.
<br>
<br>데이터베이스 회복(Recovery) 기법에 관련된 내용.
<br>( )은 트렌젝션이 데이터를 변경하면, 트렌젝션이 부분 완료되기 전이라도 즉시 실제 DB에 그 내용을 반영하는 기법.
<br>장애가 발생하여 회복 작업할 경우를 대비하여 갱신된 내용들을 로그에 보관시킨다.
<br>( )에서 회복 작업을 수행할 경우 Redo와 Undo 모두 수행이 가능하다.
<br>
즉각 갱신 기법(Immediate Update)
<br>
<br>데이터베이스 병행제어(Concurrency Control) 기법 중 하나로이다.
<br>접근한 데이터에 대한 연산을 모두 마칠 때 까지 추가적인 접근을 제한함으로써 상호 배타적으로 접근하여 작업을 수행하도록 하는 기법이다.
<br>
<br>
릴리즈 노트는 개발 과정에서 정리된 릴리즈 정보를 고객과 공유하기 위한 문서이다. <br>
릴리즈 노트는 정확하고 완전한 정보를 기반으로 개발팀에서 직접 현재 시제로 작성해야 한다. <br>
릴리즈 노트 작성시 노트 이름, 소프트웨어, 릴리즈 버전, 릴리즈 날짜, 릴리즈 노트 날짜, 버전 등이 포함되는 항목은? <br>
<br>소프트웨어 개발에서의 작업 중 형상 통제에 대해 간략히 서술하시오.
<br>
형상 통제는 식별된 형상 항목에 대한 변경 요구를 검토하여 현재의 기준선이 잘 반영될 수 있도록 조정하는 작업이다.
<br>
<br>소프트웨어 ( )는 소프트웨어 개발 단계의 각 과정에서 만들어지는 프로그램, 문서, 데이터등을 관리하는 것을 말한다.
<br>소프트웨어의 개발 과정에서 만들어지는 여러 버전들의 변경사항을 관리하는 일련의 활동이며 이를 지원하는 도구로 Git, SVN 등이 있다.
<br>
형상관리(SCM)]]></description><link>http://lts.kr/study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-키워드.html</link><guid isPermaLink="false">study/정보처리기사/정보처리기사 실기/🥇 정보처리 기사 실기 키워드.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Thu, 20 Feb 2025 05:11:04 GMT</pubDate><enclosure url="http://lts.kr/사진-및-문서/do-messenger_screenshot_2025-02-10_15_04_45.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="http://lts.kr/사진-및-문서/do-messenger_screenshot_2025-02-10_15_04_45.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🆕 Basic]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="http://lts.kr/?query=tag:개발" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#개발</a> <a class="tag" href="http://lts.kr/?query=tag:초보" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#초보</a> <a class="tag" href="http://lts.kr/?query=tag:기초" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#기초</a> <br> <a href="http://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="http://lts.kr?query=tag:개발" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#개발">#개발</a> <a href="http://lts.kr?query=tag:초보" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#초보">#초보</a> <a href="http://lts.kr?query=tag:기초" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#기초">#기초</a><br>]]></description><link>http://lts.kr/study/커리큘럼/🆕-dev-커리큘럼.html</link><guid isPermaLink="false">study/커리큘럼/🆕 Dev 커리큘럼.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Thu, 20 Feb 2025 04:51:06 GMT</pubDate></item><item><title><![CDATA[🎵 Obsidian]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:Tools" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Tools</a> <a class="tag" href="http://lts.kr/?query=tag:메모" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#메모</a> <a class="tag" href="http://lts.kr/?query=tag:Obsidian" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Obsidian</a> <br> <a href="http://lts.kr?query=tag:Tools" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Tools">#Tools</a> <a href="http://lts.kr?query=tag:메모" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#메모">#메모</a> <a href="http://lts.kr?query=tag:Obsidian" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Obsidian">#Obsidian</a><br>
<br>옵시디언은 Markdow기반의 노트 작성 및 지식 관리 어플이다.
<br>특히, 데이터 시각화 및 개인지식관리에 뛰어나다.
<br>
<br>옵시디언은 Markdown 형식을 기반으로 노트를 작성하며, 간단한 텍스트 포맷팅(굵게, 기울임, 리스트, 링크 등)이 가능.
<br>.md 파일로 저장되어 데이터 이동 및 백업이 자유로움.
<br>
<br>옵시디언은 위키 스타일의 링크([[노트 제목]])를 사용하여 노트 간 연결이 가능.
<br>노트 간의 관계를 자동으로 분석하여 연결된 구조를 보여줌.
<br>
<br>연결된 노트들을 시각적으로 보여주는 그래프 뷰 제공.
<br>노트 간의 관계를 네트워크 그래프 형태로 표현하여 지식 네트워크 구축에 용이.
<br>
<br>기본 기능 외에도 다양한 플러그인을 추가하여 확장 가능.
<br>공식 플러그인 및 커뮤니티에서 제공하는 다양한 기능 추가 가능. <br>예: 캘린더, 태그 관리, LaTeX 지원, AI 플러그인 등. <br>
<br>클라우드가 아닌 로컬 저장 방식을 기본으로 하여 데이터 소유권을 보장.
<br>추가적으로 Obsidian Sync를 사용하면 여러 기기 간 동기화 가능.
<br>
<br>Windows, macOS, Linux, iOS, Android에서 사용 가능.
<br>모바일에서도 원활한 노트 작성과 검색이 가능.
<br>
<br>자주 사용하는 노트 형식을 템플릿으로 저장하여 반복 사용 가능.
<br>태그(#태그이름)를 활용하여 노트 분류 및 검색 가능.
<br>
<br>특정 키워드를 기반으로 노트 검색 가능.
<br>정규 표현식(Regex) 지원으로 복잡한 검색도 가능
<br><img alt="Pasted image 20250218145702.png" src="http://lts.kr/사진-및-문서/pasted-image-20250218145702.png" target="_self"><br><img alt="Pasted image 20250218145823.png" src="http://lts.kr/사진-및-문서/pasted-image-20250218145823.png" target="_self"><br>노션이란? - 올인원 생산성 및 노트 관리 도구로, 노트 작성, 데이터베이스, 프로젝트 관리, 협업 기능을 통합적으로 제공하는 플랫폼이다<br>단편적으로 기능의 차이를 보면 다음과 같다.<br>
<br>옵시디언의 최대 장점으로는 다양한 유저 커스텀 플러그인이 있다.
<br>노션에서 기본으로 지원하는 캘린더, 데이터베이스, 클라우드, 템플릿 등을 모두 사용 가능하다.
<br>또한, 해당되는 플러그인 들은 유저들에 의해 지속적으로 업데이트 된다.
<br>EX) ChatGPT / HTML Export / Git 등등..<br>
<br>옵시디언은 노션과 달리 로컬 네이티브앱으로 인터넷 연결없이도 사용이 가능하다.
<br>로컬환경에서 Markdown문법만으로 문서가 작성되기 때문에 속도가 무척 빠르고 쾌적하다.
<br>또한, 로컬 저장 방식으로 직접적인 데이터의 소유가 가능하다. → 보안이 뛰어나다고 볼 수 있다.
<br>
<br>옵시디언은 기본적으로 모든 기능이 제한없이 무료이다.<br>
! 유료 서비스인 Obsidian Sync(클라우드 동기화 서비스) 가 있지만, Git을 통한 형상관리를 한다면 전혀 사용할 필요가 없다
<br>따라서, 용량에 구애받지 않고 무제한 확장이 가능하다고 볼 수 있다.
<br>
<br>그럼에도 노션이 가지는 장점도 만만치 않으며, 옵시디언의 단점 또한 존재한다.
<br>즉, 각자의 작업 환경 및 취향에 맞추어서 최적의 Tool을 선택하는 것이 바람직 하다고 볼 수 있다.
<br>나는 그래도 옵시디언이다.]]></description><link>http://lts.kr/tools/🎵-obsidian.html</link><guid isPermaLink="false">Tools/🎵 Obsidian.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 19 Feb 2025 08:46:17 GMT</pubDate><enclosure url="http://lts.kr/사진-및-문서/pasted-image-20250218145702.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="http://lts.kr/사진-및-문서/pasted-image-20250218145702.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🪕 JPA 에 대한 고찰]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="http://lts.kr/?query=tag:JPA" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#JPA</a> <a class="tag" href="http://lts.kr/?query=tag:DB" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#DB</a> <a class="tag" href="http://lts.kr/?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <br> <a href="http://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="http://lts.kr?query=tag:JPA" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#JPA">#JPA</a> <a href="http://lts.kr?query=tag:DB" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#DB">#DB</a> <a href="http://lts.kr?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a><br>
<br>java에서 DB를 사용할 수 있도록 연결해주는 응용프로그램 인터페이스인 java api이다.
<br>java와 연동되는 DBMS에 따라 그에 맞는 JDBC(ex. MySQL Connector)를 설치해야 한다.
<br>그에 맞는 드라이버만 존재한다면, java에서 DB에 구애받지 않고 똑같은 코드로 사용이 가능하다.
<br>
<br>SQL명령을 명시적으로 작성해야 한다.
<br>객치지향 프로그래밍과의 괴리가 있다.
<br>
<br>DB를 엑세스 하기 위한 표준 개방형 응용 프로그램 인터페이스를 뜻한다.
<br>ODBC는 JDBC와 달리 모든 어떠한 DBMS인지와 상관없이 적용된다. <br>
<br>jpa는 서로 다른 두 개념을 매핑해주는 ORM(Object Relational Mapping)중 하나이다.
<br>DB와 java객체간의 매핑을 자동화하여, SQL대신 java객체와 상호작용 하도록 설계되어있다. <br>RDB는 하나의 row를 하나의 인스턴스라고 생각한다면 컬럼의 값은 필드의 값으로 매핑할 수 있다.
<br>하지만 객체의 필드에 리스트가 존재하는 경우 상황이 애매해진다.
<br>또한 java객체의 필드에 또 다른 객체가 존재한는 경우 java는 참조를 하지만, DB는 Join으로 접근하기 때문에 다르다.
<br>이러한 비슷한 두 개념을 매핑해주는 역할을 하는것이다. <br>JPA는 DB와 객체를 매핑하는 기술일 뿐,<br>
내부적으로 DB와 통신을 위해서는 JDBC를 필요로 하게된다.<br>또한 JPA도 JDBC와 마찬가지로 인터페이스이기 때문에 구현체가 필요하고, 그 구현체 중 하나가 Hibernate이다.<br>
<br>Spring Data JPA란 JPA를 Repository 기반으로 간편하고 효율적으로 사용할 수 있는 모듈이다.
<br>Repository의 메서드를 통해 쿼리를 날릴 수 있다.
<br>또는 직접 쿼리를 만들고 싶다면 @Query 어노테이션을 사용한다.
<br> <img alt="Pasted image 20250110144021.png" src="http://lts.kr/사진-및-문서/pasted-image-20250110144021.png" target="_self"><br>
<br>JPQL은 JPA에서 사용되는 쿼리 언어로, SQL과 비슷하지만 객체를 대상을 쿼리를 작성하게된다.
<br>테이블이 아닌 엔티티 객체를 대상으로 하기 때문에, 객체지향적이다.
<br>
<br>SQL 유사성 : select, where, group by 등 SQL 과 유사한 문법 사용
<br>엔티티 중심 : DB테이블 대신 엔티티 클래스와 속성을 기준으로 작성한다.
<br>동적 쿼리 지원 : 런타임에 JPQL 문자열 생성 실행 가능
<br>별칠(alias) 사용 필수
<br>
<br>문자열(String)형태 이기에 개발자 의존적 형태이다 <br>컴파일 단계에서 타입체크가 불가능하다 <br>런타임단계에서 오류가 발생할 수 있다 <br>
<br>위에서 기술한 JPQL의 문제점을 보완하기 위해 나온것이 query dsl이다.
<br>정적 타입을 이용해, SQL, JPQL을 코드로 작성할 수 있도록 도와주는 오픈소스 API
<br>
<br>컴파일 단계에서 오류 확인 가능, 후속 조치 가능 <br>JPQL의 단점들을 거의 보완
<br>
<br>코드가 너무 길어진다... <br>FROM절의 서브쿼리를 사용하는것에 제약이 있다. <br>세세한 튜닝이나, DBMS의 고유기능을 유연하게 사용할 수 없다. <br>N+1 문제는 데이터베이스와 애플리케이션 간의 비효율적인 쿼리 실행으로 인해 발생하는 성능 문제를 지칭합니다.<br>
이는 주로 ORM(Object-Relational Mapping) 기술(JPA, Hibernate 등)을 사용할 때 발생하며, 한 번의 데이터베이스 조회로 해결할 수 있는 작업에 대해 추가적인 N개의 쿼리가 실행되는 상황을 의미합니다.<br>N+1 문제는 주로 지연 로딩(Lazy Loading)으로 인해 발생합니다.<br>
지연 로딩은 관련 엔티티를 필요할 때만 로딩하는 방식으로, 기본적으로 효율적인 방법이지만 아래와 같은 상황에서 문제가 발생합니다.<br>
<br>
두 개의 엔티티 간 관계: <br>Parent(부모 엔티티)와 Child(자식 엔티티) 관계.
<br>Parent 1개에는 여러 Child가 연결. <br>
문제 발생 과정: <br>부모 엔티티를 조회하는 쿼리 1번 실행.
<br>각 부모 엔티티에 연결된 자식 엔티티를 조회하는 쿼리 N번 실행. <br>List&lt;Parent&gt; parents = entityManager.createQuery("SELECT p FROM Parent p", Parent.class).getResultList(); // 각 Parent 엔티티의 자식 엔티티를 로드 (지연 로딩)
for (Parent parent : parents) { System.out.println(parent.getChildren().size()); // 자식 엔티티 조회 쿼리 발생
} <br>
<br>SELECT * FROM Parent; → 부모 엔티티를 조회하는 쿼리 1번 실행.
<br>SELECT * FROM Child WHERE parent_id = ?; → 각 부모 엔티티마다 자식 데이터를 조회하는 쿼리 N번 실행.
<br>결과적으로 1 + N개의 쿼리가 실행됩니다.
<br>데이터가 많을수록 성능 저하가 극심해집니다.
<br>
<br>데이터베이스와 애플리케이션 간의 불필요한 트래픽 증가.
<br>쿼리 실행 횟수가 많아져 응답 시간이 느려짐.
<br>대량의 데이터가 있을 경우 애플리케이션 성능이 크게 저하.
<br>
<br>페치 조인은 SQL의 JOIN을 사용해 관련된 엔티티를 한 번의 쿼리로 로드하는 방식입니다.
<br>String jpql = "SELECT p FROM Parent p JOIN FETCH p.children";
List&lt;Parent&gt; parents = entityManager.createQuery(jpql, Parent.class).getResultList();
<br>JOIN FETCH를 사용하면 부모와 자식 엔티티를 한 번에 가져옵니다.
<br>장점: 데이터베이스 쿼리를 최소화.
<br>단점: 데이터가 많을 경우 메모리 사용량 증가.
<br>
<br>JPA에서 제공하는 기능으로, 로딩 시 어떤 관계를 함께 로드할지 명시적으로 정의합니다
<br>@Entity
@NamedEntityGraph( name = "Parent.withChildren", attributeNodes = @NamedAttributeNode("children")
)
public class Parent { ... } // 사용 시
EntityGraph&lt;?&gt; entityGraph = em.getEntityGraph("Parent.withChildren");
List&lt;Parent&gt; parents = em.createQuery("SELECT p FROM Parent p", Parent.class) .setHint("javax.persistence.fetchgraph", entityGraph) .getResultList(); <br>장점: 명시적으로 필요한 관계만 가져올 수 있음.
<br>단점: 추가적인 설정 필요.
<br>
<br>필요한 데이터만 직접 SQL 또는 JPQL로 조회하여 반환.
<br>String jpql = "SELECT new com.example.dto.ParentChildDTO(p.name, c.name) " + "FROM Parent p JOIN p.children c";
List&lt;ParentChildDTO&gt; dtos = entityManager.createQuery(jpql, ParentChildDTO.class).getResultList(); <br>장점: 불필요한 엔티티 로드 방지.
<br>단점: 객체 매핑 작업 추가.
<br>- 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위
<br>- Spring에서 제공하는 트렌젝션 관리 기능과 JPA를 연결하는 역할을 수행.
<br>- 클래스나 메서드에 삽입하면, AOP레벨(프록시를 사용하여)에서 트렌젝션매니저를 이용한 동작을 공통으로 적용.
<br>- 영속성 컨텍스트를 관리하는 인터페이스
- 엔티티의 저장/수정/삭제/조회 작업을 수행
- 스레드 세이프하지 않으므로 한트레젝션 내에서만 사용
- 앤티티매니저펙토리는 스레드세이프하므로 공유 가능
<br>- JPA의 엔티티를 관리하는 1차 캐시 역할을 하는 메모리 공간
- 엔티티와 DB데이터간의 상태 동기화를 책임
- 1차캐싱 / 변경 감지 / 지연 로딩 의 특징을 갖는다
- 지연로딩 : 관계된 엔티티를 실제로 필요할때만 가져오며, 변경점을 한번만 commit한다
<br>- DB스냅샷 : - 트렌젝션이 시작될때 생성된다. - 독립적인 데이터베이스 복사본으로, 원본데이터 변경과 무관하다. - 고급 격리 수준(REPEATABLE READ, SERIALIZABLE)에서 MVCC(Multi-Version Concurrency Control)를 구현할 때 사용한다. - 물리적인 복사본이 아닌, 논리적으로 매 쿼리마다 동적으로 가공이 되는 방식이다.
- 앤티티매니저_스냅샷 : - 엔티티가 영속성 컨텍스트에 로드될 때 생성된다. - 엔티티의 초기 상태를 저장하여 변경 감지에 사용된다.]]></description><link>http://lts.kr/study/dev-seminar/🪕-jpa-에-대한-고찰.html</link><guid isPermaLink="false">study/Dev Seminar/🪕 JPA 에 대한 고찰.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 19 Feb 2025 07:51:34 GMT</pubDate><enclosure url="http://lts.kr/사진-및-문서/pasted-image-20250110144021.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="http://lts.kr/사진-및-문서/pasted-image-20250110144021.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🍂 JPA, Mybatis , Dead Lock]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="http://lts.kr/?query=tag:JPA" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#JPA</a> <a class="tag" href="http://lts.kr/?query=tag:Java" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Java</a> <a class="tag" href="http://lts.kr/?query=tag:Mybatis" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Mybatis</a> <a class="tag" href="http://lts.kr/?query=tag:DeadLock" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#DeadLock</a> <br> <a href="http://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="http://lts.kr?query=tag:JPA" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#JPA">#JPA</a> <a href="http://lts.kr?query=tag:Java" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Java">#Java</a> <a href="http://lts.kr?query=tag:Mybatis" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Mybatis">#Mybatis</a> <a href="http://lts.kr?query=tag:DeadLock" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#DeadLock">#DeadLock</a><br>...Stack trace 중 일부 발췌<br>HikariPool Dead lock Caused by: org.apache.ibatis.exceptions.PersistenceException:
###Error querying database. Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is java.sql.SQLTransientConnectionException: HikariPool-1 - Connection is not available, request timed out after 30008ms.
###The error occurred while executing a query
###Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is java.sql.SQLTransientConnectionException: HikariPool-1 - Connection is not available, request timed out after 30008ms.
Caused by: java.sql.SQLTransientConnectionException: HikariPool-1 - Connection is not available, request timed out after 30008ms.
at com.zaxxer.hikari.pool.HikariPool.createTimeoutException(HikariPool.java:696)
at com.zaxxer.hikari.pool.HikariPool.getConnection(HikariPool.java:197)
at com.zaxxer.hikari.pool.HikariPool.getConnection(HikariPool.java:162)
<br>// 위 조건 발생 코드 예시
public void deadLockMethod(){ mybatisSelectMethod(); jpaSelectMethod(); mybatisSelectMethod();
}
<br>데드락 문제는 데이터베이스 커넥션 고갈과 트랜잭션 리소스 경합이 복합적으로 작용하여 발생합니다.<br>
<br>
공유 커넥션 풀(HikariCP): <br>JPA와 MyBatis 모두 HikariCP를 통해 동일한 데이터베이스 커넥션 풀을 공유합니다.
<br>한쪽에서 커넥션을 점유하고 반환하지 않으면, 다른 쪽에서 커넥션 요청 시 대기 상태가 길어지고, 결국 시간 초과(timeout)로 이어집니다. <br>
트랜잭션 관리의 복잡성: <br>JPA와 MyBatis가 서로 다른 방식으로 커넥션을 관리하면서 동일 트랜잭션 내에서 서로 경합을 벌일 가능성이 큽니다.
<br>트랜잭션의 범위가 너무 크거나, 트랜잭션 경계에서 커넥션이 제대로 정리되지 않으면 커넥션 고갈 상태가 발생합니다. <br>
Nested Query 및 커넥션 잠금: <br>deadLockMethod() 코드처럼 동일 메서드 내에서 JPA와 MyBatis를 교차 호출하면, 커넥션이 중복 점유(lock)될 가능성이 있습니다.
<br>예를 들어, MyBatis가 첫 번째 호출에서 커넥션을 점유한 상태에서 JPA가 새로운 커넥션을 요청하면, 풀에서 여유가 없을 경우 대기 상태가 발생합니다. <br>
<br>
JPA와 MyBatis의 동시 사용 <br>JPA는 엔터티 매니저(EntityManager)를 통해 트랜잭션을 관리하고, MyBatis는 SQL 세션(SqlSession)을 통해 관리합니다.
<br>이 둘은 서로 독립적으로 작동하기 때문에 동일한 트랜잭션 내에서 하나의 커넥션을 공유하지 못하고, 각자 별도의 커넥션을 요청할 수 있습니다. <br>
커넥션 반환 누락 <br>MyBatis 또는 JPA 메서드 호출 후 커넥션이 적절히 반환되지 않으면(pool로 반환되지 않음), 커넥션 풀이 고갈될 가능성이 높아집니다. <br>
Connection Pool 고갈 <br>HikariCP의 기본 maxPoolSize(기본값: 10)가 초과되면 대기 상태가 발생하며, 대기 시간(connectionTimeout)이 지나면 SQLTransientConnectionException이 발생합니다. <br>
<br>최대 커넥션 수 증가: HikariCP의 maximumPoolSize를 늘려 충분한 커넥션을 사용할 수 있도록 설정합니다. properties spring.datasource.hikari.maximum-pool-size=30 spring.datasource.hikari.connection-timeout=30000<br>최소 유휴 커넥션 유지: properties spring.datasource.hikari.minimum-idle=10<br>
<br>JPA와 MyBatis 호출이 동일한 트랜잭션 내에서 실행되도록 스프링 트랜잭션 관리를 통합합니다.
<br>@Transactional 어노테이션을 적용하여 트랜잭션 범위를 명시적으로 정의합니다.<br>@Transactional
public void deadLockMethod() { mybatisSelectMethod(); jpaSelectMethod(); mybatisSelectMethod();
}
<br>
<br>JPA와 MyBatis가 동일한 트랜잭션 안에서 하나의 커넥션을 공유하도록 설정합니다.
<br>Spring의 DataSourceTransactionManager를 사용하여 데이터 소스 기반으로 트랜잭션을 관리합니다.<br> @Bean public PlatformTransactionManager transactionManager(DataSource dataSource) { return new DataSourceTransactionManager(dataSource); } <br>
<br>JPA에서 Lazy Loading이 과도하게 사용될 경우, 예상치 못한 시점에서 데이터베이스 호출이 발생하며 추가적인 커넥션 요청을 유발할 수 있습니다.
<br>가능하면 즉시 로딩(Eager Fetch)을 사용하거나, 필요한 데이터를 명시적으로 로딩합니다.<br>@EntityGraph(attributePaths = {"childEntities"}) List&lt;ParentEntity&gt; findWithChildren();
<br>
<br>MyBatis 사용 시 SqlSession을 명시적으로 닫아 커넥션이 즉시 반환되도록 합니다. try (SqlSession session = sqlSessionFactory.openSession()) { // MyBatis 작업 수행 }
<br>@Service
public class DeadlockService { private final SqlSessionFactory sqlSessionFactory; private final JpaRepository jpaRepository; public DeadlockService(SqlSessionFactory sqlSessionFactory, JpaRepository jpaRepository) { this.sqlSessionFactory = sqlSessionFactory; this.jpaRepository = jpaRepository; } @Transactional public void resolveDeadlockMethod() { // MyBatis 호출 try (SqlSession session = sqlSessionFactory.openSession()) { session.selectList("namespace.mybatisSelect"); } // JPA 호출 jpaRepository.findAll(); // 다시 MyBatis 호출 try (SqlSession session = sqlSessionFactory.openSession()) { session.selectList("namespace.mybatisSelect"); } }
}
<br><a data-tooltip-position="top" aria-label="https://velog.io/@12onetwo12/%EC%9E%A5%EC%95%A0%ED%9A%8C%EA%B3%A0-DBCP-Connection-Leak-%ED%95%B4%EA%B2%B0-%EC%97%AC%EC%A0%95-feat.HikariCP-Dead-lock-QueryDSL" rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@12onetwo12/%EC%9E%A5%EC%95%A0%ED%9A%8C%EA%B3%A0-DBCP-Connection-Leak-%ED%95%B4%EA%B2%B0-%EC%97%AC%EC%A0%95-feat.HikariCP-Dead-lock-QueryDSL" target="_self">[ 트러블슈팅 ] JPA, Mybatis 동시 사용시 발생할 수 있는 HikariCP Dead lock 해결 여정 ( feat.OSIV )</a>]]></description><link>http://lts.kr/study/dev-seminar/🍂-jpa,-mybatis-,-dead-lock.html</link><guid isPermaLink="false">study/Dev Seminar/🍂 JPA, Mybatis , Dead Lock.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 19 Feb 2025 07:50:53 GMT</pubDate></item><item><title><![CDATA[🔹 TDD에 대하여]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="http://lts.kr/?query=tag:Java" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Java</a> <a class="tag" href="http://lts.kr/?query=tag:TDD" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#TDD</a> <a class="tag" href="http://lts.kr/?query=tag:Test" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Test</a> <br> <a href="http://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="http://lts.kr?query=tag:Java" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Java">#Java</a> <a href="http://lts.kr?query=tag:TDD" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#TDD">#TDD</a> <a href="http://lts.kr?query=tag:Test" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Test">#Test</a><br>
<br>
코드 품질 향상 <br>TDD는 먼저 테스트를 작성한 후 코드를 구현하므로, 요구사항이 코드로 명확히 반영됩니다.
<br>코드의 결함이 초기에 발견되어 수정 비용이 감소합니다. <br>
유지보수성 강화 <br>잘 작성된 테스트는 코드가 리팩토링될 때 문제를 방지합니다.
<br>신규 기능 추가 시, 기존 코드와의 충돌을 빠르게 감지할 수 있습니다. <br>
명확한 설계 유도 <br>TDD는 코드를 작고 독립적인 단위로 나누어 설계하도록 장려합니다.
<br>자연스럽게 SRP(Single Responsibility Principle) 등 객체지향 원칙을 따르게 됩니다. <br>
개발자 간 협업 강화 <br>테스트는 개발자들 간의 명세서 역할을 하며, 코드의 동작을 명확히 설명합니다.
<br>코드리뷰 시 테스트를 통해 의도한 동작을 검증할 수 있습니다. <br>
<br>
적용이 적합한 상황 <br>핵심 비즈니스 로직: 제품의 주요 기능이나 서비스 로직은 테스트가 필수적입니다.
<br>복잡한 계산이나 알고리즘: 오작동이 치명적인 로직에는 TDD가 효과적입니다.
<br>API 개발: REST API나 GraphQL과 같은 인터페이스는 TDD로 사전 정의하여 일관성을 보장합니다.
<br>CI/CD 파이프라인: 자동화된 테스트를 활용하여 배포 전에 코드를 검증합니다. <br>
적용이 어려운 상황 <br>UI/UX: 사용자 인터페이스는 변동이 잦아 TDD를 적용하기 어렵습니다. 대신 e2e 테스트를 고려할 수 있습니다.
<br>초기 프로토타입 개발: 초기에는 빠른 구현이 우선이므로 TDD를 생략할 수 있습니다.
<br>시간/리소스 부족: 모든 코드를 테스트하기 어려운 경우, 핵심 영역에 우선순위를 두어야 합니다. <br>
테스트의 범위 조정 <br>유닛 테스트: 가장 작은 단위의 코드 동작을 테스트합니다.
<br>통합 테스트: 여러 모듈이 함께 작동하는지 확인합니다.
<br>엔드투엔드 테스트(e2e): 사용자가 시스템 전체를 사용할 때의 흐름을 테스트합니다. <br>
<br>
우선순위를 정하라 <br>모든 코드를 테스트하기보다는 핵심적인 기능에 집중합니다.
<br>낮은 리스크 영역은 이후에 커버리지를 추가할 수 있습니다. <br>
자동화와 병행하라 <br>CI/CD 환경에서 테스트가 자동으로 실행되도록 설정하여, 코드 품질을 지속적으로 유지합니다. <br>
테스트를 문서로 활용하라 <br>테스트는 단순히 검증 도구가 아니라, 코드의 의도를 설명하는 문서 역할을 합니다.
<br>
<br>사례: 금융 계산, 결제 시스템, 인증 시스템.
<br>이유: 로직 오류가 사용자 신뢰에 큰 영향을 미칠 수 있으며, 수정 비용이 크기 때문.
<br>장점: <br>요구사항 변경 시 빠르게 대응 가능.
<br>결함 발생 확률 감소. <br>TDD 도입 판단 기준: <br>로직 복잡도: 복잡할수록 도입 우선순위가 높음.
<br>장애 비용: 장애 발생 시 손실이 크면 반드시 도입. <br>
<br>사례: 여러 팀이 API를 개발하고 사용하는 상황.
<br>이유: 인터페이스 사양이 변경되면 다른 팀에 영향을 줄 수 있음.
<br>장점: <br>명확한 명세서 제공으로 의사소통 오류 감소.
<br>코드 변경 시, 관련 기능이 깨지지 않도록 보호. <br>TDD 도입 판단 기준: <br>팀 간 의존도가 높을수록 도입 가치 증가.
<br>계약 기반 API 설계(contract-first approach)에 적합. <br>
<br>사례: 추천 시스템, 머신러닝 모델 전처리 로직.
<br>이유: 알고리즘의 정확도가 비즈니스 성과와 직결.
<br>장점: <br>다양한 입력 데이터에 대한 처리 검증 가능.
<br>결과의 일관성 유지. <br>TDD 도입 판단 기준: <br>입력/출력 데이터의 조합이 복잡할수록 필요성 증가.
<br>정형화된 테스트 케이스 작성이 용이한 경우 적합. <br>
<br>사례: 스타트업 초기 제품.
<br>이유: 빠른 피드백과 시장 검증이 우선.
<br>단점: <br>초기에는 개발 속도가 저하될 수 있음.
<br>불필요한 테스트 작성 가능성. <br>TDD 도입 판단 기준: <br>제품 성공 가능성이 높은 핵심 기능에만 제한적으로 적용.
<br>테스트는 리팩토링 이후 작성하는 방식을 병행. <br>
<br>사례: 장기 유지보수가 필요한 레거시 시스템.
<br>이유: 시간이 지나도 코드 품질을 유지해야 함.
<br>장점: <br>기존 코드를 안전하게 리팩토링 가능.
<br>신규 개발자 온보딩 시 유용한 학습 자료 제공. <br>TDD 도입 판단 기준: <br>유지보수 비용이 크거나, 새로운 요구사항이 자주 추가되는 프로젝트. <br>JUnit 5는 단위 테스트(Unit Test)를 작성하기 위한 핵심 도구입니다. Spring Boot는 기본적으로 JUnit 5를 지원하며, 다양한 애너테이션과 Assertions API를 통해 테스트를 쉽게 작성할 수 있습니다.<br>
<br>@Test <br>테스트 메서드를 정의. <br>@BeforeEach / @AfterEach <br>각각 테스트 메서드 실행 전후에 실행될 로직 정의. <br>@BeforeAll / @AfterAll <br>각각 테스트 클래스 실행 전후에 한 번만 실행. <br>@Disabled <br>테스트 메서드나 클래스를 비활성화. <br>@Tag <br>테스트 그룹화(tagging) 기능 제공. <br>
<br>assertEquals(expected, actual): 두 값이 동일한지 비교.
<br>assertTrue(condition): 조건이 참인지 확인.
<br>assertThrows(exception, executable): 특정 예외가 발생하는지 확인.
<br>import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*; class CalculatorTest { @Test void additionShouldBeCorrect() { Calculator calculator = new Calculator(); int result = calculator.add(2, 3); assertEquals(5, result, "2 + 3은 5여야 합니다."); } @Test void divisionShouldThrowExceptionForZero() { Calculator calculator = new Calculator(); assertThrows(ArithmeticException.class, () -&gt; calculator.divide(5, 0)); }
}
<br>
<br>빠른 실행: 단위 테스트는 다른 계층과 독립적이므로 빠르게 실행 가능.
<br>간단한 설정: 별도의 컨텍스트 로딩 없이 메서드 단위로 검증 가능.
<br>Spring Test Framework는 Spring Boot 애플리케이션의 통합 테스트를 지원합니다. 스프링 컨텍스트를 로드하여 Spring Bean, 의존성 주입, 데이터베이스 연동 등을 테스트할 수 있습니다.<br>
<br>
@SpringBootTest <br>전체 애플리케이션 컨텍스트를 로드.
<br>단위 테스트와 통합 테스트를 모두 지원.
<br>@SpringBootTest
class MyAppTests { @Test void contextLoads() { }
}
<br>@WebMvcTest
<br>컨트롤러 테스트 전용으로 사용.
<br>MVC 관련 빈만 로드하여 REST API 테스트에 최적화.
<br>@WebMvcTest(controllers = MyController.class)
class MyControllerTest { @Autowired private MockMvc mockMvc; @Test void shouldReturnDefaultMessage() throws Exception { mockMvc.perform(get("/api/hello")) .andExpect(status().isOk()) .andExpect(content().string("Hello, World!")); }
} <br>@DataJpaTest
<br>JPA와 관련된 빈만 로드하여 테스트 속도를 최적화.
<br>H2 Database와 함께 사용하여 데이터 계층 테스트.
<br>@DataJpaTest
class UserRepositoryTest { @Autowired private UserRepository userRepository; @Test void shouldSaveAndFindUser() { User user = new User("John Doe", "john@example.com"); userRepository.save(user); Optional&lt;User&gt; result = userRepository.findByEmail("john@example.com"); assertTrue(result.isPresent()); assertEquals("John Doe", result.get().getName()); }
} <br>4.@MockBean<br>특정 빈을 모킹하여 테스트 시 실제 구현체 대신 사용할 수 있음.
<br>@SpringBootTest
class MyServiceTest { @MockBean private MyRepository myRepository; @Autowired private MyService myService; @Test void shouldUseMockedRepository() { when(myRepository.findSomething()).thenReturn("Mocked Result"); String result = myService.getSomething(); assertEquals("Mocked Result", result); }
} <br>
<br>
JDBC 드라이버 준비 <br>테스트할 데이터베이스의 JDBC 드라이버를 다운로드하여 JMeter의 lib 디렉토리에 복사. <br>예: MySQL은 mysql-connector-java, PostgreSQL은 postgresql.jar. <br>
테스트 대상 애플리케이션 준비 <br>JPA가 사용하는 데이터베이스를 직접 테스트하려면 데이터베이스 접속 정보가 필요.
<br>Spring Boot 애플리케이션을 통해 동적으로 데이터를 생성하고 쿼리를 실행. <br>
<br>JMeter의 Thread Group에 JDBC Connection Configuration을 추가.
<br>설정: <br>Variable Name: 커넥션을 참조할 이름 (예: DBConnection).
<br>Database URL: JDBC URL (예: jdbc:mysql://localhost:3306/testdb).
<br>JDBC Driver class: 드라이버 클래스 이름 (예: com.mysql.cj.jdbc.Driver).
<br>Username/Password: 데이터베이스 접속 정보. <br>
<br>
Thread Group에 JDBC Request를 추가. <br>
설정: <br>Variable Name: 이전 단계에서 설정한 Variable Name 입력 (DBConnection).
<br>Query Type: <br>Select Statement: 데이터 조회 쿼리.
<br>Update Statement: 데이터 수정 쿼리. <br>Query: 실행할 SQL 쿼리. <br>예: SELECT * FROM users WHERE status = 'ACTIVE'; <br>
매개변수를 동적으로 설정하려면 Prepared Statement를 사용할 수 있음: <br>SQL: SELECT * FROM users WHERE age &gt; ?;
<br>Parameters: 30 (동적으로 전달할 값). <br>
<br>
Thread Group 설정: <br>Number of Threads (Users): 동시 실행 사용자 수.
<br>Ramp-Up Period: 사용자가 몇 초에 걸쳐 증가할지 설정.
<br>Loop Count: 각 사용자가 실행할 요청 반복 횟수. <br>
부하를 동적으로 변경: <br>스레드 그룹에서 Scheduler를 활성화하여 특정 시간 간격으로 부하를 증감 가능. <br>
<br>
HTTP 요청을 통해 JPA 메서드 호출 <br>REST API 엔드포인트를 호출하여 JPA 쿼리 실행.
<br>JMeter의 HTTP Sampler로 테스트: <br>URL: http://localhost:8080/api/users?status=ACTIVE
<br>Method: GET/POST. <br>
JPA 쿼리 매개변수 동적 설정 <br>REST API에 쿼리 매개변수 전달.
<br>JMeter의 CSV Data Set Config를 사용하여 다양한 입력값 시뮬레이션: <br>CSV 파일: age,status 25,ACTIVE 30,INACTIVE 35,ACTIVE<br>테스트 설정: <br>Parameter: ${age}와 ${status}로 대체. <br>
<br>
JMeter View Results Tree <br>쿼리 실행 결과 및 응답 시간 확인. <br>
Database Monitoring Tools <br>데이터베이스의 실행 계획(EXPLAIN) 확인.
<br>DB에서 쿼리 실행 시간, CPU 사용량, I/O 병목 파악. <br>
Spring Actuator Metrics <br>@Timed 애너테이션 또는 Actuator 메트릭을 통해 JPA 메서드의 실행 시간 측정. <br>
<br>
데이터베이스 상태 초기화 <br>테스트 전에 데이터베이스 상태를 초기화하여 결과의 일관성 유지. <br>
실제 환경과 동일한 설정 <br>실제 운영 환경의 DB 크기, 커넥션 풀 크기, 네트워크 조건을 반영. <br>
적정 부하 설정 <br>TPS(Transactions Per Second)를 기준으로 동시 요청 수 결정]]></description><link>http://lts.kr/study/dev-seminar/🔹-tdd에-대하여.html</link><guid isPermaLink="false">study/Dev Seminar/🔹 TDD에 대하여.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 19 Feb 2025 07:49:42 GMT</pubDate></item><item><title><![CDATA[🔻 Redis 캐쉬 전략 - hello 서비스에 적용하여 성능개선 가능성]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="http://lts.kr/?query=tag:Hello" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Hello</a> <a class="tag" href="http://lts.kr/?query=tag:Redis" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Redis</a> <a class="tag" href="http://lts.kr/?query=tag:Cash" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Cash</a> <a class="tag" href="http://lts.kr/?query=tag:설계" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#설계</a> <br> <a href="http://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="http://lts.kr?query=tag:Hello" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Hello">#Hello</a> <a href="http://lts.kr?query=tag:Redis" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Redis">#Redis</a> <a href="http://lts.kr?query=tag:Cash" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Cash">#Cash</a> <a href="http://lts.kr?query=tag:설계" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#설계">#설계</a><br>
<br>
Spring Cache Abstraction 사용 <br>Spring Boot는 @Cacheable, @CachePut, @CacheEvict와 같은 어노테이션을 제공하여 간단히 캐싱을 설정할 수 있습니다.
<br>Redis는 Spring의 캐시 추상화(CacheManager)를 구현하는 데 사용되며, 손쉽게 통합할 수 있습니다. <br>
데이터 계층 캐싱 <br>데이터베이스 조회를 대신하여 Redis에 데이터를 저장함으로써 반복적인 DB 호출을 줄입니다.
<br>예를 들어, 자주 조회되는 데이터(예: 상품 목록, 사용자 프로필)를 캐시에 저장하여 DB 부하를 줄일 수 있습니다. <br>
분할 키 전략(Key Partitioning) <br>Redis의 키는 고유해야 하므로, 데이터 유형에 따라 네임스페이스를 설정합니다.
<br>예: user:{id}, product:{id}와 같은 구조로 관리하여 충돌 방지. <br>
TTL(Time-To-Live) 설정 <br>캐시 데이터에 TTL을 설정하여 데이터가 일정 시간이 지나면 만료되도록 구성합니다.
<br>이를 통해 오래된 데이터를 제거하고 메모리 관리 효율성을 높일 수 있습니다. <br>
Eviction 정책 <br>Redis의 LRU(Least Recently Used) 정책을 활용하여 메모리 한계에 도달하면 오래 사용되지 않은 데이터를 제거합니다.
<br>필요에 따라 LFU(Least Frequently Used) 또는 FIFO(First In First Out) 정책을 선택. <br>
Multi-Level 캐싱 <br>Redis 캐시를 1차 캐시로 사용하고, 애플리케이션 내 로컬 메모리(예: Caffeine)를 2차 캐시로 설정하여 자주 액세스하는 데이터를 더 빠르게 제공합니다. <br>
대량 데이터 처리 <br>Redis의 Hash 또는 Set 자료구조를 사용하여 대량 데이터를 효율적으로 저장 및 관리합니다.
<br>예: 사용자의 여러 설정값을 Redis의 Hash로 저장. <br>
Pub/Sub를 활용한 캐시 무효화 <br>Redis의 Pub/Sub 기능을 사용하여 캐시 갱신이나 무효화 이벤트를 동기화합니다.
<br>이를 통해 여러 인스턴스 간 캐시 일관성을 유지할 수 있습니다. <br>
분산 환경에서 캐시 <br>Redis는 클러스터링과 샤딩을 통해 분산 환경에서 확장성을 제공합니다.
<br>Spring Boot 애플리케이션이 여러 인스턴스에서 실행 중이라면, 단일 Redis 서버 또는 클러스터를 활용하여 공유 캐시를 사용할 수 있습니다. <br>
<br>
DB 쿼리 감소 <br>자주 사용하는 데이터를 Redis에 저장하여 DB 호출 횟수를 줄입니다.
<br>읽기 요청이 많은 서비스에서 DB 부하를 대폭 감소시킬 수 있습니다. <br>
빠른 데이터 액세스 <br>Redis는 메모리 기반 데이터 저장소로, 읽기/쓰기 속도가 매우 빠릅니다. 이는 데이터베이스와 비교해 성능을 극대화할 수 있습니다. <br>
높은 확장성 <br>Redis는 샤딩 및 클러스터링을 통해 수평적으로 확장할 수 있어, 트래픽 증가에 효과적으로 대응 가능합니다. <br>
데이터 동기화 비용 절감 <br>여러 애플리케이션 인스턴스에서 동일한 Redis 캐시를 사용함으로써 데이터 동기화 비용을 줄입니다. <br>
캐시 적중률 증가 <br>캐시 히트율이 높아지면 요청 응답 속도가 비약적으로 증가합니다. 이를 통해 사용자 경험(UX)을 향상시킬 수 있습니다. <br>
결과적으로 비용 절감 <br>DB 스케일링이나 고사양 서버로의 업그레이드 비용을 절감할 수 있습니다. <br>
<br>
데이터 일관성 <br>캐시와 데이터베이스 간의 일관성 문제가 발생할 수 있습니다. 이를 해결하기 위해 TTL, Pub/Sub, 캐시 무효화 전략을 적절히 사용해야 합니다. <br>
메모리 사용량 <br>Redis는 메모리 기반이므로, 메모리 관리에 주의해야 합니다. TTL 설정과 적절한 Eviction 정책을 적용해야 합니다. <br>
복잡성 증가 <br>Redis 캐시 도입은 초기 설정과 유지보수 복잡도를 증가시킬 수 있습니다. <br>
<br>모든 데이터가 메모리에 저장되어 읽기 및 쓰기 속도가 매우 빠릅니다.
<br>레이지 이베이션(Lazy Eviction): 메모리 초과 시 LRU(Least Recently Used), LFU(Least Frequently Used) 등의 정책으로 데이터를 자동 제거.
<br>데이터가 메모리에서 처리되기 때문에 실시간 분석, 캐싱, 세션 관리와 같은 고속 처리가 필요한 작업에 적합.
<br>
<br>Redis는 단순 문자열(String)뿐 아니라 다음과 같은 다양한 데이터 구조를 지원합니다: <br>String: 단순 키-값 저장.
<br>Hash: 필드와 값을 저장하는 Key-Value Map 구조.
<br>List: 순서가 있는 문자열 리스트.
<br>Set: 고유한 값들의 집합.
<br>Sorted Set: 값과 함께 점수(Score)를 저장하며, 정렬된 집합.
<br>Stream: 로그 데이터나 메시지 스트리밍을 위한 데이터 구조.
<br>HyperLogLog: 메모리 효율적인 고유 값 개수 추정.
<br>Bitmap: 비트 조작 가능.
<br>Geospatial: 지리적 좌표를 저장하고 반경 검색 지원. <br>
<br>RDB (Redis DataBase) 스냅샷: 특정 시간 간격으로 데이터를 디스크에 저장.
<br>AOF (Append Only File): 모든 쓰기 연산을 로그로 저장하여 데이터 복원 가능.
<br>RDB와 AOF를 조합해 사용할 수 있어 데이터 손실과 복원 속도를 조정 가능.
<br>
<br>Redis는 퍼블리셔-구독자(Pub/Sub) 모델을 지원합니다.
<br>메시지 브로커처럼 동작하며, 다수의 클라이언트 간 메시지를 주고받을 수 있습니다.
<br>채널 또는 패턴 기반 메시징 지원.
<br>
<br>Redis Cluster: <br>데이터를 여러 노드에 분산 저장.
<br>노드 간 데이터 자동 샤딩 및 장애 복구 제공. <br>Sentinel: <br>마스터-슬레이브 복제를 관리하여 고가용성 제공.
<br>마스터 장애 시 자동 장애 조치 및 슬레이브 승격. <br>
<br>서버에서 실행할 수 있는 Lua 스크립트를 지원하여 일괄 처리나 원자적 연산이 가능.
<br>클라이언트-서버 간 왕복 비용을 줄이고 성능 최적화.
<br>
<br>초당 수백만 개의 읽기/쓰기 요청을 처리할 수 있는 속도를 자랑.
<br>낮은 지연 시간과 높은 처리량 제공.
<br>
<br>각 키에 TTL(Time-To-Live)을 설정하여 만료 시간을 지정 가능.
<br>Redis는 다양한 메모리 정책을 지원하여 메모리 사용량 관리: <br>noeviction, allkeys-lru, allkeys-lfu, volatile-lru, volatile-lfu, volatile-ttl 등. <br>
<br>Redis는 MULTI, EXEC, WATCH 명령어를 통해 트랜잭션 지원.
<br>기본적으로 모든 명령은 원자적으로 처리되며, MULTI/EXEC로 묶어서 실행 가능.
<br>
<br>Master-Slave 구조를 통해 데이터를 복제.
<br>마스터에서 발생한 모든 데이터 변경 사항이 슬레이브 노드로 전파.
<br>읽기 분산 및 장애 복구 시 활용.
<br>
<br>위치 정보를 기반으로 거리 계산 및 반경 검색을 수행.
<br>예: 특정 반경 내의 상점 목록 검색.
<br>
<br>Redis CLI: 기본 제공 명령줄 도구로 상태 점검 및 관리 가능.
<br>INFO 명령어: 메모리 사용량, 연결, 키 개수 등 서버 상태를 제공.
<br>다양한 대시보드 도구와 통합 가능(예: RedisInsight).
<br>
<br>수평 확장을 지원하여 대규모 트래픽을 처리 가능.
<br>클러스터링, 샤딩, 복제를 통해 장애를 대비한 고가용성 보장.
<br>
<br>Redis는 오픈소스이므로 자유롭게 사용 가능.
<br>클라우드 제공 업체(AWS ElastiCache, Azure Redis Cache, Google Cloud Memorystore)와 쉽게 통합 가능.
<br>
<br>Stream 처리: 실시간 데이터 스트림 저장 및 처리 가능.
<br>Bloom Filter 및 Cuckoo Filter: 확률적 자료구조 지원.
<br>Modules: 확장 기능(예: RedisJSON, RedisGraph, RedisAI) 추가 가능.
<br>
<br>빠른 성능: 메모리 기반 아키텍처로 낮은 지연 시간과 높은 처리량 제공.
<br>다양한 데이터 구조: 폭넓은 데이터 유형을 효율적으로 저장 및 관리.
<br>유연성: 캐싱, 메시징, 세션 관리 등 다양한 사용 사례에 적합.
<br>확장성: 클러스터링과 복제를 통해 대규모 트래픽 처리 가능.
<br>간단한 설정: 빠른 설치와 간단한 설정으로 쉽게 시작 가능.
<br>
<br>메모리 한계: Redis는 메모리 기반이므로 큰 데이터를 다룰 경우 메모리 용량이 제한 요인이 될 수 있음.
<br>데이터 손실 가능성: AOF를 사용하지 않거나 RDB만 사용하면 마지막 스냅샷 이후 데이터가 손실될 가능성이 있음.
<br>멀티쓰레드 부재: Redis는 기본적으로 싱글쓰레드로 동작하므로, CPU 활용 측면에서 제한이 있을 수 있음.
<br>
<br>캐시와 DB 간의 일관성 문제를 발생시키지 않을 select(조회) 쿼리, 재사용률이 높은 데이터 <br>다른 프로젝트 인스턴스에서 데이터 교환이 자주 일어나는 경우 <br>
<br>사용자 별로 문서 크기가 크게 상이해도 동적으로 메모리를 관리하여 저장 실패 확률을 줄일수 있다.
<br>장애가 발생 하더라도 앱서버와 분리되어있으므로 서비스 영향도를 더욱 줄일 수있을것 같다.
<br>
<br>정적오브젝트 로딩 후 동작하는 js특성
<br>다양한 오브젝트를 저장할 수 있는 redis특성 사용
<br>로직을 변경 하지 않고, 재진입시 js대기 시간을 크게 줄일 수 있을것으로 생각됨
<br><img alt="Pasted image 20241206140739.png" src="http://lts.kr/사진-및-문서/pasted-image-20241206140739.png" target="_self"><br><img alt="Pasted image 20241206140822.png" src="http://lts.kr/사진-및-문서/pasted-image-20241206140822.png" target="_self"><br>
<br>
이러한 경우 재 조회나, 검색 필터 적용시 데이터 최신화 필요도가 떨어지기 때문에, 캐쉬 전략을 사용했을 때<br>
데이터를 받아오는 시간을 크게 줄일 수 있을것으로 예상됨 <br>
또한 성공 실패여부 및 횟수를 저장하여 리트라이 로직 등도 추가할 수있으며,<br>
모든 프로젝트의 api에 공통으로 적용하여 사용할 수 있음. <br> "coordinates": [<br>
128.0827,<br>
37.6061<br>
],<br>
위도/경도 및 시간 정보를 캐쉬에 취합 후, 영구저장 DB 대분류(지역 및 시간대) 로 카운트를 집계하여,<br>
마케팅 요청시 광고 타겟 위치 및 시간대를 지정하여 광고 요청을 한다면 적은비용 대비 높은 효과를 기대할 수 있다.]]></description><link>http://lts.kr/study/dev-seminar/🔻-redis-캐쉬-전략-hello-서비스에-적용하여-성능개선-가능성.html</link><guid isPermaLink="false">study/Dev Seminar/🔻 Redis 캐쉬 전략 - hello 서비스에 적용하여 성능개선 가능성.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 19 Feb 2025 07:48:02 GMT</pubDate><enclosure url="http://lts.kr/사진-및-문서/pasted-image-20241206140739.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="http://lts.kr/사진-및-문서/pasted-image-20241206140739.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[📔 DB 테이블 설계, 어떻게 하는게 옳은 방법인가]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="http://lts.kr/?query=tag:DB" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#DB</a> <a class="tag" href="http://lts.kr/?query=tag:DataBase" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#DataBase</a> <a class="tag" href="http://lts.kr/?query=tag:설계" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#설계</a> <br> <a href="http://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="http://lts.kr?query=tag:DB" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#DB">#DB</a> <a href="http://lts.kr?query=tag:DataBase" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#DataBase">#DataBase</a> <a href="http://lts.kr?query=tag:설계" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#설계">#설계</a><br><img alt="Pasted image 20241220113308.png" src="http://lts.kr/사진-및-문서/pasted-image-20241220113308.png" target="_self"><br>
<img alt="Pasted image 20241220113315.png" src="http://lts.kr/사진-및-문서/pasted-image-20241220113315.png" target="_self"><br>
<br>위 예시의 경우 데이터를 행(Row)이 아닌 열(Column)로 저장한 것으로 보인다.
<br>
<br>
페이지가 10개를 초과하면 새로운 페이지에 대해 var11, var12 등의 컬럼을 추가로 만들어야한다. ( 실제로 일어날 뻔 했다. ) <br>
이는 테이블 스키마를 수정하는 작업이며, 다음과 같은 위험을 수반한다. <br>서비스 중단: 테이블 스키마 변경 중 데이터베이스가 잠기거나 애플리케이션이 중단될 가능성이 있다.
<br>코드 변경 필요: 새로운 컬럼에 맞춰 애플리케이션 로직(예: 데이터 입력, 조회 쿼리)을 수정해야 한다.
<br>관리 복잡성 증가: 테이블 구조가 복잡해져 유지보수 비용이 증가한다. <br> -현재 구조는 hit 수 외의 추가 정보를 기록하기 어렵다. ( 나중에 추가해달라고 할것같음. ) <br>예: 페이지별 방문자의 디바이스 정보, 지역 정보 등. <br>
<br>열로 데이터를 저장하면 특정 페이지의 hit 수를 조회할 때, 각 컬럼을 명시적으로 참조해야 합니다. <br>예: 특정 날짜에 대해 var1 ~ var10의 데이터를 모두 합산하려면 SELECT var1 + var2 + ... + var10 FROM table 같은 비효율적인 쿼리를 작성해야 합니다. <br>페이지별 hit 데이터를 통계적으로 분석하려는 경우(예: 총합, 평균 등) 쿼리가 복잡해지며, 컬럼이 늘어나면 쿼리 수정이 필요합니다.
<br>idx (PK) | xdate (PK) | page_id | hit_count
--------------------------------------------- 1 | 20241208 | var1 | 21 2 | 20241208 | var2 | 15 3 | 20241209 | var1 | 13
<br>새로운 페이지를 추가할 때 스키마 변경 불필요.
<br>스토리지 효율성 향상 (0 또는 NULL 값 제거).
<br>데이터 분석 및 통계 작업 간소화.
<br>검색, 집계 성능 최적화 가능.
<br>변경 전 (비정규화된 테이블):<br>
<br>맞다. var1, var2 .. 는 각기 다른 페이지의 hit를 저장한다.
<br>하지만, "페이지의 hit 수"라는 속성에서 본다면, 동일한 의미를 여러 셀에 분산 저장한다고 볼 수 있다.<br>
따라서 데이터의 동일 속성을 위반했다고 볼 수 있다.<br>따라서 다음과 같이 각 컬럼이 진짜 원자값을 갖도록 수정할 수 있다.<br>다음과 같은 형태를 띄게 된다.<br>
<br>여기서, category는 page_name에 종속되어있으며, page_name은 page_id에 종속되어있다.
<br>페이지 속성(비기본 속성)들이 기본키의 부분적으로 종속되어있다.<br>hit_count는 xdate, page_id를 기본키로 갖는다 <br>category는 page_name를 종속하며, page_name은 page_id -&gt; page_id처럼 간접 종속을 하기 때문에 만족<br>속성 A → 속성 B → 속성 C로 이루어진 종속 관계에서, A가 C를 직접 결정하지 않고, B를 통해 C를 결정하는 경우를 말한다.<br>해당 테이블에서 간접 종속을 제외한다.<br>]]></description><link>http://lts.kr/study/dev-seminar/📔-db-테이블-설계,-어떻게-하는게-옳은-방법인가.html</link><guid isPermaLink="false">study/Dev Seminar/📔 DB 테이블 설계, 어떻게 하는게 옳은 방법인가.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 19 Feb 2025 07:44:41 GMT</pubDate><enclosure url="http://lts.kr/사진-및-문서/pasted-image-20241220113308.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="http://lts.kr/사진-및-문서/pasted-image-20241220113308.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🥈 필기 5과목 - 정보시스템 구축관리]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:정보처리기사" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정보처리기사</a> <a class="tag" href="http://lts.kr/?query=tag:필기" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#필기</a> <a class="tag" href="http://lts.kr/?query=tag:정리" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정리</a> <br> <a href="http://lts.kr?query=tag:정보처리기사" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정보처리기사">#정보처리기사</a> <a href="http://lts.kr?query=tag:필기" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#필기">#필기</a> <a href="http://lts.kr?query=tag:정리" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정리">#정리</a> <br>
<br>클래스 인터페이스
<br>명령어(사용자 질의 수)
<br>데이터 파일
<br>출력 보고서
<br>흭공개운유<br>
<br>네트워크 변화에 신속히 대처할 수 있다.
<br>거리 벡터 라우팅 프로토콜 이라고 한다.
<br>멀티캐스팅을 지원한다.
<br>최단 경로 탐색에 다익스트라 알고리즘을 사용한다.
<br>
<br>클래스 설계서
<br>통합시험 결과서
<br>프로그램 코드
<br>사용자 요구사항 정의서
<br>
<br>암호화 키와 복호화 키가 동일한 암호화 알고리즘을 뜻한다.
<br>
<br>COCOMO
<br>Putnam
<br>Function-Point
<br>PERT
<br>
<br>비교적 실행속도 빠르기 때문에, 다양한 암호의 핵심 함수로 사용될 수 있다.
<br>키 교환을 필요로 하기 때문에, 키를 교환하는 중 탈취가 될 가능성이 있다.
<br>
<br>자신만이 보관하는 비밀키를 이용하여 인증, 전자서명 등에 적용이 가능하다.
<br>- 캡슐화를 통해 모듈화를 강화하고, 설계 및 구현의 변경에 따른 영향을 최소화 함으로써 품질을 향상시킨다.
<br>- 재사용 가능한 모듈들을 제공함으로써 예산을 절감한다.
<br>- 다형성을 통한 인터페이스 확장이 가능하여 다양한 형태와 기능을 가진 애플리케이션 개발이 가능하다.
<br>- 개발자가 관리하고 통제해야 하는 객체들의 제어를 프레임워크에 넘김으로써 생상선을 향상시킴
<br>
<br>벨만-포드 알고리즘 사용
<br>RIP프로토콜 ( 최대 홉 개수 15개 )
<br>인접 라우터와 주기적으로 정보 교환
<br>
<br>다익스트라 알고리즘 사용
<br>OSPF프로토콜 ( 최대 홉 개수 제한 없음 )
<br>최단 경로, 최소 지연, 최대 처리량
<br><a data-href="🥇 정보처리 기사 실기 키워드" href="http://lts.kr/study/정보처리기사/정보처리기사-실기/🥇-정보처리-기사-실기-키워드.html" class="internal-link" target="_self" rel="noopener nofollow">🥇 정보처리 기사 실기 키워드</a>]]></description><link>http://lts.kr/study/정보처리기사/정보처리기사-필기/🥈-필기-5과목-정보시스템-구축관리.html</link><guid isPermaLink="false">study/정보처리기사/정보처리기사 필기/🥈 필기 5과목 - 정보시스템 구축관리.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 19 Feb 2025 06:34:52 GMT</pubDate></item><item><title><![CDATA[🥈 필기 4과목 - 프로그래밍 언어 활용]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:정보처리기사" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정보처리기사</a> <a class="tag" href="http://lts.kr/?query=tag:필기" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#필기</a> <a class="tag" href="http://lts.kr/?query=tag:정리" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정리</a> <br> <a href="http://lts.kr?query=tag:정보처리기사" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정보처리기사">#정보처리기사</a> <a href="http://lts.kr?query=tag:필기" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#필기">#필기</a> <a href="http://lts.kr?query=tag:정리" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정리">#정리</a> <br> 다른 프로세스가 뺐지 못하는 상태.
<br>#### - 최적의 경로를 산출하기 위한 정보로서 홉(거리 값)만을 고려하므로, RIP를 선택한 경로가 ==최적의 경로가 아닌경우가== 많이 발생할 수 있다.
<br>
<br>두 모듈이 매개변수로 자료를 전달할 때, 자료구조 형태로 전달되어 이용될 때 데이터가 결합되어 있다고 한다.
<br>
<br>하나의 모듈이 직접적으로 다른 모듈의 내용을 참조할 때 두 모듈은 내용적으로 결합되어 있다고 한다.
<br>
<br>두 모듈이 동일한 전역 데이터를 접근한다면 공통결합 되어 있다고 한다.
<br>결합도 - 두 모듈간의 상호작용, 또는 의존도 정도를 나타내는 것.<br>// a[0]의 주소값이 0일때, int a[] = {14, 22, 30, 38}; printf("%u", &amp;a[2]); =&gt; a[2]자리의 첫번째 주소값 -&gt; 18
printf("%u", a); =&gt; a[0]자리의 첫번째 주소값 -&gt; 10 주소값 a[0] 14 =&gt; 10,11,12,13 / a[1] 22 =&gt; 14,15,16,17 / a[2] 30 =&gt; 18,19,20,21 / a[3] 38 =&gt; 22,23,24,25 <br>권한이 있는 사용자들만 접근할 수 있는 보안 방법
<br>자원에 대한 접근을 사용자나 그룹의 신분에따라 제한, 자원의 소유권을 가진 사람이 다른 사람의 접근을 허용하거나 제한할 수 있음
<br>미리 정해진 자원의 보안 레벨과 사용자에게 허락된 접근권한비교
<br>
<br>5만 라인 이하
<br>사무 처리용, 업무용, 과학용 소프트웨어 개발에 적합
<br>
<br>30만라인 이하
<br>컴파일러, 인터프리터 개발에 적합
<br>
<br>30만 라인 이상
<br>미사일 유도시스템, 실시간 처리 시스템 개발에 적합
<br>네트워크상에서 공유되는 파일시스템. 다른 원격 호스트의 파일 시스템을 로컬 디스크에 접근하듯 간단하게 접근하여 자신의 디렉토리처럼 사용할 수 있다.
<br>네트워크 보안을 위한 유틸리티. 네트워크의 보안을 위해 물리적 연결과 어떤 서버와 운영 체제가 작동 중인지 따위를 조사하는 응용 프로그램.
<br>어떤 프로젝트를 마치기까지 수행되는 작업의 각 단계(상태)를 그래프의 정점으로 표현하고, 작업 하나가 완료되어 다음 단계로 넘어가는 시간을 그래프의 간선으로 나타낸 방향 그래프.
<br>네트워크를 제어부, 데이터 전달부로 분리하여 네트워크 관리자가 보다 효율적으로 네트워크를 제어, 관리할 수 있는 기술. 기존의 라우터, 스위치 등과 같이 하드웨어에 의존하는 네트워크 체계에서 안정성, 속도, 보안 등을 소프트웨어로 제어, 관리하기 위해 개발됨. 네트워크 장비의 펌웨어 업그레이드를 통해 사용자의 직접적인 데이터 전송 경로 관리가 가능하고, 기존 네트워크에는 영향을 주지 않으면서 특정 서비스의 전송 경로 수정을 통하여 인터넷상에서 발생하는 문제를 처리할 수 있음.
<br>작업들 간의 상호 관련성, 결정경로, 경계시간, 자원할당 등을 제시한다.
<br>각 작업들이 언제 시작하고 언제 종료되는지에 대한 일정을 막대 도표를 이용하여 표시한다. 시간선(Time-line)차트 라고도 한다. 수평 막대의 길이는 각 작업의 기간을 나타낸다.
<br>내공 외제 스자<br>1의 개수가 27개 즉 11111111 11111111 11111111 11100000<br>
0 0 0 0 0 1 1 1<br>
1 2 4 8 16 32 64 128 -&gt; 32 + 64 + 128 = 224<br>
<br>프로세스가 두개일때, 상호 배제를 보장하는 최초의 알고리즘
<br>flag와 turn변수를 사용하여 조정
<br>
<br>프로세스 n개의 상호 배제 문제를 해결한 알고리즘
<br>프로세스에게 고유한 번호를 부여하고, 번호를 기준으로 우선순위를 정하여 우선순위가 높은 프로세스가 먼저 임계구역에 진입하도록 구현
<br>
<br>프로세스가 두개일때 상호배제를 보장. 데커 알고리즘과 유사하지만 상대방에게 진입 기회를 양보한다는 차이
<br>
<br>공유된 자원의 데이터 혹은 임계영역 등에 따라 여러 Process혹은 Thread가 접근하는 것을 막아줌
<br><a data-href="🥈 필기 5과목 - 정보시스템 구축관리" href="http://lts.kr/study/정보처리기사/정보처리기사-필기/🥈-필기-5과목-정보시스템-구축관리.html" class="internal-link" target="_self" rel="noopener nofollow">🥈 필기 5과목 - 정보시스템 구축관리</a>]]></description><link>http://lts.kr/study/정보처리기사/정보처리기사-필기/🥈-필기-4과목-프로그래밍-언어-활용.html</link><guid isPermaLink="false">study/정보처리기사/정보처리기사 필기/🥈 필기 4과목 - 프로그래밍 언어 활용.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 19 Feb 2025 06:34:48 GMT</pubDate></item><item><title><![CDATA[🥈 필기 3과목 - 데이터베이스 구축]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:정보처리기사" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정보처리기사</a> <a class="tag" href="http://lts.kr/?query=tag:필기" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#필기</a> <a class="tag" href="http://lts.kr/?query=tag:정리" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정리</a> <br> <a href="http://lts.kr?query=tag:정보처리기사" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정보처리기사">#정보처리기사</a> <a href="http://lts.kr?query=tag:필기" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#필기">#필기</a> <a href="http://lts.kr?query=tag:정리" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정리">#정리</a> <br>0 or 1
<br>트렌젠션 전/후 같아야함
<br>다른 트렌젝션의 간섭 X
<br>트렌젝션 커밋 결과가 영구히 저장
<br>하드웨어와 소프트웨어의 물리적 위치를 사용자가 알 필요 없다. 논리적인 명칭으로만 엑세스할 수 있음
<br>사용자에게 통지할 필요없이 시스템 안에 파일들과 자원들의 부가적인 복사를 자유롭게 할 수 있다.
<br>다중 사용자들이 자원들을 자동으로 공유할 수 있다.
<br>사용자들은 어는 위치의 시스템에 장애가 발생했는지 알 필요가 없다.
<br>트렌젝션 모델링 / 독립적인 개념 스키마 모델링 / 개념스키마 설계 / E-R 다이어그램
<br>트렌젝션 인터페이스 설계 / DBMS에 맞는 논리스키마 설계 / 테이블설계 / 논리적 맵핑 / 스키마 평가 및 정제
<br>레코드 집중의 분석,설계 / 저장레코드 양식 설계 / 저장 구조 및 엑세스 경로 설정
<br>각 릴레이션의 기본키를 구성하는 속성은 null값이나 중복값을 갖을 수 없음.
<br>외래키 값은 null이거나 참조하는 릴레이션의 기본키와 값이 동일해야 한다.
<br>특정 속성에 대해 고유한 값을 가지도록 조건이 주어진경우, 릴레이션의 각 튜플이 가지는 속성 값들은 서로 달라야 한다.
<br>각 릴레이션은 최소한 한 개 이상의 키가 존재해야 한다.
<br>릴레이션 내의 튜플들이 각 속성의 도메인에 지정된 값만을 가져야 한다.
<br>도메인 : 하나의 에트리뷰트가 가질 수 있는 원자값들의 집합<br><a data-href="🥈 필기 4과목 - 프로그래밍 언어 활용" href="http://lts.kr/study/정보처리기사/정보처리기사-필기/🥈-필기-4과목-프로그래밍-언어-활용.html" class="internal-link" target="_self" rel="noopener nofollow">🥈 필기 4과목 - 프로그래밍 언어 활용</a>]]></description><link>http://lts.kr/study/정보처리기사/정보처리기사-필기/🥈-필기-3과목-데이터베이스-구축.html</link><guid isPermaLink="false">study/정보처리기사/정보처리기사 필기/🥈 필기 3과목 - 데이터베이스 구축.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 19 Feb 2025 06:34:46 GMT</pubDate></item><item><title><![CDATA[🥈 필기 2과목 - 소프트웨어 개발]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:정보처리기사" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정보처리기사</a> <a class="tag" href="http://lts.kr/?query=tag:필기" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#필기</a> <a class="tag" href="http://lts.kr/?query=tag:정리" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정리</a> <br> <a href="http://lts.kr?query=tag:정보처리기사" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정보처리기사">#정보처리기사</a> <a href="http://lts.kr?query=tag:필기" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#필기">#필기</a> <a href="http://lts.kr?query=tag:정리" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정리">#정리</a> <br>
<br>프로그램의 하위 모듈에서 상위 모듈 방향으로 통합
<br>하나의 주요 제어 모듈과 관련된 종속 모듈의 그룹인 클러스터 필요
<br>
<br>상위 모듈에서 하위 모듈방향으로 통합
<br>깊이 우선 통합법, 넓이 우선 통합법 사용
<br>초기부터 사용자에게 시스템 구조를 보여줌
<br>
<br>사용사례를 확장하여 명세하거나 설계 다이어그램, 원시코드, 테스트 케이스 등에 적용할 수 있다.
<br>복잡한 알고리즘 또는 반복, 실시간 동작, 병행 처리와 같은 기능이나 동작을 이해하려고 할 때 유용하다.
<br>단순한 테스트 케이스를 이용하여 프로덕트를 수작업으로 수행해 보는 것이다.
<br>요구사항 명세서 작성자를 포함하여 사전 검토한 후에 짧은 검토 회의를 통해 결함을 발견
<br>
<br>요구사항 명세서 작성자를 제외한 다른 검토 전문가들이 요구사항 명세서를 확인하면서 결함을 발견
<br>9 / 12 / 14 / 25<br>
<br>기초 경로 검사 -&gt; 화이트 박스 테스트
<br>동치 클래스 분해
<br>경계값 분석
<br>원인 결과 그래프
<br>- 소프트웨어 품질 평가를 위한 소프트웨어 품질평가 통합모델의 표준
- `SQuaRE`라고도 한다.
- 기존 평가모델인 `ISO/IEC9126` 과 `ISO/IEC14598`을 통합하였다.
<br>- 소프트웨어의 내부 및 외부 품질과 사용 품질에 대한 모델 등, 품질 모델 부분을 다룬다.
<br>- 소프트웨어의 내부 측정, 외부 측정, 사용품질 측정 등 품직 측정 부분을 다룬다.
<br>
<br>특정한 몇몇 테스트 케이스의 입력 값들에 대해서만 기대하는 결과를 제공하는 오라클이다.
<br>
<br>모든 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공하는 오라클
<br>
<br>특정 테스트 케이스의 입력값에 대해 기대하는 결과를 제공하고, 나머지 입력값들에 대해서는 추정으로 처리
<br>
<br>애플리케이션의 변경이 있을 경우 테스트 케이스의 수행 전과 후의 결과값이 동일한지를 확인하는 오라클
<br><a data-href="🥈 필기 3과목 - 데이터베이스 구축" href="http://lts.kr/study/정보처리기사/정보처리기사-필기/🥈-필기-3과목-데이터베이스-구축.html" class="internal-link" target="_self" rel="noopener nofollow">🥈 필기 3과목 - 데이터베이스 구축</a>]]></description><link>http://lts.kr/study/정보처리기사/정보처리기사-필기/🥈-필기-2과목-소프트웨어-개발.html</link><guid isPermaLink="false">study/정보처리기사/정보처리기사 필기/🥈 필기 2과목 - 소프트웨어 개발.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 19 Feb 2025 06:34:45 GMT</pubDate></item><item><title><![CDATA[🥈 필기 1과목 - 소프트웨어 설계]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:정보처리기사" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정보처리기사</a> <a class="tag" href="http://lts.kr/?query=tag:필기" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#필기</a> <a class="tag" href="http://lts.kr/?query=tag:정리" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#정리</a> <br> <a href="http://lts.kr?query=tag:정보처리기사" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정보처리기사">#정보처리기사</a> <a href="http://lts.kr?query=tag:필기" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#필기">#필기</a> <a href="http://lts.kr?query=tag:정리" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#정리">#정리</a> <br>
<br>클래스 인터페이스
<br>명령어(사용자 질의 수)
<br>데이터 파일
<br>출력 보고서
<br>흭공개운유<br>
<br>네트워크 변화에 신속히 대처할 수 있다.
<br>거리 벡터 라우팅 프로토콜 이라고 한다.
<br>멀티캐스팅을 지원한다.
<br>최단 경로 탐색에 다익스트라 알고리즘을 사용한다.
<br>
<br>클래스 설계서
<br>통합시험 결과서
<br>프로그램 코드
<br>사용자 요구사항 정의서
<br>
<br>암호화 키와 복호화 키가 동일한 암호화 알고리즘을 뜻한다.
<br>
<br>COCOMO
<br>Putnam
<br>Function-Point
<br>PERT
<br>
<br>비교적 실행속도 빠르기 때문에, 다양한 암호의 핵심 함수로 사용될 수 있다.
<br>키 교환을 필요로 하기 때문에, 키를 교환하는 중 탈취가 될 가능성이 있다.
<br>
<br>자신만이 보관하는 비밀키를 이용하여 인증, 전자서명 등에 적용이 가능하다.
<br>- 캡슐화를 통해 모듈화를 강화하고, 설계 및 구현의 변경에 따른 영향을 최소화 함으로써 품질을 향상시킨다.
<br>- 재사용 가능한 모듈들을 제공함으로써 예산을 절감한다.
<br>- 다형성을 통한 인터페이스 확장이 가능하여 다양한 형태와 기능을 가진 애플리케이션 개발이 가능하다.
<br>- 개발자가 관리하고 통제해야 하는 객체들의 제어를 프레임워크에 넘김으로써 생상선을 향상시킴
<br>
<br>벨만-포드 알고리즘 사용
<br>RIP프로토콜 ( 최대 홉 개수 15개 )
<br>인접 라우터와 주기적으로 정보 교환
<br>
<br>다익스트라 알고리즘 사용
<br>OSPF프로토콜 ( 최대 홉 개수 제한 없음 )
<br>최단 경로, 최소 지연, 최대 처리량
<br><a data-href="🥈 필기 2과목 - 소프트웨어 개발" href="http://lts.kr/study/정보처리기사/정보처리기사-필기/🥈-필기-2과목-소프트웨어-개발.html" class="internal-link" target="_self" rel="noopener nofollow">🥈 필기 2과목 - 소프트웨어 개발</a>]]></description><link>http://lts.kr/study/정보처리기사/정보처리기사-필기/🥈-필기-1과목-소프트웨어-설계.html</link><guid isPermaLink="false">study/정보처리기사/정보처리기사 필기/🥈 필기 1과목 - 소프트웨어 설계.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 19 Feb 2025 06:34:43 GMT</pubDate></item><item><title><![CDATA[🎩 DevOps]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="http://lts.kr/?query=tag:DevOps" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#DevOps</a> <a class="tag" href="http://lts.kr/?query=tag:CI/CD" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#CI/CD</a> <br> <a href="http://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="http://lts.kr?query=tag:DevOps" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#DevOps">#DevOps</a> <a href="http://lts.kr?query=tag:CI/CD" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#CI/CD">#CI/CD</a><br>
<br>애플리케이션을 실행하는데 필요한 모든 구성 요소와 기능을 갖춘 소프트웨어이다.
<br>전체 실행(runtime)환경에서 애플리케이션을 패키징하고 격리할 수 있는 기술이다.
<br>
컨테이너화 된 애플리케이션은 환경(개발/테스트/프로덕션)에 쉽게 이동할 수 있다. <br>
컨테이너 파이프라인에 보안을 구축하고 인프라를 보호하여 컨테이너의 안정성, 확장성, 신뢰성을 보장할 수 있다. <br>
일관된 행동과 기능으로, 퍼블릭/프라이빗/클라우드 간에 쉽게 이동이 가능하다. <br>
<br>담당 영역을 분리하여 개발 팀과 운영 팀간의 충돌을 줄일 수 있다.
<br>오픈기술을 기반으로 하기 때문에, 최신 기술을 활용하여 다양하고 강력한 기술의 제품을 채택할 수 있다.<br>
ex) docker / k8s 등등
<br>클라우드 네이티브 개발 방식에 필요한 기반 기술을 제공한다.
<br>
<br>전사적으로 배포를 관리할 수 있는 방법이다.
<br>k8s(쿠버네티스)는 컨테이너 작업을 자동화하는 오픈소스 플랫폼이다.
<br>컨테이너화 된 애플리케이션을 배포하고 확장하는데 수동 프로세스를 필요로 하지 않는다.
<br>docker는 전통적인 LXC와 다르다. docker도 처음에는 LXC기반으로 개발되었지만 이후, 이러한 종속관계에서 벗어났다.
LXC는 경량/가상화 기술은 뛰어났지만 사용자환경은 그에 미치지 못햇다.
하지만 docker는 컨테이너를 실행하는 것 이상의 다양한 생성/구축/이미지전송 등의 프로세스 관리를 용이하게 해준다.
<br>- 젠킨스는 지속적 통합(CI)및 지속적 배포(CD)도구로, 개발 프로세스의 빌드, 테스트, 배포 등을 자동화하고 관리해주는 도구이다.
<br>
<br>개발자들이 작성한 코드를 중앙 저장소에 자주 통합하고, 자동화된 빌드와<br>
테스트를 통해 문제를 빠르게 발견하고 해결할 수 있게 해주는것.
<br>
<br>모든 변경사항을 자동화된 테스트와 빌드를 거친 후 실제 서버에 자동으로<br>
배포하는 기술. ( 현제 HF서비스에서는 ArgoCD를 사용하여 진행한다. )
<br>
<br>이러한 구조를 통해 다양한 환경에서 동시에 빌드와 테스트를 수행할 수 있으며,<br>
부하 분삭 및 확장성을 제공한다.
<br>
<br>젠킨스는 소스코드관리(SCM)시스템과 통합하여 변경사항이 발견될때<br>
자동으로 빌드 및 테스트를 실행할 수 있다.<br>
웹훅이나 폴링 방식을 사용하여 scm시스템에서 변경사항을 감지하고<br>
해당작업을 트리거한다.
<br>
<br>젠킨스는 빌드 및 테스트작업이 완료되면 해당결과와 로그를 저장한다.<br>
이를 통해 빌드 실패의 원인을 찾거나 테스트 결과를 검토할수 있다.
<br>
<br>젠킨스는 빌드, 테스트 및 배포 과정에서 발생하는 로그와 메트릭을 수집하고<br>
분석하여 성능문제, 장애, 최적화 포인트 등을 식별할 수 있다.
<br>
<br>
개발자가 소스코드 변경사항을 SCM 시스템에 푸시한다. <br>
젠킨스는 웹훅이나 폴링 방식을 통해 변경사항을 감지하고 Jenkinsfile에 정의된 파이프라인을 실행한다. <br>
젠킨스는 마스터노드에서 슬레이브 노드로 작업을 할당하고 슬레이브 노드에서 빌드, 테스트 , 배포 작업을 수행한다. <br>
각 단계에서 필요의 경우, 플러그인을 사용하여 다양한 도구와 통합하여작업을 수행할 수 있다. <br>
작업이 완료되면 젠킨스는 결과와 로그를 저장하고 개발자에게 알림을 전송한다. <br> Linux 컨테이너를 만들고 사용할 수 있도록 하는 컨테이너화 기술이다. 컨테이너를 매우 가벼운 모듈식 가상 머신처럼 다룰 수 있으며, 컨테이너를 구축, 배포, 복사, 이동 등 유연하게 사용할 수 있도록 도와준다. 애플리케이션을 클라우드에 최적화 하도록 지원한다.
<br>
<br>커널과 네임스페이스 등 Linux의 기능을 사용하여 프로세스를 분리함으로 써, 독립적으로 실행할 수 있도록 한다.
<br>개별적으로 실행하여 인프라를 더 효과적으로 활용하고 개별시스템을 사용할 때와 동일한 보안을 유지할 수 있도록 한다.
<br>이미지 기반 배포 모델을 제공하여, 여러 환경에서 종속 항목과 손쉽게 공유 할 수 있다.
<br>
<br>모듈성 <br>컨테이너화에 대한 docker의 접근방식은 전체 애플리케이션을 분해하지 않고도 업데이트 또는 복구를 가능하게 한다 <br>계층 및 이미지 버전제어 <br>docker의 이미지파일은 일련의 계층으로 구성되며 이러한 계층들은 단일 이미지로 결합된다.<br>
이러한 이미지 계층을 재사용하여 구축 속도가 빠르며, 각 계층화에는 버전 제어가 가능하다. <br>롤백 <br>롤백 기능을 제공하여 이전 이미지 버전으로 롤백이 가능하다. <br>신속한 배포 <br>이전에는 하드웨어 확보, 실행, 프로비저닝, 테스트 하는데에 몇일이 걸렸으나, docker기반의 컨테이너는 배포 시간을 몇 초로 줄일 수 있다. <br>
<br>
도커는 애플리케이션 뿐만 아니라, 실행에 필요한 시스템 환경을 모아서 컨테이너로 관리한다. 이것을 Docker Image라고 한다. <br>
이 이미지로 만든 컨테이너는 도커가 설치된 곳이라면 어디든 똑같이 작동함을 보장한다. <br>
개발자가 커밋할때마다, Jenkins와 같은 CI( 지속적 통합 )툴이 해당 소스를 도커 이미지로 빌드하고, 이미지 레파지토리에서 이미지를 버전별로 관리한다. <br>
해당 이미지를 배포 하면, 독립적으로 동작하기 때문에 CD( 지속적인 배포 )또한 가능하게 된다. <br>
이러한 특징은 MSA와도 잘 맞는데, 각각의 서비스를 컨테이너로 배포하는 것이다. <br>
<br>쿠버네티스는 "컨테이너화된 애플리케이션"을 배포, 관리, 확장 할때 수반되는 다수의 "수동 프로세스를 자동화"하는 오픈소스 "컨테이너 오케스트레이션 플랫폼"이다.
<br>1. 프로비저닝 및 배포
2. 구성 및 일정 조정
3. 리소스 할당
4. 컨테이너 가용성 체크
5. 로드밸런싱 기반 컨테이너 스케일링
6. 트래픽 라우팅
7. 컨테이너 상세 모니터링
8. 컨테이너 간 상호작용 및 보안
<br>
<br>클러스터 <br>컨트롤 플레인 및 하나 이상의 컴퓨팅 머신 또는 노드를 뜻한다. <br>컨트롤 플레인 <br>쿠버네티스 노드를 제어하는 프로세스의 컬렉션. 여기에 모든 태스크 할당이 시작된다. <br>kubelet <br>노드에서 실행되며, 컨테이너 매니패스트를 읽고, 정의된 컨테이너가 실행중인지 확인한다. <br>포드(Pod) <br>단일 노드에 배포된 하나 이상의 컨테이너 그룹. 포드에 있는 모든 컨테이너는 IP주소.호스트 이름, 기타 리소스 등을 공유한다. <br> 작동 중인 쿠버네티스 배포를 클러스터라고 한다. 클러스터는 컨테이너를 실행하는 호스트 그룹으로, 컨트롤 플레인과 컴퓨팅머신의 2개 부분으로 시각화 할 수 있다.
<br> Docker는 쿠버네티스가 오케스트레이션하는 컨테이너의 런타임으로 사용할 수 있다. 쿠버네티스가 노드에 대해 pod을 예약하면 해당 노드의 kubelet(각 컨테이너의 실행을 보장하는 서비스)가 지정된 컨테이너를 실행하도록 Docker에 명령한다. 이후, kubelet은 Docker로 부터, 지속적으로 상태를 수집하고 컨트롤 플레인에서 해당 정보를 집계한다.
<br>** 한줄 요약 : docker는 k8s가 시키는데로(이미짜여진대로, 자동으로) 컨테이너를 실행한다.<br>- DevOps(개발과 운영을 통합하여 효율성,협력,안정성을 개선하는 개발/운영 방법론)의 실천 방법중 하나로, 애플리케이션 배포와 운영에 관련된 모든요소를 Git에서 관리(Opertation)한다는 뜻이다.
- Git의 버전관리 시스템과 운영환경간의 일관성을 유지하여 소프트웨어간의 불일치 문제를
해결할 수 있다.
<br>- GitOps를 구현하기 위한 도구 중 하나로, k8s애플리케이션의 자동배포(CD)를 위한 오픈소스 도구 이다.
k8s클러스터에 배포된 애플리케이션의 CD를 담당한다.
- Git저장소에서 변경사항을 감지하여 자동으로 k8s클러스터에 애플리케이션을 배포한다.
<br>
<br>쿠버네티스는 클러스터 안에서 컨테이너 애플리케이션이나 네트워크 설정, 배치 실행을 하는 Job등<br>
리소스를 작성한다. 이와 같은 구체적인 설정 정보를 파일로 관리하는데,<br>
이것이 매니페스트파일(manifest file)이라고 한다.
<br>JSON이나 YALM 파일로 작성되며, 오브젝트를 생성하기 위해 필요한 파일이기도 하다.
<br> local브랜치에서 작업 후 각(dev/stg/prod)프로젝트로 소스를 통합(merge)한다.
<br>jar, 메니페스트 file 등 소스,배포에 필요한 파일들 이미지 화
<br> Jenkin에서 이미지화된 배포에 필요한 파일,소스들을 ArgoCD로 Pull한다.
<br> Jenkins에서 받은 이미지파일과 매니패스트파일을 기반으로 실제 서버에 배포한다.
<br><img alt="Pasted image 20240531162124.png" src="http://lts.kr/사진-및-문서/pasted-image-20240531162124.png" target="_self"><br>
<br>두가지 모두 소스코드 저장소 호스팅 플랫폼이며, 기술적 기반을 깃(Git)으로 삼는다는 점에서 비슷하다.
<br>기본 기능은 같지만, 서비스의 초점이 조금 다른곳에 맞추어져 있다.
<br>
<br>깃허브와 깃랩의 가장 큰 차이점은 데브옵스 요소에 있다.
<br>
<br>즉 깃랩은 젠킨스와 아르고와 같은 CI/CD 도구들을 사용하지 않아도 자체적으로 파이프라인을 구성하여 간단하고 빠른 배포가 가능하다. 하지만 우리는 깃랩은 사용하지만, 깃랩CI/CD는 사용하고 있지 않은 상태이다.
<br>
<br>그덕에 신속한 배포가 가능하고, 문제 발생시 이전 버전으로 신속하게 복원할 수 있다.
<br>
<br>프로덕션과 스테이징의 분기가 최소한으로 있으며, 이러한 여러 다중 분기 접근방식은 여러단계의 테스트로 안정적인 유지가 가능하게 한다. 한편 이러한 이유로 병합및 수정시 코드 검토가 까다로워진다.
<br><img alt="Pasted image 20240722180706.png" src="http://lts.kr/사진-및-문서/pasted-image-20240722180706.png" target="_self"><br>
<br>ELK란 elastic / logstash / kibana 의 앞글자를 딴 시슷템으로<br>
데이터를 수집, 처리, 조회 하는데 특화되어있는 시스템이다.
<br>
<br>인덱스란 ? - 단일 데이터 단위를 도큐먼트라고 하며, 이 도큐먼트를 모아놓은 집합을 인덱스라고 한다.
<br>
<br>인덱스 용량이 증가함에 따라 운영부담과 비용이 크게 증가한다.
<br>튜닝을 통한 안정화에 한계가 있다.
<br>
<br>
수평 확장이 가능하다 <br>
가용성 높은 다중 테넌트 로그 집계가 가능하다 <br>
로그에 대한 메타데이터만 인덱싱한다. 즉 레이블을 기반으로 구축되어있다. <br>
로그 내용을 색인화 하는것이 아닌, 레이블 세트를 색인화 하기 때문에 데이터 량을 감소시킬 수 있다. <br>
검색시 레이블 기반으로만 조회하고, 레이블과 매칭된 압축된 로그 데이터를 가져와 사용한다. <br>
<br>풀텍스트 검색시 기존 ELK대비 느리다.
<br>쿼리언어를 새로이 학습해야한다.
<br>레퍼런스가 부족하다.
<br>]]></description><link>http://lts.kr/study/cs/🎩-devops.html</link><guid isPermaLink="false">study/CS/🎩 DevOps.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 19 Feb 2025 06:34:27 GMT</pubDate><enclosure url="http://lts.kr/사진-및-문서/pasted-image-20240531162124.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="http://lts.kr/사진-및-문서/pasted-image-20240531162124.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🍃 Spring]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="http://lts.kr/?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <a class="tag" href="http://lts.kr/?query=tag:FRAMWORK" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#FRAMWORK</a> <br> <a href="http://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="http://lts.kr?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a> <a href="http://lts.kr?query=tag:FRAMWORK" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#FRAMWORK">#FRAMWORK</a><br>1. 컴파일러에게 코드작성 문법에러를 체크하도록 정보 제공
2. 빌드나 배치시 코드를 자동으로 생성할수 있도록 정보 제공
3. 실행시 특정 기능을 수행하도록 정보 제공
<br>- Spring컨테이너에 의해 관리되는 재사용 가능한 컴포넌트이다.
즉 스프링이 관리하는 자바 객체 이다.
- getter/setter를 포함한다.
<br>이때 객체가 생성된다면 싱글톤 패턴으로 생성이 된다. ** Spring Framework의 도움을 받으면 단점을 줄이고 장점을 사용할 수 있다.
<br>*@Controller / @Service / @Repository 등의 어노테이션을 포함한다.<br>
싱글톤패턴?<br>인스턴스(객체)가 오직 한개만 생성된다
<br>장점 : 메모리낭비를 방지한다.<br>
이미 생성된 객체를 재사용하기 때문에 속도가 빠르며<br>
전역으로 사용되는 인스턴스이기 때문에 데이터공유가 쉽다.
<br>단점 : 테스트에 어려움이있다.<br>
자식클래스를 만들수없다.<br>
내부의 상태를 변경하기 어렵다.
<br> - 컴포넌트와 컨트롤러 모두 Bean객체를 등록하지만
컨트롤러는 url과 클래스를 이어주는 역할을 할 수 있다.
<br>JAVA오브젝트로 자동 변환해준다. (Controller기준 받는 입장)
<br>프론트앤드에서 Ajax요청시 JSON형식으로 값이 넘어오는데,<br>
이 JSON형식을 받을때 사용하는 어노테이션이다. <br>자동으로 자바객체로 바꿔준다.
<br>- 외부API에서 name으로 넘긴 값을 String name에 저장함.
<br>- Autowired/생성자/setter 이렇게 총 3가지 방법으로 의존성을 주입받을 수 있다.
<br>- 경로변수는 {id}로 둘러싸인 값을 의미한다.
- 주로 상세조회, 수정, 삭제 등의 작업에서 리소스 식별자로 사용된다.
<br>하이버네이트가 오브젝트를 대신 갱신한다.
<br>*빌더 패턴이란? : 생성자에 파라미터를 주입하여 생성하는것이 아닌, 별도의 Builder를 두어서 객체를 생성하는것을 말한다.
생성자가 없는경우 : 모든 맴버 변수를 파라미터로 받는 기본 생성자 생성
생성자가 있는 경우 : 따로 생성자를 생성하지 않음
<br>@Getter/@Setter/@ToString/@EqualsAndHashCode/@RequiredArgsConstructor를 자동으로 적용시켜준다.
<br>@NonNull이나 final이 붙은 필드값 들에 대해 생성자를 자동으로 생성해준다. ( @Autowired를 사용하지 않고 의존성주입이 가능하다)
해당 어노테이션을 사용하면 클래스가 의존하고 있는 필드를 간단하게 초기화할 수 있다.
<br>해당 어노테이션을 사용하면 클래스의 모든 필드값을 한 번에 초기화할 수 있다.
<br>해당 어노테이션을 사용하면 클래스에 명시적으로 선언된 생성자가 없더라도 인스턴스를 생성할 수 있다. 개발자가 실수로 클래스의 필드 중 하나의 필드에 대한값 설정을 누락 시킬수도 있어, 객체는 불완전한 상태가 되어버린다.
이를 방지하고자 모든 필드값을 가지도록 강제하고 싶다면, AccessLevel.PROTECTED 속성을 부여해줘 해결할 수 있다.
다음과 같은 속성을 부여해주면, 기본 생성자의 접근 제어가되어 IDE단계에서 누락을 방지할 수 있다.
<br>- equals는 두 객체의 내용이 같은지, 동등성을 비교하는 연산자이다.
- hashcode는 두 객체가 같은 객체인지, 동일성을 비교하는 연산자 이다.
<br>
<br>생성자의 파라미터가 많은 경우 가독성이 떨어진다. <br>빌더패턴으로 생성하는 경우 각 값들이 함수로 셋팅이되고, 각각 무슨값들이 어떠한 것을을 의미하는지 파악하기가 수월하다.<br>
ex)<br>
Bag bag = new Bag("name", 1000, "memo", "20", "30");<br>
vs<br>
Bag bag = Bag.builder()<br>
,name("name")<br>
,money(1000)<br>
,memo("memo")<br>
,won(20)<br>
,dolor(30)<br>
,build(); <br>어떠한 값을 먼저 넣더라도 상관없다(순서x) <br>생성자의 경우 정해진 파라미터대로 값을 입력해야 정해진 값에 매핑이 되지만, 빌더패던의 경우 필드 이름을 기준으로 값을 삽입하게 때문에 순서를 생각하지 않아도 된다. <br>
<br>@NoArgsConstructor로 기본 생성자의 생성을 방지하고, @Builder를 이용하여 객체의 생성에 유연성을 준다.<br>
이때, 이 2개의 어노테이션을 함께 사용하기 위해서는 @AllArgsConstructor 어노테이션이 필요하다.
<br>이유 : @Build는 위에서 설명한 바와 같이 생성자가 없다면 모든 파라미터를 갖는 생성자를 생성하지만, @NoArgsConstructor로 인해 아무런 생성자를 생성하지 않는다. 이때 build메서드를 사용하여 모든파라미터를 받는 메서드(생성자)를 동작시키면 매칭되는 생성자가 없기때문에 오류를 야기한다.<br>
따라서 @AllArgsConstructor 어노테이션을 추가로 작성하여 해결할 수 있다.<br>더 깔끔한 방법으로는 직접 생성자를 생성해주고, 빌더 패턴에서 해당 생성자를 사용하도록 하는 방법도 있다.<br>- 위 두개의 어노테이션을 편리하게 생성자를 자동으로 생성해 주지만, 주의를 요할 필요가 있다.
<br>어떠한 클래스에서 순서대로 인자를 받는 생성자가 있다고 했을 때, 개발자가 임의로 순서를 변경할 경우, 리펙토링은 전혀 작동하지 않고, lombok이 개발자가 인지하지 못하는 사이에 순서에 맞춰 두 필드를 변경해 버린다.
<br>그렇기 때문에 순서의 구애받지 않는 @Builder 어노테이션을 사용한는 것을 권장하고 있다.
<br> Mutable(변경가능한)객체에 아무런 파라미터 없이 그냥 사용하는 경우에 문제가 발생할 수 있다.
<br>동일한 객체임에도 불구하고 Set으로 필드값을 변경하게 되면, hashCode가 변경되면서 찾을 수 없게되는 부분이 있다. <br>- 위에서 설명한 @RequiredArgsConstructor 및 @EqualsAndHashCode를 포함하고 있기 때문에 사용을 피하는 것이 좋다.
<br>- 불변 클래스를 생성해주는 @Value또한, @EqualsAndHashCode와 @AllArgsConstructor를 포함하고 있기 때문에 사용을 피하는것이 좋다. - 불변클래스 이기 때문에 @EqualsAndHashCode는 문제가 되지 않지만, AllArgsConstructor가 문제를 일으킬 가능성이 있다.
<br>- 두가지 모두 브라우저 저장 장소이다.
주로, 휘발성 데이터를 저장할 목적을 갖고있다. <br>	@Component public class Controller{ @Autowired private Service servic ... }
<br>- 단일책임의 원칙 위반
- 의존성을 주입하기 쉽기 때문에, @Autoqwired아래에 개수 제한없이 추가할 수 있다.
- 이때, 하나의 class가 많은 책임을 갖고, 순환참조가 이뤄질 수도 있기 때문에
의존성이 높아져, 사용을 피하는것이 좋다.
<br>	@Component public class Controller{ private Service servic @Autowired private void setService(Service servic){ this.service = service; } }
<br>선택적인 의존성을 사용할때 유용하다.<br>
스프링 3.x 에서는 수정자 주입을 권장하고있다.<br>- 수정자 주입을 사용하게 되면, service구현제를 주입하지 않아도 controller객체는 생서이 가능하기때문에 널포인터익셉션이 발생할 가능성이 있다.
주입이 필요한 객체가 주입되지 않아도 얼마든지 객체를 생성할 수 있다는것이 문제다.
<br>	@Component public class Service{ private DAO dao; //생성자 @Autowired private Service(DAO dao){ this.dao = dao; } } @Component public class Controller{ private final Service servic = new Service( new DAO( ) ); }
<br>- Spring Framework 에서 권장하는 방법으로, 필수적으로 사용해야하는 의존성 없이는 객체를 만들지 못하도록 강제할 수 있기
때문에 사용을 권장하고 있다.
- Spring 4.3 버전 이후부터는 Class를 완벽하게 DI Framework로 부터
분리할 수 있다.
- 단일 생성자에 한해서 @Autowired를 붙이지 않아도 된다.
- 필드 주입과 수정자 주입은 final로 선언할 수 없지만, 생성자 주입은 final로 필드 객체를 선언하여 런타임에 불변성을 보장한다.
- 앞서 설명한 필드 주입의 모든 단점을 보완할 수 있다.
<br>하지만 실무에서는 필드 주입을 주로 사용한다.<br>
이유 : 가장 구현하기 쉽고, 읽기 편하기 때문이다.<br>Spring에서의 데이터 검증(Validation)은 여러 계층에 거쳐서 발생한다.<br>
여기서, 가장 기본적인 검증 방법은 Bean Validation이다.<br>'필드'에 특정 어노테이션을 적용하여 필드가 갖는 제약 조건을 정의하는 구조로 이루어진 검사다.<br>
validator가 그 클래스로 생성된 객체의 유효성 여부를 확인한다.<br>
이때, 어떠한 비즈니스로직에 대한 검증이 아닌, 객체 자체 필드에 대한 검증을 한다.
<br>	@RestController @AllArgsConstructor public class BookController { private BookService bookService; @PostMapping("/books") public void save(@RequestBody @Valid AddBookRequestDto addBookRequestDto, BindingResult bindingResult) { if(bindingResult.hasErrors()) { bindingResult.getAllErrors() .forEach(objectError-&gt;{ System.err.println("code : " + objectError.getCode()); System.err.println("defaultMessage : " + objectError.getDefaultMessage()); System.err.println("objectName : " + objectError.getObjectName()); }); return; } bookService.save(addBookRequestDto.toEntity()); }
<br>-&gt; 여기서@Valid 어노테이션이 Request에 있는 방인된 객체(dto)의 유효성을 확인하고<br>
유효하지 않은객체라면 BindingResult 파라미터에 들어가게 된다.<br>그렇다면, @PathVariable과 @RequestParam은 어떻게 유효성 검사를 진행할까?<br>
클래스에 @Validated 어노테이션을 등록해 주면 된다.
@RestController<br>
@Validated<br>
public class UserController {
} <br>- Entity와 관련된 코드들은 많은데 비해 Dto의 경우는 상대적으로 적다.
그런 상황에서 Entity의 변경가능성은 Dto의 비해서 또 적다.
만약 Entity를 Request나 Respons에 사용하게 된다면 변경 가능성이 높아지고,
동시에 같이 변경되는 코드들이 늘어나기 때문에 코드 유지보수를 생각했을때 분리하는것이 옳다.
<br>- 엔티티 매니저는 DB커넥션처럼 사용된다. 즉, 엔티티매니저를 절대 공유해서는 안된다.
하나의 스레드에서만 사용해야하며, 사용이 끝나면 반납해야한다.
그 이유는 트렌젝션 단위로 엔티티매니저를 사용하기 때문이다.
여러 쓰레드가 동시에 사용하게 된다면 영속성 과 DB간의 데이터동기화가 깨지게 되기 때문이다.
<br>- 저장 프로시저는 각 DBMS에서 제공하는 기능으로, SQL문을 저장해놓고, 필요할 때마다 호출해서 사용하는 프로그래밍 기능이다.
<br>
<br>
SQL의성능을 향상시킬수 있다. <br>SP를 실행하게 되면 최적화, 컴파일 단계를 거쳐, 결과가 캐시에 저장되게 되는데,<br>
이 후 해당 SP를 실행하게 되면 캐시에 있는것을 가져와 사용하므로 실행속도가 빠르다. <br>
유지보수 및 재활용 측면에서 유리하다. <br>응용프로그램 내에서 직접 SQL문을 호출하지않고 SP이름을 호출하도록 설정하면<br>
SP파일만 수정하면 되기때문에 유지보수와 재활용 측면에서 유리하다 <br>
보안이 강화될 수 있다. <br>사용자별로 테이블 권한을 부여하는것이 아닌, SP에만 접근 권한을 주는 방식으로 보안을 강화할 수 있다.<br>
실제 테이블에 접근하여 조작하는것이 위험하기 때문에 개발자에게는 SP권한만 주는 방식을 많이 사용한다. <br>또한, 일반적인 쿼리들은 Where의 조건이 조금만 달라져도, 최적화 컴파일을 다시 수행하여야 하지만,<br>
함수 형태의 SP로 생성하게 되면 매개변수만 변경하여 성능적인 측면을 크게 높일 수 있다.<br>1. DB에서 SP를 생성한다( 미리 작성되어있는 쿼리 모음 )
2. SP의 리턴값을 저장하는 Entity클래스(@NamedStoredProcedureQuery어노테이션)으로 연결함.
3. Repository에서 프로시저 객체를 생성한다. 이때, 2.에서 생성한 프로시저JPA의 파라미터를 설정한 후 execute한다.
<br>궁금한점 : 저장 프로시저를 사용할경우 Entity는 테이블명으로 class와 연결하지 않아도 괜찮은것인가?<br>@NamedStoredProcedureQuery어노테이션을 Entity에 적용하면 DBMS에 정의 되어있는 SP(저장 프로시저)<br>
와 연동하여 사용할 수 있다.
<br>	String username = "java"; String jpql = "select m from Member m where m.username = :username"; List&lt;Member&gt; result = em.createQuery(query, Member.class).getResultList()
<br>jpql이란 JPA의 일부로, 쿼리를 Table이 아닌 객체 기준으로 작성하는 객체지향 쿼리 언어 이다.<br>문제점 : String형태 이기 때문에 개발자 의존적인 형태를 띈다.<br>
컴파일 단계에서 Type-Check가 불가능하다.<br>
런타임 단계에서 오류가 발생한다.(장애 리스크가 증가한다)<br>	String username = "java"; List&lt;Member&gt; result = queryFactory .select(member) .from(member) .where(usernameEq(username)) .fetch();
<br>QueryDSL은 해당 문제를 해결하기 위해서 나온 기능이다.<br>장점 : 문자가 아닌 코드로 쿼리를 작성할 수 있어 컴파일 시점에 문법오류 확인 가능.<br>
IDE의 자동완성 기능의 도움을 받을 수 있다.<br>
복잡한 쿼리나 동적 쿼리 작성이 편하다.<br>
쿼리 작성시 제약조건 등 메서드를 추출해서 재사용할 수 있다.<br>- 두 클래스 모두 JPA에서 동적쿼리를 제작할 때 사용한다.
BooleanBuilder는 if문을 각 데이터 조건에 맞게 코드로 작성할 수 있도록 도와주는 역할을 한다.
<br>BooleanExpression 는 메서드를 생성하여 where절 안에서 호출하여 구현할 수 있다.<br>
메서드 안에서 where절로 null이 반환되면 해당 조건이 무시되기 때문에 동적쿼리가 가능하다.<br>
(모든 조건이 NULL을 반환하면 전체 엔티티를 불러오는 점을 주의하자)<br>
메서드는 재사용이 가능하고, 메서드들 끼리 재조합도 가능하기 때문에 유지보수나, 재활용에 유리하다.<br>*동적쿼리 - 실행시점에서, 사용자나 프로그램의 사정에따라 쿼리의 조건이나 구조를 동적으로 결정할때 사용.<br>- SQL문법과 유사하게 복잡한 쿼리를 제작할 수 있게 도와주는 SPRING의 JPA지원 클래스이다.
<br>ex)<br> private RemainDto firstList(DashBoardModel model) { return factory .select( Projections.fields( RemainDto.class, cfProductInvest.amount.sum().coalesce(0L).as("total"), new CaseBuilder() .when(cfProduct.category.eq("2")) .then(cfProductInvest.amount) .otherwise(0L).sum().coalesce(0L).as("estate"), new CaseBuilder() .when(cfProduct.category.ne("2")) .then(cfProductInvest.amount) .otherwise(0L).sum().coalesce(0L).as("noneEstate") ) ) .from(cfProductInvest) .leftJoin(cfProduct) .on(cfProductInvest.productIdx.eq(cfProduct.idx)) .leftJoin(g5Member) .on(cfProductInvest.memberIdx.eq(g5Member.mbNo)) .where( g5Member.mbId.eq(model.getMbId()), cfProductInvest.investState.eq("Y") ) .fetchOne(); }
<br>- 스프링배치는 엔터프라이즈 시스템의 강력한 배치 어플리케이션을 개발할 수 있도록 설계된 배치프레임워크이다.
- 일괄처리(Batch Processing), 분산처리 작업을 효율적으로 처리할 수있는 기능 제공.
- 로깅/추적, 트렌잭션관리, 작업 처리통계, 작업재시작, 리소스관리 등 대용량 레코드 처리에 필수적인 기능을 제공
- SpringBatch는 JobRepository로 동작하는데, 여기에 Job / JobLauncher / Step이 포함되어있다.
<br>SpringBatch는 대량의 데이터를 일괄적으로 처리할 뿐<br>
특정 주기마다 자동으로 돌아가는 스케줄링 기능은 없다.<br>
단지, 스케줄러와 함계 사용할 수 있도록 설계되어있을 뿐이다.
<br>그렇기 때문에 스케줄링 라이브러리인 Quartz라이브러리를 추가하여 같이 사용한다.<br>
<br>독립적으로 실행할 수 있는 고유하며 순서가 지정된 스텝의 목록
<br>애플리케이션 실행시 Job으로 인식되는 bean들이 자동으로 실행된다.
<br>1개 이상의 Step을 포함하여 원하는 동작을 실행시킬 수 있다
<br>배치 처리 과정 중 전체 계층의 최상단에 위치도
<br>
<br>job의 구성요소로 자체적인 입력/출력/처리를 가질 수 있다.
<br>tasklet 또는 Chunk기반 처리를 포함하여 step안에서 수행될 기능들을 명시할 수 있다.
<br>트렌젝션은 step내에서 이루어진다. 때문에, 독립되도록 의도적으로 설계된 것이다.
<br>
<br>Step의 작업 단위를 Tasklet으로 정의
<br>주로 간단한 작업(단일 데이터 처리, 파일 삭제 등)에 적합하다.
<br>@Component
public class SimpleTasklet implements Tasklet { @Override public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception { System.out.println("Tasklet 방식으로 작업 수행"); return RepeatStatus.FINISHED; }
} @Bean
public Step step1(StepBuilderFactory stepBuilderFactory) { return stepBuilderFactory.get("step1") .tasklet(new SimpleTasklet()) .build();
} @Bean
public Job job(JobBuilderFactory jobBuilderFactory, Step step1) { return jobBuilderFactory.get("job") .start(step1) .build();
} <br>
<br>대량 데이터를 일정 크기(chunk)로 나누어 처리한다.
<br>Reader / Processor / Writer로 구성된다.
<br>@Bean
public FlatFileItemReader&lt;String&gt; reader() { return new FlatFileItemReaderBuilder&lt;String&gt;() .name("fileReader") .resource(new ClassPathResource("input.txt")) .lineMapper(new DefaultLineMapper&lt;String&gt;() { { setLineTokenizer(new DelimitedLineTokenizer()); setFieldSetMapper(new PassThroughFieldSetMapper()); } }) .build();
} @Bean
public ItemProcessor&lt;String, String&gt; processor() { return item -&gt; "Processed " + item;
} @Bean
public FlatFileItemWriter&lt;String&gt; writer() { return new FlatFileItemWriterBuilder&lt;String&gt;() .name("fileWriter") .resource(new FileSystemResource("output.txt")) .lineAggregator(new PassThroughLineAggregator&lt;&gt;()) .build();
} @Bean
public Step step(StepBuilderFactory stepBuilderFactory) { return stepBuilderFactory.get("step") .&lt;String, String&gt;chunk(10) .reader(reader()) .processor(processor()) .writer(writer()) .build();
} @Bean
public Job job(JobBuilderFactory jobBuilderFactory, Step step) { return jobBuilderFactory.get("job") .start(step) .build();
} <br>
<br>잡 리스너를 이용해서 스프링batch 생명주기의 여러로직을 추가할 수 있다.<br>
ex) beforeJob , afterJob 등등
<br>=&gt; 스케줄러는 Jenkins에서 SSH스크립트를 통해 주기적으로 실행한다. Controller에 POST주소가 맵핑되어있는 이유는 테스트로 직접 실행하기 위함이다.<br>
<br>Tasklet 방식과 Chunk 방식 모두 사용 가능하지만, 보통 Chunk방식에서 사용한다.
<br>
<br>대량 데이터를 효율적으로 처리하기 위해 데이터를 여러 개의 작은 조각(Partition)으로 나눠 병렬적으로 처리하는 기술입니다. Spring Batch에서 파티셔닝은 마스터-슬레이브 패턴을 사용하며, 마스터는 작업을 분할하고 슬레이브는 각각의 분할된 작업을 수행합니다.
<br>import org.springframework.batch.core.partition.support.Partitioner;
import org.springframework.batch.item.ExecutionContext;
import java.util.HashMap;
import java.util.Map; public class RangePartitioner implements Partitioner { @Override public Map&lt;String, ExecutionContext&gt; partition(int gridSize) { Map&lt;String, ExecutionContext&gt; partitions = new HashMap&lt;&gt;(); int min = 1; // 데이터베이스 ID의 최소값 int max = 5; // 데이터베이스 ID의 최대값 int targetSize = (max - min) / gridSize + 1; // 각 Partition의 범위 크기 int start = min; int end = start + targetSize - 1; for (int i = 0; i &lt; gridSize; i++) { ExecutionContext context = new ExecutionContext(); context.putInt("minId", start); // 시작 ID context.putInt("maxId", end); // 종료 ID partitions.put("partition" + i, context); start += targetSize; end += targetSize; } return partitions; }
}
<br>
<br>데이터베이스에 100개의 레코드가 있음.
<br>gridSize = 4: 데이터를 4개의 Partition으로 나눔.
<br>chunkSize = 10: 각 Partition에서 데이터를 10개씩 읽어 처리.
<br>스레드 풀 크기 = 4: 4개의 Partition이 동시에 실행 가능.
<br>코드가 여러줄 나올거같진 않아서 방식은<br>
페어 프로그래밍 방식으로 진행하도록 하죠<br>개발 절차는 이렇게 갈 예정이에요<br>Chunk, Partioning방식을 Job을 추가 개발 (기존 balanceJob 유지)
<br>당분간 두 Job을 병행하면서 비교
<br>추가한 Job 기능에 문제없다면 기존 balanceJob 삭제
<br>
<br>
Partition 생성: <br>Partition 1: ID 1 ~ 25
<br>Partition 2: ID 26 ~ 50
<br>Partition 3: ID 51 ~ 75
<br>Partition 4: ID 76 ~ 100 <br>
각 Partition에서 Chunk 처리: <br>Partition 1: <br>Chunk 1: ID 1 ~ 10 → 커밋
<br>Chunk 2: ID 11 ~ 20 → 커밋
<br>Chunk 3: ID 21 ~ 25 → 커밋 <br>Partition 2: <br>Chunk 1: ID 26 ~ 35 → 커밋
<br>Chunk 2: ID 36 ~ 45 → 커밋
<br>Chunk 3: ID 46 ~ 50 → 커밋 <br>나머지 Partition도 동일 방식으로 처리. <br>
병렬 실행: <br>스레드 풀 크기 = 4이므로 4개의 Partition이 동시에 실행됩니다.
<br>Partition 처리 순서는 스레드 풀에서 처리되는 순서에 따라 다를 수 있음. <br>
트랜잭션 관리: <br>각 Partition은 독립적인 트랜잭션을 가짐.
<br>각 Chunk가 커밋될 때마다 트랜잭션이 종료됨. <br>투자신청기록쪽 api -&gt; API레스폰스모델<br>
웹플럭스(비동기 기반)을 사용해서 service프로젝트와 (내부)통신한다.<br>내부통신을 위해 필요한 헤더, url등을 생성해야하기 때문에 senderutils 클래스를 공통(빈)을 정의해서 만들어 통신.<br>retrieve ** 중요<br>
웹클라이언트 클래스 객체를 사용해서 uri 콘텐츠 등등 헤더와 바디(데이타)를 정의한다<br>
<br>스프링5에서 소개된 리엑티브 프로그래밍, 반응형 및 비동기적인 웹 어플리케이션 개발을 지원하는 모듈이다.<br>
<img alt="Pasted image 20240611144129.png" src="http://lts.kr/사진-및-문서/pasted-image-20240611144129.png" target="_self">
<br>*리엑티브 프로그래밍이란 ?<br>
- 비동기 및 이벤트 기반 애플리케이션을 개발하기 위한 패러다임으로, 주로 높은 확장성과 성능을 제공하는것<br>내부통신을 이용하여 API프로젝트와 통신할때 주소 맵핑이 어떻게 이루어지는지??<br>
- Spring WebClient를 이용하여 내부 통신을 한다.<br>
<br>
SpringWebFlux의 일부로써, 비동기적인 방식으로 HTTP 요청을 보내고 응답을 받을 수 있는 라이브러리이다. <br>
웹으로 API를 호출하기 위해 사용되는 HTTP Client모듈 중 하나이다. <br>
RestTemplate과 같은 기능을 하지만, RestTemplate는 Blocking 방식이고, WebClient는 Non-Blocking방식이다.<br>
Blocking 동기 - Non-Blocking 비동기 ( 정확히 같은것은 아니지만 비슷하다 ? ) <br>
요청자(APP)에서 WebClient라이브러리를 사용한 senderUtils를 사용하여<br>
프로퍼티 소스와, 송신방식(GET/POST), 넘길 값(DTO), request를 수신할 값(ApiResponseModel)을 설정한다. <br>-SpringMVC에서는 WebFlux와 달리, 블로킹I/O를 사용하기 때문에, 동기적인 작업을 수행할 떄에는 WebClient보다 RestTemplat이 효과적이지만, 비동기 작업을 할 때에는 WebClient를 사용하는것이 효과적이다.<br>
<br>Thread Pool을 애플리케이션 구동시 미리 만들어 두고,<br>
요청시 가용한 Thread가 있다면 1요청당 1Thread가 할당된다.
<br>만약 가용한 스레드가 부족하다면 Queue는 대기하게 되며,<br>
전체 서비스의 속도가 현저히 느려지게 된다.
<br>
<br>Core당 1개의 Thread를 사용한다.
<br>요청은 Event Loop내의 job으로 등록되고, 각 job을 제공자에게 요청한 후,<br>
기다리지 않고 다른 job을 처리한다.
<br>Event Loop는 제공자로부터 callback으로 응답이 오면, 그 결과를 요청자에게 제공하낟.
<br>따라서 반응성/탄력성/가용성/비동기성 을 보장하기 때문에 동시사용자가 크게 몰렸을때<br>
RestTemplate에 비해 성능이 저하되지 않는다.
<br>- 웹 애플리케이션 최전방에서 사용자의 요청을 접수하여 URL기주능로 요청을 처리할 controller를 찾고, 그 controller에 처리를 위임한 후, 결과를 받아서 사용자에게 처리 결과가 담긴 화면을 제공해준다.
<br>설정은 web.xml의 정보를 활용한다. 사용자 요청을 처리할 Controller목록과 사용자 에게 보여줄 화면을 찾는 ViewResolver가 있다.
<br>#### PathVariable 방법 @RestController public class SecondController { @GetMapping("/second/{id}") //PK(id)가 (변수)인 페이지를 찾고 싶다 public String getData(@PathVariable Integer id) { return "id : "+id; }
#### QueryString 방법 @GetMapping("/second") public String getData2(String title, String content) { return "title:"+title+", content :"+content; }
<br>@PostMapping("/second") public String postData(String title, String content) { return "title:"+title+", content :"+content; }
<br>	@PutMapping("/second") public String putData(String title, String content) { return "title:"+title+", content :"+content; }
<br>PostMapping과 같은원리로 작동한다
<br>	@DeleteMapping("/second/{id}") //쿼리스트링 해도 됨 public String deleteData(@PathVariable Integer id) { return id+"delete ok"; }
<br>
<br>데이터 전달이 필요한 경우 @RequestParam을 사용하거나<br>
@DeleteMapping 대신에 @PutMapping을 사용하도록 하자
<br> 내생각에는 메서드를 명시적으로 작성 할 수 있기 때문에 더욱 가독성이 높아지는 장점이 있지 않을까 싶다.
<br>
<br>
애플리케이션 내부-외부 사이의 메시징을 가능하게 하는 프레임워크이다. <br>
Spring Framwork에서 매세징이란 메타데이터와 함께 결합되어있는 이련의 자바 오브젝트를 위한 포괄적인 Wrapper를 말한다. 메시지는 여러개의 헤더로 구성된다. <br>
Enterprise Integration Patterns은 엔터프라이즈 환경에서 사용하고 있는 다양한 분야(ex. 결제,메일, 각 부서별 서비스) 의 애플리케이션을 통합, 즉 유기적으로 연결해서 효율적으로 적절하게 통합하는 방법을 여러 패턴을 통해 제시했다. <br>
하나의 동작을 하는 서비스의 각각의 기능들(프로젝트)이 내/외부 모듈과 접촉하는 부분을 쉽게 구성할 수 있도록 하는 기능들을 제공한다. <br>
<br>채널: 한 요소로부터 다른 요소로 메시지를 전달
<br>필터: 조건에 맞는 메시지가 플로우를 통과하게 해줌
<br>변환기: 메시지 값을 변경하거나 메시지 페이로드의 타입을 다른 타입으로 변환
<br>라우터: 여러 채널 중 하나로 메시지를 전달하며 대개 메시지 헤더를 기반으로 함
<br>분배기: 들어오는 메시지를 두 개 이상의 메시지로 분할하며, 분할된 각 메시지는 다른 채널로 전송
<br>집적기: 분배기와 상반된 것으로 별개의 채널로부터 전달되는 다수의 메시지를 하나의메시지로 결합함
<br>서비스 액티베이터: 메시지를 처리하도록 자바 메서드에 메시지를 넘겨준 후 메서드의 반환값을 출력 채널로 전송
<br>채널 어댑터: 외부 시스템에 채널을 연결함. 외부 시스템으로부터 입력을 받거나 쓸 수 있음
<br>게이트웨이: 인터페이스를 통해 통합플로우로 데이터를 전달
<br>
<br>Spring Integration은 'pipe and filters' 모델을 구현하기 위해 3가지 핵심 개념으로 구성되어 있다.
<br>header, payload로 구성되어 있는 내용을 포함하고 있는 generic wrapper. 컴포넌트 간에 이동되는 실제 데이터이다.
<br><img alt="Pasted image 20240605160336.png" src="http://lts.kr/사진-및-문서/pasted-image-20240605160336.png" target="_self"><br>pipes-and-filters 모델의 pipe에 해당.
컴포넌트간의 메세지 중간 통로 역할을 함으로써 컴포넌트간 디컬플링을 유지 할 수 있도록 하며 interception, monitering 포인트가 될 수 있다. 다른 주요 기능 중 하나는, 메세지 버퍼 역할을 할 수 있는 Queue로써 동작할 수 있다.
FIFO방식으로 컨슈머가 가져갈 때 까지 큐에 저장된다.
<br>ex)<br>
@Bean<br>
public MessageChannel sampleChannel() {<br>
return new DirectChannel();<br>
}<br>
-&gt; DirectChannel은 Point to Point로, 하나의 MessageHeader에게 Message를 전달한다.<br>
이외에도 다양한 체널종류가 있다.<br>pipes-and-filters 모델의 filters에 해당.
Spring integration상에서 채널을 통해서 메세지를 받고, 소비하는 주체이며 하나의 클래스이다.
여기서 말하는 EndPoint란 Spring integration이 구성할 파이프라인의 끝단이 아닌, 파이프라인 중간에서 메세지를 변경하거나 필터링 하거나, 다른 채널로 라우팅하는 요소이다.
<br>ex)
@MessageEndpoint
public class serverEndpoint { ...
}
<br>
Spring integration에서 일련의 작업들을 정의한 플로우를 integration flow 라고 하는데, 이 플로우가 Message Endpoint로 구성되어있다. <br>
엔드포인트는 작업 타입에 따라 크게 그 종류를 나눌 수 있는데 Transformer(변형), Filter(필터링), Router(메세지를 특정 채널로 전송), Splitter(메세지를 분리하여 여러 채널로 전송), Aggregator(splitter의 반대), Service Activator(메세지로 특정 작업을 수행할 수 있는 핸들러를 붙일 수 있는 엔드포인트), Channel Adapter(외부 시스템과 입출력이 가능)가 있다. <br>
<br>통합 파이프라인 중간에 위치하며, 조건을 기반으로 플로우의 전 단계로부터 다음단계로의 메세지 전달에 조건을 달 수 있다.<br>
ex)
<br>@Filter( inputChannel="numberChannel", outputchannel="evenNumberChannel" )
public boolean evenNumberFilter( Integer number ) { return number % 2 == 0; //숫자를 받아 짝수만 전달
}
<br>
<br>입력체널로 부터 메세지를 수신하고, 이 메세지를 MessageHandler 인터페이스를 통해 구현한 클래스에 전달(서비스호출)한다.
<br>서비스를 메시징 시스템에 연결하기 위한 앤드포인트이다.
<br>입력 채널이 설정되어 있어야 하고, 서비스가 값을 리턴하도록 구현했다면 출력 채널도 설정해야한다.
<br>**만약 출력체널을 설정하지 않았을 때 메세지에 "return address"가 있다면 이 헤더에 지정한 체널로 응답을 전송한다.
<br>MessageChennel메서드를 입력해서 파이프라인을 구축한다,
<br>ex)
@ServiceActivator(inputChannel = "sampleChannel") { }
<br>1. e.getMessage() : 에러 메시지의 정보를 받음
2. e.getExceptionCode() : 에러 메시지 발생 코드를 받음
3. e.getStatus() : 에러 메시지의 발생 상태를 받음
4. HttpStatus(enum 클래스)를 받아 해당 value(Code) 와 getReasonPhrase(message)를 얻을 수 있음
<br>1. 체크 예외 발생한 예외를 잡아서(catch) 체크 후 예외를 복구 or 회피 하도록 만드는 구체적인 처리를 필요로 하는 예외이다. try catch가 강제된다. 컴파일 시점에서 에러의 확인이 가능하다. try catch를 할 수 없다면 예외를 밖으로 던지는 Throw 예외를 필수로 선언해 주어야 한다.
2. 언체크 예외 예외를 잡아서 해당 예외에 대한 처리가 필요 없는 예외. RuntimeException을 상속 받은 예외들이 이에 포함된다.
<br>UncheckedException으로 처리
<br>try { 예외가 생길 가능성이 있는 코드
} catch (예외종류){ 예외처리 코드
} finaly { 예외와 상관없이 항상 실행시킬 코드(선택사항)
}
<br>자바에서는 Exception클래스에서 상속받은 다양한 Exception클래스를 갖고 있기 때문에, 여러가지 에러 발생 가능성에 대해서 예외 구문을 처리해 줄 수 있다.<br>자신을 호출하는 메서드에 예외처리의 책임을 떠넘기는 것이다.<br>
단, throws를 사용하려면 반드시 호출한 메서드에 try-catch 구문을 사용하여 예외를 처리해 주어야 한다.<br>public class ThrowTest { public static void main(String[] args) { int n1, n2; n1=12; n2=0; try { throwTest(n1, n2); } catch (ArithmeticException e) { // n1/n2 라면 발생했을 것 System.out.println("ArithmeticException: " + e.getMessage()); } } public static void throwTest(int a, int b) throws ArithmeticException{ System.out.println("throw a/b: "+ a/b); }
}
<br>throw와 throws는 큰 차이가 있다.<br>
throw는 개발자가 직접 예외를 발생시키고싶을 떄 사용하는 것이다.<br>
주로 RuntimeException처리를 위해 사용한다.<br>**checkedException에서도 사용이 가능하다.<br>throw new IOException("IO Exception occurred");
<br>사용예제<br>public class ThrowTest { public static void main(String[] args) { int n1, n2; n1=12; n2=0; try { throwTest(n1, n2); } catch (ArithmeticException e) { // n1/n2 라면 발생했을 것 System.out.println("ArithmeticException: " + e.getMessage()); } } public static void throwTest(int a, int b) throws ArithmeticException{ throw new ArithmeticException(); }
}
<br>해당 코드의 익셉션 메세지는 null 로 뜨게 된다.<br>
throw는 Exception을 던질 때, 예외 내용을 함께 던져 주지 않기 때문이다.<br>
그래서 개발자가 Exception을 따로 커스터마이징해서 만들고, 그 안에 메세지를 넣어서 던져주는 방식이다.<br>
<br>
CheckedException =&gt; try ~ catch 문, throws(의존관계) 로 처리! <br>
UnCheckedException(RuntimeException) =&gt; 기본적으로 복구 불가능한 예외(발생시 런타임 중지)로, CheckedExceptoin이어도 더 구체적인 UnCheckedException으로 발생시켜! throw로 exception을 던지고, ExceptionHandler로 처리! <br>
언체크드익셉션(런타입익셉션) -&gt; 기본적으로 복구 불가능한 예외(발생시 런타임 중지)로, 체크드익셉션이어도 더 구체적인 언체크드익셉션으로 발생시켜 쓰로우로 익셉션을 던지고, 익셉션핸들러로 처리 <br>
<br>
해당 구조가 갖는 장점이 무엇인가?<br>
먼저 Serviced에 인터페이스를 구현하여 세부 구현체를 숨기고 인터페이스를 바라보게 함으로써 클래스간의 의존관계를 줄이는것 이다.<br>
좀 더 쉽게 정리하면,<br>
하나의 인터페이스를 구현하는 여러개의 구현체가 있고, 기능에 따라 적절한 구현체가 드어감으로써 다형성을 주기위함이다. <br>
하지만, 인터페이스 하나에 구현체 한개만 사용하는경우는 어떠한가?<br>
이렇게 된다면, 의존관계를 줄여주는 효과도, 다형성을 주는 효과도 없게된다.<br>
하지만 보통의 경우 한개의 기능을하는 인터페이스를 여러기능의 구현체로 나누는 일은 쉽게 일어나지 않는다. <br>public interface CardPaymentService { void pay();
} public class ShinhanCardPaymentService implements CardPaymentService{ private ShinhanCard shinhanCard; @Override public void pay() { shinhanCard.pay(); //신한 카드 결제 API 호출 // 결제를 위한 비즈니스 로직 실행.... }
}
<br>
<br>위와 같은 경우, 하나의 인터페이스에 하나의 구현체를 갖지만, 향후 추가적으로 구현체가 더 생길여지가 있으니, 인터페이스를 두는것이 바람직 하다고 할 수 있다.
<br>그렇다면 향후 구현체가 추가될 계획이 없는 기능들 까지 인터페이스를 만들어주어야 하는가?<br>그렇지 않다, 예를들어 간단하게 아이디를 기반으로한 조회기능 등은 인터페이스를 구현하지 않고 바로 서비스 객체를 생성하는것이 옳다.
<br>public interface ChangePasswordService { public void change(MemberId id, PasswordDto.ChangeRequest dto);
} public class ByAuthChangePasswordService implements ChangePasswordService { private MemberFindService memberFindService; @Override public void change(MemberId id, PasswordDto.ChangeRequest dto) { if (dto.getAuthCode().equals("인증 코드가 적합한지 로직 추가...")) { final Member member = memberFindService.findById(id); final String newPassword = dto.getNewPassword().getValue(); member.changePassword(newPassword); // 필요로직... } }
} public class ByPasswordChangePasswordService implements ChangePasswordService { private MemberFindService memberFindService; @Override public void change(MemberId id, PasswordDto.ChangeRequest dto) { if (dto.getPassword().equals("비밀번호가 일치하는지 판단 로직...")) { final Member member = memberFindService.findById(id); final String newPassword = dto.getNewPassword().getValue(); member.changePassword(newPassword); } }
}
<br>이렇게 비밀번호를 변경하는 기능같은 경우에는 2가지 이상의 경우가 있기때문에 인터페이스로 구현하는것이 옳아보인다.<br>- Controller로 부터 값을 받는 객체로 사용.
<br>
<br>엔티티로부터 타입 변환을 하여 Controller로 넘겨주는 객체
<br>Page&lt;Dto&gt; -&gt; List&lt;Dto&gt;
<br><img alt="Pasted image 20240723134224.png" src="http://lts.kr/사진-및-문서/pasted-image-20240723134224.png" target="_self"><br><img alt="Pasted image 20240723134333.png" src="http://lts.kr/사진-및-문서/pasted-image-20240723134333.png" target="_self"><br>
<br>비동기 적으로 입출력처리를 관리하기 때문에 전송 작업이 성공했는지 실패했는지 알수 있다.
<br>비동기식 작업에서 높은 성능을 유지할수 있다.
<br>@Test
@DisplayName("같은 객체를 equals 비교")
void equals() { //given Menu friedChicken = new Menu("후라이드치킨", 16_000); Menu friedChicken2 = new Menu("후라이드치킨", 16_000); //when &amp; then assertThat(friedChicken).isEqualTo(friedChicken2);
}
<br>헤당 코드와 같이 구현한다면, false를 출력한다.<br>
이유는 객체의 equals메서드는 주소값이 서로 다른 객체는 다른객체로 판단하기 때문이다.<br>이때, 왜 HashCode도 재정의 해야하나?<br>해당 규약으로 인하여, 서로다른 객체의 해쉬값을 통일시켜주어야 한다.]]></description><link>http://lts.kr/study/cs/🍃-spring.html</link><guid isPermaLink="false">study/CS/🍃 Spring.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 19 Feb 2025 06:30:52 GMT</pubDate><enclosure url="http://lts.kr/사진-및-문서/pasted-image-20240611144129.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="http://lts.kr/사진-및-문서/pasted-image-20240611144129.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[📭 Server]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="http://lts.kr/?query=tag:Server" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Server</a> <br> <a href="http://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="http://lts.kr?query=tag:Server" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Server">#Server</a><br>
<br>서버에 일을 분산시켜주는 역할을 한다.
<br>Random 랜덤분배 <br>Least loaded 가장 적은양의 작업을 처리하고 있는 서버에게 요청 할당 <br>Round Robin 순서를 정하여 돌아가며 작업 분배 <br>
<br>layer4 : 데이터의 내용을 보지 않고 IP주소 및 TCP/UDP정보에 따라 단순히 분배를 해준다
<br>layer7 : 서버가 하는 역할이 분리되어 있는 환경에서 데이터의 내용을 보고 각기 맞는 역할을 하는 서버에게 분배
<br>로드밸런서는 클라이언트가 요청을 보내야 할 서버를 골라야하는 부담을 덜어주며, 로드 밸런서에게 할당된 vIP(가상IP)로 요청을 보내기만 하면 로드 밸런서에서 알아서 작업을 나눠준다.<br>
서버에서는 적절한 로드 밸런서를 사용하면 들어오는 요청이 여러 장비에 분산되어 처리량이 늘어나고 응답 시간이 줄어드는 효과를 기대할 수 있다.<br>
<br>
웹서버가 클라이언트의 요청에 의해 웹페이지에 대한 응답 결과를 돌려줬을때,<br>
클라이언트의 화면에는 랜더링해야하는 수많은 이미지가 필요하다.<br>
이 이미지를 웹서버가 전부 주려면 데이터의 용량이 무거워서 서버에 부하가 걸리게 되는데,,<br>
따라서 웹서버는 이미지를 대신 건내주는 CDN에게 요청한다는 개념이다. <br>
CDN은 일반적으로 용량이 큰 컨텐츠 데이터를 빠른속도로 제공하기 위해 사용자와 가까운곳에 분산되어 있는 데이터 저장 서버이다. <br>
<br>push CDN : 서버에서 컨텐츠가 업로드 되거나, 변경되었을 때 모두 반영하는 방식
<br>pull CDN : 클라이언트가 요청할 때마다 컨텐츠가 CDN에 새로 저장되는 방식
<br>두 방식 모두 장단점이 있다.<br>
Push방식은 모든 컨텐츠를 갖고 있기 때문에 웹서버에 요청할 일이 없지만 유지하는데 필요한 용량과 비용이 크고,<br>
Pull방식은 요청이 들어왔을 때 컨텐츠가 있다면 즉각 응답하지만, 그렇지 않을때 웹서버에 요청해야하는 부담이 있다.<br><img alt="Pasted image 20240603173517.png" src="http://lts.kr/사진-및-문서/pasted-image-20240603173517.png" target="_self"><br>하지만, MSA의 경우 각 서비스마다 다른 데이터베이스를 사용하는 것이 일반적이고, 이를 하나의 데이터베이스 트렌젝션으로 처리하는 것은 기술적으로 어렵고, 처리한다 해도 긴 트렌젝션이 발생하기 때문에 효용도 적다.<br>
<img alt="Pasted image 20240603180042.png" src="http://lts.kr/사진-및-문서/pasted-image-20240603180042.png" target="_self"><br>
<br>tcc는 분산된 REST 시스템들 간의 트랜젝션을 HTTP와 REST원칙으로 접근하여 해결하는 방법이다.
<br>REST API 호출은 한 번에 끝내는 것이 아니라, 2번의 걸쳐서(Try / Confirm) 진행하게 된다.<br>
트렌젝션의 All-or-Nothing을 TCC의 REST API를 호출을 시도(Try)하고 전부 확정(Confirm)하거나 전부 취소(Cancel)하는 것으로 구현된다.<br>Spring RestTemplate을 사용하여 HTTP 요청(POST)을 보냈을 때, try 요청의 경우 정상적인 HTTP응답(HttpStatus.CREATED)를 받으면 HTTP BODY에는 JSON형태로 Confirm하게 하거나 Cancel 할 수 있는 URL이 담겨 있다.
<br>
<br>여기서 Service에서 반환받은 값을 기준으로 Confirm 할지 Cancel할지 선택하게 된다.
<br>중요한 것은 여기서 실제로 데이터베이스 테이블에 변경이 있는것 이 아닌, Confirm되었을때 그때 처리가 된다.
<br>
<br>여기서 받은 반환값을 토대로 Service에서는 resource 필드(JSON)을 역질렬화 하고 이를 사용하여 그때 실제로 데이터베이스에 있는 테이블을 변경하게 된다.
<br>
<br>
Try는 리소스를 사용하기 전에 예약하는 것이다. 만약 4.구매 주문 생성에서 Try만 하고, 실패했다면 REST로 통신은 기다리고 있던(Try만 한 상태) 두 API에는 Confirm이 전달되지 않아 예약만 된 상태로 남아있게 된다. <br>
예약된 상태는 특정 리소스를 점유하고 있다는 의미이며, 리소스를 점유하고 있는 동안에는 다른 API에서 해당 리소스를 사용하는 것은 제한된다. <br>
따라서, 4. 행위에서 Try만 하고 실패했다면, 예약한 리소스까지 해제해주어야 한다. <br>
분산된 환경에서 리소스를 해제하는 것은 쉬운 문제가 아닌데, TCC매커니즘에서는 Cancel과 Timeout 두가지 방법으로 예약된 리소스를 해제한다.<br>
<img alt="Pasted image 20240604102140.png" src="http://lts.kr/사진-및-문서/pasted-image-20240604102140.png" target="_self"> <br>REST커뮤니케이션 관전에서 자세하게 설명하면,<br>TCC REST API Consumer(여기선 OrderService)가 Try요청
<br>TCC REST API Provider (여기선 StockService/PaymentService)는 응답으로 Confirm하거나 Cancel할 수 있는 URI를 반환
<br>이를 사용하여 API Consumer는 DELETE HTTP Method로 예약한 리소스에 대한 해제를 요청한다.
<br><img alt="Pasted image 20240604144026.png" src="http://lts.kr/사진-및-문서/pasted-image-20240604144026.png" target="_self"><br>클라이언트가 주문을하고, OrderService는 StockService와 PaymentService로 Try한다.<br>
그리고 구매 주문을 생성 후 Confirm하였다. StockService는 재고 처리에 성공을 한 반면, PaymentService는 결제에 실패한다.<br>
이경우에는 어떻게 일관성을 유지할 수 있을까?
<br>
<br>관계형 데이터베이스에서 트랜젝션을 처리할 때에는 데이터 적합성을 보장해야 하기 때문에 엄격한 일관성 모델을 사용한다.
<br>하지만 결제시스템 하나의 문제로 모든 비즈니스가 멈추게 되는 문제가 발생한다.(보통은 멈추는게 맞다)
<br>
<br>
StockService와 PaymentService는 OrderService로부터 받은 Confirm요청을 Queue나 Log파일에 큐잉 하고, 이를 비동기적으로 처리한다. Confirm처리 과정에서 오류가 나는 경우 계속해서 재시도하여 결국(언젠가) 처리하게 한다. <br>
이렇게 단기적으로 일관성을 잃더라도(클라이언트 입장에서는 성공했다고 느끼지만, 실제 결제처리가 되지 않았을 수도 있다.) 결국에서는 일관성을 유지하는 모델을 결과적 일관성 이라고 한다. <br>
단, 결과적 일관성 모델은 단기적으로 일관성을 잃어버렸을 때를 대비한 화면 처리 등이 필요하다. <br>
ex) 아마존에서 전자책을 구입한 후, 결제 과정이 진행되었고 이후 카드가 정상처리되지 않는 메일을 받아, 2일후에 제대로 결제처리를 하였다.]]></description><link>http://lts.kr/study/cs/📭-server.html</link><guid isPermaLink="false">study/CS/📭 Server.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 19 Feb 2025 06:30:45 GMT</pubDate><enclosure url="http://lts.kr/사진-및-문서/pasted-image-20240603173517.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="http://lts.kr/사진-및-문서/pasted-image-20240603173517.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🐞 etc]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="http://lts.kr/?query=tag:기타" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#기타</a> <br> <a href="http://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="http://lts.kr?query=tag:기타" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#기타">#기타</a><br>순서를 맞추어 호출하는 로직과 예외처리를하는 로직이 컨트롤러에 집중되어 있다면 가독성이 떨어지게된다 이를 해결하기위해, 서비스에서 로직을 구현하게 된다면 서비스에서 서비스를 호출하는 순환참조를 야기할 수 있게된다. 이를위한 해결법으로 서비스를 주입받는 메인 서비스를 만들어 여러서비스를 주입받고 한개의 서비스에서 이를 동작시킬 수 있다.
<br>	1. String x = "abc"; 2. String y = new String("abc");
<br>1번의 경우로 생성했을 때는 abc라는 문자열을 String 상수 pool에 저장하고,<br>
다음번에 동일 문자열이 선언될 때 이풀에서 꺼내의 재사용하게 된다.<br>2번의 경우엔 String을 인스턴스와 하여 새로운 객체를 생성하게 된다.<br>
String Class는 자신을 수정하는 기능을 제공하지 않기때문에,<br>
1번의 경우로 선언했을경우 한가지가 바뀌게 되면 나머지가 모두 바뀌게 된다.<br>
이러한 일을 방지하기 위해서는 생성자를 이용한 선언(2번)을 사용해야한다.<br>
<br>Apach에서 2004년 출시한 빌드 툴이다.
<br>Ant를 사용하던 개발자들의 불편함을 해소 + 부가기능을 추가 하기위해 만들어졌다.
<br>
<br>Ant와 Maven의 장점을 모아 2012년 출시한 빌드 툴이다.
<br>Gradel이 시기 상 늦게 출시된 만큼 사용성/성능 등 비교적 뛰어난 스펙을 갖고 있다.
<br>
<br>
Gradle의 Groovy를 이용해서 기존 XML로 작성되있던 요소들의 단점을 해소하고 있다. <br>XML의 경우 코드가 길어지면 가독성이 떨어진다.
<br>의존관계가 복잡한 프로젝트 설정에 어려움이 있다. <br>
특정 상황에서 Gradle의 속도는 Maven보다 훨씬 빠르다. <br>Gradle은 캐시를 사용하기 때문에 반복될 수록 속도 차이는 더욱 커진다. <br>
<br>
일반적으로 하나의 인스턴스만 존재해야 할 경우 Singleton패턴을 사용하게 된다.<br>
single thread환경에서 사용되는 경우에는 아무런 문제가 없지만, Multi thread환경에서<br>
singleton객체에 접근 시 초기화 관련하여 문제가 있다. <br>
보통 Singleton객체를 얻는 Static메서드는 getInstance( )로 작명하는게 일반적이다. <br>
<br>단순하게 문제를 해결하고자 한다면, 메서드에 synchronized 키워드만 추가해도 무방하다.<br>
하지만, 이는 하는 역할에 비해서 동기화 오버헤드가 심하다는 단점이 있다.
<br>
<br>간단하게 설명하면, 객체가 필요할 때로 초기화를 미루는 것이다.
<br>public class Singleton { private Singleton() {} public static Singleton getInstance() { return LazyHolder.INSTANCE; } private static class LazyHolder { private static final Singleton INSTANCE = new Singleton(); }
}
<br>처음 singleton로딩 시에는 LazyHolder클래스의 변수가 없기 때문에 초기화 하지 않는다.<br>
LazyHolder클래스는 singleton클래스의 getInstance( ) 메서드가 참조되는 순간 class가 로딩되며 초기화 된다.<br>Class를 로딩하고 초기화하는 시점은 thread-safe가 보장되기 때문에, 성능과 안정성을 모두 보장하는 훌륭한 방법이다.]]></description><link>http://lts.kr/study/cs/🐞-etc.html</link><guid isPermaLink="false">study/CS/🐞 etc.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 19 Feb 2025 06:30:35 GMT</pubDate></item><item><title><![CDATA[☕ JAVA , OOP]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="http://lts.kr/?query=tag:Java" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Java</a> <a class="tag" href="http://lts.kr/?query=tag:OOP" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#OOP</a> <br> <a href="http://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="http://lts.kr?query=tag:Java" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Java">#Java</a> <a href="http://lts.kr?query=tag:OOP" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#OOP">#OOP</a><br>- 컴파일 다형성
- 이름이 같지만, 매개변수의 타입/개수/순서 를 다르게 정의하여 사용하는 방법
- 어떤 메서드가 호출될지 컴파일 시점에서 결정
- 코드를 직관적이게 만드는데 사용
<br>- 런타임 다형성
- 부모클래스 또는 인터페이스에 정의된 메서드를 하위 클래스에서 재정의하여 사용하는 방법
- 어떤 메서드가 호출될지 런타임 시점에 결정된다.
<br>Map&lt;String, Integer&gt; map1 = new HashMap&lt;&gt;();
Map&lt;String, Integer&gt; map2 = new TreeMap&lt;&gt;();
<br>해당 형태로 map1 / 2를 구현했다면.<br>
객체 타입은 각각 HashMap/TreeMap 이 되며,<br>
변수 타입은 모두 Map이 된다.<br>
- 즉 map1.add / map2.add 등 Map인터페이스가 가진 함수만을 사용할 수 있으며,<br>
HashMap이나 TreeMap가 가진 고유메서드는 사용할 수 없다.<br>
하지만, 오버라이딩(런타임 다형성)으로 재정의한 각각의 메서드로 해당 동작이<br>
구현체의 특성에 맞게 실행되게 된다.<br>Java는 다중 상속을 지원하지 않는다.(부모가 2명 이상인것)
<br>다중 상속 처럼 여러개를 상속받을 수 있다. 부모의 메서드를 사용하며, 동작이 의도대로 흘러가도록 강제할 수 있으나, 구현은 자식 클래스에서 하기때문에 결합도를 낮출 수 있다.
<br>
<br>상속은 부모 클래스의 내부 구현에 대해 상세히 알아야 하기 때문에, 자식과 부모 사이의 결합도가 높아질 수 밖에 없다.
<br>또한, 부모의 쓸모없는 기능까지 모두 받게 될 가능성이 있다.
<br>부모 클래스가 수정되면, 자식클래스도 동시에 수정해야하는 경우가 생긴다.
<br>단일 상속만 가능하기 때문에, 결국 인터페이스를 또 사용하게 된다.
<br>
<br>합성은 구현에 의존하지 않는 점에서 상속과 다르다. <br>합성을 이용했을 때는, 객체의 내부는 공개되지 않고 인터페이스를 통해 코드를 재사용하기 때문에,<br>
구현에 대한 의존성을 인터페이스에 대한 의존성으로 변경하여 결합도를 낮출 수 있다.
<br>합성 관계는 실행 시점에 동적으로 변경될수 있다.(런타임) <br>public class Phone { private RatePolicy ratePolicy; // 클래스 합성 private List&lt;Call&gt; calls = new ArrayList&lt;&gt;(); // 클래스 합성 public Phone(RatePolicy ratePolicy) { this.ratePolicy = ratePolicy; } public List&lt;Call&gt; getCalls() { return Collections.unmodifiableList(calls); }
}
<br>
<br>객체지향 설계시 지켜야 하는 5가지 원칙들의 앞글자를 딴것이다.
<br>순서는 노상관이다.
<br>책임 = 기능 이다. 수정시 영향도를 낮추는 주요한 원칙이다.
<br>- 추상화 사용을 통한 관계를 구축하기를 권장하는 의미이다.
- 추상클래스,인터페이스를 통한 관계를 구축하여 확장은 쉽고, 변경에는 영향도가 없어지도록 분리해라?
<br>- 코드에는 문제가 없더라도, 부모타입의 설계 목적에도 부합하도록 설계해라. -&gt; 부모의 동작의도대로 흘러가도록 설계해라
- Map a = new HashMap(); 같이 구현해서, 사용해도 문제 없도록 하는거다
- &gt; 변수는 Map타입으로, Map메서드만 사용가능하지만 객체는 HashMap이기 때문에 각각의 기능으로 수행되고, 수정시에도 Map을 상속받는 다른 클래스로 변경이 쉬워진다.
<br>- 인터페이스의 단일책임과 비슷하다. 기능별로 잘 분리하고, 수정을 최소화할수 있도록 처음부터 생각하라.
<br>- 리스코프 치환의 원칙을 따라 설계했다면, 의존성 역전의 원칙을 따르기 쉬워진다.
- 의존관계를 맺을때, 변화기 쉬운것 보다, 변화하기 어려운 것에 의존하라는 것이다.
<br>
<br>자바 개발 키트의 약자로, 개발자들이 자바로 개발하는데 사용되는 SDK키트라고 생각하면 된다.
<br>자바 개발시 필요한 라이브러리와, javac, javadoc 등의 개발도구를 포함한다.
<br>자바 실행 프로그램인 JRE도 포함한다. (JRE에는 JVM이 들어가있다.)
<br>- 대표적으로, 안드로이드 스튜디오 등이 있다.
<br>
<br>Java SE(standard edition) : 가장 기본이 되는 표준 에디션의 자바 플랫폼.
<br>Java EE(enterprise edition) : 대규모 기업용 에디션. SE의 확장판
<br>Java ME(micro edition) : 피쳐폰/셋톱박스/프린터 와 같은 작은 임베디드 기기를 다루는데 이용하는 에디션
<br>Java FX : 가볍고 예쁜 그래픽 사용자 인터페이스를 제공하는 에디션
<br>
<br>JRE는 자바 실행환경의 약자로서, JVM과 자바 프로그램을 실행시킬 때 필요한 라이브러리 API를 함께 묶어서 배포되는 패키지.
<br>또한, 자바 런타임 환경에서 사용하는 프로퍼티 세팅과 리소스(jar)파일을 가지고 있다.
<br>JRE는 기본적으로 JDK에 포함되어있기 때문에 JDK를 설치하면 함께 설치된다.<br>
<img alt="Pasted image 20250110101642.png" src="http://lts.kr/사진-및-문서/pasted-image-20250110101642.png" target="_self">
<br>
<br>JVM은 자바 가상머신의 약자로서, 직역하면 자바를 실행하는 머신, 자바를 돌리는 프로그램이다.
<br>자바로 작성된 모든 프로그램은 JVM에서만 실행될 수 있으므로, 자바 프로그램을 실행하기 위해서는 바늗시 자바 가상머신의 설치가 선행되어야 한다.
<br>
<br>java는 OS에 종속적이지 않다는 특징을 가지고 있다.
<br>
<br>
소스코드를 컴파일하여 기계어를 만드는 과정에서, window/mac/linux가 각기 다르게 컴파일을 시킨다. <br>
때문에 각 OS별로 상이한 문법을 사용하게 되는 일이 벌어진다. <br>
이러한 언어를 "이식성이 낮다" 라고 표한다. <br>
하지만 java는 jvm를 거쳐서 OS와 상호작용 하기때문에, OS에 구애받지 않게 된다. <br>
<br>위에서 c언어는 컴파일을 거치면 기계어가 된다고 했는데,
<br>java는 JVM을 거쳐 바이트 코드로 변환되게 된다. <br>이는 가상 머신이 이해할 수 있는 중간 레벨의 언어로, 반쪽짜리 컴파일 결과물 이라고 할 수 있다.
<br>이는 어떠한 환경에 종속적이지 않고 실행될 수 있다.
<br>즉, 재컴파일 할 필요없이 기계가 바로 읽고 실행 할 수 있는 코드를 만들어 주는것이다.
<br>하지만 자바 프로그램과 달리 JVM은 각 운영체제에 종속적이므로, 각 운영체제에 맞는 JVM을 알맞게 설치해주어야한다.<br>
<br>위의 설명과 같이 java는 일반 프로그램보다 JVM이라는 단계를 한 단계 더 거치기 때문에, 상대적으로 실행속도가 느리다는 단점을 내포하고 있다.
<br>이를 보환하기 위해, 필요한 부분만을 기계어로 바꾸어 속도를 향상시키는 JIT 컴파일러 같은 내부 프로그램이 있지만, 그럼에도 여전히 느리다.
<br><img alt="Pasted image 20250110103409.png" src="http://lts.kr/사진-및-문서/pasted-image-20250110103409.png" target="_self"><br>위 그림에서 Compiler는 javac.exe에 해당되고 JVM은 java.exe에 해당된다.
<br>소스코드(MyPrograme.java)를 작성한다.
<br>컴파일러(Compiler)는 자바 소스코드를 이용하여 클래스 파일(MyProgram.class)을 생성한다. 컴파일 된 클래스 파일은 JVM(Java Virtual Machine)이 인식할 수 있는 바이트 코드 파일이다.
<br>JVM은 클래스 파일의 바이트 코드를 해석하여 바이너리 코드로 변환하고 프로그램을 수행한다.
<br>MyProgram 수행 결과가 컴퓨터에 반영된다
<br>
<br>c또는 c++등으로 작성된 프로그램은 최종 결과물로 exe파일을 만들어낸다.
<br>java도 exe파일을 만들 수 있지만, class파일로 굳이 만들어내는 이유는 다음과 같다 <br>JVM이 exe에 포함되는 형식으로 가능하기 때문에 exe파일이 무척 커지게 되는 단점이 있다.
<br>때문에 보통의 경우 일부러 생성하지 않는것이다. <br>
<br>java에서 String은 객체이다.
<br>int, char와 달리 기본형,원시형(primitive type)이 아닌 참조형(reference type)변수로 분류된다.
<br>메모리의 Stack영역이 아닌, Heap영역에서 문자열 데이터가 생성되고 다뤄진다는 말이다.<br>
<img alt="Pasted image 20250110122312.png" src="http://lts.kr/사진-및-문서/pasted-image-20250110122312.png" target="_self">
<br>또한 String은 불변(Immutable)객체이다. <br>예를들어, s = "a"; 에 s = s + s; 를 하면 "aa"가 되겠지만, heap영역 메모리에 새로운 주소로 생성하게 된다. <br>
<br>JVM에서는 String Constant Pool이라는 독립적인 영억을 Heap영역에 구축하여<br>
문자열들을 Constant화 하여 다른 변수 혹은 객체들과 공유한다.
<br>이 과정에서 데이터 캐싱이 일어나고, 그만큼 성능적인 이득을 취할 수 있게된다.
<br>
<br>데이터가 불변하다면, 멀티 스레드 환경에서 동기화 문제가 발생하지 않기 때문에 안전한 결과를 낼 수 있다.
<br>
<br>만일 번지수의 문자열 값이 변경이 가능하다면, 참조값을 변경하여 애플리케이션에 보안 문제를 일으킬 수 있다.
<br>
<br>먼저 문자열 리터럴 방식으로 변수에 저장하게 되면, 이 값은 string constant pool에 저장이 되지만, new연산자를 사용하여 생성한 값은 Heap영역에 존재하게된다.
<br>
<br>대상 값 자체를 비교
<br>
<br>대상의 주소값을 비교.
<br>즉, new연산자를 통해 만들어진 객체를 equals로 비교한다면 true가 나오겠지만,<br>
== 연산자를 사용한다면 false가 나오게 되는것이다.<br> 두 클래스 모두 문자열을 연산(추가 및 변경)할 때 주로 사용하는 자료형이다.<br>
물론 String자료형 으로도 + 나 concat()으로 문자열을 이어붙일수 있다.<br>
하지만 +를 이용해 String인스턴스의 문자열을 결합하면, 내용이 합쳐진 새로운 String인스턴스를 생성하게된다.<br>
문자열을 많이 결합하면 결합할수록 공간낭비는 물론, 속도 또한 매우 느려진다.<br>이를 해결하기 위해 Java는 문자열 연산을 전용으로 하는 자료형을 따로 만들어 제공하였다.<br>
<br>내부적으로 Buffur라고 하는 독립적인 공간을 가지게 되어
<br>문자열을 바로 추가할 수 있어 공간의 낭비도 없으며, 문자열 연산 속도도 매우 빠르다
<br>기본적으로 16개의 문자를 저장할 수 있는 크기이며,<br>
연산 중 할당된 버퍼의 크기를 넘게되면 자동으로 버퍼를 증강 시킨다.<br>SpringBuffer와 SpringBuilder의 메서드 사용법은 동일하다.<br>
<br>불변자료형 으로써, 초기 공간과 다른 값에 대해서 새로운 메모리 공간을 할당하여 새로 생성한다.
<br>그렇게 남겨진 문자열 값은 java가비지 컬렉터에 의해 제거될 대상에 포함된다.
<br>
<br>즉, 문자열을 조작할 때 새 객체를 생서하지 않고 기존 객체를 수정한다.
<br>메모리 관리 측면에서 효율적
<br>=&gt; 사실 자바는 문자열에 + 연산을 사용하면, 컴파일 전 내부적으로 StringBuilder 클래스를 자동으로 생성한 후 다시 문자열로 돌려준다. 다만, 문자열을 합치는 일이 빈번할 경우에는 단순히 +연산을 사용하는것은 효율이 떨어지므로<br>
SpringBuffer와 SpringBuilde 를 사용하는것이 옳다고 할 수 있다.<br>
<br>컴파일 타임 위빙 (Compile-Time Weaving) <br>소스 코드 컴파일 시, Aspect가 대상 객체에 결합됩니다.
<br>AspectJ 같은 프레임워크에서는 가능하지만, Spring AOP는 이 방식을 지원하지 않습니다. <br>로드 타임 위빙 (Load-Time Weaving) <br>클래스 파일을 JVM에 로드할 때 Aspect를 결합합니다.
<br>Spring AOP는 기본적으로 지원하지 않으나, AspectJ 통합 설정을 통해 사용할 수 있습니다. <br>런타임 위빙 (Runtime Weaving) <br>Spring AOP의 기본 방식입니다.
<br>런타임에 프록시 객체를 생성하여 부가 기능을 결합합니다.
<br>JDK 동적 프록시 또는 CGLIB를 사용하여 대상 객체를 프록시로 감싸고, 프록시가 메서드 호출을 가로채서 Advice를 실행합니다. <br>
<br>프록시 생성 시: 클래스 단위에서 PointCut 조건에 따라 프록시가 생성됩니다.
<br>메서드 호출 시: 개별 메서드 단위에서 PointCut 조건을 재평가합니다.
<br>
<br>프록시 생성은 클래스 단위로 이루어지지만, PointCut 조건은 메서드 단위로 적용됩니다.
<br>런타임 정보(매개변수, 리턴 타입 등)를 기반으로 동적 조건을 평가해야 하는 경우가 있습니다.
<br>Spring AOP의 유연성과 확장성을 보장하기 위한 설계입니다.
<br>
<br>클라이언트에서 서버를 직접 호출하고, 처리결과를 받는다. -&gt; 직접호출
<br>클라이언트에서 서버를 직접 호출하지 않고, 대리자를 통해 간접적으로 서버에 요청 -&gt; 간접호출
<br>
<br>권한에 따른 접근 차단, 지연로딩을 수행하는 접근 제어 <br>서버의 기능에 다른 기능을 추가해주는 부가 기능 추가 ex) 로그, 가공 <br>대리자가 또 다른 대리자를 호출하는 프록시 체인 <br>
<br>아무 객체나 프록시가 되는것은 아니다. <br>클라이언트는 서버에 요청한지, 프록시에게 요청한지 몰라야한다. <br>즉, 클라이언트의 코드를 건드리지 않고 프록시 추가와 런타임 객체 의존 관계 주입만 변경하여야 한다.
<br>
<br>두 패턴 모두 프록시를 사용하는 방법이다.
<br>또한, 둘 모두 원본 객체를 건드리지 않고, 추가 기능을 실행 할 수 있다.
<br>하지만 GOF 디자인 패턴에서는 이 둘을 의도(Intent)에 따라서 구분한다.<br>
프록시 패턴 : 접근 제어가 목적<br>
데코레이터 패턴 : 새로운 기능 추가가 목적
<br>1.객체들이 사용하는 코드를 훼손하지 않으면서 런타임에 추가 행동들을 객체들에 할당할 때 사용.<br>상속을 사용하여 객체의 행동을 호가장하는 것이 어색하거나, 불가능할 때 사용할 수 있다.<br>
-만일 final 키워드가 기입된 클래스의 경우는 데코레이터 패턴을 통해 래핑하여 재사용 할 수 있다.
<br>ex)<br>
택스트 편집기<br>
- 택스트 편집기에서 굵게, 이텔릭체, 밑줄 등과 같은 다양한 텍스트 포맷을 지원한다.<br>
Spring<br>
- HttpServletRequestWrapper : Sevlet에서 제공하는 Wrapper로 데코레이터 패턴을 지원한다.<br>
<br>
가상 프록시, 지연 로딩이 필요한 경우 <br>부담되는 서비스 객체를 바로 초기화 한다면 리소스 낭비가 발생 할 수 있으므로, 프록시 객체를 통해 객체를 초기화 할 수 있다. <br>
보호 프록시, 접근 제어가 필요한 경우 <br>특정 클라이언트에 대해서만 서비스 객체를 이용할 수 있도록 하려는 경우 프록시 객체를 통해서 처리할 수 있다. <br>
원격 프록시, 원격 서비스의 로컬 실행이 필요한 경우 <br>서비스 객체가 원격 서버에 있는 경우에는 네트워크를 통해 클라이언트의 요청을 전달하여 처리할 수 있다. <br>
로깅 프록시, 서비스 객체에 대한 로깅이 필요한 경우 <br>프록시 객체에서 서비스에 전달하기 전과 후로 로깅을 진행할 수 있다. <br>
캐싱 프록시, 요청 결과를 캐시하고 생명주기를 관리해야 하는 경우 <br>ex) Spring JAP<br>JPA의 지연 로딩의 경우, 가상 프록시를 적용하여 실제로 객체를 조회하기 이전까지 프록시 객체로 Entity를 대신하여 제공한다.<br>
ex) Spring AOP
<br>Spring AOP는 프록시 패턴을 사용하여 트렌젝션 관리, 로깅, 보안 등의 작업을 프록시에서 처리한다.
<br>
public void write(char cbuf[], int off, int len) throws IOException { synchronized (lock) { ensureOpen(); if ((off &lt; 0) || (off &gt; cbuf.length) || (len &lt; 0) || ((off + len) &gt; cbuf.length) || ((off + len) &lt; 0)) { throw new IndexOutOfBoundsException(); } else if (len == 0) { return; } if (len &gt;= nChars) { /* If the request length exceeds the size of the output buffer, flush the buffer and then write the data directly. In this way buffered streams will cascade harmlessly. */ flushBuffer(); out.write(cbuf, off, len); return; } int b = off, t = off + len; while (b &lt; t) { int d = min(nChars - nextChar, t - b); System.arraycopy(cbuf, b, cb, nextChar, d); b += d; nextChar += d; if (nextChar &gt;= nChars) flushBuffer(); } }
} <br>
<br>JPA에서 실제 데이터가 필요한 시점까지 데이터베이스 조회를 지연하는 기법
<br>엔티티를 처음 조회할 때는 연관된 데이터를 즉시 로드하지 않고, 그 연관된 데이터가 실제로 사용될 때 데이터베이스에서 조회하는 방식
<br>불필요한 데이터 조회를 줄여서 성능을 최적화하는데 유리하다.
<br>
<br>지연 로딩을 설정하면 연관된 엔티티나 컬렉션은 처음에 프록시 객체로 로드된다. <br>프록시는 실제 엔티티를 대신하는 객체로, DB조회가 필요할 때 프록시가 실제 데이터를 조회하여 값을 제공 <br>처음 부터 연관된 데이터를 모두 로드하는것이 아닌, 실제 접근 시점에 DB에서 로드되도록 지연 <br>
<br>엔티티 A를 조회시 관련(Reference)되어 있는 엔티티 B를 한 번에 가져오지 않는다.
<br>프록시를 맵핑하고 실제 B를 조회할 때 쿼리가 나간다.<br>
쿼리가 총 두 번 나간다. A조회시 한 번, B조회시 한 번
<br>
<br>구체적인 Class Type을 알지 못하더라도 해당 Class의 method, type, variable들에 접근할 수 있도록 해주는 JAVA의 API이다.
<br>컴파일된 바이트 코드를 통해 Runtime에 동적으로 특정 Class의 정보를 추출할 수 있는 프로그래밍 기법
<br>
<br>프로그램에 사용된 구성 요소의 실제 값 또는 프로퍼티를 결정짓는 행위<br>
-즉 프로그램에서 사용되는 변수나 메서드 등 모든 것들이 결정되도록 연결해주는 것
<br>- 컴파일 시점에 결정
- 프로그램이 실행 돼도 변하지 않음
- 오버로딩 : 컴파일 다형성, 메서드 타입,개수,순서 를 다르게 하여 정의하는 것
- private, final, static이 붙은 메서드
<br>- 런타임 시점에 결정
- 오버라이딩 : 런타임 다형성, 부모,상위 클래스의 메서드를 하위 클래스가 재정의하여 사용하는 것
- Java에서의 다형성, 상속이 가능한 이유
<br>
<br>
클래스의 수정 없이 유연하게 확장 가능한 코드를 작성할 수 있다. <br>
앞서 설명했던 것을 토대로 생각해보면, Reflection은 Runtime에 Class Type을 모르는채로 객체를 생성하고 이용하기 때문에 동적 바인딩을 제공한다. <br>
<br>코드 작성 시점에서는 어떠한 Class를 사용해야할지 모르지만 Runtime에 Class를 가져와서 실행해야하는 경우 (Spring Annotation)
<br>
<br>private 변수를 변경하고 싶거나 private method를 테스트할 경우
<br>
<br>IDE 사용 시 Da 입력만해도 이와 관련된 Class 혹은 Method 목록들을 IDE가 먼저 확인하고 사용자에게 제공한다
<br>
<br>Reflection은 아래와 같은 정보를 가져올 수 있다.
<br>Class/Interface
<br>Constructor
<br>Method
<br>Field
<br>해당 정보들을 통해 (1) 객체 생성 (2) 메서드 호출 (3) 변수 값을 변경할 수 있다.<br>[1] Class / Interface<br>public static void main(String[] args) throws Exception { // 1. class를 알고 있을 경우 Class car = Car.class; // 2. class 이름만 알고 있을 경우 Class car = Class.forName("com.reflection.test.Car"); // class.getName() -&gt; com.reflection.test.Car // 3. Default 생성자를 이용한 객체 생성 Car realCar = car.newInstance(); // 4. class에 구현된 interface 확인 Class[] interfaces = car.getInterfaces();
}
<br>[2] Constructor<br>public static void main(String[] args) throws Exception { Class car = Class.forName("com.reflection.test.Car"); // 1. 인자가 없는 생성자 가져오기 Constructor constructor = car.getDeclaredConstructor(); // 2. String 인자를 가진 생성자 가져오기 Constructor constructor = car.getDeclaredConstructor(String.class); // 3. 모든 생성자 가져오기 Constructor constructors[] = car.getDeclaredConstructors(); // 4. public 생성자만 가져오기 Constructor constructors[] = car.getConstructors(); // public com.reflection.test.Car() // public com.reflection.test.Car(java.lang.String) // 5. 생성자를 이용한 객체 생성 Car realCar = constructor.newInstance();
}
<br>[3] Method<br>public static void main(String[] args) throws Exception { Class car = Class.forName("com.reflection.test.Car"); // 1. 인자가 없는 method 가져오기 Method method = car.getDeclaredMethod("move"); // 2. String 인자를 가진 method 가져오기 Method method = car.getDeclaredMethod("move", String.class); // 3. 모든 method 가져오기 Method methods[] = car.getDeclaredMethods(); // 4. 상속받은 method와 public method 가져오기 Method methods[] = car.getMethods(); // public void com.reflection.test.Car.move() // public void com.reflection.test.Car.move(java.lang.String) // 5. method 호출 Class realCar = car.newInstance(); method.invoke(realCar, /*인자*/); // 6. 접근 제한자를 무시한 method 호출. method.setAccessible(true); method.invoke(realCar, /*인자*/);
}
<br>[4] Field<br>public static void main(String[] args) throws Exception { Class car = Class.forName("com.reflection.test.Car"); // 1. car 객체에서 name 에 해당하는 field 가져오기 Field field = car.getDeclaredField("name"); // 2. car + car super 객체를 포함하여 name에 해당하는 field 가져오기 Field field = car.getField("name"); // 3. car 객체에 선언된 모든 field 가져오기 Field[] fields = car.getDeclaredFields(); // private java.lang.String com.reflection.test.Car.name // public java.lang.Integer com.reflection.test.Car.type // 4. car + car super 객체의 모든 public field 가져오기 Field[] fields = car.getFields(); // public java.lang.Integer com.reflection.test.Car.age
}
<br>[5] Field 값 변경<br>public static void main(String[] args) throws Exception { Class class = Class.forName("com.reflection.test.Car"); Constructor constructor = class.getConstructor() Car car = constructor.newInstance() Field field = car.getField("name"); // 1. public field 일 경우 field.set(car, "아반떼"); // 2. private field 일 경우 field.setAccessible(true); field.set(car, "아반떼");
}
<br>
<br>
람다 표현식(Lambda Expression)이란?<br>
함수형 프로그래밍을 구성하기 위한 함수식이며, 간단히 말해 자바의 메소드를 간결한 함수 식으로 표현한 것. <br>
이름없는 함수, 익명 함수(anonymous function) 이라고도 한다. <br>int add(int x, int y) { return x + y;
}
<br>// 위의 메서드를 람다 표현식을 이용해 아래와 같이 단축 시킬수 있다. (메서드 반환 타입, 메서드 이름 생략)
(int x, int y) -&gt; { return x + y;
};
<br>// 매개변수 타입도 생략 할 수 있다.
(x, y) -&gt; { return x + y;
};
<br>// 함수에 리턴문 한줄만 있을 경우 더욱 더 단축 시킬 수 있다. (중괄호, return 생략)
(x, y) -&gt; x + y;
<br>
<br>람다의 바디에서는 파라미터가 아닌 바디 외부에 있는 변수를 참조할 수 있다.
<br>유사하게 로컬 클래스, 익명 클래스에서도 참조가 가능하다.
<br>public class VariableCapture { private void run() { // 로컬 클래스, 익명 클래스, 람다에서 이 변수를 참조하면 effective final로 변경 int baseNumber = 10; // 람다 IntConsumer lambda = (i) -&gt; System.out.println(i + baseNumber); // i + 10 // 로컬 클래스 class LocalClass { void printBaseNumber() { System.out.println(baseNumber); // 10 } } // 익명 클래스 IntConsumer intConsumer = new IntConsumer() { @Override public void accept(int i) { System.out.println(i + baseNumber); // i + 10 } }; }
}
<br>
<br>자유 변수는 final로 선언되어 있어야 한다.
<br>final로 선언되지 않은 자유 변수는 final처럼 동작해야 한다. (effectively final)
<br>
<br>지역 변수는 JVM의 영역 중 stack영역에 생성된다.
<br>쓰레드별로 해당 stack영역을 별로 갖는다.
<br>즉, 쓰레드 끼리 공유가 되지 않는다.
<br>반면 인스턴스 변수는 Heap영역에 생성된다.
<br>즉, 인스턴스 변수는 공유가 가능하다.<br>
람다는 별도의 쓰레드에서 실행이 가능하다.<br>
따라서 지역 변수(자유 변수)가 있는 쓰레드가 사라졌을 때, 람다가 이 변수를 참조하고 있다면, 오류를 야기할 수 있는것이다.
<br>
<br>람다는 자유 변수를 참조할 때 직접 그 변수를 참조하는 것이 아닌,<br>
자유 변수를 자신의 stack영역에 복사하여 참조하는 방법으로 참조 오류를 해결했다.
<br>이러한 이유로 자유 변수는 수정이 불가능하도록 final처럼 동작해야 하는 것이다.
<br>
<br>로컬 클래스 / 익명 클래스 / 람다 모두 자유 변수를 참조할 수 있다는 공통점이 있다.
<br>하지만 로컬클래스 / 익명클래스와 다르게 람다에서는 자유 변수와 같은 이름의 변수를 선언할 수 없다.<br>
람다의 scope는 자유변수의 scope와 같기 때문이다.<br>
반면 로컬/익명 클래스는 내부에 생성된 변수의 스코프가 더 지엽적이기 때문에 선언이 가능하다.
<br>
<br>클래스 레벨의 변수나, 메서드, 블록 을 정의 할 때 사용된다.
<br>인스턴스(객체)생성 , new키워드 없이도 접근이 가능하다.
<br>모든 인스턴스에서 공유된다.
<br>static변수는 프로그램이 빌드될 때 메모리에 할당, 종료될 때 까지 유지.<br>
static키워드의 남용은 OOP의 원칙과 상반되며, 메모리 사용량의 증가로 이어질 수 있으므로 주의가 필요하다.
<br>
<br>클래스 레벨에서 공유되는 값을 정의할 때 사용.
<br>인스턴스마다 별도의 복사본을 유지 할 필요가 없다.
<br>메모리 사용을 최적화 할 수 있다.
<br>
<br>클래스 생성없이 직접 호출 가능.
<br>유틸리티 함수나, 상태가 필요없는 연산에 주로 활용. ex) 수학 연산
<br>인스턴스 생성의 오버헤드 없이 빠른 실행이 가능하다.<br>
단, static메서드는 해당 클래스 내의 다른 static메서드나, 변수에만 접근 할 수 있으므로 인스턴스 멤버에 접근해야하는 경우 사용할 수 없다.
<br><img alt="Pasted image 20250122111223.png" src="http://lts.kr/사진-및-문서/pasted-image-20250122111223.png" target="_self"><br>
<br>int, long, booolean 등 기본 자료형을 생성할 때 저장하는 공간
<br>임시적으로 사용되는 변수나 정보들이 저장되는 영역
<br>메서드 호출 시 마다 스텍 프레임(그 메서드만을 위한 공간이 생성되고, 그 메서드 안에서<br>
사용되는 값들을 저장하고, 호출된 메서드의 매개변수, 지역변수, 리턴 값 등을 임시로 저장한다.<br>그리고 메서드의 수행이 끝나면 프레임별로 삭제된다.<br>단, 데이터 타입에 따라 스텍과 힙에 저장되는 방식이 다르다는 점을 유의해야한다.<br>위사진 참고<br>- 이를 넘어서면 StackOverFlowError를 발생한다.
<br>
<br>메서드 영역과 함께 모든 스레드가 공유한다.
<br>JVM이 관리하는 프로그램 상에서 데이터를 저장하기 위해 런타임 시 동적으로 할당되어 사용되는 영역이다.
<br>new연산자로 생성되는 클래스와 인스턴스 변수, 배열 타입 등 Reference Type이 저장된다.
<br>메서드 영역에 저장된 클래스만이 힙영역에 생성이 되어 적재된다.<br>
힙영역에 더이상 아무도 참조하지않는 객체가 있다면, GC에 의해 제거된다.
<br>]]></description><link>http://lts.kr/study/cs/☕-java-,-oop.html</link><guid isPermaLink="false">study/CS/☕ JAVA , OOP.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Wed, 19 Feb 2025 06:28:44 GMT</pubDate><enclosure url="http://lts.kr/사진-및-문서/pasted-image-20250110101642.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="http://lts.kr/사진-및-문서/pasted-image-20250110101642.png"&gt;&lt;/figure&gt;</content:encoded></item></channel></rss>