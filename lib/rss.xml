<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[blog]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://lts.kr/</link><image><url>http://lts.kr/lib/media/favicon.png</url><title>blog</title><link>http://lts.kr/</link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Fri, 14 Mar 2025 06:14:07 GMT</lastBuildDate><atom:link href="http://lts.kr/lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Fri, 14 Mar 2025 06:14:02 GMT</pubDate><copyright><![CDATA[taesung's Blog]]></copyright><ttl>60</ttl><dc:creator>taesung's Blog</dc:creator><item><title><![CDATA[📕 공부]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="http://lts.kr/?query=tag:모음" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#모음</a> <br> <a href="http://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="http://lts.kr?query=tag:모음" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#모음">#모음</a><br>공부
보고 배운 지식 중 공유하고 싶은 정보를 모아둔 카테고리 입니다.
<br>
<br><a data-href="⏰ Script 로딩 지연 이슈" href="http://lts.kr/issue_troubleshooting/⏰-script-로딩-지연-이슈.html" class="internal-link" target="_self" rel="noopener nofollow">⏰ Script 로딩 지연 이슈</a>⭐
<br><a data-href="🔐 상품 투자하기 서비스 이슈 및 Lock기법 개선안" href="http://lts.kr/issue_troubleshooting/🔐-상품-투자하기-서비스-이슈-및-lock기법-개선안.html" class="internal-link" target="_self" rel="noopener nofollow">🔐 상품 투자하기 서비스 이슈 및 Lock기법 개선안</a>⭐
<br><a data-href="🍂 JPA, Mybatis , Dead Lock이슈" href="http://lts.kr/study/dev-seminar/🍂-jpa,-mybatis-,-dead-lock이슈.html" class="internal-link" target="_self" rel="noopener nofollow">🍂 JPA, Mybatis , Dead Lock이슈</a>⭐
<br><a data-href="🚦 Spring Batch 트러블슈팅" href="http://lts.kr/issue_troubleshooting/🚦-spring-batch-트러블슈팅.html" class="internal-link" target="_self" rel="noopener nofollow">🚦 Spring Batch 트러블슈팅</a>
<br><a data-href="⚔ StckOverflow 이슈와 QueryDSL" href="http://lts.kr/issue_troubleshooting/⚔-stckoverflow-이슈와-querydsl.html" class="internal-link" target="_self" rel="noopener nofollow">⚔ StckOverflow 이슈와 QueryDSL</a>
<br>
<br><a data-href="🛬 JDK와 JRE, JVM" href="http://lts.kr/study/cs/🛬-jdk와-jre,-jvm.html" class="internal-link" target="_self" rel="noopener nofollow">🛬 JDK와 JRE, JVM</a>
<br><a data-href="🌋 OSIV와 영속성 컨텍스트" href="http://lts.kr/study/cs/🌋-osiv와-영속성-컨텍스트.html" class="internal-link" target="_self" rel="noopener nofollow">🌋 OSIV와 영속성 컨텍스트</a> <br><a data-href="🐰 Java의 String과 SpringBuffer" href="http://lts.kr/study/cs/🐰-java의-string과-springbuffer.html" class="internal-link" target="_self" rel="noopener nofollow">🐰 Java의 String과 SpringBuffer</a>
<br><a data-href="🍊 Spring의 의존성 주입(DI)" href="http://lts.kr/study/cs/🍊-spring의-의존성-주입(di).html" class="internal-link" target="_self" rel="noopener nofollow">🍊 Spring의 의존성 주입(DI)</a>
<br><a data-href="🪕 JPA 에 대한 고찰" href="http://lts.kr/study/cs/🪕-jpa-에-대한-고찰.html" class="internal-link" target="_self" rel="noopener nofollow">🪕 JPA 에 대한 고찰</a>
<br>
<br><a data-href="☕ JAVA , OOP" href="http://lts.kr/study/cs/☕-java-,-oop.html" class="internal-link" target="_self" rel="noopener nofollow">☕ JAVA , OOP</a>
<br><a data-href="🍃 Spring" href="http://lts.kr/study/cs/🍃-spring.html" class="internal-link" target="_self" rel="noopener nofollow">🍃 Spring</a>
<br><a data-href="🎩 DevOps" href="http://lts.kr/study/cs/🎩-devops.html" class="internal-link" target="_self" rel="noopener nofollow">🎩 DevOps</a>
<br><a data-href="📔 DataBase" href="http://lts.kr/study/cs/📔-database.html" class="internal-link" target="_self" rel="noopener nofollow">📔 DataBase</a>
<br><a data-href="📭 Server" href="http://lts.kr/study/cs/📭-server.html" class="internal-link" target="_self" rel="noopener nofollow">📭 Server</a>
<br><a data-href="🐞 etc" href="http://lts.kr/study/cs/🐞-etc.html" class="internal-link" target="_self" rel="noopener nofollow">🐞 etc</a>
<br>
<br><a data-href="🤠 Coding Test 풀이 모음" href="http://lts.kr/study/coding-test/🤠-coding-test-풀이-모음.html" class="internal-link" target="_self" rel="noopener nofollow">🤠 Coding Test 풀이 모음</a>
<br><a data-href="👽 Algorithm" href="http://lts.kr/study/coding-test/👽-algorithm.html" class="internal-link" target="_self" rel="noopener nofollow">👽 Algorithm</a>
<br>
<br><a data-href="🔻 Redis 캐쉬 전략 - hello 서비스에 적용하여 성능개선 가능성" href="http://lts.kr/study/dev-seminar/🔻-redis-캐쉬-전략-hello-서비스에-적용하여-성능개선-가능성.html" class="internal-link" target="_self" rel="noopener nofollow">🔻 Redis 캐쉬 전략 - hello 서비스에 적용하여 성능개선 가능성</a>
<br><a data-href="🔐 상품 투자하기 서비스 이슈 및 Lock기법 개선안" href="http://lts.kr/issue_troubleshooting/🔐-상품-투자하기-서비스-이슈-및-lock기법-개선안.html" class="internal-link" target="_self" rel="noopener nofollow">🔐 상품 투자하기 서비스 이슈 및 Lock기법 개선안</a>
<br><a data-href="🔹 TDD에 대하여" href="http://lts.kr/study/dev-seminar/🔹-tdd에-대하여.html" class="internal-link" target="_self" rel="noopener nofollow">🔹 TDD에 대하여</a>
<br><a data-href="🍂 JPA, Mybatis , Dead Lock이슈" href="http://lts.kr/study/dev-seminar/🍂-jpa,-mybatis-,-dead-lock이슈.html" class="internal-link" target="_self" rel="noopener nofollow">🍂 JPA, Mybatis , Dead Lock이슈</a>
<br><a data-href="🥗 Spring Security_토큰-세션-쿠키-JWT 에 대하여" href="http://lts.kr/study/dev-seminar/🥗-spring-security_토큰-세션-쿠키-jwt-에-대하여.html" class="internal-link" target="_self" rel="noopener nofollow">🥗 Spring Security_토큰-세션-쿠키-JWT 에 대하여</a>
<br><a data-href="📔 DB 테이블 설계, 어떻게 하는게 옳은 방법인가" href="http://lts.kr/study/dev-seminar/📔-db-테이블-설계,-어떻게-하는게-옳은-방법인가.html" class="internal-link" target="_self" rel="noopener nofollow">📔 DB 테이블 설계, 어떻게 하는게 옳은 방법인가</a>]]></description><link>http://lts.kr/study/📕-공부.html</link><guid isPermaLink="false">study/📕 공부.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Fri, 14 Mar 2025 06:13:50 GMT</pubDate></item><item><title><![CDATA[🪕 JPA 에 대한 고찰]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="http://lts.kr/?query=tag:JPA" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#JPA</a> <a class="tag" href="http://lts.kr/?query=tag:DB" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#DB</a> <a class="tag" href="http://lts.kr/?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <br> <a href="http://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="http://lts.kr?query=tag:JPA" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#JPA">#JPA</a> <a href="http://lts.kr?query=tag:DB" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#DB">#DB</a> <a href="http://lts.kr?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a><br>
<br>java에서 DB를 사용할 수 있도록 연결해주는 응용프로그램 인터페이스인 java api이다.
<br>java와 연동되는 DBMS에 따라 그에 맞는 JDBC(ex. MySQL Connector)를 설치해야 한다.
<br>그에 맞는 드라이버만 존재한다면, java에서 DB에 구애받지 않고 똑같은 코드로 사용이 가능하다.
<br>
<br>SQL명령을 명시적으로 작성해야 한다.
<br>객치지향 프로그래밍과의 괴리가 있다.
<br>
<br>DB를 엑세스 하기 위한 표준 개방형 응용 프로그램 인터페이스를 뜻한다.
<br>ODBC는 JDBC와 달리 모든 어떠한 DBMS인지와 상관없이 적용된다. <br>
<br>jpa는 서로 다른 두 개념을 매핑해주는 ORM(Object Relational Mapping)중 하나이다.
<br>DB와 java객체간의 매핑을 자동화하여, SQL대신 java객체와 상호작용 하도록 설계되어있다. <br>RDB는 하나의 row를 하나의 인스턴스라고 생각한다면 컬럼의 값은 필드의 값으로 매핑할 수 있다.
<br>하지만 객체의 필드에 리스트가 존재하는 경우 상황이 애매해진다.
<br>또한 java객체의 필드에 또 다른 객체가 존재한는 경우 java는 참조를 하지만, DB는 Join으로 접근하기 때문에 다르다.
<br>이러한 비슷한 두 개념을 매핑해주는 역할을 하는것이다. <br>JPA는 DB와 객체를 매핑하는 기술일 뿐,<br>
내부적으로 DB와 통신을 위해서는 JDBC를 필요로 하게된다.<br>또한 JPA도 JDBC와 마찬가지로 인터페이스이기 때문에 구현체가 필요하고, 그 구현체 중 하나가 Hibernate이다.<br>
<br>Spring Data JPA란 JPA를 Repository 기반으로 간편하고 효율적으로 사용할 수 있는 모듈이다.
<br>Repository의 메서드를 통해 쿼리를 날릴 수 있다.
<br>또는 직접 쿼리를 만들고 싶다면 @Query 어노테이션을 사용한다.
<br> <img alt="Pasted image 20250110144021.png" src="http://lts.kr/사진-및-문서/pasted-image-20250110144021.png" target="_self"><br>
<br>JPQL은 JPA에서 사용되는 쿼리 언어로, SQL과 비슷하지만 객체를 대상을 쿼리를 작성하게된다.
<br>테이블이 아닌 엔티티 객체를 대상으로 하기 때문에, 객체지향적이다.
<br>
<br>SQL 유사성 : select, where, group by 등 SQL 과 유사한 문법 사용
<br>엔티티 중심 : DB테이블 대신 엔티티 클래스와 속성을 기준으로 작성한다.
<br>동적 쿼리 지원 : 런타임에 JPQL 문자열 생성 실행 가능
<br>별칠(alias) 사용 필수
<br>
<br>문자열(String)형태 이기에 개발자 의존적 형태이다 <br>컴파일 단계에서 타입체크가 불가능하다 <br>런타임단계에서 오류가 발생할 수 있다 <br>
<br>위에서 기술한 JPQL의 문제점을 보완하기 위해 나온것이 query dsl이다.
<br>정적 타입을 이용해, SQL, JPQL을 코드로 작성할 수 있도록 도와주는 오픈소스 API
<br>
<br>컴파일 단계에서 오류 확인 가능, 후속 조치 가능 <br>JPQL의 단점들을 거의 보완
<br>
<br>코드가 너무 길어진다... <br>FROM절의 서브쿼리를 사용하는것에 제약이 있다. <br>세세한 튜닝이나, DBMS의 고유기능을 유연하게 사용할 수 없다. <br>N+1 문제는 데이터베이스와 애플리케이션 간의 비효율적인 쿼리 실행으로 인해 발생하는 성능 문제를 지칭합니다.<br>
이는 주로 ORM(Object-Relational Mapping) 기술(JPA, Hibernate 등)을 사용할 때 발생하며, 한 번의 데이터베이스 조회로 해결할 수 있는 작업에 대해 추가적인 N개의 쿼리가 실행되는 상황을 의미합니다.<br>N+1 문제는 주로 지연 로딩(Lazy Loading)으로 인해 발생합니다.<br>
지연 로딩은 관련 엔티티를 필요할 때만 로딩하는 방식으로, 기본적으로 효율적인 방법이지만 아래와 같은 상황에서 문제가 발생합니다.<br>
<br>
두 개의 엔티티 간 관계: <br>Parent(부모 엔티티)와 Child(자식 엔티티) 관계.
<br>Parent 1개에는 여러 Child가 연결. <br>
문제 발생 과정: <br>부모 엔티티를 조회하는 쿼리 1번 실행.
<br>각 부모 엔티티에 연결된 자식 엔티티를 조회하는 쿼리 N번 실행. <br>List&lt;Parent&gt; parents = entityManager.createQuery("SELECT p FROM Parent p", Parent.class).getResultList(); // 각 Parent 엔티티의 자식 엔티티를 로드 (지연 로딩)
for (Parent parent : parents) { System.out.println(parent.getChildren().size()); // 자식 엔티티 조회 쿼리 발생
} <br>
<br>SELECT * FROM Parent; → 부모 엔티티를 조회하는 쿼리 1번 실행.
<br>SELECT * FROM Child WHERE parent_id = ?; → 각 부모 엔티티마다 자식 데이터를 조회하는 쿼리 N번 실행.
<br>결과적으로 1 + N개의 쿼리가 실행됩니다.
<br>데이터가 많을수록 성능 저하가 극심해집니다.
<br>
<br>데이터베이스와 애플리케이션 간의 불필요한 트래픽 증가.
<br>쿼리 실행 횟수가 많아져 응답 시간이 느려짐.
<br>대량의 데이터가 있을 경우 애플리케이션 성능이 크게 저하.
<br>
<br>페치 조인은 SQL의 JOIN을 사용해 관련된 엔티티를 한 번의 쿼리로 로드하는 방식입니다.
<br>String jpql = "SELECT p FROM Parent p JOIN FETCH p.children";
List&lt;Parent&gt; parents = entityManager.createQuery(jpql, Parent.class).getResultList();
<br>JOIN FETCH를 사용하면 부모와 자식 엔티티를 한 번에 가져옵니다.
<br>장점: 데이터베이스 쿼리를 최소화.
<br>단점: 데이터가 많을 경우 메모리 사용량 증가.
<br>
<br>JPA에서 제공하는 기능으로, 로딩 시 어떤 관계를 함께 로드할지 명시적으로 정의합니다
<br>@Entity
@NamedEntityGraph( name = "Parent.withChildren", attributeNodes = @NamedAttributeNode("children")
)
public class Parent { ... } // 사용 시
EntityGraph&lt;?&gt; entityGraph = em.getEntityGraph("Parent.withChildren");
List&lt;Parent&gt; parents = em.createQuery("SELECT p FROM Parent p", Parent.class) .setHint("javax.persistence.fetchgraph", entityGraph) .getResultList(); <br>장점: 명시적으로 필요한 관계만 가져올 수 있음.
<br>단점: 추가적인 설정 필요.
<br>
<br>필요한 데이터만 직접 SQL 또는 JPQL로 조회하여 반환.
<br>String jpql = "SELECT new com.example.dto.ParentChildDTO(p.name, c.name) " + "FROM Parent p JOIN p.children c";
List&lt;ParentChildDTO&gt; dtos = entityManager.createQuery(jpql, ParentChildDTO.class).getResultList(); <br>장점: 불필요한 엔티티 로드 방지.
<br>단점: 객체 매핑 작업 추가.
<br>
<br>데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위
<br>
<br>Spring에서 제공하는 트렌젝션 관리 기능과 JPA를 연결하는 역할을 수행.
<br>
<br>클래스나 메서드에 삽입하면, AOP레벨(프록시를 사용하여)에서 트렌젝션매니저를 이용한 동작을 공통으로 적용.
<br>
<br>영속성 컨텍스트를 관리하는 인터페이스
<br>엔티티의 저장/수정/삭제/조회 작업을 수행
<br>스레드 세이프하지 않으므로 한트레젝션 내에서만 사용
<br>앤티티매니저펙토리는 스레드세이프하므로 공유 가능
<br>
<br>JPA의 엔티티를 관리하는 1차 캐시 역할을 하는 메모리 공간
<br>엔티티와 DB데이터간의 상태 동기화를 책임
<br>1차캐싱 / 변경 감지 / 지연 로딩 의 특징을 갖는다
<br>지연로딩 : 관계된 엔티티를 실제로 필요할때만 가져오며, 변경점을 한번만 commit한다
<br>
<br>Lazy Loading(지연 로딩)은 연관된 엔티티를 즉시 로딩하지 않고, 필요한 순간에 쿼리를 실행하여 데이터를 가져오는 방식이다.
<br>객체를 사용할 때까지 실제 데이터를 로드하지 않고 대기하다가, 해당 데이터가 필요할 때만 SELECT 쿼리를 실행하는 방식이다.
<br>
<br>엔티티를 조회할 때 연관된 엔티티를 즉시 가져오지 않음.
<br>필요할 때(getter 호출 시) 추가적인 SELECT 쿼리를 실행하여 데이터를 가져옴.(커넥션 재할당)
<br>JPA는 프록시 객체를 사용하여 Lazy Loading을 구현함.
<br>
<br>DB스냅샷 : <br>트렌젝션이 시작될때 생성된다.
<br>독립적인 데이터베이스 복사본으로, 원본데이터 변경과 무관하다.
<br>고급 격리 수준(REPEATABLE READ, SERIALIZABLE)에서 MVCC(Multi-Version Concurrency Control)를 구현할 때 사용한다.
<br>물리적인 복사본이 아닌, 논리적으로 매 쿼리마다 동적으로 가공이 되는 방식이다. <br>앤티티매니저_스냅샷 : <br>엔티티가 영속성 컨텍스트에 로드될 때 생성된다.
<br>엔티티의 초기 상태를 저장하여 변경 감지에 사용된다.]]></description><link>http://lts.kr/study/cs/🪕-jpa-에-대한-고찰.html</link><guid isPermaLink="false">study/CS/🪕 JPA 에 대한 고찰.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Fri, 14 Mar 2025 06:14:03 GMT</pubDate><enclosure url="http://lts.kr/사진-및-문서/pasted-image-20250110144021.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="http://lts.kr/사진-및-문서/pasted-image-20250110144021.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🍂 JPA, Mybatis , Dead Lock이슈]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:세미나" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#세미나</a> <a class="tag" href="http://lts.kr/?query=tag:이슈" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#이슈</a> <a class="tag" href="http://lts.kr/?query=tag:JPA" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#JPA</a> <a class="tag" href="http://lts.kr/?query=tag:Java" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Java</a> <a class="tag" href="http://lts.kr/?query=tag:Mybatis" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Mybatis</a> <a class="tag" href="http://lts.kr/?query=tag:DeadLock" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#DeadLock</a> <br> <a href="http://lts.kr?query=tag:세미나" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#세미나">#세미나</a> <a href="http://lts.kr?query=tag:이슈" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#이슈">#이슈</a> <a href="http://lts.kr?query=tag:JPA" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#JPA">#JPA</a> <a href="http://lts.kr?query=tag:Java" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Java">#Java</a> <a href="http://lts.kr?query=tag:Mybatis" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Mybatis">#Mybatis</a> <a href="http://lts.kr?query=tag:DeadLock" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#DeadLock">#DeadLock</a><br>정보
해당 내용은 Hello 주간 세미나 중 주제로 선정된,<br>
투자하기 Dead Lock이슈 해결과정에 대한 설명이다.
<br>
<br>server log
<br>Caused by: org.apache.ibatis.exceptions.PersistenceException:
###Error querying database. Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is java.sql.SQLTransientConnectionException: HikariPool-1 - Connection is not available, request timed out after 30008ms.
###The error occurred while executing a query
###Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is java.sql.SQLTransientConnectionException: HikariPool-1 - Connection is not available, request timed out after 30008ms.
Caused by: java.sql.SQLTransientConnectionException: HikariPool-1 - Connection is not available, request timed out after 30008ms.
at com.zaxxer.hikari.pool.HikariPool.createTimeoutException(HikariPool.java:696)
at com.zaxxer.hikari.pool.HikariPool.getConnection(HikariPool.java:197)
at com.zaxxer.hikari.pool.HikariPool.getConnection(HikariPool.java:162)
<br>해당 서버의 maximum-pool-size는 40으로 설정되어있으며,<br>
30초의 대기를 했음에도 Connection Pool을 할당받지 못한 상황이다.<br>위 조건 발생 코드 예시
<br>public void deadLockMethod(){ mybatisSelectMethod(); jpaSelectMethod(); mybatisSelectMethod();
}
<br>
<br>해당 로직은 몇개월 전 수정 된 이후, 계속해서 정상적으로 운영되던 코드이다.
<br>순간적으로 트레픽이 몰린 상황을 가정하더라도, 40개의 pool이 30초간 점유를 지속한 것은 비정상 적이다.
<br>
<br>일반적으로 deadlock은 DB레벨에서의 트렌젝션이 서로 기다리는 경우에 많이 발생한다.
<br>하지만, Stack trace를 확인하였을 때, DB레벨의 deadlock은 아니었다.
<br>
<br>서비스 로직에서 한 서비스가 커넥션풀을 반환하지 않고, 또 다른 서비스가 커넥션 풀을 요청하면 무한 순환이 발생할 가능성이 있다.
<br>즉, 위 예시 코드에서 Connection Pool을 반환하지 않고 무한정 대기할 가능성이 가장 크다고 판단하였다.<br>public void deadLockMethod(){ mybatisSelectMethod(); jpaSelectMethod(); mybatisSelectMethod();
}
<br>커넥션 풀 상호 점유가 일어나고 있는 서비스 로직을 보았을 때, 특별한 점은 보이지 않는다.<br>
그러나, 한가지<br>
mybatis와 jpa를 혼용해서 사용중인 로직인 점이 눈에 뛴다.<br>@Transactional 이 걸려있지 않기 때문에, 순차적으로<br>mybatisSelectMethod(); : 커넥션 풀 점유 후 반환
<br>jpaSelectMethod(); : 앤티티 매니저에서 커넥션 풀 점유 후 close(반환)
<br>mybatisSelectMethod(); : 커넥션 풀 점유 후 반환<br>
(이때 커넥션풀이 전부 점유중이라면 대기 30s )
<br>의 순서로 진행될 거라고 생각했다.<br>MyBatis는 내부적으로 JDBC 커넥션을 관리하지 않고, DataSource를 통해 커넥션을 가져옴.<br>
즉, Spring에서 설정한 커넥션 풀(HikariCP, DBCP 등)을 통해 커넥션을 관리한다.**<br>
<br>MyBatis가 DataSource(ex: HikariCP)에서 커넥션을 요청
<br>SQL 실행 (SELECT 문 수행)
<br>커넥션이 자동 반환됨 (커밋/롤백 필요 없음)
<br>jpa또한 커넥션 풀을 통해 커넥션을 관리하지만, 영속성 컨텍스트(엔티티 매니저)에 권한을 위임한다.<br>
앤티티 매니자 : 영속성 컨텍스트를 관리하는 핵심 객체<br>
<br>jpa가 앤티티 매니저를 통해 DataSource(ex: HikariCP)에서 커넥션을 요청
<br>SQL 실행 (find(SELECT 문) 수행)
<br>엔티티 매니저 Close <br>커넥션 반환
<br>
<br>앤티티 매니저가 Connection Pool을 반환하는 시점은 언제인가
<br><a data-tooltip-position="top" aria-label="https://velog.io/@seyoung755/%EC%82%BD%EC%A7%88%EA%B8%B0-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%A7%80%EC%86%8D-%EB%B2%94%EC%9C%84-feat.-OSIV" rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@seyoung755/%EC%82%BD%EC%A7%88%EA%B8%B0-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%A7%80%EC%86%8D-%EB%B2%94%EC%9C%84-feat.-OSIV" target="_self">영속성 컨텍스트의 지속 범위</a><br>
-&gt; 서치 중 위 내용을 참고하여, OSIV 라는 것을 알게되었다.<br><img alt="Pasted image 20250314122906.png" src="http://lts.kr/사진-및-문서/pasted-image-20250314122906.png" style="width: 675px; max-width: 100%;" target="_self"><br>
OSIV란 View에 데이터를 전달할 때 지연 로딩 등의 이유로 영속성 컨텍스트를 지속해야 하는 경우에 사용되는 것이다.<br>
즉, 영속성 컨택스트(앤티티 매니저)의 생명주기를 웹 요청이 끝날 때 까지 연장하는 옵션이다.<br>
이 설정은 어플리케이션에 별다른 설정을 하지 않았다면 default ON 상태이다.<br>public void deadLockMethod(){ mybatisSelectMethod(); -- 1 jpaSelectMethod(); -- 2 mybatisSelectMethod(); -- 3
}
<br>다시 한번 위 코드를 보자.<br>트래픽이 몰려 커넥션 풀 40개가 전부 점유되었을 때를 가정하자.<br>조건<br>여러개의 클라언트의 요청이 동시에 발생
<br>2개 이상의 클라이언트가 2번함수를 수행 후, 영속성 컨택스트를 유지 중
<br>3번함수를 실행하려고 하나, 커넥션 풀이 가득차 대기상태에 돌입
<br>실행<br>개발자는 2번함수는 동작을 완료한 후 커넥션풀이 해제되길 기대함.
<br>OSIV 옵션이 켜져있을때, Lazy Loading이 view레이어 까지 이어짐.<br>
-즉, 동작이 완료되어도 커넥션풀을 해제하지 않음.
<br>3번함수는 커넥션풀이 해제되길 무한정 기다림.
<br>정말 다음과 같이 동작할까???<br>의문점
OSIV가 활성화되어 있어도, 트랜잭션이 끝나면 Hibernate는 커넥션을 즉시 반환할 텐데,<br>
어째서 무한 점유가 발생할 수 있는가?
<br>
<br>해당 서버의 옵션을 끄면, 데이터 일관성 문제 및 커넥션 점유 문제를 해결 가능<br>
한계 : 해당 서버의 다른 서비스 까지 직접적인 영향을 끼침
<br>
<br>@Transactional어노테이션은 서비스 레이어의 트렌젝션 관리에 쓰이는 것 이기 떄문에,<br>
OSIV 옵션으로 인한 view레이어의 지연로딩을 막을 수 없음
<br><a data-tooltip-position="top" aria-label="https://velog.io/@12onetwo12/%EC%9E%A5%EC%95%A0%ED%9A%8C%EA%B3%A0-DBCP-Connection-Leak-%ED%95%B4%EA%B2%B0-%EC%97%AC%EC%A0%95-feat.HikariCP-Dead-lock-QueryDSL" rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@12onetwo12/%EC%9E%A5%EC%95%A0%ED%9A%8C%EA%B3%A0-DBCP-Connection-Leak-%ED%95%B4%EA%B2%B0-%EC%97%AC%EC%A0%95-feat.HikariCP-Dead-lock-QueryDSL" target="_self">JPA, Mybatis 동시 사용시 발생할 수 있는 HikariCP Dead lock 해결 여정 ( feat.OSIV )</a>]]></description><link>http://lts.kr/study/dev-seminar/🍂-jpa,-mybatis-,-dead-lock이슈.html</link><guid isPermaLink="false">study/Dev Seminar/🍂 JPA, Mybatis , Dead Lock이슈.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Fri, 14 Mar 2025 06:14:04 GMT</pubDate><enclosure url="http://lts.kr/사진-및-문서/pasted-image-20250314122906.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="http://lts.kr/사진-및-문서/pasted-image-20250314122906.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🌋 OSIV와 영속성 컨텍스트]]></title><link>http://lts.kr/study/cs/🌋-osiv와-영속성-컨텍스트.html</link><guid isPermaLink="false">study/CS/🌋 OSIV와 영속성 컨텍스트.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Fri, 14 Mar 2025 06:13:42 GMT</pubDate></item><item><title><![CDATA[🚦 Spring Batch 트러블슈팅]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:트러블슈팅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#트러블슈팅</a> <a class="tag" href="http://lts.kr/?query=tag:EntityManager" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#EntityManager</a> <a class="tag" href="http://lts.kr/?query=tag:Transaction" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Transaction</a> <a class="tag" href="http://lts.kr/?query=tag:트렌젝션" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#트렌젝션</a> <br> <a href="http://lts.kr?query=tag:트러블슈팅" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#트러블슈팅">#트러블슈팅</a> <a href="http://lts.kr?query=tag:EntityManager" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#EntityManager">#EntityManager</a> <a href="http://lts.kr?query=tag:Transaction" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Transaction">#Transaction</a> <a href="http://lts.kr?query=tag:트렌젝션" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#트렌젝션">#트렌젝션</a><br>청크사이즈가 다름에도 처리속도가 똑같은 이유가 뭘까?<br>** Chunk 방식의 Batch에서 ChunkSize란, 한 트렌젝션 내에서 처리할 컬럼(DTO/모델)의 개수이다.<br>즉, ChunkSize가 작을수록 데이터 I/O작업 및 Overhead(데이터 읽기/쓰기, 트랜잭션 시작 및 종료 등)가 증가하여 총 실행시간이 길어져야한다.<br>청크 사이즈별 실행시간 측정 데이터
<br>grid-size:12 / chunk-size:30
-
3분 22.856초
3분 23.096초 grid-size:12 / chunk-size:20
-
3분 23.546초
3분 23.784초 grid-size:12 / chunk-size:10
-
3분 24.243초
3분 22.389초
3분 24.667초
3분 24.789초 grid-size:12 / chunk-size:5
-
3분 24.953초
3분 24.353초
<br>
<br>배치 서비스 로직의 일부
<br>dtoList.stream().parallel() .forEach(dto -&gt; {});
<br>스레드 확인
<br>} } IntStream.range(1, 10) .parallel() .forEach(i -&gt; System.out.println(Thread.currentThread().getName() + " - " + i)); }
} - 출력
ForkJoinPool.commonPool-worker-3 - 3
ForkJoinPool.commonPool-worker-1 - 1
ForkJoinPool.commonPool-worker-2 - 2
ForkJoinPool.commonPool-worker-0 - 4
... <br>
<br>별도의 셋팅이 없이 parallel() 구문을 사용하여 병렬 처리를 진행한다면,<br>
1.데이터를 작은 단위(Chunk)로 분할<br>
- 예를 들어, 1000개의 데이터를 4개의 스레드에서 처리한다고 하면, ForkJoinPool은 데이터를 여러 개의 Task로 나눈다.<br>
2.Worker Thread들이 분할된 작업을 병렬로 실행<br>
- 각 스레드는 자신이 맡은 작업을 처리하고, 남는 작업이 있다면 다른 스레드의 작업을 훔쳐(Work-Stealing) 가져와 실행한다.<br>
3.최종적으로 결과를 합쳐서 반환<br>
- 모든 작업이 완료되면 병렬 처리된 결과가 하나로 합쳐진다<br>
- ForkJoinPool이란?
Java에서 제공하는 병렬 작업을 최적화하는 스레드 풀로써,<br>
Work-Stealing 알고리즘을 사용하여 유휴스레드를 최소화하고 CPU 활용도를 극대화하는 기법이다. <br>해당 과정에서 ForkJoinPool은 작업을 여러 개의 워커 스레드(ForkJoinPool-worker-*)에서 실행하기 때문에 Spring의 ThreadLocal 기반 트랜잭션이 전파되지 않는다.<br>
<br>청크의 내부 서비스로직에서의 동작 효율을 위해 병렬처리를 사용했으나, ForkJoinPool기반의 정확한 동작원리를 충분히 고려하지 않아 발생한 이슈이다.
<br>해당 부분은 일반적인 forEach문으로 변경함으로써 이슈를 해결할 수 있었다.
<br>특히, 멀티스레드를 다룰 때에는 병렬처리를 함에 있어 주의를 필요로 함을 깨달았다.<br>반복 TEST 중.. 커넥션풀 Time Out 문제??<br><img alt="Pasted image 20241213102128.png" src="http://lts.kr/사진-및-문서/pasted-image-20241213102128.png" target="_self"><br>SHOW VARIABLES LIKE 'max_connections'; //최대 개수
SHOW STATUS LIKE 'Threads_connected'; //사용중인 개수
<br><img alt="Pasted image 20250304170347.png" src="http://lts.kr/사진-및-문서/pasted-image-20250304170347.png" target="_self"><br>
<img alt="Pasted image 20250304170412.png" src="http://lts.kr/사진-및-문서/pasted-image-20250304170412.png" target="_self"><br>
<img alt="Pasted image 20250304171240.png" src="http://lts.kr/사진-및-문서/pasted-image-20250304171240.png" target="_self"><br>운영 DB의 커넥션 pool은 충분한 상태로 보인다. <br>정보
처음 몇 번간은 정상실행 되지만, 반복 테스트 중 스레드 풀 점유 대기 타임아웃이 발생했다.
<br>배치를 완료한 이후에, 스레드 풀(히카리 풀)을 정상 반환하는지 확인.
<br><img alt="Pasted image 20241213102229.png" src="http://lts.kr/사진-및-문서/pasted-image-20241213102229.png" style="width: 750px; max-width: 100%;" target="_self"><br>먼저, QuerydslPagingItemReader의 doReadPage()의 종료조건에서 트렌젝션 커밋을 별도로 수행하지 않고 리턴을 시키고 있었다.<br>-&gt; 그럼에도 Step이 마무리될때, 적어도 Job이 마무리 될때, entityManager를 클로즈 시키는것이 자명한데, 어째서 커넥션풀이 해제되지 않을 수 있는가.<br>앤티티 매니저가 클로즈 되었음에도 커넥션풀을 물고있는 모습.<br>
<img alt="Pasted image 20241213143101.png" src="http://lts.kr/사진-및-문서/pasted-image-20241213143101.png" target="_self">
<br>코드를 뜯어보자...
<br>먼저, 앤티티 매니저는 커넥션의 반환을 위임받는다.<br>
<img alt="Pasted image 20250314120439.png" src="http://lts.kr/사진-및-문서/pasted-image-20250314120439.png" target="_self"><br>
그리고.. transactionObserver는 앤티티 매니저 객체와 연결된 트랜젝션 매니저가 종료되기를 바라보고 있었다.<br>즉,<br>주의
엔티티 매니저는 클로즈 될 때, 트렌젝션이 살아있다면 그 트렌젝션이 종료될때까지 기다린다.
<img alt="Pasted image 20241213143217.png" src="http://lts.kr/사진-및-문서/pasted-image-20241213143217.png" target="_self">
<br>
<br>엔티티 매니저가 클로즈 될 떄, 커넥션 pool이 반환될거라는 기대와는 달리,<br>
트렌젝션이 커밋 될 때 까지 커넥션pool을 계속해서 물고 있었다.<br>
(reader는 페이징을 위한 별도의 트렌젝션 생성)
<br>protected void doReadPage() { ... if (startIndex &gt;= totalRecords) { //마지막인덱스 확인 initResults(); // 빈 결과로 초기화 tx.commit(); //트렌젝션 커밋 return; } ...
<br><img alt="Pasted image 20241213103503.png" src="http://lts.kr/사진-및-문서/pasted-image-20241213103503.png" target="_self">]]></description><link>http://lts.kr/issue_troubleshooting/🚦-spring-batch-트러블슈팅.html</link><guid isPermaLink="false">Issue_TroubleShooting/🚦 Spring Batch 트러블슈팅.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Fri, 14 Mar 2025 06:14:04 GMT</pubDate><enclosure url="http://lts.kr/사진-및-문서/pasted-image-20241213102128.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="http://lts.kr/사진-및-문서/pasted-image-20241213102128.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🏹 예치금 차액 비교 Spring Batch 리펙토링]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:프로젝트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#프로젝트</a> <a class="tag" href="http://lts.kr/?query=tag:개발" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#개발</a> <a class="tag" href="http://lts.kr/?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <a class="tag" href="http://lts.kr/?query=tag:Batch" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Batch</a> <a class="tag" href="http://lts.kr/?query=tag:Partitioning" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Partitioning</a> <a class="tag" href="http://lts.kr/?query=tag:Chunk" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Chunk</a> <a class="tag" href="http://lts.kr/?query=tag:성능개선" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#성능개선</a> <br> <a href="http://lts.kr?query=tag:프로젝트" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#프로젝트">#프로젝트</a> <a href="http://lts.kr?query=tag:개발" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#개발">#개발</a> <a href="http://lts.kr?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a> <a href="http://lts.kr?query=tag:Batch" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Batch">#Batch</a> <a href="http://lts.kr?query=tag:Partitioning" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Partitioning">#Partitioning</a> <a href="http://lts.kr?query=tag:Chunk" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Chunk">#Chunk</a> <a href="http://lts.kr?query=tag:성능개선" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#성능개선">#성능개선</a> <br>기존 예치금 차액비교 Batch의 Tasklet방식의 배치의 단점을 보완하는 chunk 방식의 배치를 구현하고,<br>
나아가 다른 기능의 Batch에도 효과적으로 빠르게 적용할 수 있는재사용성/유지보수성 높은 코드, 선례를 만들기 위함이다.<br>
<br>Chunk, Partioning방식을 Job을 추가 개발 (기존 balanceJob 유지)
<br>당분간 두 Job을 병행하면서 비교
<br>추가한 Job 기능에 문제없다면 기존 balanceJob 삭제
<br><img alt="회사 은행 서비스1111.png" src="http://lts.kr/사진-및-문서/회사-은행-서비스1111.png" target="_self"><br>
<img alt="Spring Batch Tasklet 예치금 잔액 비교 1.png" src="http://lts.kr/사진-및-문서/spring-batch-tasklet-예치금-잔액-비교-1.png" target="_self"><br>
<img alt="Spring Batch Tasklet 예치금 잔액 비교 잘못된 차액발생 인식 타임라인.png" src="http://lts.kr/사진-및-문서/spring-batch-tasklet-예치금-잔액-비교-잘못된-차액발생-인식-타임라인.png" target="_self"><br>
<br>평균 소요시간: 약 17.35분
<br>최대 소요시간: 22분
<br>최소 소요시간: 12분<br>
<img alt="output (1).png" src="http://lts.kr/사진-및-문서/output-(1).png" target="_self">
<br>
<br>처음 가져온 Point 배치 완료시 까지 계속 물고있다. -&gt; 한 트렌젝션의 범위가 넓다.
<br>정보 <br>병목이 있진 않으나, 한 배치서비스의 트렌젝션에서 외부 api의 값 변동을 반영하지 못함. <br>
<br>G5-Point 등은 처음 7시 시점에 묶여있다. 회원별로 실데이터를 건건이 api(신한)를 호출하여 비교한다. 때문에, 7시 이후에 수정된데이터를 실시간으로 반영하지 못한다.
<br>
<br>목적 : batch의 step 레벨에서의 스레드 분리 ( 병렬처리 )
<br>
<br>독립적인 ExecutionContext가 주어져 상태를 안전하게 관리할 수 있다.
<br>
<br>목적 : 각 step내의 트렌젝션 단위 분리
<br>Reader / Processor / writer 가 역할을 분담
<br>
<br>
Partition 생성: <br>Partition 1 : ID 1 ~ 25 / 대기열1 : ID 101 ~ 125 / 대기열2 : ID 201 ~ 225
<br>Partition 2 : ID 26 ~ 50 / 대기열 : ID 126 ~ 150 / 대기열2 : ID 226 ~ 250
<br>Partition 3 : ID 51 ~ 75 / 대기열 : ID 151 ~ 175 / 대기열2 : -
<br>Partition 4 : ID 76 ~ 100 / 대기열 : ID 176 ~ 200 / 대기열2 : - <br>
각 Partition에서 Chunk 처리: <br>Partition 1: <br>Chunk 1: ID 1 ~ 10 → 커밋
<br>Chunk 2: ID 11 ~ 20 → 커밋
<br>Chunk 3: ID 21 ~ 25 → 커밋 <br>Partition 2: <br>Chunk 1: ID 26 ~ 35 → 커밋
<br>Chunk 2: ID 36 ~ 45 → 커밋
<br>Chunk 3: ID 46 ~ 50 → 커밋 <br>나머지 Partition도 동일 방식으로 처리. <br>
병렬 실행: <br>스레드 풀 크기 = 4이므로 4개의 Partition이 동시에 실행됩니다.
<br>Partition 처리 순서는 스레드 풀에서 처리되는 순서에 따라 다를 수 있음. <br>
트랜잭션 관리: <br>각 Partition은 독립적인 트랜잭션을 가짐.
<br>각 Chunk가 커밋될 때마다 트랜잭션이 종료됨. <br>
<br>
Partition 생성: <br>Partition 1 : ID 1 ~ 25 / 대기열1 : ID 101 ~ 125 / 대기열2 : ID 201 ~ 225
<br>Partition 2 : ID 26 ~ 50 / 대기열 : ID 126 ~ 150 / 대기열2 : ID 226 ~ 250
<br>Partition 3 : ID 51 ~ 75 / 대기열 : ID 151 ~ 175 / 대기열2 : ID 251 ~ 275
<br>Partition 4 : ID 76 ~ 100 / 대기열 : ID 176 ~ 200 / 대기열2 : ID 276 ~ 300
<br>추가 스레드 풀 생성
<br>Partition 5 : ID 300 ~ 325 / 대기열 : ID 326 ~ 350 / 대기열2 : ID 351 ~ 375
<br>추가 스레드 풀 생성
<br>Partition 6 : ID 376 ~ 400 / 대기열 : ID 401 ~ 425 / 대기열2 : ID 426 ~ 450 모든 대기열 소모 및 최대 스레드 풀 도달 =&gt; 작업 중단 및 오류 <br>-&gt; 이로볼때, 쿼리작업보다 api호출작업의 소요시간이 길어보임<br>범위 - 2017-11-07 ~ 2017-12-01
startDate=2017-11-07&amp;endDate=2017-12-01 ## 컬럼 개수 - 292개 기존 병렬처리 : 1분 7초
기존로직 : 6분 32초 t:스레드 개수 / c:각 스레드별 청크 파티션 수 ###### SimpleAsyncTaskExecutor vs ThreadPoolTaskExecutor SimpleAsyncTaskExecutor
g4/c10 : 1분 41.586초
g5/c10 : 1분 30.037초
g5/c3 : 1분 28.997초
g5/c1 : 1분 29.931초
g8/c10 : 1분 36.019초
g10/c1 : 1분 24.529초 - ThreadPoolTaskExecutor
Th min/maxSize64, g64/c10 : 1분 42.848초
Th min/maxSize32, g32/c10 : 1분 26.551초 Th min/maxSize16, g16/c10 : 1분 46.753초 / 1분 33.779초 / 2분 25.759초
1분 11.668초 / 2분 5.773초 / 2분 39.553초 Th min/maxSize32, g8/c20 : 3분 25.743초 Th min/maxSize16, g4/c10 : 2분 29.207초 / 2분 8.004초
<br>
<br>Grid사이즈(파티셔닝 갯수) 만큼 스레드 풀 계속 생성
<br>파티셔닝 갯수가 많아졌을 때, 스레드 생성/소멸에 드는 오버헤드 증가
<br>
<br>최소 스레드풀 개수 / 최대 스레드풀 개수 / 대기열 큐 크기 / 유휴 시간 모두 설정가능
<br>파티셔닝 갯수가 많을 경우, 처리 성능에 맞는 스레드 풀에서 대기작업으로 처리하여 오버헤드 감소
<br>
<br>총 처리량 기준 1/n로 각 스레드에 할당시 충분히 감당한 양으로, 대기열을 사용할 필요가 없다.
<br>
<br>쿼리 호출 및 페이징 기법 직접 구현
<br>
<br>Native Query 형태로 호출하여 자동 페이징
<br>
<br>Spring Batch에서는 공식적으로 지원하지 않음
<br>자동 페이징
<br>Querydsl형태로 쿼리 호출 가능
<br>
<br>기존(헬로)의 Querydsl기반 JPAQuery를 그대로 사용 가능
<br>자동 페이징
<br>그 외 Querydsl의 장점 보유
<br>
<br>기존 PagingItemReader의 메서드를 오버라이딩 하여 사용하며,<br>
JPQL이 수행되던 부분에 코드를 수정하였다.
<br>@Bean @Scope(value = "step", proxyMode = ScopedProxyMode.TARGET_CLASS) public QuerydslPagingItemReader&lt;HfbatBankBalanceCheckDto&gt; balanceReader() { ExecutionContext jobContext = Objects.requireNonNull(StepSynchronizationManager.getContext()).getStepExecution().getJobExecution().getExecutionContext(); Date startDate = (Date) jobContext.get(START_DATE_KEY); Date endDate = (Date) jobContext.get(END_DATE_KEY); return new QuerydslPagingItemReader&lt;&gt;( entityManagerFactory, executionOrder, DEFAULT_CHUNK_SIZE, queryFactory -&gt; repository.newFindChangeBalanceMemberList( startDate, endDate )); }
<br>
<br>각 파티션 스레드 별 종료 시간이 크게 상이하다. 총 소요시간 기준 최대 약 20% 차이
<br>적용 한다면, 각 스레드 별로 even하게 작업을 수행하여 총 소요시간을 줄일 수 있을것이라 판단 <br>JOB private static AtomicLong executionOrder = new AtomicLong(0); ... new QuerydslPagingItemReader&lt;&gt;( entityManagerFactory, executionOrder, DEFAULT_CHUNK_SIZE, queryFactory -&gt; repository.newFindChangeBalanceMemberList( startDate, endDate ));
<br>job 레벨에서의 스레드 세이프한 전역 변수를 생성하였다.
<br>그 후, 각 파티션 별 리더에 인자값으로 넘긴다.
<br>long currentExecutionOrder = executionOrder.getAndIncrement(); long startIndex = (currentExecutionOrder) * getPageSize(); int totalRecords = stepContext.getInt("totalRecords"); if (startIndex &gt;= totalRecords) { initResults(); // 빈 결과로 초기화 tx.commit(); return; } int chunkSizeToRead = Math.min(getPageSize(), (int) (totalRecords - startIndex)); // 남은 데이터 크기만큼 읽기 // QueryDSL Query 생성 JPQLQuery&lt;T&gt; query = createQuery() .offset(startIndex) .limit(chunkSizeToRead);
<br>
<br>먼저 한 청크단위의 작업을 끝낸 파티션은 그 다음 작업을 즉시 할당받게 된다.
<br>즉, 총 처리시간 기준 가장 빨리끝난 파티션과 가장 늦게 끝난 파티션의 실행 시간 차이는 최대 한 청크사이즈를 처리하는 시간보다 크지 않게 된다.
<br>1차 비교 이후 차액이 발생한 녀석들의 List 를 한번 더 검증한 후, =&gt; 추후 변경 됨<br>
검증된 녀석들을 <br>List&lt;BalanceCheckResultDto&gt; realDiffList= new ArrayList&lt;&gt;();
<br>최종적인 차액 리스트에 넣는다.<br>writer는 각 프로세서의 리턴으로 받은 녀석들을 하나의 DTO List로 합쳐 메세징 처리를 하게 된다.<br>
<br>유지보수성이 좋다.
<br>환경셋팅에 리소스가 많이든다. <br>
<br>구현 레벨이 가장 쉽다
<br>DTO(데이터)가 많아질 경우, 큰 리소스를 차지한다.
<br>
<br>방법 2.보다는 리소스가 적지만, 문자열 처리 시간이 추가로 소모된다.
<br>
<br>높은 쓰기 성능을 갖고있다.
<br>동시성 문제 없이 다중 스레드에서 사용 가능하다.
<br>인덱스로 접근이 불가능하다.
<br>QueueManager클래스를 생성하며 공통으로 사용 가능하도록 하였고,<br>@Slf4j public class QueueManager&lt;T&gt; { protected final ConcurrentLinkedQueue&lt;T&gt; sharedQueue = new ConcurrentLinkedQueue&lt;&gt;(); // 데이터 추가 public void addItemToSharedQueue(T item) { if (item != null) { sharedQueue.add(item); } }
<br>이를 상속받아 특정 오브젝트를 넘길 수 있도록 하였다.<br>public class BalanceQueue extends QueueManager&lt;BalanceCheckResultDto&gt;{ public List&lt;BalanceCheckResultDto&gt; getDtoFromQueue() { return super.getItemsFromQueue(); } }
<br><img alt="Pasted image 20241217150339.png" src="http://lts.kr/사진-및-문서/pasted-image-20241217150339.png" target="_self"><br>리스너에 너무 많은 역할이 부여된 모습
<br><img alt="Pasted image 20241219145746.png" src="http://lts.kr/사진-및-문서/pasted-image-20241219145746.png" target="_self"><br>
<br>StepExecution-Level ExecutionContext <br>
각 Step에 고유한 ExecutionContext가 생성됩니다. <br>
Step 내의 Reader, Processor, Writer 등에서 공유됩니다. <br>
다른 Step과는 공유되지 않습니다. <br>
balanceWorkerStep 내에서는 Reader, Processor, Writer가 동일한 ExecutionContext를 공유합니다. <br>
balancePartitionStep과 balanceWorkerStep의 ExecutionContext는 서로 독립적입니다. <br>JobExecution-Level ExecutionContext <br>Job 전체에서 공유되며, 모든 Step이 동일한 ExecutionContext에 접근할 수 있습니다.
<br>JobExecutionContext는 Step 간 데이터 전달이 필요할 때 유용합니다. <br>JobExecutionListener 객체 생성<br>@Slf4j public class JobTimerExecutionListener implements JobExecutionListener { private final String jobName; private long startTime = System.currentTimeMillis(); public JobTimerExecutionListener(String jobName) { this.jobName = jobName; } @Override public void beforeJob(JobExecution var1) { startTime = System.currentTimeMillis(); } @Override public void afterJob(JobExecution var1) { long endTime = System.currentTimeMillis(); long elapsedTime = endTime - startTime; long minutes = (elapsedTime / 1000) / 60; // 밀리초를 분으로 변환 double seconds = (elapsedTime / 1000.0) % 60; // 남은 밀리초를 초로 변환 (소수점 포함) log.info("{}-completed: {} ms | {} minutes {} seconds", jobName, elapsedTime, minutes, seconds); } }
<br><img alt="output (9) 1.png" src="http://lts.kr/사진-및-문서/output-(9)-1.png" target="_self"><br><img alt="output (10).png" src="http://lts.kr/사진-및-문서/output-(10).png" target="_self"><br><img alt="do-messenger_screenshot_2024-12-23_14_40_21.png" src="http://lts.kr/사진-및-문서/do-messenger_screenshot_2024-12-23_14_40_21.png" target="_self"><br><img alt="Pasted image 20241224093159.png" src="http://lts.kr/사진-및-문서/pasted-image-20241224093159.png" target="_self"><br>
<img alt="Pasted image 20241224093207.png" src="http://lts.kr/사진-및-문서/pasted-image-20241224093207.png" target="_self"><br>
<img alt="Pasted image 20241224093225.png" src="http://lts.kr/사진-및-문서/pasted-image-20241224093225.png" target="_self"><br>]]></description><link>http://lts.kr/project/hello-batch/🏹-예치금-차액-비교-spring-batch-리펙토링.html</link><guid isPermaLink="false">project/hello Batch/🏹 예치금 차액 비교 Spring Batch 리펙토링.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Fri, 14 Mar 2025 06:14:05 GMT</pubDate><enclosure url="http://lts.kr/사진-및-문서/회사-은행-서비스1111.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="http://lts.kr/사진-및-문서/회사-은행-서비스1111.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🍊 Spring의 의존성 주입(DI)]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="http://lts.kr/?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <a class="tag" href="http://lts.kr/?query=tag:FRAMWORK" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#FRAMWORK</a> <a class="tag" href="http://lts.kr/?query=tag:DI" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#DI</a> <a class="tag" href="http://lts.kr/?query=tag:의존성주입" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#의존성주입</a> <br> <a href="http://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="http://lts.kr?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a> <a href="http://lts.kr?query=tag:FRAMWORK" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#FRAMWORK">#FRAMWORK</a> <a href="http://lts.kr?query=tag:DI" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#DI">#DI</a> <a href="http://lts.kr?query=tag:의존성주입" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#의존성주입">#의존성주입</a><br>	@Component public class Controller{ @Autowired private Service servic ... }
<br>- 단일책임의 원칙 위반하기 쉬워진다.
- 의존성을 주입하기 쉽기 때문에, @Autoqwired아래에 개수 제한없이 추가할 수 있다.
- 이때, 하나의 class가 많은 책임을 갖고, 순환참조가 이뤄질 수도 있기 때문에
의존성이 높아져, 사용을 피하는것이 좋다.
<br>	@Component public class Controller{ private Service servic @Autowired private void setService(Service servic){ this.service = service; } }
<br>선택적인 의존성을 사용할때 유용하다.<br>
스프링 3.x 에서는 수정자 주입을 권장하고있다.<br>- 수정자 주입을 사용하게 되면, service구현제를 주입하지 않아도 controller객체는 생서이 가능하기때문에 널포인터익셉션이 발생할 가능성이 있다.
주입이 필요한 객체가 주입되지 않아도 얼마든지 객체를 생성할 수 있다는것이 문제다.
<br>	@Component public class Service{ private DAO dao; //생성자 @Autowired //생략가능 public Service(DAO dao){ this.dao = dao; } } @Component public class Controller{ private final Service servic = new Service( new DAO( ) ); /* Spring사용시 */ private final Service service; // 생성자 주입 @Autowired public Controller(Service service) { this.service = service; } }
<br>
<br>Spring Framework 에서 권장하는 방법으로, 필수적으로 사용해야하는 의존성 없이는 객체를 만들지 못하도록 강제할 수 있기 때문에 사용을 권장하고 있다.
<br>Spring 4.3 버전 이후부터는 Class를 완벽하게 DI Framework로 부터 분리할 수 있다.
<br>단일 생성자에 한해서 @Autowired를 붙이지 않아도 된다.
<br>필드 주입과 수정자 주입은 final로 선언할 수 없지만, 생성자 주입은<br>
final로 필드 객체를 선언하여 런타임에 불변성을 보장한다.
<br>앞서 설명한 필드 주입의 모든 단점을 보완할 수 있다.
<br>]]></description><link>http://lts.kr/study/cs/🍊-spring의-의존성-주입(di).html</link><guid isPermaLink="false">study/CS/🍊 Spring의 의존성 주입(DI).md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Fri, 14 Mar 2025 00:56:08 GMT</pubDate></item><item><title><![CDATA[2. 스프링 핵심 원리 이해]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:SpringCoreBasic" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SpringCoreBasic</a> <a class="tag" href="http://lts.kr/?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <a class="tag" href="http://lts.kr/?query=tag:lectur" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#lectur</a> <a class="tag" href="http://lts.kr/?query=tag:강의" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#강의</a> <br> <a href="http://lts.kr?query=tag:SpringCoreBasic" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SpringCoreBasic">#SpringCoreBasic</a> <a href="http://lts.kr?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a> <a href="http://lts.kr?query=tag:lectur" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#lectur">#lectur</a> <a href="http://lts.kr?query=tag:강의" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#강의">#강의</a><br>]]></description><link>http://lts.kr/lectur/2.-스프링-핵심-원리-이해.html</link><guid isPermaLink="false">lectur/2. 스프링 핵심 원리 이해.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Thu, 13 Mar 2025 09:08:35 GMT</pubDate></item></channel></rss>