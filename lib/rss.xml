<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[blog]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://lts.kr/</link><image><url>http://lts.kr/lib/media/favicon.png</url><title>blog</title><link>http://lts.kr/</link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Thu, 27 Mar 2025 09:20:55 GMT</lastBuildDate><atom:link href="http://lts.kr/lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Thu, 27 Mar 2025 09:20:52 GMT</pubDate><copyright><![CDATA[taesung's Blog]]></copyright><ttl>60</ttl><dc:creator>taesung's Blog</dc:creator><item><title><![CDATA[🍎 Redis로 Key관리하기]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="http://lts.kr/?query=tag:Redis" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Redis</a> <a class="tag" href="http://lts.kr/?query=tag:Cash" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Cash</a> <a class="tag" href="http://lts.kr/?query=tag:memory" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#memory</a> <a class="tag" href="http://lts.kr/?query=tag:다중서버" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#다중서버</a> <a class="tag" href="http://lts.kr/?query=tag:NoSql" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#NoSql</a> <br> <a href="http://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="http://lts.kr?query=tag:Redis" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Redis">#Redis</a> <a href="http://lts.kr?query=tag:Cash" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Cash">#Cash</a> <a href="http://lts.kr?query=tag:memory" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#memory">#memory</a> <a href="http://lts.kr?query=tag:다중서버" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#다중서버">#다중서버</a> <a href="http://lts.kr?query=tag:NoSql" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#NoSql">#NoSql</a><br>
<br>주로 애플리케이션 캐시 또는 빠른 응답 데이터베이스로 사용되는 오픈소스,<br>
인매모리, NoSql &lt;키, 벨류&gt; 저장소이다.
<br>또한, redis는 보조기억장치(HDD / SSD)가 아닌 메모리에 데이터를 저장하여<br>
탁월한 속도, 안정성, 성능을 제공할 수 있다.<br> 애플이케이션이 외부 데이터 소스에 의존하는 경우 트레픽이 증가하거나, 애플리케이션이 확장될때 소스의 지연 시간과 처리량으로 인하여 병목현상이 발생할 수 있다.<br>
이때 Redis를 적용하면, 데이터를 메모리에 저장하여 읽거나 쓸때 지연 시간을 최소화 할 수 있다.<br>
<br>redis는 앱 성능 향상을 위해 특별히 설계되어, 기존 NoSQL 데이터 저장소와 차별화 되는 기능이 있다.
<br>
<br>MongoDB, PostgreSql 과 같은 NoSQL DB와 달리, 메모리를 저장소로 사용하여<br>
읽기 쓰기 성능이 월등히 높다. 또한 고가용성과 확장성을 보장하는데 도움이된다.
<br>고가용성 이란?
가용성 : 서버 또는 네트워크 등의 정보 시스템이 정상적으로 사용 가능한 정도를 의미.<br>
== 정상적인 사용시간 / 전체 사용시간 = 시스템 가동률(가용성) 여기서, 고가용성이란 가용성이 99%, 99.9% 등과 같이 높은 가용성을 지닌 시스템을 의미한다.
<br>
<br>redis는 웹 클라이언트가 평소보다 처리하는데 오래 걸릴 수 있는 작업을 대기열에 넣을 수 있다.<br>
요청/응답 주기의 백그라운드에서 실행되는 자동화된 프로세스를 쉽게 구현할 수 있는 것이다.
<br>
<br>redis는 기술적으로는 키/벨류 저장소 이지만, 여러 데이터 유형과 구조를 지원하는 데이터 구조 서버이다.
<br>
<br>고유하고 정렬되지 않은 문자열
<br>바이너리 세이프 데이터
<br>하이퍼로그
<br>비트 배열
<br>해시
<br>목록
<br>
<br>RSA 적용기 ▶ <a data-href="🚨 RSA 암호화 방식의 이해와 적용 (feat.취약성점검)" href="http://lts.kr/study/cs/🚨-rsa-암호화-방식의-이해와-적용-(feat.취약성점검).html" class="internal-link" target="_self" rel="noopener nofollow">🚨 RSA 암호화 방식의 이해와 적용 (feat.취약성점검)</a>
<br>
<br>Disk 기반의 DB보다 성능 측면에서, 뛰어남.<br>
로그인/회원가입(트래픽이 크지 않음)의 보안성 향상을 위해, 복호화 요청이 들어왔을때 개인키를 꺼냄과 동시에 삭제시키고, 매번 새로 발급되도록 하였음. ( put / pop )형식
<br>
<br>다중 컨테이너 환경에서 동일한 인메모리(캐시)에 접근하기 위해서, 독립적인 서버를 갖는 Redis를 사용.
<br>Sticky Session도 있는데?
해당 방식은 요청에 대해 처리한 WAS에서만 세션을 관리(응답)하는 기법이다.<br>
세션을 고정시켜놓기에, 로드 벨런싱 기능이 잘 작동하기 힘들어 트래픽이 한 서버에 집중될 수 있다.
또한, Session Clustering을 사용한다면, 여러대의 서버에 세션을 동일하게 가져가야 하기 때문에,<br>
메모리 용량과 트래픽이 증가하게 된다.
<br>build.gradle에 의존성 추가 <br>implementation 'org.springframework.boot:spring-boot-starter-data-redis' <br>yml redis 속성 추가 <br>cache: type: redis redis: cache-null-values: true redis: host: `레디스 호스트`
port: `레디스 포트`
<br>
<br>@Configuration으로 redis사용에 필요한 셋팅을 Bean으로 등록할 클래스.
<br>@Configuration public class RedisConfiguration { @Value("${spring.redis.host}") private String host; @Value("${spring.redis.port}") private int port;
}
<br>Redis 서버와 연결을 생성 및 관리해주는 인터페이스<br>@Bean public RedisConnectionFactory redisConnectionFactory() { return new LettuceConnectionFactory(host, port); }
<br>어플리케이션 서버와 Redis 서버 간의 데이터 송수신을 하는 클라이언트
<br>대표적으로 Lettuce와 Jedis, Redisson 이 있다.
<br>
<br>비동기 및 논블로킹 I/O를 기반으로 하여 고부하, 다중 스레드 환경에 적합
<br>
<br>블로킹 I/O(동기) 방식을 사용.
<br>고부하나 비동기 처리가 중요한 환경에서는 효울이 떨어진다.
<br>
<br>단순히 Redis 연결을 관리하는 것을 넘어 분산 락, 분산 컬렉션, 분산 캐시 등 고급 기능을 제공.
<br>직접 RedisConnectionFactory로 사용하기보다는 RedissonClient를 빈으로 등록하고 이를 통해 분산 락이나 캐시 매니저를 구성.
<br> ▶ <a data-href="🔐 상품 투자하기 서비스 Lock기법 개선안" href="http://lts.kr/issue_troubleshooting/🔐-상품-투자하기-서비스-lock기법-개선안.html" class="internal-link" target="_self" rel="noopener nofollow">🔐 상품 투자하기 서비스 Lock기법 개선안</a><br>
<br>따라서 해당 코드에는 비동기 성능이 높은 좋은 Lettuce 선택.<br>Redis에 저장될 캐시의 기본 직렬화 및 만료 시간 등의 설정을 담당.<br>private RedisCacheConfiguration redisCacheDefaultConfiguration() { return RedisCacheConfiguration .defaultCacheConfig() .serializeKeysWith(RedisSerializationContext.SerializationPair .fromSerializer(new StringRedisSerializer())) .serializeValuesWith(RedisSerializationContext.SerializationPair .fromSerializer(new GenericJackson2JsonRedisSerializer());
}
<br>serializeKeysWith : StringRedisSerializer를 사용하여 키를 문자열로 직렬화합니다.
<br>serializeValuesWith : GenericJackson2JsonRedisSerializer와 ObjectMapper를 사용해 JSON 형식으로 직렬화 GenericJackson2JsonRedisSerializer : 직렬화 방식 중 하나로, JSON형식을 지원. <br>여러 캐시 이름에 대해 각기 다른 TTL(Time To Live)을 동적으로 설정.<br>private Map&lt;String, RedisCacheConfiguration&gt; redisCacheConfigurationMap() { Map&lt;String, RedisCacheConfiguration&gt; cacheConfigurations = new HashMap&lt;&gt;(); for (Map.Entry&lt;String, Long&gt; cacheNameAndTimeout : cacheProperties.getTtl().entrySet()) { cacheConfigurations .put(cacheNameAndTimeout.getKey(), redisCacheDefaultConfiguration().entryTtl( Duration.ofSeconds(cacheNameAndTimeout.getValue()))); cacheConfigurations .put(`원하는 Custom RedisCacheConfiguration 정책 추가`) // 커스텀 } return cacheConfigurations; }
<br>외부 설정(CacheProperties)에서 캐시별 TTL 정보를 읽어와 각 캐시의 만료 시간을 지정<br>
이를 통해 특정 캐시만 별도의 만료 정책 등을 적용할 수 있다.
<br>entryTtl : 기본 만료시간 설정
<br>Spring의 캐시 추상화에서 Redis를 캐시 저장소로 사용하기 위한 캐시 매니저를 생성<br>
위에서 설정한 redisCacheDefaultConfiguration과 cacheConfigurations(커스텀) 이 삽입된다.<br>@Bean
public CacheManager redisCacheManager(RedisConnectionFactory redisConnectionFactory) { return RedisCacheManager.RedisCacheManagerBuilder .fromConnectionFactory(redisConnectionFactory) .cacheDefaults(redisCacheDefaultConfiguration()) .withInitialCacheConfigurations(redisCacheConfigurationMap()) .build();
}
<br>withInitialCacheConfigurations : RedisCacheManager를 생성할 때 미리 정의된 특정 캐시 이름에 대해 개별적인 설정을 적용할 수 있도록 해주는 메서드입니다.
<br>
<br>추가예정.]]></description><link>http://lts.kr/study/cs/🍎-redis로-key관리하기.html</link><guid isPermaLink="false">study/CS/🍎 Redis로 Key관리하기.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Thu, 27 Mar 2025 09:20:16 GMT</pubDate></item><item><title><![CDATA[🚨 RSA 암호화 방식의 이해와 적용 (feat.취약성점검)]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="http://lts.kr/?query=tag:Tokken" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Tokken</a> <a class="tag" href="http://lts.kr/?query=tag:Security" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Security</a> <a class="tag" href="http://lts.kr/?query=tag:SPRING" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SPRING</a> <a class="tag" href="http://lts.kr/?query=tag:보안" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#보안</a> <br> <a href="http://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="http://lts.kr?query=tag:Tokken" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Tokken">#Tokken</a> <a href="http://lts.kr?query=tag:Security" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Security">#Security</a> <a href="http://lts.kr?query=tag:SPRING" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#SPRING">#SPRING</a> <a href="http://lts.kr?query=tag:보안" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#보안">#보안</a><br>1977년에 Rivest, Shamir, Adleman 이라는 세 명의 수학자가 고안해서 RSA라고 부른다.<br>
이 방식은 지금도 SSL/TLS, 이메일, 디지털 서명, 인증서 등 보안의 핵심 인프라에서 계속 쓰이고 있는 방식이다.<br>
<br>RSA는 "공개키로 암호화하고, 개인키로 복호화" 또는 그 반대로 동작하는 비대칭 암호화 알고리즘이다.
<br>
<br>공개키로 암호화된 데이터는 개인키를 소유한 공개키 생성자만이 복호화 가능하다.
<br>사용자( Client )마다 공개키와 개인키를 접근 시 새로 생성/발급하여 원본 데이터 추적이 불가하다.
<br>결론
즉, 클라이언트의 요청이 들어오면 서버에서 공개키(클라이언트에게 제공할 키) 와 개인키(서버측에서 갖고있는, 공개키와 한쌍이 되는 키) 를 매번 새로 발급하기 때문에, 추적이 어렵고 암호화에 뛰어나다.
<br>
<br>서비스 특성에 따라 적절하게 적용할 필요가 있다.
<br>정보 <br>RSA 키 객체 (PublicKey, PrivateKey) 는 메모리 상에서만 동작할 수 있다.
<br>우리가 파일, 네트워크, DB로 키를 주고받을 때는 Base64 문자열 로 직렬화해야 해야한다. <br>[로그인 / 회원가입 페이지]<br>클라이언트에서 서버에 공개키 요청
<br>서버에서 키쌍 과 KeyUUID 생성
<br>개인키는 KeyUUID와 함께 캐쉬에 저장 / 공개키는 KeyUUID와 클라이언트에 전달
<br>클라이언트는 서버로부터 받은 공개키로 평문 암호화, 서버에 전달
<br>암호화된 평문을 KeyUUID로 찾은 공개키로 복호화 -&gt; 평문 완성
<br>
<br>암호화, 해시, 키 생성, 인증서 처리, 서명 등 암호학 기반 기능들을 제공하는 클래스들의 모음이다.
<br> private static final String INSTANCE_TYPE = "RSA"; // 2048bit RSA KeyPair 생성. public static KeyPair generateKeypair() throws NoSuchAlgorithmException { KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(INSTANCE_TYPE); keyPairGen.initialize(2048, new SecureRandom()); return keyPairGen.genKeyPair(); } <br>KeyPairGenerator (공개키/개인키 쌍 생성) 을 사용한다.
<br>NoSuchAlgorithmException : 지정한 알고리즘 이름이 현재 JVM 환경에서 지원되지 않거나 잘못된 경우 발생하는 체크 예외다.
<br>KeyPair타입 : PrivateKey와 PublicKey로 이루어져있는 데이터 타입
<br>SecureRandom을 시드로 사용해 보안 수준 향상
<br> 2048bit로 RSA암호화 방식을 사용하여 keyPair를 생성하는 코드이다.<br>	private static final String INSTANCE_TYPE = "RSA"; // 평문 + 공개키 Base64로 암호문 생성 public static String rsaEncode(String plainText, String publicKey) throws InvalidKeyException, InvalidKeySpecException, NoSuchAlgorithmException, NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException { Cipher cipher = Cipher.getInstance(INSTANCE_TYPE); cipher.init(Cipher.ENCRYPT_MODE, convertPublicKey(publicKey)); byte[] plainTextByte = cipher.doFinal(plainText.getBytes()); return base64EncodeToString(plainTextByte); } //Base64 공개키 -&gt; 공개키로 디코딩 public static PublicKey convertPublicKey(String publicKey) throws InvalidKeySpecException, NoSuchAlgorithmException { KeyFactory keyFactory = KeyFactory.getInstance(INSTANCE_TYPE); byte[] publicKeyByte = Base64.getDecoder().decode(publicKey.getBytes()); return keyFactory.generatePublic(new X509EncodedKeySpec(publicKeyByte)); }
<br>
Cipher : Java 보안 API에서 실제 암호화/복호화를 수행하는 핵심 클래스<br>
AES, RAS, DES 같은 알고리즘을 직접 실행하는 암호 모듈 , 암호화 엔진 이다. <br>
Cipher cipher = Cipher.getInstance(INSTANCE_TYPE); : 타입에 따라, 암호화 모드와 패딩 방식이 결정된다. <br>
convertPublicKey : base64기반 코드를 실제 키 객체로 변환 <br>
KeyFactory : 키 복원용 펙토리 객체 <br>
keyFactory.generate... : 실제 키 객체 생성 <br>
X509EncodedKeySpec → 공개키 표준 포맷 스펙 <br>node-forge 패키지를 사용한다. base64, encode등 TLS프로토콜(암호화 도구)를 구현한 패키지 이다.
<br>&lt;script src="https://cdn.jsdelivr.net/npm/node-forge@1.3.1/dist/forge.min.js"&gt;&lt;/script&gt; &lt;script&gt;
/** * 서버에서 공개키를 받아서 RSA로 암호화하는 함수 * @param {string} plainText - 암호화할 평문 * @param {string} publicKeyBase64 - 서버로부터 받은 Base64 인코딩된 공개키 * @returns {string} 암호화된 Base64 문자열 */
function rsaEncryptWithBase64PublicKey(plainText, publicKeyBase64) { const forge = window.forge; // 1. Base64 디코딩 → DER 바이너리 const der = forge.util.decode64(publicKeyBase64); // 2. DER → ASN.1 파싱 → PublicKey 객체 const asn1 = forge.asn1.fromDer(der); const publicKey = forge.pki.publicKeyFromAsn1(asn1); // 3. RSA 암호화 const encryptedBytes = publicKey.encrypt(plainText, 'RSAES-PKCS1-V1_5'); // 4. 암호문을 Base64 인코딩해서 반환 return forge.util.encode64(encryptedBytes);
}
&lt;/script&gt;
<br>클라이언트 단에서 request전달 전, 암호화 하기 위한 코드 / 동작 구성은 2.1과 동일 하다
<br>	private static final String INSTANCE_TYPE = "RSA"; // 암호문 + 개인키 Base64로 평문 생성 public static String rsaDecode(String encryptedPlainText, String privateKey) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidKeySpecException, IllegalBlockSizeException, BadPaddingException { byte[] encryptedPlainTextByte = Base64.getDecoder().decode(encryptedPlainText.getBytes()); Cipher cipher = Cipher.getInstance(INSTANCE_TYPE); cipher.init(Cipher.DECRYPT_MODE, convertPrivateKey(privateKey)); return new String(cipher.doFinal(encryptedPlainTextByte)); } //Base64 개인키 -&gt; 개인키로 디코딩 public static PrivateKey convertPrivateKey(String privateKey) throws InvalidKeySpecException, NoSuchAlgorithmException { KeyFactory keyFactory = KeyFactory.getInstance(INSTANCE_TYPE); byte[] privateKeyByte = Base64.getDecoder().decode(privateKey.getBytes()); return keyFactory.generatePrivate(new PKCS8EncodedKeySpec(privateKeyByte)); }
<br>Cipher 객체를 사용하여 위와 동일하게 동작.
<br>PKCS8EncodedKeySpec → 개인키 표준 포맷 스펙
<br> public static String base64EncodeToString(byte[] byteData) { return Base64.getEncoder().encodeToString(byteData); }
<br>cipher.doFinal(...) 과 같은 코드는 바이너리 데이터로 리턴값을 보낸다.
<br>
<br>JUnit → 테스트 프레임워크 <br>AssertJ → 테스트 결과를 검증(assert)할 때 쓰는 강력한 assertion 도구
<br>JS코드는 제외<br>private static final String PLAIN_TEXT = "키 암/복호화 테스트 123 abc !@#"; @Test @DisplayName("RSA 키쌍 생성 및 암/복호화 통합 테스트") public void testGenerateKeypairAndEncryptDecrypt() throws Exception { // 키쌍 생성 KeyPair keyPair = rsaService.generateKeypair(); PublicKey publicKey = keyPair.getPublic(); PrivateKey privateKey = keyPair.getPrivate(); // 공개키, 개인키 → Base64 인코딩 String publicKeyBase64 = rsaService.base64EncodeToString(publicKey.getEncoded()); String privateKeyBase64 = rsaService.base64EncodeToString(privateKey.getEncoded()); System.out.println("공개키Base64 : " + publicKeyBase64); System.out.println("개인키Base64 : " + privateKeyBase64); // 암호화 String encryptedText = rsaService.rsaEncode(PLAIN_TEXT, publicKeyBase64); System.out.println("RSA암호화 텍스트 : " + encryptedText); // 복호화 (개인키 사용해야 함) String decryptedText = rsaService.rsaDecode(encryptedText, privateKeyBase64); System.out.println("RSA복호화 텍스트 : " + decryptedText); // 검증 Assertions.assertThat(decryptedText).isEqualTo(PLAIN_TEXT); }
<br>결과<br>
<img alt="Pasted image 20250325102427.png" src="http://lts.kr/사진-및-문서/pasted-image-20250325102427.png" target="_self"><br>Base64기반 String 변환 및 암/복호화 테스트 완료
<br>js암호화도 동일하게 동작 확인
<br><img alt="Pasted image 20250325165845.png" src="http://lts.kr/사진-및-문서/pasted-image-20250325165845.png" target="_self"><br>
<img alt="Pasted image 20250325172818.png" src="http://lts.kr/사진-및-문서/pasted-image-20250325172818.png" target="_self"><br>]]></description><link>http://lts.kr/study/cs/🚨-rsa-암호화-방식의-이해와-적용-(feat.취약성점검).html</link><guid isPermaLink="false">study/CS/🚨 RSA 암호화 방식의 이해와 적용 (feat.취약성점검).md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Thu, 27 Mar 2025 07:33:18 GMT</pubDate><enclosure url="http://lts.kr/사진-및-문서/pasted-image-20250325102427.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="http://lts.kr/사진-및-문서/pasted-image-20250325102427.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[📕 공부]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="http://lts.kr/?query=tag:모음" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#모음</a> <br> <a href="http://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="http://lts.kr?query=tag:모음" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#모음">#모음</a><br>공부
보고 배운 지식 중 공유하고 싶은 정보를 모아둔 카테고리 입니다.
<br>
<br><a data-href="🚨 RSA 암호화 방식의 이해와 적용 (feat.취약성점검)" href="http://lts.kr/study/cs/🚨-rsa-암호화-방식의-이해와-적용-(feat.취약성점검).html" class="internal-link" target="_self" rel="noopener nofollow">🚨 RSA 암호화 방식의 이해와 적용 (feat.취약성점검)</a>
<br><a data-href="🍎 Redis로 Key관리하기" href="http://lts.kr/study/cs/🍎-redis로-key관리하기.html" class="internal-link" target="_self" rel="noopener nofollow">🍎 Redis로 Key관리하기</a>
<br><a data-href="🌋 OSIV와 영속성 컨텍스트" href="http://lts.kr/study/cs/🌋-osiv와-영속성-컨텍스트.html" class="internal-link" target="_self" rel="noopener nofollow">🌋 OSIV와 영속성 컨텍스트</a>
<br><a data-href="🐰 Java의 String과 SpringBuffer" href="http://lts.kr/study/cs/🐰-java의-string과-springbuffer.html" class="internal-link" target="_self" rel="noopener nofollow">🐰 Java의 String과 SpringBuffer</a>
<br><a data-href="🛬 JDK와 JRE, JVM" href="http://lts.kr/study/cs/🛬-jdk와-jre,-jvm.html" class="internal-link" target="_self" rel="noopener nofollow">🛬 JDK와 JRE, JVM</a>
<br><a data-href="🍊 Spring의 의존성 주입(DI)" href="http://lts.kr/study/cs/🍊-spring의-의존성-주입(di).html" class="internal-link" target="_self" rel="noopener nofollow">🍊 Spring의 의존성 주입(DI)</a>
<br><a data-href="🪕 JPA 관련 용어 정리" href="http://lts.kr/study/cs/🪕-jpa-관련-용어-정리.html" class="internal-link" target="_self" rel="noopener nofollow">🪕 JPA 관련 용어 정리</a>
<br>
<br><a data-href="☕ JAVA , OOP" href="http://lts.kr/study/cs/☕-java-,-oop.html" class="internal-link" target="_self" rel="noopener nofollow">☕ JAVA , OOP</a>
<br><a data-href="🍃 Spring" href="http://lts.kr/study/cs/🍃-spring.html" class="internal-link" target="_self" rel="noopener nofollow">🍃 Spring</a>
<br><a data-href="🎩 DevOps" href="http://lts.kr/study/cs/🎩-devops.html" class="internal-link" target="_self" rel="noopener nofollow">🎩 DevOps</a>
<br><a data-href="📔 DataBase" href="http://lts.kr/study/cs/📔-database.html" class="internal-link" target="_self" rel="noopener nofollow">📔 DataBase</a>
<br><a data-href="📭 Server" href="http://lts.kr/study/cs/📭-server.html" class="internal-link" target="_self" rel="noopener nofollow">📭 Server</a>
<br><a data-href="🐞 etc" href="http://lts.kr/study/cs/🐞-etc.html" class="internal-link" target="_self" rel="noopener nofollow">🐞 etc</a>
<br>
<br><a data-href="🤠 Coding Test 풀이 모음" href="http://lts.kr/study/coding-test/🤠-coding-test-풀이-모음.html" class="internal-link" target="_self" rel="noopener nofollow">🤠 Coding Test 풀이 모음</a>
<br><a data-href="👽 Algorithm" href="http://lts.kr/study/coding-test/👽-algorithm.html" class="internal-link" target="_self" rel="noopener nofollow">👽 Algorithm</a>
<br>
<br><a data-href="🔻 Redis 캐쉬 전략 - hello 서비스에 적용하여 성능개선 가능성" href="http://lts.kr/study/dev-seminar/🔻-redis-캐쉬-전략-hello-서비스에-적용하여-성능개선-가능성.html" class="internal-link" target="_self" rel="noopener nofollow">🔻 Redis 캐쉬 전략 - hello 서비스에 적용하여 성능개선 가능성</a>
<br><a data-href="🔐 상품 투자하기 서비스 Lock기법 개선안" href="http://lts.kr/issue_troubleshooting/🔐-상품-투자하기-서비스-lock기법-개선안.html" class="internal-link" target="_self" rel="noopener nofollow">🔐 상품 투자하기 서비스 Lock기법 개선안</a>
<br><a data-href="🔹 TDD에 대하여" href="http://lts.kr/study/dev-seminar/🔹-tdd에-대하여.html" class="internal-link" target="_self" rel="noopener nofollow">🔹 TDD에 대하여</a>
<br><a data-href="🍂 JPA, Mybatis , Dead Lock이슈" href="http://lts.kr/study/dev-seminar/🍂-jpa,-mybatis-,-dead-lock이슈.html" class="internal-link" target="_self" rel="noopener nofollow">🍂 JPA, Mybatis , Dead Lock이슈</a>
<br><a data-href="🥗 Spring Security_토큰-세션-쿠키-JWT 에 대하여" href="http://lts.kr/study/dev-seminar/🥗-spring-security_토큰-세션-쿠키-jwt-에-대하여.html" class="internal-link" target="_self" rel="noopener nofollow">🥗 Spring Security_토큰-세션-쿠키-JWT 에 대하여</a>
<br><a data-href="📔 DB 테이블 설계, 어떻게 하는게 옳은 방법인가" href="http://lts.kr/study/dev-seminar/📔-db-테이블-설계,-어떻게-하는게-옳은-방법인가.html" class="internal-link" target="_self" rel="noopener nofollow">📔 DB 테이블 설계, 어떻게 하는게 옳은 방법인가</a>]]></description><link>http://lts.kr/study/📕-공부.html</link><guid isPermaLink="false">study/📕 공부.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Thu, 27 Mar 2025 07:31:42 GMT</pubDate></item><item><title><![CDATA[🔻 Redis 캐쉬 전략 - hello 서비스에 적용하여 성능개선 가능성]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:공부" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공부</a> <a class="tag" href="http://lts.kr/?query=tag:Hello" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Hello</a> <a class="tag" href="http://lts.kr/?query=tag:Redis" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Redis</a> <a class="tag" href="http://lts.kr/?query=tag:Cash" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Cash</a> <a class="tag" href="http://lts.kr/?query=tag:설계" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#설계</a> <br> <a href="http://lts.kr?query=tag:공부" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#공부">#공부</a> <a href="http://lts.kr?query=tag:Hello" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Hello">#Hello</a> <a href="http://lts.kr?query=tag:Redis" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Redis">#Redis</a> <a href="http://lts.kr?query=tag:Cash" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#Cash">#Cash</a> <a href="http://lts.kr?query=tag:설계" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#설계">#설계</a><br>
<br>
Spring Cache Abstraction 사용 <br>Spring Boot는 @Cacheable, @CachePut, @CacheEvict와 같은 어노테이션을 제공하여 간단히 캐싱을 설정할 수 있습니다.
<br>Redis는 Spring의 캐시 추상화(CacheManager)를 구현하는 데 사용되며, 손쉽게 통합할 수 있습니다. <br>
데이터 계층 캐싱 <br>데이터베이스 조회를 대신하여 Redis에 데이터를 저장함으로써 반복적인 DB 호출을 줄입니다.
<br>예를 들어, 자주 조회되는 데이터(예: 상품 목록, 사용자 프로필)를 캐시에 저장하여 DB 부하를 줄일 수 있습니다. <br>
분할 키 전략(Key Partitioning) <br>Redis의 키는 고유해야 하므로, 데이터 유형에 따라 네임스페이스를 설정합니다.
<br>예: user:{id}, product:{id}와 같은 구조로 관리하여 충돌 방지. <br>
TTL(Time-To-Live) 설정 <br>캐시 데이터에 TTL을 설정하여 데이터가 일정 시간이 지나면 만료되도록 구성합니다.
<br>이를 통해 오래된 데이터를 제거하고 메모리 관리 효율성을 높일 수 있습니다. <br>
Eviction 정책 <br>Redis의 LRU(Least Recently Used) 정책을 활용하여 메모리 한계에 도달하면 오래 사용되지 않은 데이터를 제거합니다.
<br>필요에 따라 LFU(Least Frequently Used) 또는 FIFO(First In First Out) 정책을 선택. <br>
Multi-Level 캐싱 <br>Redis 캐시를 1차 캐시로 사용하고, 애플리케이션 내 로컬 메모리(예: Caffeine)를 2차 캐시로 설정하여 자주 액세스하는 데이터를 더 빠르게 제공합니다. <br>
대량 데이터 처리 <br>Redis의 Hash 또는 Set 자료구조를 사용하여 대량 데이터를 효율적으로 저장 및 관리합니다.
<br>예: 사용자의 여러 설정값을 Redis의 Hash로 저장. <br>
Pub/Sub를 활용한 캐시 무효화 <br>Redis의 Pub/Sub 기능을 사용하여 캐시 갱신이나 무효화 이벤트를 동기화합니다.
<br>이를 통해 여러 인스턴스 간 캐시 일관성을 유지할 수 있습니다. <br>
분산 환경에서 캐시 <br>Redis는 클러스터링과 샤딩을 통해 분산 환경에서 확장성을 제공합니다.
<br>Spring Boot 애플리케이션이 여러 인스턴스에서 실행 중이라면, 단일 Redis 서버 또는 클러스터를 활용하여 공유 캐시를 사용할 수 있습니다. <br>
<br>
DB 쿼리 감소 <br>자주 사용하는 데이터를 Redis에 저장하여 DB 호출 횟수를 줄입니다.
<br>읽기 요청이 많은 서비스에서 DB 부하를 대폭 감소시킬 수 있습니다. <br>
빠른 데이터 액세스 <br>Redis는 메모리 기반 데이터 저장소로, 읽기/쓰기 속도가 매우 빠릅니다. 이는 데이터베이스와 비교해 성능을 극대화할 수 있습니다. <br>
높은 확장성 <br>Redis는 샤딩 및 클러스터링을 통해 수평적으로 확장할 수 있어, 트래픽 증가에 효과적으로 대응 가능합니다. <br>
데이터 동기화 비용 절감 <br>여러 애플리케이션 인스턴스에서 동일한 Redis 캐시를 사용함으로써 데이터 동기화 비용을 줄입니다. <br>
캐시 적중률 증가 <br>캐시 히트율이 높아지면 요청 응답 속도가 비약적으로 증가합니다. 이를 통해 사용자 경험(UX)을 향상시킬 수 있습니다. <br>
결과적으로 비용 절감 <br>DB 스케일링이나 고사양 서버로의 업그레이드 비용을 절감할 수 있습니다. <br>
<br>
데이터 일관성 <br>캐시와 데이터베이스 간의 일관성 문제가 발생할 수 있습니다. 이를 해결하기 위해 TTL, Pub/Sub, 캐시 무효화 전략을 적절히 사용해야 합니다. <br>
메모리 사용량 <br>Redis는 메모리 기반이므로, 메모리 관리에 주의해야 합니다. TTL 설정과 적절한 Eviction 정책을 적용해야 합니다. <br>
복잡성 증가 <br>Redis 캐시 도입은 초기 설정과 유지보수 복잡도를 증가시킬 수 있습니다. <br>
<br>메모리 한계: Redis는 메모리 기반이므로 큰 데이터를 다룰 경우 메모리 용량이 제한 요인이 될 수 있음.
<br>데이터 손실 가능성: AOF를 사용하지 않거나 RDB만 사용하면 마지막 스냅샷 이후 데이터가 손실될 가능성이 있음.
<br>멀티쓰레드 부재: Redis는 기본적으로 싱글쓰레드로 동작하므로, CPU 활용 측면에서 제한이 있을 수 있음.
<br>
<br>캐시와 DB 간의 일관성 문제를 발생시키지 않을 select(조회) 쿼리, 재사용률이 높은 데이터 <br>다른 프로젝트 인스턴스에서 데이터 교환이 자주 일어나는 경우 <br>
<br>사용자 별로 문서 크기가 크게 상이해도 동적으로 메모리를 관리하여 저장 실패 확률을 줄일수 있다.
<br>장애가 발생 하더라도 앱서버와 분리되어있으므로 서비스 영향도를 더욱 줄일 수있을것 같다.
<br>
<br>정적오브젝트 로딩 후 동작하는 js특성
<br>다양한 오브젝트를 저장할 수 있는 redis특성 사용
<br>로직을 변경 하지 않고, 재진입시 js대기 시간을 크게 줄일 수 있을것으로 생각됨
<br><img alt="Pasted image 20241206140739.png" src="http://lts.kr/사진-및-문서/pasted-image-20241206140739.png" target="_self"><br><img alt="Pasted image 20241206140822.png" src="http://lts.kr/사진-및-문서/pasted-image-20241206140822.png" target="_self"><br>
<br>
이러한 경우 재 조회나, 검색 필터 적용시 데이터 최신화 필요도가 떨어지기 때문에, 캐쉬 전략을 사용했을 때<br>
데이터를 받아오는 시간을 크게 줄일 수 있을것으로 예상됨 <br>
또한 성공 실패여부 및 횟수를 저장하여 리트라이 로직 등도 추가할 수있으며,<br>
모든 프로젝트의 api에 공통으로 적용하여 사용할 수 있음. <br> "coordinates": [<br>
128.0827,<br>
37.6061<br>
],<br>
위도/경도 및 시간 정보를 캐쉬에 취합 후, 영구저장 DB 대분류(지역 및 시간대) 로 카운트를 집계하여,<br>
마케팅 요청시 광고 타겟 위치 및 시간대를 지정하여 광고 요청을 한다면 적은비용 대비 높은 효과를 기대할 수 있다.<br>]]></description><link>http://lts.kr/study/dev-seminar/🔻-redis-캐쉬-전략-hello-서비스에-적용하여-성능개선-가능성.html</link><guid isPermaLink="false">study/Dev Seminar/🔻 Redis 캐쉬 전략 - hello 서비스에 적용하여 성능개선 가능성.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Thu, 27 Mar 2025 07:31:09 GMT</pubDate><enclosure url="http://lts.kr/사진-및-문서/pasted-image-20241206140739.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="http://lts.kr/사진-및-문서/pasted-image-20241206140739.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🔫 이슈·트러블슈팅]]></title><description><![CDATA[<a class="tag" href="http://lts.kr/?query=tag:이슈" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#이슈</a> <a class="tag" href="http://lts.kr/?query=tag:트러블슈팅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#트러블슈팅</a> <a class="tag" href="http://lts.kr/?query=tag:모음" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#모음</a> <br> <a href="http://lts.kr?query=tag:이슈" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#이슈">#이슈</a> <a href="http://lts.kr?query=tag:트러블슈팅" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#트러블슈팅">#트러블슈팅</a> <a href="http://lts.kr?query=tag:모음" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#모음">#모음</a><br>이슈 / 트러블 슈팅
크고 작은 이슈와, 그 해결 과정을 쓴 글 모음입니다.
<br>
<br><a data-href="🍂 JPA, Mybatis , Dead Lock이슈" href="http://lts.kr/study/dev-seminar/🍂-jpa,-mybatis-,-dead-lock이슈.html" class="internal-link" target="_self" rel="noopener nofollow">🍂 JPA, Mybatis , Dead Lock이슈</a> <br><a data-href="🌋 OSIV와 영속성 컨텍스트" href="http://lts.kr/study/cs/🌋-osiv와-영속성-컨텍스트.html" class="internal-link" target="_self" rel="noopener nofollow">🌋 OSIV와 영속성 컨텍스트</a>
<br><a data-href="🪕 JPA 관련 용어 정리" href="http://lts.kr/study/cs/🪕-jpa-관련-용어-정리.html" class="internal-link" target="_self" rel="noopener nofollow">🪕 JPA 관련 용어 정리</a> <br><a data-href="🔐 상품 투자하기 서비스 Lock기법 개선안" href="http://lts.kr/issue_troubleshooting/🔐-상품-투자하기-서비스-lock기법-개선안.html" class="internal-link" target="_self" rel="noopener nofollow">🔐 상품 투자하기 서비스 Lock기법 개선안</a>
<br><a data-href="⚔ StckOverflow 이슈와 QueryDSL" href="http://lts.kr/issue_troubleshooting/⚔-stckoverflow-이슈와-querydsl.html" class="internal-link" target="_self" rel="noopener nofollow">⚔ StckOverflow 이슈와 QueryDSL</a>
<br>
<br><a data-href="🚨 RSA 암호화 방식의 이해와 적용 (feat.취약성점검)" href="http://lts.kr/study/cs/🚨-rsa-암호화-방식의-이해와-적용-(feat.취약성점검).html" class="internal-link" target="_self" rel="noopener nofollow">🚨 RSA 암호화 방식의 이해와 적용 (feat.취약성점검)</a> <br><a data-href="🍎 Redis로 Key관리하기" href="http://lts.kr/study/cs/🍎-redis로-key관리하기.html" class="internal-link" target="_self" rel="noopener nofollow">🍎 Redis로 Key관리하기</a> <br><a data-href="🚦 Spring Batch 트러블슈팅" href="http://lts.kr/issue_troubleshooting/🚦-spring-batch-트러블슈팅.html" class="internal-link" target="_self" rel="noopener nofollow">🚦 Spring Batch 트러블슈팅</a>
<br><a data-href="⏰ Script 로딩 지연 문제 해결 .js" href="http://lts.kr/issue_troubleshooting/⏰-script-로딩-지연-문제-해결-.js.html" class="internal-link" target="_self" rel="noopener nofollow">⏰ Script 로딩 지연 문제 해결 .js</a>]]></description><link>http://lts.kr/project/🔫-이슈·트러블슈팅.html</link><guid isPermaLink="false">project/🔫 이슈·트러블슈팅.md</guid><dc:creator><![CDATA[taesung's Blog]]></dc:creator><pubDate>Thu, 27 Mar 2025 06:04:14 GMT</pubDate></item></channel></rss>